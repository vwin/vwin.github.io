{"pages":[{},{},{},{},{},{}],"posts":[{"title":"Hexo-更换valine评论到waline","date":"2022-11-20T05:51:24.000Z","path":"2022/11/20/Hexo-更换valine评论到waline/","text":"Valine作为一款无后端的评论系统的安全性是很难保证的,waline相比valine更安全。 背景Valine和Waline，感觉上就相差肯定不多。Waline其实就是一个带后端的Valine，可以进行一些反垃圾和校验操作。 更换步骤以下步骤基于原有系统为Valine系统的简单迁移方法。 Vercel 部署（服务端）deploy 点击上方跳转至Vercel部署。 未登录需要注册或登录，使用Github快捷登录。 输入名称创建项目，Vercel会根据Waline模板新建并初始化仓库。 几分钟后，满屏烟花部署成功。 转到Dashboard-Setting-Environment Variables，进行环境变量配置。 环境变量配置 必备 LEAN_ID —— LeanCloud中获得的APP ID LEAN_KEY —— LeanCloud中获得的APP KEY LEAN_MASTER_KEY —— LeanCloud中获得的Master Key 以上默认LeanCloud国际版，如果是LeanCloud国内版，还要配置LEAN_SERVER环境变量，值为绑定好的域名。点击Deployments-Redeploy重新部署。当STATUS变为Ready后，点击Visit跳转的地址即为服务端地址。 邮件提醒 SMTP_SERVICE: SMTP 邮件发送服务提供商。支持的服务提供商列表(如果运营商不受支持，必须填写 SMTP_HOST 和 SMTP_PORT。 SMTP_HOST: SMTP 服务器地址，一般可以在邮箱的设置中找到。 SMTP_PORT: SMTP 服务器端口，一般可以在邮箱的设置中找到。 SMTP_USER: SMTP 邮件发送服务的用户名，一般为登录邮箱。 SMTP_PASS: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。 SITE_NAME: 网站名称，用于在消息中显示。 SITE_URL: 网站地址，用于在消息中显示。 AUTHOR_EMAIL: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。 选填: SENDER_NAME: 自定义发送邮件的发件人 SENDER_EMAIL: 自定义发送邮件的发件地址 MAIL_SUBJECT: 自定义评论回复邮件标题 MAIL_TEMPLATE: 自定义评论回复邮件内容 MAIL_SUBJECT_ADMIN: 自定义新评论通知邮件标题 MAIL_TEMPLATE_ADMIN: 自定义新评论通知邮件内容 HTML 引入 (客户端)在pure主题中，需要修改\\hexo\\themes_pure\\layout_script_comment\\valine.ejs文件。去掉 12&lt;script src=&quot;//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//unpkg.com/valine@latest/dist/Valine.min.js&quot;&gt;&lt;/script&gt; 加上 12345&lt;script src=&quot;https://unpkg.com/@waline/client@v2/dist/waline.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/@waline/client@v2/dist/waline.css&quot;/&gt; 去掉 12345678910111213new Valine(&#123; el: &#x27;#vcomments&#x27;, verify: &lt;%= theme.comment.valine.verify %&gt;, notify: &lt;%= theme.comment.valine.notify %&gt;, appId: &#x27;&lt;%= theme.comment.valine.appid %&gt;&#x27;, appKey: &#x27;&lt;%= theme.comment.valine.appkey %&gt;&#x27;, placeholder: &#x27;&lt;%= theme.comment.valine.placeholder %&gt;&#x27;, avatar: &#x27;&lt;%= theme.comment.valine.avatar %&gt;&#x27;, meta: meta, pageSize: &#x27;&lt;%= theme.comment.valine.pageSize %&gt;&#x27; || 10, serverURLs: &#x27;&lt;%= theme.comment.valine.serverURLs %&gt;&#x27;, visitor: &lt;%= theme.comment.valine.visitor %&gt; &#125;); 更换为 1234Waline.init(&#123; el: &#x27;#comments&#x27;, serverURL: &#x27;https://your-domain.vercel.app&#x27;,&#125;); 此时评论服务已能在博客成功运行。 评论管理（管理端）部署完成后，在&#x2F;ui&#x2F;register进行注册。第一个注册的人被设定为管理员。管理员可管理评论。用户可通过评论框注册账号，登录后可跳转至自己的评论页。 其它如果无法发布评论，比如报错说格式不对（要求Number结果是String）之类的，建议查看LeanCloud数据中的单元格式是否正确。 Waline配置邮件通知Waline官网邮件通知邮件通知模板样式 参考资料Waline官网","raw":"---\ntitle: Hexo-更换valine评论到waline\ntoc: true\ndate: 2022-11-20 13:51:24\ntags: [hexo,valine,waline]\ncategories: [Hexo]\ndescription:\n---\nValine作为一款无后端的评论系统的安全性是很难保证的,waline相比valine更安全。\n<!-- more -->\n\n# 背景\n\nValine和Waline，感觉上就相差肯定不多。Waline其实就是一个带后端的Valine，可以进行一些反垃圾和校验操作。\n\n# 更换步骤\n以下步骤基于原有系统为Valine系统的简单迁移方法。\n\n## Vercel 部署（服务端）\n\n[deploy](https://vercel.com/import/project?template=https://github.com/walinejs/waline/tree/main/example)\n\n点击上方跳转至Vercel部署。\n\n1. 未登录需要注册或登录，使用Github快捷登录。\n2. 输入名称创建项目，Vercel会根据Waline模板新建并初始化仓库。\n3. 几分钟后，满屏烟花部署成功。\n4. 转到Dashboard-Setting-Environment Variables，进行环境变量配置。\n\n## 环境变量配置\n- 必备\n  - LEAN_ID —— LeanCloud中获得的APP ID\n  - LEAN_KEY —— LeanCloud中获得的APP KEY\n  - LEAN_MASTER_KEY —— LeanCloud中获得的Master Key　\n  \n以上默认LeanCloud国际版，如果是LeanCloud国内版，还要配置LEAN_SERVER环境变量，值为绑定好的域名。\n点击Deployments-Redeploy重新部署。当STATUS变为Ready后，点击Visit跳转的地址即为服务端地址。\n\n## 邮件提醒\n- SMTP_SERVICE: SMTP 邮件发送服务提供商。[支持的服务提供商列表](https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json)(如果运营商不受支持，必须填写 SMTP_HOST 和 SMTP_PORT。\n- SMTP_HOST: SMTP 服务器地址，一般可以在邮箱的设置中找到。\n- SMTP_PORT: SMTP 服务器端口，一般可以在邮箱的设置中找到。\n- SMTP_USER: SMTP 邮件发送服务的用户名，一般为登录邮箱。\n\n- SMTP_PASS: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。\n- SITE_NAME: 网站名称，用于在消息中显示。\n- SITE_URL: 网站地址，用于在消息中显示。\n- AUTHOR_EMAIL: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。\n\n选填:\n- SENDER_NAME: 自定义发送邮件的发件人\n- SENDER_EMAIL: 自定义发送邮件的发件地址\n- MAIL_SUBJECT: 自定义评论回复邮件标题\n- MAIL_TEMPLATE: 自定义评论回复邮件内容\n- MAIL_SUBJECT_ADMIN: 自定义新评论通知邮件标题\n- MAIL_TEMPLATE_ADMIN: 自定义新评论通知邮件内容\n\n\n## HTML 引入 (客户端)\n在pure主题中，需要修改\\hexo\\themes\\_pure\\layout\\_script\\_comment\\valine.ejs文件。\n去掉\n```shell\n<script src=\"//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js\"></script>\n<script src=\"//unpkg.com/valine@latest/dist/Valine.min.js\"></script>\n```\n\n加上\n\n```shell\n<script src=\"https://unpkg.com/@waline/client@v2/dist/waline.js\"></script>\n<link\n  rel=\"stylesheet\"\n  href=\"https://unpkg.com/@waline/client@v2/dist/waline.css\"\n/>\n```\n\n去掉\n```shell\nnew Valine({\n    el: '#vcomments',\n    verify: <%= theme.comment.valine.verify %>,\n    notify: <%= theme.comment.valine.notify %>,\n    appId: '<%= theme.comment.valine.appid %>',\n    appKey: '<%= theme.comment.valine.appkey %>',\n    placeholder: '<%= theme.comment.valine.placeholder %>',\n    avatar: '<%= theme.comment.valine.avatar %>',\n    meta: meta,\n    pageSize: '<%= theme.comment.valine.pageSize %>' || 10,\n    serverURLs: '<%= theme.comment.valine.serverURLs %>',\n    visitor: <%= theme.comment.valine.visitor %>\n  });\n```\n\n更换为\n```shell\nWaline.init({\n      el: '#comments',\n      serverURL: 'https://your-domain.vercel.app',\n});\n```\n此时评论服务已能在博客成功运行。\n\n## 评论管理（管理端）\n部署完成后，在<serverURL>/ui/register进行注册。第一个注册的人被设定为管理员。\n管理员可管理评论。\n用户可通过评论框注册账号，登录后可跳转至自己的评论页。\n\n## 其它\n如果无法发布评论，比如报错说格式不对（要求Number结果是String）之类的，建议查看LeanCloud数据中的单元格式是否正确。\n\n# Waline配置邮件通知\n[Waline官网邮件通知](https://waline.js.org/guide/server/notification.html#%E9%99%84%E5%8A%A0%E8%AF%B4%E6%98%8E)\n[邮件通知模板样式](https://sarakale.top/blog/posts/537344b2.html)\n# 参考资料\n[Waline官网](https://waline.js.org/)\n\n\n","content":"<p>Valine作为一款无后端的评论系统的安全性是很难保证的,waline相比valine更安全。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>Valine和Waline，感觉上就相差肯定不多。Waline其实就是一个带后端的Valine，可以进行一些反垃圾和校验操作。</p>\n<h1 id=\"更换步骤\"><a href=\"#更换步骤\" class=\"headerlink\" title=\"更换步骤\"></a>更换步骤</h1><p>以下步骤基于原有系统为Valine系统的简单迁移方法。</p>\n<h2 id=\"Vercel-部署（服务端）\"><a href=\"#Vercel-部署（服务端）\" class=\"headerlink\" title=\"Vercel 部署（服务端）\"></a>Vercel 部署（服务端）</h2><p><a href=\"https://vercel.com/import/project?template=https://github.com/walinejs/waline/tree/main/example\">deploy</a></p>\n<p>点击上方跳转至Vercel部署。</p>\n<ol>\n<li>未登录需要注册或登录，使用Github快捷登录。</li>\n<li>输入名称创建项目，Vercel会根据Waline模板新建并初始化仓库。</li>\n<li>几分钟后，满屏烟花部署成功。</li>\n<li>转到Dashboard-Setting-Environment Variables，进行环境变量配置。</li>\n</ol>\n<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><ul>\n<li>必备<ul>\n<li>LEAN_ID —— LeanCloud中获得的APP ID</li>\n<li>LEAN_KEY —— LeanCloud中获得的APP KEY</li>\n<li>LEAN_MASTER_KEY —— LeanCloud中获得的Master Key</li>\n</ul>\n</li>\n</ul>\n<p>　</p>\n<p>以上默认LeanCloud国际版，如果是LeanCloud国内版，还要配置LEAN_SERVER环境变量，值为绑定好的域名。<br>点击Deployments-Redeploy重新部署。当STATUS变为Ready后，点击Visit跳转的地址即为服务端地址。</p>\n<h2 id=\"邮件提醒\"><a href=\"#邮件提醒\" class=\"headerlink\" title=\"邮件提醒\"></a>邮件提醒</h2><ul>\n<li><p>SMTP_SERVICE: SMTP 邮件发送服务提供商。<a href=\"https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json\">支持的服务提供商列表</a>(如果运营商不受支持，必须填写 SMTP_HOST 和 SMTP_PORT。</p>\n</li>\n<li><p>SMTP_HOST: SMTP 服务器地址，一般可以在邮箱的设置中找到。</p>\n</li>\n<li><p>SMTP_PORT: SMTP 服务器端口，一般可以在邮箱的设置中找到。</p>\n</li>\n<li><p>SMTP_USER: SMTP 邮件发送服务的用户名，一般为登录邮箱。</p>\n</li>\n<li><p>SMTP_PASS: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。</p>\n</li>\n<li><p>SITE_NAME: 网站名称，用于在消息中显示。</p>\n</li>\n<li><p>SITE_URL: 网站地址，用于在消息中显示。</p>\n</li>\n<li><p>AUTHOR_EMAIL: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。</p>\n</li>\n</ul>\n<p>选填:</p>\n<ul>\n<li>SENDER_NAME: 自定义发送邮件的发件人</li>\n<li>SENDER_EMAIL: 自定义发送邮件的发件地址</li>\n<li>MAIL_SUBJECT: 自定义评论回复邮件标题</li>\n<li>MAIL_TEMPLATE: 自定义评论回复邮件内容</li>\n<li>MAIL_SUBJECT_ADMIN: 自定义新评论通知邮件标题</li>\n<li>MAIL_TEMPLATE_ADMIN: 自定义新评论通知邮件内容</li>\n</ul>\n<h2 id=\"HTML-引入-客户端\"><a href=\"#HTML-引入-客户端\" class=\"headerlink\" title=\"HTML 引入 (客户端)\"></a>HTML 引入 (客户端)</h2><p>在pure主题中，需要修改\\hexo\\themes_pure\\layout_script_comment\\valine.ejs文件。<br>去掉</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;//unpkg.com/valine@latest/dist/Valine.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>加上</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://unpkg.com/@waline/client@v2/dist/waline.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;link</span><br><span class=\"line\">  rel=&quot;stylesheet&quot;</span><br><span class=\"line\">  href=&quot;https://unpkg.com/@waline/client@v2/dist/waline.css&quot;</span><br><span class=\"line\"><span class=\"meta prompt_\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>去掉</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Valine(&#123;</span><br><span class=\"line\">    el: &#x27;#vcomments&#x27;,</span><br><span class=\"line\">    verify: &lt;%= theme.comment.valine.verify %&gt;,</span><br><span class=\"line\">    notify: &lt;%= theme.comment.valine.notify %&gt;,</span><br><span class=\"line\">    appId: &#x27;&lt;%= theme.comment.valine.appid %&gt;&#x27;,</span><br><span class=\"line\">    appKey: &#x27;&lt;%= theme.comment.valine.appkey %&gt;&#x27;,</span><br><span class=\"line\">    placeholder: &#x27;&lt;%= theme.comment.valine.placeholder %&gt;&#x27;,</span><br><span class=\"line\">    avatar: &#x27;&lt;%= theme.comment.valine.avatar %&gt;&#x27;,</span><br><span class=\"line\">    meta: meta,</span><br><span class=\"line\">    pageSize: &#x27;&lt;%= theme.comment.valine.pageSize %&gt;&#x27; || 10,</span><br><span class=\"line\">    serverURLs: &#x27;&lt;%= theme.comment.valine.serverURLs %&gt;&#x27;,</span><br><span class=\"line\">    visitor: &lt;%= theme.comment.valine.visitor %&gt;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>更换为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Waline.init(&#123;</span><br><span class=\"line\">      el: &#x27;#comments&#x27;,</span><br><span class=\"line\">      serverURL: &#x27;https://your-domain.vercel.app&#x27;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时评论服务已能在博客成功运行。</p>\n<h2 id=\"评论管理（管理端）\"><a href=\"#评论管理（管理端）\" class=\"headerlink\" title=\"评论管理（管理端）\"></a>评论管理（管理端）</h2><p>部署完成后，在<serverURL>&#x2F;ui&#x2F;register进行注册。第一个注册的人被设定为管理员。<br>管理员可管理评论。<br>用户可通过评论框注册账号，登录后可跳转至自己的评论页。</serverURL></p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>如果无法发布评论，比如报错说格式不对（要求Number结果是String）之类的，建议查看LeanCloud数据中的单元格式是否正确。</p>\n<h1 id=\"Waline配置邮件通知\"><a href=\"#Waline配置邮件通知\" class=\"headerlink\" title=\"Waline配置邮件通知\"></a>Waline配置邮件通知</h1><p><a href=\"https://waline.js.org/guide/server/notification.html#%E9%99%84%E5%8A%A0%E8%AF%B4%E6%98%8E\">Waline官网邮件通知</a><br><a href=\"https://sarakale.top/blog/posts/537344b2.html\">邮件通知模板样式</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://waline.js.org/\">Waline官网</a></p>\n","slug":"Hexo-更换valine评论到waline","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/20/Hexo-%E6%9B%B4%E6%8D%A2valine%E8%AF%84%E8%AE%BA%E5%88%B0waline/","excerpt":"Valine作为一款无后端的评论系统的安全性是很难保证的,waline相比valine更安全。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://vwin.github.io/tags/hexo/"},{"name":"valine","slug":"valine","permalink":"http://vwin.github.io/tags/valine/"},{"name":"waline","slug":"waline","permalink":"http://vwin.github.io/tags/waline/"}]},{"title":"Hexo-解决Valine评论不显示的问题","date":"2022-11-20T05:27:32.000Z","path":"2022/11/20/Hexo-解决Valine评论不显示的问题/","text":"博客无法显示评论也无法提交新评论，解决问题记录 背景使用hexo pure主题提供的valine评论插件设置完后，发现评论无法显示后来在Valine的官方群中，有部分网友表示最近遇到相同问题，共性是都使用的LeanCloud国际版。哦，原来是LeanCloud的锅。 具体排查查看网页控制台，我发现， 123Failed to load resource: net::ERR_EMPTY_RESPONSEus-api.leancloud.cn/后面还有一长串 或者 123Failed to load resource: net::ERR_NAME_NOT_RESOLVEDus-api.leancloud.cn/后面还有一长串 调试过程中还报过别的错，我没有记录，但总之，都是围绕这个域名解析的问题。反正就是这个域名无法正确得到结果。那怎么办呢？根据群里大佬讨论可得，似乎是现在国际版对这个域名不再支持了，也有人说是不稳定，推荐自定义服务器URL。 解决方法法一：导出数据，更换到国内节点，快准狠。 法二：懒得换（比如我），那就改代码吧。如果主题中已配置的Valine有severURLs字段，直接设置即可。 1serverURLs: https://xxxxxxxx.api.lncldglobal.com # 把xxxxxxxx替换为自己AppID的前8位字符 如果主题未配置该参数，就需要找到valine的js文件，比如我这里的 \\hexo\\themes\\pure\\layout_script_comment\\valine.ejs 1234567891011new Valine(&#123; el: &#x27;#comments&#x27;, notify: &#x27;&lt;%= theme.comment.valine.notify %&gt;&#x27; == &#x27;true&#x27;, verify: &#x27;&lt;%= theme.comment.valine.verify %&gt;&#x27; == &#x27;true&#x27;, appId: &quot;&lt;%= theme.comment.valine.appId %&gt;&quot;, appKey: &quot;&lt;%= theme.comment.valine.appKey %&gt;&quot;, avatar: &quot;&lt;%= theme.comment.valine.avatar %&gt;&quot;, placeholder: &quot;&lt;%= theme.comment.valine.placeholder %&gt;&quot;, pageSize: &quot;&lt;%= theme.comment.valine.pageSize %&gt;&quot;, serverURLs: &#x27;&lt;%= theme.comment.valine.serverURLs %&gt;&#x27; // 增加这一行！！！&#125;) 然后再配置上面的serverURLs。 然而我在配置完这一步后，仍然不能显示正确的评论。群里大佬已经撤了，剩下一个前端菜狗在风中凌乱。 为什么不行呢？ 我认真地排查后发现评论这块并没有跳转到我设定的serverURLs，还是us-api.leancloud.cn啊。 为什么呢？ 我开始翻Valine的Github的Issues区，从一个大佬提出的Issue中发现了端倪。详见：https://github.com/xCss/Valine/issues/376 这个大佬提问说这个av.js是不是有bug啊？ 看了大佬的截图，我懂了。 这个cdn是版本不对了吧？ 于是我找到LeadClond官网手册，查询最新的CDN链接。https://leancloud.cn/docs/sdk_setup-js.html 将\\hexo\\themes\\pure\\layout_script_comment\\valine.ejs 这个文件的这一行 1234&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;替换为&lt;script src=&quot;//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js&quot;&gt;&lt;/script&gt; 再重新部署，评论已经能成功显示了。 回顾三部曲： 设置serverURLs。 若Valine的js文件未定义，需增加定义serverURLs。 更新av-min.js文件。 参考资料https://github.com/xCss/Valine/issues/340https://github.com/xCss/Valine/issues/376","raw":"---\ntitle: Hexo-解决Valine评论不显示的问题\ntoc: true\ndate: 2022-11-20 13:27:32\ntags: [Hexo,valine]\ncategories: [Hexo]\ndescription:\n---\n博客无法显示评论也无法提交新评论，解决问题记录\n\n<!-- more-->\n\n# 背景\n使用hexo pure主题提供的valine评论插件设置完后，发现评论无法显示\n后来在Valine的官方群中，有部分网友表示最近遇到相同问题，共性是都使用的LeanCloud国际版。\n哦，原来是LeanCloud的锅。\n\n# 具体排查\n查看网页控制台，我发现，\n\n```shell\nFailed to load resource: net::ERR_EMPTY_RESPONSE\n\nus-api.leancloud.cn/后面还有一长串\n```\n\n或者\n\n```shell\nFailed to load resource: net::ERR_NAME_NOT_RESOLVED\n\nus-api.leancloud.cn/后面还有一长串\n```\n\n调试过程中还报过别的错，我没有记录，但总之，都是围绕这个域名解析的问题。反正就是这个域名无法正确得到结果。\n那怎么办呢？根据群里大佬讨论可得，似乎是现在国际版对这个域名不再支持了，也有人说是不稳定，推荐自定义服务器URL。\n\n\n# 解决方法\n法一：导出数据，更换到国内节点，快准狠。\n\n法二：懒得换（比如我），那就改代码吧。\n如果主题中已配置的Valine有severURLs字段，直接设置即可。\n\n```shell\nserverURLs: https://xxxxxxxx.api.lncldglobal.com # 把xxxxxxxx替换为自己AppID的前8位字符\n```\n\n如果主题未配置该参数，就需要找到valine的js文件，比如我这里的\n\n> \\hexo\\themes\\pure\\layout\\_script\\_comment\\valine.ejs\n\n```js\nnew Valine({\n    el: '#comments',\n    notify: '<%= theme.comment.valine.notify %>' == 'true',\n    verify: '<%= theme.comment.valine.verify %>' == 'true',\n    appId: \"<%= theme.comment.valine.appId %>\",\n    appKey: \"<%= theme.comment.valine.appKey %>\",\n    avatar: \"<%= theme.comment.valine.avatar %>\",\n    placeholder: \"<%= theme.comment.valine.placeholder %>\",\n    pageSize: \"<%= theme.comment.valine.pageSize %>\",\n    serverURLs: '<%= theme.comment.valine.serverURLs %>'  // 增加这一行！！！\n})\n```\n\n然后再配置上面的serverURLs。\n\n然而我在配置完这一步后，仍然不能显示正确的评论。群里大佬已经撤了，剩下一个前端菜狗在风中凌乱。\n\n为什么不行呢？\n\n我认真地排查后发现评论这块并没有跳转到我设定的serverURLs，还是us-api.leancloud.cn啊。\n\n为什么呢？\n\n我开始翻Valine的Github的Issues区，从一个大佬提出的Issue中发现了端倪。详见：https://github.com/xCss/Valine/issues/376\n\n这个大佬提问说这个av.js是不是有bug啊？\n\n看了大佬的截图，我懂了。\n\n这个cdn是版本不对了吧？\n\n于是我找到LeadClond官网手册，查询最新的CDN链接。https://leancloud.cn/docs/sdk_setup-js.html\n\n将\\hexo\\themes\\pure\\layout\\_script\\_comment\\valine.ejs 这个文件的这一行\n\n```shell\n<script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n替换为\n\n<script src=\"//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js\"></script>\n```\n\n再重新部署，评论已经能成功显示了。\n\n回顾三部曲：\n\n1. 设置serverURLs。\n2. 若Valine的js文件未定义，需增加定义serverURLs。\n3. 更新av-min.js文件。\n\n\n# 参考资料\nhttps://github.com/xCss/Valine/issues/340\nhttps://github.com/xCss/Valine/issues/376\n","content":"<p>博客无法显示评论也无法提交新评论，解决问题记录</p>\n<span id=\"more\"></span>\n\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>使用hexo pure主题提供的valine评论插件设置完后，发现评论无法显示<br>后来在Valine的官方群中，有部分网友表示最近遇到相同问题，共性是都使用的LeanCloud国际版。<br>哦，原来是LeanCloud的锅。</p>\n<h1 id=\"具体排查\"><a href=\"#具体排查\" class=\"headerlink\" title=\"具体排查\"></a>具体排查</h1><p>查看网页控制台，我发现，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failed to load resource: net::ERR_EMPTY_RESPONSE</span><br><span class=\"line\"></span><br><span class=\"line\">us-api.leancloud.cn/后面还有一长串</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failed to load resource: net::ERR_NAME_NOT_RESOLVED</span><br><span class=\"line\"></span><br><span class=\"line\">us-api.leancloud.cn/后面还有一长串</span><br></pre></td></tr></table></figure>\n\n<p>调试过程中还报过别的错，我没有记录，但总之，都是围绕这个域名解析的问题。反正就是这个域名无法正确得到结果。<br>那怎么办呢？根据群里大佬讨论可得，似乎是现在国际版对这个域名不再支持了，也有人说是不稳定，推荐自定义服务器URL。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>法一：导出数据，更换到国内节点，快准狠。</p>\n<p>法二：懒得换（比如我），那就改代码吧。<br>如果主题中已配置的Valine有severURLs字段，直接设置即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serverURLs: https://xxxxxxxx.api.lncldglobal.com # 把xxxxxxxx替换为自己AppID的前8位字符</span><br></pre></td></tr></table></figure>\n\n<p>如果主题未配置该参数，就需要找到valine的js文件，比如我这里的</p>\n<blockquote>\n<p>\\hexo\\themes\\pure\\layout_script_comment\\valine.ejs</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Valine</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#comments&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">notify</span>: <span class=\"string\">&#x27;&lt;%= theme.comment.valine.notify %&gt;&#x27;</span> == <span class=\"string\">&#x27;true&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">verify</span>: <span class=\"string\">&#x27;&lt;%= theme.comment.valine.verify %&gt;&#x27;</span> == <span class=\"string\">&#x27;true&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">appId</span>: <span class=\"string\">&quot;&lt;%= theme.comment.valine.appId %&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">appKey</span>: <span class=\"string\">&quot;&lt;%= theme.comment.valine.appKey %&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">avatar</span>: <span class=\"string\">&quot;&lt;%= theme.comment.valine.avatar %&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">placeholder</span>: <span class=\"string\">&quot;&lt;%= theme.comment.valine.placeholder %&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">pageSize</span>: <span class=\"string\">&quot;&lt;%= theme.comment.valine.pageSize %&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">serverURLs</span>: <span class=\"string\">&#x27;&lt;%= theme.comment.valine.serverURLs %&gt;&#x27;</span>  <span class=\"comment\">// 增加这一行！！！</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后再配置上面的serverURLs。</p>\n<p>然而我在配置完这一步后，仍然不能显示正确的评论。群里大佬已经撤了，剩下一个前端菜狗在风中凌乱。</p>\n<p>为什么不行呢？</p>\n<p>我认真地排查后发现评论这块并没有跳转到我设定的serverURLs，还是us-api.leancloud.cn啊。</p>\n<p>为什么呢？</p>\n<p>我开始翻Valine的Github的Issues区，从一个大佬提出的Issue中发现了端倪。详见：<a href=\"https://github.com/xCss/Valine/issues/376\">https://github.com/xCss/Valine/issues/376</a></p>\n<p>这个大佬提问说这个av.js是不是有bug啊？</p>\n<p>看了大佬的截图，我懂了。</p>\n<p>这个cdn是版本不对了吧？</p>\n<p>于是我找到LeadClond官网手册，查询最新的CDN链接。<a href=\"https://leancloud.cn/docs/sdk_setup-js.html\">https://leancloud.cn/docs/sdk_setup-js.html</a></p>\n<p>将\\hexo\\themes\\pure\\layout_script_comment\\valine.ejs 这个文件的这一行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">替换为</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=&quot;//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>再重新部署，评论已经能成功显示了。</p>\n<p>回顾三部曲：</p>\n<ol>\n<li>设置serverURLs。</li>\n<li>若Valine的js文件未定义，需增加定义serverURLs。</li>\n<li>更新av-min.js文件。</li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://github.com/xCss/Valine/issues/340\">https://github.com/xCss/Valine/issues/340</a><br><a href=\"https://github.com/xCss/Valine/issues/376\">https://github.com/xCss/Valine/issues/376</a></p>\n","slug":"Hexo-解决Valine评论不显示的问题","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/20/Hexo-%E8%A7%A3%E5%86%B3Valine%E8%AF%84%E8%AE%BA%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"博客无法显示评论也无法提交新评论，解决问题记录","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/categories/Hexo/"}],"tags":[{"name":"valine","slug":"valine","permalink":"http://vwin.github.io/tags/valine/"},{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/tags/Hexo/"}]},{"title":"ToB业务理解","date":"2022-11-19T06:16:47.000Z","path":"2022/11/19/ToB业务理解/","text":"","raw":"---\ntitle: ToB业务理解\ntoc: true\ndate: 2022-11-19 14:16:47\ntags:\ncategories:\ndescription:\n---\n","content":"","slug":"ToB业务理解","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/19/ToB%E4%B8%9A%E5%8A%A1%E7%90%86%E8%A7%A3/","excerpt":"","categories":[],"tags":[]},{"title":"压测-基于K6的web性能测试和实时监控解决方案","date":"2022-11-15T08:38:42.000Z","path":"2022/11/15/压测-基于K6的web性能测试和实时监控解决方案/","text":"对于性能测试，除了LoadRunner、Jmeter以外，新一代的测试工具还有哪些可选？ 有没有原生集成测试结果集的数据可视化的测试解决方案？ 本文尝试用Grafana Lab出品的K6解决上述问题。 概述关于k6，一张图说明其基本特性： 方案选型 综上，选择K6主要解决了学习成本 &amp; 实时监控对接的痛点，能够方便快速地构建web性能测试解决方案 安装部署MacOS环境直接通过Homebrew安装 1$ brew install k6 CentOS环境1234$ sudo yum install https://dl.k6.io/rpm/repo.rpm$ sudo yum install k6# 如CentOS版本低于8，则执行：$ sudo yum install --nogpgcheck k6 场景案例准备工作建议提前做好被测机的系统参数调优 1234sysctl -w net.ipv4.ip_local_port_range=&quot;1024 65535&quot;sysctl -w net.ipv4.tcp_tw_reuse=1sysctl -w net.ipv4.tcp_timestamps=1ulimit -n 250000 示例场景1——直接指定并发数&amp;时长先创建名为 script.js 的用例文件： 123456789import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;export default function () &#123;http.get(&#x27;http://nginx.example.site/&#x27;);sleep(1);&#125; 保存后执行： 1k6 run --vus 100 --durating 10s script.js 等待执行完成后，可看到上述总结报告 示例场景2——阶梯式性能测试，并通过InfluxDB + Grafana呈现实时监控看板同样，创建script.js用例文件： 123456789101112131415161718192021import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;export const options = &#123; stages: [ &#123; duration: &#x27;1m&#x27;, target: 100 &#125;, // below normal load &#123; duration: &#x27;1m&#x27;, target: 100 &#125;, &#123; duration: &#x27;1m&#x27;, target: 200 &#125;, // normal load &#123; duration: &#x27;1m&#x27;, target: 200 &#125;, &#123; duration: &#x27;1m&#x27;, target: 300 &#125;, // around the breaking point &#123; duration: &#x27;1m&#x27;, target: 300 &#125;, &#123; duration: &#x27;1m&#x27;, target: 400 &#125;, // beyond the breaking point &#123; duration: &#x27;1m&#x27;, target: 400 &#125;, &#123; duration: &#x27;1m&#x27;, target: 0 &#125;, // scale down. Recovery stage. ],&#125;; http.get(&#x27;http://nginx.example.site&#x27;); sleep(1);&#125; 在本地或者服务端安装基于Docker-Compose的 InfluxDB + Grafana，用于接收k6测试过程中的实时数据 123456$ git clone &#x27;https://github.com/k6io/k6&#x27;$ cd k6$ docker-compose up -d \\ influxdb \\ grafana 登录Grafana完成InfluxDB 数据源配置 然后完成K6 Dashboard导入。Dashboard来源：https://grafana.com/grafana/dashboards/2587 导入完成后执行测试用例，引入 -o 参数，确保输出到InfluxDB 1k6 run -o influxdb=http://localhost:8086/k6 script.js 查看Grafana的实时监控 参考文档https://k6.io/docs/misc/fine-tuning-os/https://k6.io/docs/getting-started/installation/https://k6.io/blog/zh/k6-vs-jmeter/","raw":"---\ntitle: 压测-基于K6的web性能测试和实时监控解决方案\ntoc: true\ndate: 2022-11-15 16:38:42\ntags: [压测,k6]\ncategories: [测试]\ndescription:\n---\n\n对于性能测试，除了LoadRunner、Jmeter以外，新一代的测试工具还有哪些可选？ 有没有原生集成测试结果集的数据可视化的测试解决方案？ 本文尝试用Grafana Lab出品的K6解决上述问题。\n\n<!-- more -->\n\n# 概述\n关于k6，一张图说明其基本特性：\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img.png)\n\n# 方案选型\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_1.png)\n\n综上，选择K6主要解决了学习成本 & 实时监控对接的痛点，能够方便快速地构建web性能测试解决方案\n\n\n\n# 安装部署\n## MacOS环境\n直接通过Homebrew安装\n```shell\n$ brew install k6\n```\n## CentOS环境\n```shell\n$ sudo yum install https://dl.k6.io/rpm/repo.rpm\n$ sudo yum install k6\n# 如CentOS版本低于8，则执行：\n$ sudo yum install --nogpgcheck k6\n```\n\n# 场景案例\n## 准备工作\n建议提前做好被测机的系统参数调优\n```shell\nsysctl -w net.ipv4.ip_local_port_range=\"1024 65535\"\nsysctl -w net.ipv4.tcp_tw_reuse=1\nsysctl -w net.ipv4.tcp_timestamps=1\nulimit -n 250000\n```\n\n## 示例场景1——直接指定并发数&时长\n先创建名为 script.js 的用例文件：\n```js\n\nimport http from 'k6/http';\nimport { sleep } from 'k6';\n\n\nexport default function () {\nhttp.get('http://nginx.example.site/');\nsleep(1);\n}\n```\n\n保存后执行：\n```shell\nk6 run --vus 100 --durating 10s script.js\n```\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_3.png)\n等待执行完成后，可看到上述总结报告\n\n\n## 示例场景2——阶梯式性能测试，并通过InfluxDB + Grafana呈现实时监控看板\n同样，创建script.js用例文件：\n```js\nimport http from 'k6/http';\nimport { sleep } from 'k6';\n\n\nexport const options = {\n  stages: [\n    { duration: '1m', target: 100 }, // below normal load\n    { duration: '1m', target: 100 },\n    { duration: '1m', target: 200 }, // normal load\n    { duration: '1m', target: 200 },\n    { duration: '1m', target: 300 }, // around the breaking point\n    { duration: '1m', target: 300 },\n    { duration: '1m', target: 400 }, // beyond the breaking point\n    { duration: '1m', target: 400 },\n    { duration: '1m', target: 0 }, // scale down. Recovery stage.\n  ],\n};\n\n  http.get('http://nginx.example.site');\n  sleep(1);\n}\n```\n\n在本地或者服务端安装基于Docker-Compose的 InfluxDB + Grafana，用于接收k6测试过程中的实时数据\n\n\n```shell\n$ git clone 'https://github.com/k6io/k6'\n$ cd k6\n$ docker-compose up -d \\\n         influxdb \\\n         grafana\n\n```\n\n登录Grafana完成InfluxDB 数据源配置\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_4.png)\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_5.png)\n\n然后完成K6 Dashboard导入。Dashboard来源：https://grafana.com/grafana/dashboards/2587\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_6.png)\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_7.png)\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_8.png)\n\n导入完成后执行测试用例，引入 -o 参数，确保输出到InfluxDB\n```shell\nk6 run -o influxdb=http://localhost:8086/k6 script.js\n```\n\n查看Grafana的实时监控\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_9.png)\n\n# 参考文档\nhttps://k6.io/docs/misc/fine-tuning-os/ \nhttps://k6.io/docs/getting-started/installation/\nhttps://k6.io/blog/zh/k6-vs-jmeter/","content":"<p>对于性能测试，除了LoadRunner、Jmeter以外，新一代的测试工具还有哪些可选？ 有没有原生集成测试结果集的数据可视化的测试解决方案？ 本文尝试用Grafana Lab出品的K6解决上述问题。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>关于k6，一张图说明其基本特性：<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img.png\"></p>\n<h1 id=\"方案选型\"><a href=\"#方案选型\" class=\"headerlink\" title=\"方案选型\"></a>方案选型</h1><p><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_1.png\"></p>\n<p>综上，选择K6主要解决了学习成本 &amp; 实时监控对接的痛点，能够方便快速地构建web性能测试解决方案</p>\n<h1 id=\"安装部署\"><a href=\"#安装部署\" class=\"headerlink\" title=\"安装部署\"></a>安装部署</h1><h2 id=\"MacOS环境\"><a href=\"#MacOS环境\" class=\"headerlink\" title=\"MacOS环境\"></a>MacOS环境</h2><p>直接通过Homebrew安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew install k6</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"CentOS环境\"><a href=\"#CentOS环境\" class=\"headerlink\" title=\"CentOS环境\"></a>CentOS环境</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo yum install https://dl.k6.io/rpm/repo.rpm</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo yum install k6</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如CentOS版本低于8，则执行：</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo yum install --nogpgcheck k6</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"场景案例\"><a href=\"#场景案例\" class=\"headerlink\" title=\"场景案例\"></a>场景案例</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>建议提前做好被测机的系统参数调优</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl -w net.ipv4.ip_local_port_range=&quot;1024 65535&quot;</span><br><span class=\"line\">sysctl -w net.ipv4.tcp_tw_reuse=1</span><br><span class=\"line\">sysctl -w net.ipv4.tcp_timestamps=1</span><br><span class=\"line\">ulimit -n 250000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例场景1——直接指定并发数-amp-时长\"><a href=\"#示例场景1——直接指定并发数-amp-时长\" class=\"headerlink\" title=\"示例场景1——直接指定并发数&amp;时长\"></a>示例场景1——直接指定并发数&amp;时长</h2><p>先创建名为 script.js 的用例文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> http <span class=\"keyword\">from</span> <span class=\"string\">&#x27;k6/http&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; sleep &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;k6&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">http.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;http://nginx.example.site/&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存后执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k6 run --vus 100 --durating 10s script.js</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_3.png\"><br>等待执行完成后，可看到上述总结报告</p>\n<h2 id=\"示例场景2——阶梯式性能测试，并通过InfluxDB-Grafana呈现实时监控看板\"><a href=\"#示例场景2——阶梯式性能测试，并通过InfluxDB-Grafana呈现实时监控看板\" class=\"headerlink\" title=\"示例场景2——阶梯式性能测试，并通过InfluxDB + Grafana呈现实时监控看板\"></a>示例场景2——阶梯式性能测试，并通过InfluxDB + Grafana呈现实时监控看板</h2><p>同样，创建script.js用例文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> http <span class=\"keyword\">from</span> <span class=\"string\">&#x27;k6/http&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; sleep &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;k6&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> options = &#123;</span><br><span class=\"line\">  <span class=\"attr\">stages</span>: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">100</span> &#125;, <span class=\"comment\">// below normal load</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">100</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">200</span> &#125;, <span class=\"comment\">// normal load</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">200</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">300</span> &#125;, <span class=\"comment\">// around the breaking point</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">300</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">400</span> &#125;, <span class=\"comment\">// beyond the breaking point</span></span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">400</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">duration</span>: <span class=\"string\">&#x27;1m&#x27;</span>, <span class=\"attr\">target</span>: <span class=\"number\">0</span> &#125;, <span class=\"comment\">// scale down. Recovery stage.</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  http.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;http://nginx.example.site&#x27;</span>);</span><br><span class=\"line\">  <span class=\"title function_\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在本地或者服务端安装基于Docker-Compose的 InfluxDB + Grafana，用于接收k6测试过程中的实时数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">clone</span> <span class=\"string\">&#x27;https://github.com/k6io/k6&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> k6</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">docker-compose up -d \\</span></span><br><span class=\"line\"><span class=\"language-bash\">         influxdb \\</span></span><br><span class=\"line\"><span class=\"language-bash\">         grafana</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>登录Grafana完成InfluxDB 数据源配置<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_4.png\"><br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_5.png\"></p>\n<p>然后完成K6 Dashboard导入。Dashboard来源：<a href=\"https://grafana.com/grafana/dashboards/2587\">https://grafana.com/grafana/dashboards/2587</a><br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_6.png\"><br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_7.png\"><br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_8.png\"></p>\n<p>导入完成后执行测试用例，引入 -o 参数，确保输出到InfluxDB</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k6 run -o influxdb=http://localhost:8086/k6 script.js</span><br></pre></td></tr></table></figure>\n\n<p>查看Grafana的实时监控<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/img_9.png\"></p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://k6.io/docs/misc/fine-tuning-os/\">https://k6.io/docs/misc/fine-tuning-os/</a><br><a href=\"https://k6.io/docs/getting-started/installation/\">https://k6.io/docs/getting-started/installation/</a><br><a href=\"https://k6.io/blog/zh/k6-vs-jmeter/\">https://k6.io/blog/zh/k6-vs-jmeter/</a></p>\n","slug":"压测-基于K6的web性能测试和实时监控解决方案","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/15/%E5%8E%8B%E6%B5%8B-%E5%9F%BA%E4%BA%8EK6%E7%9A%84web%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"对于性能测试，除了LoadRunner、Jmeter以外，新一代的测试工具还有哪些可选？ 有没有原生集成测试结果集的数据可视化的测试解决方案？ 本文尝试用Grafana Lab出品的K6解决上述问题。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"压测","slug":"压测","permalink":"http://vwin.github.io/tags/%E5%8E%8B%E6%B5%8B/"},{"name":"k6","slug":"k6","permalink":"http://vwin.github.io/tags/k6/"}]},{"title":"自动驾驶-GeoJson学习","date":"2022-11-14T08:50:42.000Z","path":"2022/11/14/自动驾驶-GeoJson学习/","text":"自动驾驶学习过程中-geojson学习记录 简介GeoJSON是一种基于JSON的地理空间数据交换格式，它定义了几种类型JSON对象以及它们组合在一起的方法，以表示有关地理要素、属性和它们的空间范围的数据。2015年，互联网工程任务组（IETF）与原始规范作者组建了一个GeoJSON工作组，一起规范GeoJSON标准。在2016年8月，推出了最新的GeoJSON数据格式标准规范RFC 7946。GeoJSON使用唯一地理坐标参考系统WGS1984和十进制度单位，一个GeoJSON对象可以是Geometry, Feature或者FeatureCollection。其几何对象包括有点（表示地理位置）、线（表示街道、公路、边界）、多边形（表示国家、省、领土），以及由以上类型组合成的复合几何图形。 示例GeoJSON是用于对各种地理数据进行编码一种JSON格式。 一个GeoJSON对象可能代表一个空间区域（Geometry），一个空间有限的实体（Feature），或是一个Feature列表（FeatureCollection）。对象有三个值 1.类型(type) 2.结构(geometory) 3.特性(properties) type的类型可以是，Point MultiPoint LineString MultiLineString Polygon MultiPolygon 或者GeometryCollection。 GeoJSON支持如下几何类型： Point 点 LineString 线段 Polygon 多边形 MultiPoint 多个点 MultiLineString 多个线段 MultiPolygon 多个多边形 GeometryCollection 几何集合 格式涉及最广义的地理数据；任何具有地理空间界限的特质都可能是一个Feature，不论它是否是一个物理结构。GeoJSON中的这些概念都不是新创建出来的，而是从预先已经存在的开放地理信息系统标准中派生出来的，转化成更符合web程序开发的JSON格式。 线要素LineString线要素就是指线段，记录的是线的端点坐标，可视化时会按照记录顺序联结。对于曲线（如贝塞尔曲线）目前还没有很好的表达，但是在地理数据中，曲线一般会用LineString去拟合，现实地理世界中也没有标准的曲线地理要素。 多边形Polygon注：单个多边形是一个3维数组，可以包含多个二维数组，这种情况和MultiPolygon效果很像。 可视化软件qgis作用:QGIS是我们常用的编辑地理数据的工具。使用QGIS，可以对多种地理数据格式的数据进行可视化、编辑、互转格式。 在GIS中，图层（Layer）定义了空间数据在地图窗口中的显示机制，是地理空间数据的可视化表达。图层通常与具体的数据源关联，采用符号和标签等制图元素将空间数据绘制在地图中。 多个图层叠加得到内容丰富的地图。QGIS为图层提供的操作包括：添加&#x2F;删除图层、调整图层顺序、设置&#x2F;调整图层坐标参照系、设置&#x2F;调整&#x2F;管理图层符号、添加标签、图层浏览、图层复制、提取图层要素、设置可见比例尺、编辑图层等。 展示geojson数据:可以直接拖拽，也可以在browser中找到geojson打开，然后可以在Layers中选择展示的图层 参考： Qgis软件使用: https://www.bilibili.com/video/BV1PW411N7vH?p=24&amp;spm_id_from=pageDriver 矢量和格栅数据区别 格栅数据（JPG、BMP、TIF等等） 是通过空间点的密集而规则的排列表示整体的空间现象的一种数据格式。其数据结构简单，定位存取性能好，可以与影像和DEM数据进行联合空间分析，数据共享容易实现，对栅格数据的操作比较容易。 栅格数据的数据量与格网间距的平方成反比，较高的几何精度的代价是数据量的极大增加。以像素大小来衡量数据的清晰度。 矢量数据（cad数据、gis数据、coreldraw数据等） 是通过记录坐标的方式尽可能精确地表示点、线和多边形等地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。矢量结构的显著特点：定位明显，属性隐含。可无限放大或缩小。","raw":"---\ntitle: 自动驾驶-GeoJson学习\ntoc: true\ndate: 2022-11-14 16:50:42\ntags: [自动驾驶,geojson]\ncategories: [技术]\ndescription:\n---\n\n自动驾驶学习过程中-geojson学习记录\n\n<!-- more -->\n\n# 简介\nGeoJSON是一种基于JSON的地理空间数据交换格式，它定义了几种类型JSON对象以及它们组合在一起的方法，以表示有关地理要素、属性和它们的空间范围的数据。\n2015年，互联网工程任务组（IETF）与原始规范作者组建了一个GeoJSON工作组，一起规范GeoJSON标准。在2016年8月，推出了最新的GeoJSON数据格式标准规范RFC 7946。\nGeoJSON使用唯一地理坐标参考系统WGS1984和十进制度单位，一个GeoJSON对象可以是Geometry, Feature或者FeatureCollection。\n其几何对象包括有点（表示地理位置）、线（表示街道、公路、边界）、多边形（表示国家、省、领土），以及由以上类型组合成的复合几何图形。\n# 示例\nGeoJSON是用于对各种地理数据进行编码一种JSON格式。 一个GeoJSON对象可能代表一个空间区域（Geometry），一个空间有限的实体（Feature），或是一个Feature列表（FeatureCollection）。对象有三个值 1.类型(type) 2.结构(geometory) 3.特性(properties) type的类型可以是，Point MultiPoint LineString MultiLineString  Polygon MultiPolygon 或者GeometryCollection。\n\nGeoJSON支持如下几何类型：\n\n- Point 点 \n- LineString 线段 \n- Polygon 多边形 \n- MultiPoint 多个点 \n- MultiLineString 多个线段 \n- MultiPolygon 多个多边形 \n- GeometryCollection 几何集合\n\n格式涉及最广义的地理数据；任何具有地理空间界限的特质都可能是一个Feature，不论它是否是一个物理结构。GeoJSON中的这些概念都不是新创建出来的，而是从预先已经存在的开放地理信息系统标准中派生出来的，转化成更符合web程序开发的JSON格式。\n\n## 线要素LineString\n线要素就是指线段，记录的是线的端点坐标，可视化时会按照记录顺序联结。对于曲线（如贝塞尔曲线）目前还没有很好的表达，但是在地理数据中，曲线一般会用LineString去拟合，现实地理世界中也没有标准的曲线地理要素。\n![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img.png)\n![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_1.png)\n\n## 多边形Polygon\n注：单个多边形是一个3维数组，可以包含多个二维数组，这种情况和MultiPolygon效果很像。\n![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_2.png)\n![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_3.png)\n\n# 可视化软件qgis\n作用:QGIS是我们常用的编辑地理数据的工具。使用QGIS，可以对多种地理数据格式的数据进行可视化、编辑、互转格式。\n\n在GIS中，图层（Layer）定义了空间数据在地图窗口中的显示机制，是地理空间数据的可视化表达。图层通常与具体的数据源关联，采用符号和标签等制图元素将空间数据绘制在地图中。\n\n多个图层叠加得到内容丰富的地图。\n![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_4.png)\nQGIS为图层提供的操作包括：添加/删除图层、调整图层顺序、设置/调整图层坐标参照系、设置/调整/管理图层符号、添加标签、图层浏览、图层复制、提取图层要素、设置可见比例尺、编辑图层等。\n\n展示geojson数据:可以直接拖拽，也可以在browser中找到geojson打开，然后可以在Layers中选择展示的图层\n![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_5.png)\n\n# 参考：\n1. Qgis软件使用: https://www.bilibili.com/video/BV1PW411N7vH?p=24&spm_id_from=pageDriver\n2. 矢量和格栅数据区别\n- 格栅数据（JPG、BMP、TIF等等） \n  - 是通过空间点的密集而规则的排列表示整体的空间现象的一种数据格式。其数据结构简单，定位存取性能好，可以与影像和DEM数据进行联合空间分析，数据共享容易实现，对栅格数据的操作比较容易。 \n  - 栅格数据的数据量与格网间距的平方成反比，较高的几何精度的代价是数据量的极大增加。以像素大小来衡量数据的清晰度。\n- 矢量数据（cad数据、gis数据、coreldraw数据等） \n  - 是通过记录坐标的方式尽可能精确地表示点、线和多边形等地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。\n  矢量结构的显著特点：定位明显，属性隐含。可无限放大或缩小。\n\n\n\n\n\n\n","content":"<p>自动驾驶学习过程中-geojson学习记录</p>\n<span id=\"more\"></span>\n\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>GeoJSON是一种基于JSON的地理空间数据交换格式，它定义了几种类型JSON对象以及它们组合在一起的方法，以表示有关地理要素、属性和它们的空间范围的数据。<br>2015年，互联网工程任务组（IETF）与原始规范作者组建了一个GeoJSON工作组，一起规范GeoJSON标准。在2016年8月，推出了最新的GeoJSON数据格式标准规范RFC 7946。<br>GeoJSON使用唯一地理坐标参考系统WGS1984和十进制度单位，一个GeoJSON对象可以是Geometry, Feature或者FeatureCollection。<br>其几何对象包括有点（表示地理位置）、线（表示街道、公路、边界）、多边形（表示国家、省、领土），以及由以上类型组合成的复合几何图形。</p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>GeoJSON是用于对各种地理数据进行编码一种JSON格式。 一个GeoJSON对象可能代表一个空间区域（Geometry），一个空间有限的实体（Feature），或是一个Feature列表（FeatureCollection）。对象有三个值 1.类型(type) 2.结构(geometory) 3.特性(properties) type的类型可以是，Point MultiPoint LineString MultiLineString  Polygon MultiPolygon 或者GeometryCollection。</p>\n<p>GeoJSON支持如下几何类型：</p>\n<ul>\n<li>Point 点 </li>\n<li>LineString 线段 </li>\n<li>Polygon 多边形 </li>\n<li>MultiPoint 多个点 </li>\n<li>MultiLineString 多个线段 </li>\n<li>MultiPolygon 多个多边形 </li>\n<li>GeometryCollection 几何集合</li>\n</ul>\n<p>格式涉及最广义的地理数据；任何具有地理空间界限的特质都可能是一个Feature，不论它是否是一个物理结构。GeoJSON中的这些概念都不是新创建出来的，而是从预先已经存在的开放地理信息系统标准中派生出来的，转化成更符合web程序开发的JSON格式。</p>\n<h2 id=\"线要素LineString\"><a href=\"#线要素LineString\" class=\"headerlink\" title=\"线要素LineString\"></a>线要素LineString</h2><p>线要素就是指线段，记录的是线的端点坐标，可视化时会按照记录顺序联结。对于曲线（如贝塞尔曲线）目前还没有很好的表达，但是在地理数据中，曲线一般会用LineString去拟合，现实地理世界中也没有标准的曲线地理要素。<br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img.png\"><br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_1.png\"></p>\n<h2 id=\"多边形Polygon\"><a href=\"#多边形Polygon\" class=\"headerlink\" title=\"多边形Polygon\"></a>多边形Polygon</h2><p>注：单个多边形是一个3维数组，可以包含多个二维数组，这种情况和MultiPolygon效果很像。<br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_2.png\"><br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_3.png\"></p>\n<h1 id=\"可视化软件qgis\"><a href=\"#可视化软件qgis\" class=\"headerlink\" title=\"可视化软件qgis\"></a>可视化软件qgis</h1><p>作用:QGIS是我们常用的编辑地理数据的工具。使用QGIS，可以对多种地理数据格式的数据进行可视化、编辑、互转格式。</p>\n<p>在GIS中，图层（Layer）定义了空间数据在地图窗口中的显示机制，是地理空间数据的可视化表达。图层通常与具体的数据源关联，采用符号和标签等制图元素将空间数据绘制在地图中。</p>\n<p>多个图层叠加得到内容丰富的地图。<br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_4.png\"><br>QGIS为图层提供的操作包括：添加&#x2F;删除图层、调整图层顺序、设置&#x2F;调整图层坐标参照系、设置&#x2F;调整&#x2F;管理图层符号、添加标签、图层浏览、图层复制、提取图层要素、设置可见比例尺、编辑图层等。</p>\n<p>展示geojson数据:可以直接拖拽，也可以在browser中找到geojson打开，然后可以在Layers中选择展示的图层<br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/img_5.png\"></p>\n<h1 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h1><ol>\n<li>Qgis软件使用: <a href=\"https://www.bilibili.com/video/BV1PW411N7vH?p=24&amp;spm_id_from=pageDriver\">https://www.bilibili.com/video/BV1PW411N7vH?p=24&amp;spm_id_from=pageDriver</a></li>\n<li>矢量和格栅数据区别</li>\n</ol>\n<ul>\n<li>格栅数据（JPG、BMP、TIF等等） <ul>\n<li>是通过空间点的密集而规则的排列表示整体的空间现象的一种数据格式。其数据结构简单，定位存取性能好，可以与影像和DEM数据进行联合空间分析，数据共享容易实现，对栅格数据的操作比较容易。 </li>\n<li>栅格数据的数据量与格网间距的平方成反比，较高的几何精度的代价是数据量的极大增加。以像素大小来衡量数据的清晰度。</li>\n</ul>\n</li>\n<li>矢量数据（cad数据、gis数据、coreldraw数据等） <ul>\n<li>是通过记录坐标的方式尽可能精确地表示点、线和多边形等地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。<br>矢量结构的显著特点：定位明显，属性隐含。可无限放大或缩小。</li>\n</ul>\n</li>\n</ul>\n","slug":"自动驾驶-GeoJson学习","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/14/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-GeoJson%E5%AD%A6%E4%B9%A0/","excerpt":"自动驾驶学习过程中-geojson学习记录","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"自动驾驶","slug":"自动驾驶","permalink":"http://vwin.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"},{"name":"geojson","slug":"geojson","permalink":"http://vwin.github.io/tags/geojson/"}]},{"title":"自动驾驶-QGIS使用","date":"2022-11-14T08:49:11.000Z","path":"2022/11/14/自动驾驶-QGIS使用/","text":"自动驾驶学习过程中使用到的qgis工具使用记录 下载适合自己系统的，基本一路默认安装下载链接：https://qgis.org/en/site/forusers/download.html 官方教程: https://www.osgeo.cn/qgis_tutorial/ 图层的概念 每一张表都是一个单独的图层，每一个图层具有一种拓扑类型，如点、线、面。道路是线 图层可以叠加、渲染、空间查询、空间分析 读取文件 打开界面shift+ctrl弹出文件导入对话框 导入路网数据 接入谷歌地图 https://www.jianshu.com/p/4e2f8f586e19 查看谷歌街景https://www.google.com/maps/place/25%C2%B001&#39;01.2%22N+121%C2%B037&#39;24.0%22E/@25.0232244,121.6244533,858m/data=!3m1!1e3!4m5!3m4!1s0x0:0x0!8m2!3d25.0169967!4d121.6233305?hl=zh-CN 常用工具 属性查看 筛选 右键点击图层，选中 open attribute 在出来的表格中，左下角，选中field filter 或 advanced filter 如果要筛选LINK_ID，选中 LINK_ID，输入想找的道路ID，回车 出来结果，鼠标点击结果，同时点 ctrl+p，可以定位过去看到路网；如果出通过其他条件，出来的结果不止一条，可以先选中1条，按住shift再选中其他条，可以同时选中中间的所有结果 新增label: 右键单击图层，选中 property，选中 labels，可以给路网添加标签 渲染样式: 右键单击图层，在菜单中选中property，选择symbology，可以调整路网的宽度和颜色 地图链接如下： 腾讯地图http://rt1.map.gtimg.com/realtimerender?z=%7Bz%7D&amp;x=%7Bx%7D&amp;y=%7B-y%7D&amp;type=vector&amp;style=0&amp;version=1.1 高德矢量图https://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x={x}&amp;y={y}&amp;z={z} 高德卫星：https://webst01.is.autonavi.com/appmaptile?style=6&amp;x={x}&amp;y={y}&amp;z={z} 高德路网：https://wprd01.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=8&amp;ltype=11 谷歌路网：http://mt2.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz} 谷歌卫星：http://mt2.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=%7BX%7D&amp;y=%7By%7D&amp;z=%7Bz} 谷歌地形：http://mt0.google.cn/vt/lyrs=t&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz} 谷歌卫星-hybird：https://mt1.google.com/vt/lyrs=y&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz} OpenStreetMap路网：https://tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png","raw":"---\ntitle: 自动驾驶-QGIS使用\ntoc: true\ndate: 2022-11-14 16:49:11\ntags: [qgis,自动驾驶]\ncategories: [技术]\ndescription: \n---\n自动驾驶学习过程中使用到的qgis工具使用记录\n\n<!-- more -->\n\n1. 下载适合自己系统的，基本一路默认安装\n下载链接：https://qgis.org/en/site/forusers/download.html\n1. 官方教程: https://www.osgeo.cn/qgis_tutorial/ ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image.png)\n2. 图层的概念\n   - 每一张表都是一个单独的图层，每一个图层具有一种拓扑类型，如点、线、面。道路是线\n   - 图层可以叠加、渲染、空间查询、空间分析\n3. 读取文件\n   - 打开界面shift+ctrl弹出文件导入对话框 ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_2.png)\n   - 导入路网数据 ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_3.png)\n4. 接入谷歌地图\n   - https://www.jianshu.com/p/4e2f8f586e19\n5. 查看谷歌街景\n   https://www.google.com/maps/place/25%C2%B001'01.2%22N+121%C2%B037'24.0%22E/@25.0232244,121.6244533,858m/data=!3m1!1e3!4m5!3m4!1s0x0:0x0!8m2!3d25.0169967!4d121.6233305?hl=zh-CN\n   ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_4.png)\n6. 常用工具\n   ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_5.png)\n   - 属性查看 ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_6.png)\n   - 筛选\n     - 右键点击图层，选中 open attribute\n     - 在出来的表格中，左下角，选中field filter 或 advanced filter ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_7.png)\n     - 如果要筛选LINK_ID，选中 LINK_ID，输入想找的道路ID，回车 ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_8.png)\n     - 出来结果，鼠标点击结果，同时点 ctrl+p，可以定位过去看到路网；如果出通过其他条件，出来的结果不止一条，可以先选中1条，按住shift再选中其他条，可以同时选中中间的所有结果 ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_9.png) ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_10.png) ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_11.png)\n     - 新增label: 右键单击图层，选中 property，选中 labels，可以给路网添加标签 ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_12.png) ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_13.png)\n     - 渲染样式: 右键单击图层，在菜单中选中property，选择symbology，可以调整路网的宽度和颜色 ![](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_14.png)\n7. 地图链接如下：\n   - 腾讯地图\n   http://rt1.map.gtimg.com/realtimerender?z=%7Bz%7D&x=%7Bx%7D&y=%7B-y%7D&type=vector&style=0&version=1.1\n   - 高德矢量图\n   https://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}\n   - 高德卫星：\n   https://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}\n   - 高德路网：\n   https://wprd01.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scl=2&style=8&ltype=11\n   - 谷歌路网：\n   http://mt2.google.cn/vt/lyrs=m&hl=zh-CN&gl=cn&x=%7Bx%7D&y=%7By%7D&z=%7Bz}\n   - 谷歌卫星：\n   http://mt2.google.cn/vt/lyrs=s&hl=zh-CN&gl=cn&x=%7BX%7D&y=%7By%7D&z=%7Bz}\n   - 谷歌地形：\n   http://mt0.google.cn/vt/lyrs=t&hl=zh-CN&gl=cn&x=%7Bx%7D&y=%7By%7D&z=%7Bz}\n   - 谷歌卫星-hybird：\n   https://mt1.google.com/vt/lyrs=y&x=%7Bx%7D&y=%7By%7D&z=%7Bz}\n   - OpenStreetMap路网：\n   https://tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png\n\n\n\n     \n\n","content":"<p>自动驾驶学习过程中使用到的qgis工具使用记录</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>下载适合自己系统的，基本一路默认安装<br>下载链接：<a href=\"https://qgis.org/en/site/forusers/download.html\">https://qgis.org/en/site/forusers/download.html</a></li>\n<li>官方教程: <a href=\"https://www.osgeo.cn/qgis_tutorial/\">https://www.osgeo.cn/qgis_tutorial/</a> <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image.png\"></li>\n<li>图层的概念<ul>\n<li>每一张表都是一个单独的图层，每一个图层具有一种拓扑类型，如点、线、面。道路是线</li>\n<li>图层可以叠加、渲染、空间查询、空间分析</li>\n</ul>\n</li>\n<li>读取文件<ul>\n<li>打开界面shift+ctrl弹出文件导入对话框 <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_2.png\"></li>\n<li>导入路网数据 <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_3.png\"></li>\n</ul>\n</li>\n<li>接入谷歌地图<ul>\n<li><a href=\"https://www.jianshu.com/p/4e2f8f586e19\">https://www.jianshu.com/p/4e2f8f586e19</a></li>\n</ul>\n</li>\n<li>查看谷歌街景<br><a href=\"https://www.google.com/maps/place/25%C2%B001&#39;01.2%22N+121%C2%B037&#39;24.0%22E/@25.0232244,121.6244533,858m/data=!3m1!1e3!4m5!3m4!1s0x0:0x0!8m2!3d25.0169967!4d121.6233305?hl=zh-CN\">https://www.google.com/maps/place/25%C2%B001&#39;01.2%22N+121%C2%B037&#39;24.0%22E/@25.0232244,121.6244533,858m/data=!3m1!1e3!4m5!3m4!1s0x0:0x0!8m2!3d25.0169967!4d121.6233305?hl=zh-CN</a><br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_4.png\"></li>\n<li>常用工具<br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_5.png\"><ul>\n<li>属性查看 <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_6.png\"></li>\n<li>筛选<ul>\n<li>右键点击图层，选中 open attribute</li>\n<li>在出来的表格中，左下角，选中field filter 或 advanced filter <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_7.png\"></li>\n<li>如果要筛选LINK_ID，选中 LINK_ID，输入想找的道路ID，回车 <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_8.png\"></li>\n<li>出来结果，鼠标点击结果，同时点 ctrl+p，可以定位过去看到路网；如果出通过其他条件，出来的结果不止一条，可以先选中1条，按住shift再选中其他条，可以同时选中中间的所有结果 <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_9.png\"> <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_10.png\"> <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_11.png\"></li>\n<li>新增label: 右键单击图层，选中 property，选中 labels，可以给路网添加标签 <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_12.png\"> <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_13.png\"></li>\n<li>渲染样式: 右键单击图层，在菜单中选中property，选择symbology，可以调整路网的宽度和颜色 <img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/image_14.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>地图链接如下：<ul>\n<li>腾讯地图<br><a href=\"http://rt1.map.gtimg.com/realtimerender?z=%7Bz%7D&amp;x=%7Bx%7D&amp;y=%7B-y%7D&amp;type=vector&amp;style=0&amp;version=1.1\">http://rt1.map.gtimg.com/realtimerender?z=%7Bz%7D&amp;x=%7Bx%7D&amp;y=%7B-y%7D&amp;type=vector&amp;style=0&amp;version=1.1</a></li>\n<li>高德矢量图<br><a href=\"https://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D\">https://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x={x}&amp;y={y}&amp;z={z}</a></li>\n<li>高德卫星：<br><a href=\"https://webst01.is.autonavi.com/appmaptile?style=6&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D\">https://webst01.is.autonavi.com/appmaptile?style=6&amp;x={x}&amp;y={y}&amp;z={z}</a></li>\n<li>高德路网：<br><a href=\"https://wprd01.is.autonavi.com/appmaptile?x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=8&amp;ltype=11\">https://wprd01.is.autonavi.com/appmaptile?x={x}&amp;y={y}&amp;z={z}&amp;lang=zh_cn&amp;size=1&amp;scl=2&amp;style=8&amp;ltype=11</a></li>\n<li>谷歌路网：<br><a href=\"http://mt2.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D\">http://mt2.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz}</a></li>\n<li>谷歌卫星：<br><a href=\"http://mt2.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=%7BX%7D&amp;y=%7By%7D&amp;z=%7Bz%7D\">http://mt2.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=%7BX%7D&amp;y=%7By%7D&amp;z=%7Bz}</a></li>\n<li>谷歌地形：<br><a href=\"http://mt0.google.cn/vt/lyrs=t&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D\">http://mt0.google.cn/vt/lyrs=t&amp;hl=zh-CN&amp;gl=cn&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz}</a></li>\n<li>谷歌卫星-hybird：<br><a href=\"https://mt1.google.com/vt/lyrs=y&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz%7D\">https://mt1.google.com/vt/lyrs=y&amp;x=%7Bx%7D&amp;y=%7By%7D&amp;z=%7Bz}</a></li>\n<li>OpenStreetMap路网：<br><a href=\"https://tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png\">https://tile.openstreetmap.org/%7Bz%7D/%7Bx%7D/%7By%7D.png</a></li>\n</ul>\n</li>\n</ol>\n","slug":"自动驾驶-QGIS使用","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/14/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-QGIS%E4%BD%BF%E7%94%A8/","excerpt":"自动驾驶学习过程中使用到的qgis工具使用记录","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"自动驾驶","slug":"自动驾驶","permalink":"http://vwin.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"},{"name":"qgis","slug":"qgis","permalink":"http://vwin.github.io/tags/qgis/"}]},{"title":"后台测试入门-如何做后台性能测试","date":"2022-11-14T05:31:58.000Z","path":"2022/11/14/后台测试入门-如何做后台性能测试/","text":"本文从性能测试基础理论，真实的后台测试实践举例，常见性能问题举例三个方面，帮你快速入门后台性能测试 性能测试的目的性能测试需求来源在项目测试的过程中，经常会收到或评估出如下需求： XX天要做活动，流量要翻十倍 这次项目加了个XX功能，需要压一下 做了个性能优化，看看效果怎么样 做了个新系统，性能要测一下 这个模块并发有风险，要压一下看看 这个模块有几个参数需要压一下调整下 常见的性能测试目的在正常请求流量下，系统的各个性能指标： 平均响应时间，响应时间分布，超时率 根据线上部署情况，CPU，内存，磁盘io，网络等硬件资源使用情况 请求成功率系统能够承受的极限压力，以及系统性能瓶颈: 极限压力指的是在满足运维指标的情况下，系统能承受的每秒最大请求数（平响，成功率） 极限峰值压力，极限持续压力系统稳定性: 在多并发情况下，系统可能存在异常 在长时间运行的情况下，系统可能出现异常 在大量异常请求或异常响应情况下，系统可能出现异常 性能测试设计做性能测试设计，首先问自己4步: How – 怎么压 起多大压力？怎么起压力？压多长时间？ Who – 要压谁 压测对象是什么，模块？系统？ What – 压什么请求 压测接口有哪些？ 压测请求怎么构造？ Where – 压什么环境 线上环境？线下环境？ 压测环境怎么保证真实? How-怎么压-根据目的确定方案 在正常请求流量下，系统的各个性能指标： 方案最简单明确，按需求压力进行加压，观察收集各个指标即可 需求流量分析结果设计流量(线上流量、产品开发评估、漏斗模型等) 各个性能指标的获取 平均响应时间&#x2F;吞吐量：压测工具 机器指标： 负载监控：cpu 、内存、硬盘io、网络 io 业务指标： 业务日志 系统能够承受的极限压力，以及系统性能瓶颈: 阶梯加压法，通过调整请求并发数逐步提高压力，收集系统信息获取系统每秒处理请求数，平均响应时间和成功率 系统稳定性： 使用一定qps（极限&#x2F;日常） 提高并发数 长时间压力下 异常请求或后端返回情况下 What-压测什么请求根据线上流量情况设计: - 处理线上混合流量时系统情况：登录服务重构 - 系统性能回归常用：增长平台性能优化根据需求流量分析结果设计: - 新系统：足迹地图服务上线 - 活动：地图国庆&#x2F;春节活动 Who-压测对象是谁根据发压对象，调整压测方案 国庆活动：活动整体系统，从入口层发压 新模块上线：模块级压测 Where-压测什么环境线上性能测试：准确、风险大线下完整系统的性能测试：成本极高，相对准确线下子系统的性能测试：最常用，准确性较差线下模块级性能测试：通常用来预估 线下性能测试线下测试环境与线上环境一致 &#x3D; 几乎不可能了解部署可能的差异对系统性能的影响，尽量接近线上环境机器性能：与线上同配置（CPU&#x2F;内存）、机器类型相同（tkex中选择生产环境负载）网络情况：部署地域、发压&amp;被压机器同地域配置参数：日志级别、连接池大小……数据库，redis等其它公共模块的版本，配置等 最重要的一点：不要请求到线上环境！！！包括各种连接下游配置、mysql、redis等存储 线上性能测试 线上性能测试优势: 精准得出性能测试结果 线下没有成本搭建性能测试系统时 系统级发现模块间链接问题 需要解决的问题 数据影响、流量影响、外部影响、系统服务拒绝风险 数据影响：指压测产生的数据对线上影响 方案1：数据清理 方案2：数据隔离（逻辑隔离，物理隔离） 流量影响：指线上流量和压测流量共用一个模块互相影响 线上切流量 压测流量标识 外部影响：线上压测影响外部基础服务或下游业务方 专有逻辑打桩mock 系统服务拒绝风险：压挂了怎么办 阶梯控制压力、做好预案、流量低峰进行 性能测试方案性能测试方案应该包含的内容： 设计目标：实现的功能、性能目标 系统环境： 被测系统与周边模块的联系（拓扑图）、被测系统所在机器的软硬件参数、测试环境的部署 接口或模块的压测目标： 线上接口访问量统计、压测场景分析、被测接口功能梳理、各接口压测目标 数据、脚本的准备：压力词表产出方式、压力计算、压力工具、服务支持（主要是需要开发做的）、计划的压测过程 压测数据收集及系统监控 风险评估：潜在的对其他系统的影响（如线上）、线下压测存在的不可抗力的不准确性、无法提前避免的情况 如何决定压测环境的部署方式？ 目标和对应的测试环境： 测试迭代会不会导致系统性能下降-&gt;线下单台 新模块的稳定性及极限压力-&gt;线下等比例缩放或线上 流量飙升-&gt;线下等比例缩放或线上 如何产出压测词表？ 按接口分别配置压力 混压还是单压 接口内区分不同类请求（真实数据还是数据构造） 避免命中缓存热点或数据库热点 性能测试执行性能测试执行包括： 测试工具准备：压测工具、第三方依赖mock、环境监控配置（007） 测试词表（测试数据）准备：编写脚本拉取线上日志做处理、编写脚本直接构造测试词表、跑脚本插库、写redis queue 测试环境搭建：严格按照测试方案搭建测试环境、注意不要配置连到线上、涉及请求第三方提前沟通、测试连通性，包括压测工具正确性（观察error日志）、注意服务的启动参数是否跟线上一致（cpu、内存等） 起压：按照测试方案起压、时刻观察系统状态（系统监控、负载监控、error日志，业务日志） 性能问题初步分析及定位：响应时间变长（cpu、内存、慢sql、数据库监控、业务日志、error日志）、模块挂掉（ cpu、内存、error日志）、返回报错（error日志） 性能测试报告性能测试报告应该包含如下内容（包括但不限于）: 性能测试方案&amp;测试建模：作为链接或者附件放在测试报告里 测试结论：被测系统是否满足性能要求、如果不满足，你的建议是什么、对于线上部署的建议（机器配置、数据库&#x2F;redis配置、配置参数） 压测结果：压测得到的吞吐量、平均相应时间、超时率等 问题列表&amp;优化方案： 发现了什么问题，如何解决的，解决前后性能对比，可能的话可以进行多轮测试 如果有自己的分析，可以加上自己的分析过程 监控情况测试报告示例： xx五一活动压测实践需求背景在五一出行高峰，基于IP使用、导航功能场景规划活动，希望借力五一自然流量高峰，提升IP使用人数及天频。活动包括两部分： 趣味H5小游戏「前进吧，导航官」，引导用户在游戏中完成IP设置；APP端内「集福利拼图得出行礼包」活动，吸引导航用户参与，提升导航功能渗透，进而提升月人天。两个活动通过拼图发放连结，福利拼图可在小游戏中获得、也可在使用语音导航中获得。 压测场景分析基于测试建模和服务拓扑关系，进行压测接口和接口功能梳理。 确定需要压测的接口&#x2F;场景确定要压测的接口，主要从以下3个方面考虑：访问量大的接口：进入活动页面就会访问的接口活动主页 info接口活动奖品领取 grant接口本次新增接口：本次拼图为新增功能，相关接口拼图信息、拼图分享码生成、领取拼图、赠送拼图等本次改动较多接口：抽奖接口 以下为本次压测的具体压测接口和场景： 确定压测目标根据产品给出的量级预估产品预估量级：每天大概Xw的曝光UV，PV可能Xw预估公式：PV&#x2F;（83600） 3 &#x3D; Xqps参考往期活动21年国庆活动info接口最高qps为X21年十二月活动info接口最高qps为X本次活动流量预估产品给PV值很低，本次活动无业务流量峰值（固定时间开奖、提现等），参考往期活动峰值和经验，压测目标暂定访问量大的接口&gt;Xqps，其他接口&gt;Xqps，即满足需求实际最高QPS：info接口 Xqps 压测环境压测环境：本次压测在测试环境进行链路压测方案方案一：去掉下游依赖，mock方案二：直接请求or改造下游服务方案选择积分、商城服务（无修改）：直接请求画像服务（有修改）：请求本次画像测试环境登录、稽查服务：mock 压测工具&amp;压测用例编写使用现有平台或工具均可优测平台：https://utest.21kunpeng.com/home新活动（无线上数据），编写用例直接构造测试词表 压测用例编写举例测试场景一：合成拼图lottery接口场景分析：合成拼图的前提条件是需要有拼图碎片，所以需要先构造拼图数据（词表）数据构造方法：1、写脚本插入写入；2、调抽奖接口获取采用方法：经过分析，调接口构造数据的方法最简单：单独配置一个抽奖玩法，每次抽奖获取合成所需的8张拼图 测试场景二：导航官酷跑后发奖grant接口场景分析：导航官酷跑游戏，先调用info接口，获取本次酷跑地图（在多少米获取金币），酷跑结束后，调用grant接口领取金币奖励。Grant接口的请求参数，需要使用之前info接口的返回值。 常见的性能问题举例数据库相关问题数据库连接池设置不合理&#x2F;未设置&#x2F;失效问题举例：五一活动中数据库连接池设置被误删除问题现象：qps压不上去&#x2F;错误率上升，error日志：数据库连接失败等 数据库索引问题：未使用索引，索引字段使用类型错误问题举例：五一活动中查询活动id字段，应使用string类型，实际使用int类型问题现象： qps压不上去，平均相应时间变长，数据库存在慢查询、CPU过高 数据库索引问题：索引设计过多，导致插入过慢问题举例：春节活动发现发奖代理db插入较慢，发现建表时字段设计过大，索引设计多，导致插入一行占用空间带 数据库表分区问题：未按照分区字段查询，导致全表扫描问题举例：五一活动查询抽奖表，该表按照user_id分区，但使用的是id作为查询条件问题现象：qps压不上去，平均相应时间变长，数据库存在慢查询、CPU过高 接口逻辑问题返回数据问题：问题举例：首页、抽奖等接口返回回包过大（大于500kB）：通过前端添加请求参数，过滤本次活动无用数据问题现象：回包过大 无关逻辑&#x2F;调用：问题举例：春节活动无需用户画像功能，在代码中依然调用了该功能 调用第三方问题调用第三方服务错误：问题举例：调用画像服务接口错误，调用了内部接口，性能无法满足对外服务要求问题现象：qps压不上去&#x2F;错误率上升，error日志：调用画像接口失败","raw":"---\ntitle: 后台测试入门-如何做后台性能测试\ntoc: true\ndate: 2022-11-14 13:31:58\ntags: [后台,测试,性能测试]\ncategories: [测试]\ndescription:\n---\n本文从性能测试基础理论，真实的后台测试实践举例，常见性能问题举例三个方面，帮你快速入门后台性能测试\n\n<!--more-->\n\n# 性能测试的目的\n## 性能测试需求来源\n在项目测试的过程中，经常会收到或评估出如下需求：\n\n- XX天要做活动，流量要翻十倍\n- 这次项目加了个XX功能，需要压一下\n- 做了个性能优化，看看效果怎么样\n- 做了个新系统，性能要测一下\n- 这个模块并发有风险，要压一下看看\n- 这个模块有几个参数需要压一下调整下 \n\n## 常见的性能测试目的\n在正常请求流量下，系统的各个性能指标： \n- 平均响应时间，响应时间分布，超时率 \n- 根据线上部署情况，CPU，内存，磁盘io，网络等硬件资源使用情况 \n- 请求成功率\n系统能够承受的极限压力，以及系统性能瓶颈:\n- 极限压力指的是在满足运维指标的情况下，系统能承受的每秒最大请求数（平响，成功率） \n- 极限峰值压力，极限持续压力\n系统稳定性:\n- 在多并发情况下，系统可能存在异常 \n- 在长时间运行的情况下，系统可能出现异常 \n- 在大量异常请求或异常响应情况下，系统可能出现异常\n\n# 性能测试设计\n做性能测试设计，首先问自己4步:\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img.png)\n\n- How – 怎么压 \n  - 起多大压力？怎么起压力？压多长时间？\n- Who – 要压谁\n  - 压测对象是什么，模块？系统？\n- What – 压什么请求\n  - 压测接口有哪些？\n  - 压测请求怎么构造？\n- Where – 压什么环境\n  - 线上环境？线下环境？\n- 压测环境怎么保证真实?\n\n## How-怎么压-根据目的确定方案\n1. 在正常请求流量下，系统的各个性能指标：\n   - 方案最简单明确，按需求压力进行加压，观察收集各个指标即可\n   - 需求流量分析结果设计流量(线上流量、产品开发评估、漏斗模型等)\n   - 各个性能指标的获取\n      - 平均响应时间/吞吐量：压测工具\n      - 机器指标： 负载监控：cpu 、内存、硬盘io、网络 io\n      - 业务指标： 业务日志\n2. 系统能够承受的极限压力，以及系统性能瓶颈:\n    阶梯加压法，通过调整请求并发数逐步提高压力，收集系统信息获取系统每秒处理请求数，平均响应时间和成功率\n\n3. 系统稳定性：\n    - 使用一定qps（极限/日常）\n    - 提高并发数\n    - 长时间压力下\n    - 异常请求或后端返回情况下\n\n\n## What-压测什么请求\n根据线上流量情况设计:\n    - 处理线上混合流量时系统情况：登录服务重构 \n    - 系统性能回归常用：增长平台性能优化\n根据需求流量分析结果设计:\n    - 新系统：足迹地图服务上线\n    - 活动：地图国庆/春节活动\n\n## Who-压测对象是谁\n根据发压对象，调整压测方案\n- 国庆活动：活动整体系统，从入口层发压\n- 新模块上线：模块级压测\n\n## Where-压测什么环境\n线上性能测试：准确、风险大\n线下完整系统的性能测试：成本极高，相对准确\n线下子系统的性能测试：最常用，准确性较差\n线下模块级性能测试：通常用来预估\n\n### 线下性能测试\n线下测试环境与线上环境一致 = 几乎不可能\n了解部署可能的差异对系统性能的影响，尽量接近线上环境\n机器性能：与线上同配置（CPU/内存）、机器类型相同（tkex中选择生产环境负载）\n网络情况：部署地域、发压&被压机器同地域\n配置参数：日志级别、连接池大小……\n数据库，redis等其它公共模块的版本，配置等\n>最重要的一点：不要请求到线上环境！！！包括各种连接下游配置、mysql、redis等存储\n\n### 线上性能测试\n1. 线上性能测试优势:\n   - 精准得出性能测试结果 \n   - 线下没有成本搭建性能测试系统时 \n   - 系统级发现模块间链接问题\n2. 需要解决的问题 \n   - 数据影响、流量影响、外部影响、系统服务拒绝风险\n3. 数据影响：指压测产生的数据对线上影响 \n   - 方案1：数据清理\n   - 方案2：数据隔离（逻辑隔离，物理隔离）\n4. 流量影响：指线上流量和压测流量共用一个模块互相影响 \n   - 线上切流量 \n   - 压测流量标识\n5. 外部影响：线上压测影响外部基础服务或下游业务方 \n   - 专有逻辑打桩mock\n6. 系统服务拒绝风险：压挂了怎么办 \n   - 阶梯控制压力、做好预案、流量低峰进行\n\n# 性能测试方案\n性能测试方案应该包含的内容：\n1. 设计目标：实现的功能、性能目标\n2. 系统环境： \n   - 被测系统与周边模块的联系（拓扑图）、被测系统所在机器的软硬件参数、测试环境的部署\n3. 接口或模块的压测目标： \n   - 线上接口访问量统计、压测场景分析、被测接口功能梳理、各接口压测目标 \n4. 数据、脚本的准备：压力词表产出方式、压力计算、压力工具、服务支持（主要是需要开发做的）、计划的压测过程\n5. 压测数据收集及系统监控\n6. 风险评估：潜在的对其他系统的影响（如线上）、线下压测存在的不可抗力的不准确性、无法提前避免的情况\n7. 如何决定压测环境的部署方式？ \n   - 目标和对应的测试环境： \n   - 测试迭代会不会导致系统性能下降->线下单台 \n   - 新模块的稳定性及极限压力->线下等比例缩放或线上 \n   - 流量飙升->线下等比例缩放或线上\n8. 如何产出压测词表？ \n   - 按接口分别配置压力\n   - 混压还是单压\n   - 接口内区分不同类请求（真实数据还是数据构造）\n   - 避免命中缓存热点或数据库热点\n\n\n# 性能测试执行\n性能测试执行包括：\n1. 测试工具准备：压测工具、第三方依赖mock、环境监控配置（007）\n2. 测试词表（测试数据）准备：编写脚本拉取线上日志做处理、编写脚本直接构造测试词表、跑脚本插库、写redis queue\n3. 测试环境搭建：严格按照测试方案搭建测试环境、注意不要配置连到线上、涉及请求第三方提前沟通、测试连通性，包括压测工具正确性（观察error日志）、注意服务的启动参数是否跟线上一致（cpu、内存等）\n4. 起压：按照测试方案起压、时刻观察系统状态（系统监控、负载监控、error日志，业务日志）\n5. 性能问题初步分析及定位：响应时间变长（cpu、内存、慢sql、数据库监控、业务日志、error日志）、模块挂掉（ cpu、内存、error日志）、返回报错（error日志）\n\n# 性能测试报告\n性能测试报告应该包含如下内容（包括但不限于）:\n1. 性能测试方案&测试建模：作为链接或者附件放在测试报告里\n2. 测试结论：被测系统是否满足性能要求、如果不满足，你的建议是什么、对于线上部署的建议（机器配置、数据库/redis配置、配置参数）\n3. 压测结果：压测得到的吞吐量、平均相应时间、超时率等\n4. 问题列表&优化方案： \n   - 发现了什么问题，如何解决的，解决前后性能对比，可能的话可以进行多轮测试\n   - 如果有自己的分析，可以加上自己的分析过程\n5. 监控情况\n测试报告示例：\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_2.png)\n\n# xx五一活动压测实践\n## 需求背景\n\n在五一出行高峰，基于IP使用、导航功能场景规划活动，希望借力五一自然流量高峰，提升IP使用人数及天频。活动包括两部分：\n\n趣味H5小游戏「前进吧，导航官」，引导用户在游戏中完成IP设置；\nAPP端内「集福利拼图得出行礼包」活动，吸引导航用户参与，提升导航功能渗透，进而提升月人天。\n两个活动通过拼图发放连结，福利拼图可在小游戏中获得、也可在使用语音导航中获得。\n\n## 压测场景分析\n基于测试建模和服务拓扑关系，进行压测接口和接口功能梳理。\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_3.png)\n\n## 确定需要压测的接口/场景\n确定要压测的接口，主要从以下3个方面考虑：\n访问量大的接口：进入活动页面就会访问的接口\n活动主页 info接口\n活动奖品领取 grant接口\n本次新增接口：本次拼图为新增功能，相关接口\n拼图信息、拼图分享码生成、领取拼图、赠送拼图等\n本次改动较多接口：抽奖接口\n\n以下为本次压测的具体压测接口和场景：\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_4.png)\n\n## 确定压测目标\n根据产品给出的量级预估\n产品预估量级：每天大概Xw的曝光UV，PV可能Xw\n预估公式：PV/（8*3600）* 3 = Xqps\n参考往期活动\n21年国庆活动info接口最高qps为X\n21年十二月活动info接口最高qps为X\n本次活动流量预估\n产品给PV值很低，本次活动无业务流量峰值（固定时间开奖、提现等），参考往期活动峰值和经验，压测目标暂定访问量大的接口>Xqps，其他接口>Xqps，即满足需求\n实际最高QPS：info接口 Xqps\n## 压测环境\n压测环境：本次压测在测试环境进行\n链路压测方案\n方案一：去掉下游依赖，mock\n方案二：直接请求or改造下游服务\n方案选择\n积分、商城服务（无修改）：直接请求\n画像服务（有修改）：请求本次画像测试环境\n登录、稽查服务：mock\n## 压测工具&压测用例编写\n使用现有平台或工具均可\n优测平台：https://utest.21kunpeng.com/home\n新活动（无线上数据），编写用例直接构造测试词表\n\n## 压测用例编写举例\n### 测试场景一：合成拼图lottery接口\n场景分析：合成拼图的前提条件是需要有拼图碎片，所以需要先构造拼图数据（词表）\n数据构造方法：1、写脚本插入写入；2、调抽奖接口获取\n采用方法：经过分析，调接口构造数据的方法最简单：单独配置一个抽奖玩法，每次抽奖获取合成所需的8张拼图\n### 测试场景二：导航官酷跑后发奖grant接口\n场景分析：导航官酷跑游戏，先调用info接口，获取本次酷跑地图（在多少米获取金币），酷跑结束后，调用grant接口领取金币奖励。Grant接口的请求参数，需要使用之前info接口的返回值。\n\n# 常见的性能问题举例\n## 数据库相关问题\n### 数据库连接池设置不合理/未设置/失效\n问题举例：五一活动中数据库连接池设置被误删除\n问题现象：qps压不上去/错误率上升，error日志：数据库连接失败等\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_5.png)\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_6.png)\n\n### 数据库索引问题：未使用索引，索引字段使用类型错误\n问题举例：五一活动中查询活动id字段，应使用string类型，实际使用int类型\n问题现象： qps压不上去，平均相应时间变长，数据库存在慢查询、CPU过高\n\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_7.png)\n\n### 数据库索引问题：索引设计过多，导致插入过慢\n\n问题举例：春节活动发现发奖代理db插入较慢，发现建表时字段设计过大，索引设计多，导致插入一行占用空间带\n\n### 数据库表分区问题：未按照分区字段查询，导致全表扫描\n问题举例：五一活动查询抽奖表，该表按照user_id分区，但使用的是id作为查询条件\n问题现象：qps压不上去，平均相应时间变长，数据库存在慢查询、CPU过高\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_8.png)\n\n## 接口逻辑问题\n### 返回数据问题：\n问题举例：首页、抽奖等接口返回回包过大（大于500kB）：通过前端添加请求参数，过滤本次活动无用数据\n问题现象：回包过大\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_9.png)\n\n### 无关逻辑/调用：\n问题举例：春节活动无需用户画像功能，在代码中依然调用了该功能\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_10.png)\n\n## 调用第三方问题\n### 调用第三方服务错误：\n问题举例：调用画像服务接口错误，调用了内部接口，性能无法满足对外服务要求\n问题现象：qps压不上去/错误率上升，error日志：调用画像接口失败\n![](http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_11.png)\n","content":"<p>本文从性能测试基础理论，真实的后台测试实践举例，常见性能问题举例三个方面，帮你快速入门后台性能测试</p>\n<span id=\"more\"></span>\n\n<h1 id=\"性能测试的目的\"><a href=\"#性能测试的目的\" class=\"headerlink\" title=\"性能测试的目的\"></a>性能测试的目的</h1><h2 id=\"性能测试需求来源\"><a href=\"#性能测试需求来源\" class=\"headerlink\" title=\"性能测试需求来源\"></a>性能测试需求来源</h2><p>在项目测试的过程中，经常会收到或评估出如下需求：</p>\n<ul>\n<li>XX天要做活动，流量要翻十倍</li>\n<li>这次项目加了个XX功能，需要压一下</li>\n<li>做了个性能优化，看看效果怎么样</li>\n<li>做了个新系统，性能要测一下</li>\n<li>这个模块并发有风险，要压一下看看</li>\n<li>这个模块有几个参数需要压一下调整下</li>\n</ul>\n<h2 id=\"常见的性能测试目的\"><a href=\"#常见的性能测试目的\" class=\"headerlink\" title=\"常见的性能测试目的\"></a>常见的性能测试目的</h2><p>在正常请求流量下，系统的各个性能指标： </p>\n<ul>\n<li>平均响应时间，响应时间分布，超时率 </li>\n<li>根据线上部署情况，CPU，内存，磁盘io，网络等硬件资源使用情况 </li>\n<li>请求成功率<br>系统能够承受的极限压力，以及系统性能瓶颈:</li>\n<li>极限压力指的是在满足运维指标的情况下，系统能承受的每秒最大请求数（平响，成功率） </li>\n<li>极限峰值压力，极限持续压力<br>系统稳定性:</li>\n<li>在多并发情况下，系统可能存在异常 </li>\n<li>在长时间运行的情况下，系统可能出现异常 </li>\n<li>在大量异常请求或异常响应情况下，系统可能出现异常</li>\n</ul>\n<h1 id=\"性能测试设计\"><a href=\"#性能测试设计\" class=\"headerlink\" title=\"性能测试设计\"></a>性能测试设计</h1><p>做性能测试设计，首先问自己4步:<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img.png\"></p>\n<ul>\n<li>How – 怎么压 <ul>\n<li>起多大压力？怎么起压力？压多长时间？</li>\n</ul>\n</li>\n<li>Who – 要压谁<ul>\n<li>压测对象是什么，模块？系统？</li>\n</ul>\n</li>\n<li>What – 压什么请求<ul>\n<li>压测接口有哪些？</li>\n<li>压测请求怎么构造？</li>\n</ul>\n</li>\n<li>Where – 压什么环境<ul>\n<li>线上环境？线下环境？</li>\n</ul>\n</li>\n<li>压测环境怎么保证真实?</li>\n</ul>\n<h2 id=\"How-怎么压-根据目的确定方案\"><a href=\"#How-怎么压-根据目的确定方案\" class=\"headerlink\" title=\"How-怎么压-根据目的确定方案\"></a>How-怎么压-根据目的确定方案</h2><ol>\n<li><p>在正常请求流量下，系统的各个性能指标：</p>\n<ul>\n<li>方案最简单明确，按需求压力进行加压，观察收集各个指标即可</li>\n<li>需求流量分析结果设计流量(线上流量、产品开发评估、漏斗模型等)</li>\n<li>各个性能指标的获取<ul>\n<li>平均响应时间&#x2F;吞吐量：压测工具</li>\n<li>机器指标： 负载监控：cpu 、内存、硬盘io、网络 io</li>\n<li>业务指标： 业务日志</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>系统能够承受的极限压力，以及系统性能瓶颈:<br> 阶梯加压法，通过调整请求并发数逐步提高压力，收集系统信息获取系统每秒处理请求数，平均响应时间和成功率</p>\n</li>\n<li><p>系统稳定性：</p>\n<ul>\n<li>使用一定qps（极限&#x2F;日常）</li>\n<li>提高并发数</li>\n<li>长时间压力下</li>\n<li>异常请求或后端返回情况下</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"What-压测什么请求\"><a href=\"#What-压测什么请求\" class=\"headerlink\" title=\"What-压测什么请求\"></a>What-压测什么请求</h2><p>根据线上流量情况设计:<br>    - 处理线上混合流量时系统情况：登录服务重构<br>    - 系统性能回归常用：增长平台性能优化<br>根据需求流量分析结果设计:<br>    - 新系统：足迹地图服务上线<br>    - 活动：地图国庆&#x2F;春节活动</p>\n<h2 id=\"Who-压测对象是谁\"><a href=\"#Who-压测对象是谁\" class=\"headerlink\" title=\"Who-压测对象是谁\"></a>Who-压测对象是谁</h2><p>根据发压对象，调整压测方案</p>\n<ul>\n<li>国庆活动：活动整体系统，从入口层发压</li>\n<li>新模块上线：模块级压测</li>\n</ul>\n<h2 id=\"Where-压测什么环境\"><a href=\"#Where-压测什么环境\" class=\"headerlink\" title=\"Where-压测什么环境\"></a>Where-压测什么环境</h2><p>线上性能测试：准确、风险大<br>线下完整系统的性能测试：成本极高，相对准确<br>线下子系统的性能测试：最常用，准确性较差<br>线下模块级性能测试：通常用来预估</p>\n<h3 id=\"线下性能测试\"><a href=\"#线下性能测试\" class=\"headerlink\" title=\"线下性能测试\"></a>线下性能测试</h3><p>线下测试环境与线上环境一致 &#x3D; 几乎不可能<br>了解部署可能的差异对系统性能的影响，尽量接近线上环境<br>机器性能：与线上同配置（CPU&#x2F;内存）、机器类型相同（tkex中选择生产环境负载）<br>网络情况：部署地域、发压&amp;被压机器同地域<br>配置参数：日志级别、连接池大小……<br>数据库，redis等其它公共模块的版本，配置等</p>\n<blockquote>\n<p>最重要的一点：不要请求到线上环境！！！包括各种连接下游配置、mysql、redis等存储</p>\n</blockquote>\n<h3 id=\"线上性能测试\"><a href=\"#线上性能测试\" class=\"headerlink\" title=\"线上性能测试\"></a>线上性能测试</h3><ol>\n<li>线上性能测试优势:<ul>\n<li>精准得出性能测试结果 </li>\n<li>线下没有成本搭建性能测试系统时 </li>\n<li>系统级发现模块间链接问题</li>\n</ul>\n</li>\n<li>需要解决的问题 <ul>\n<li>数据影响、流量影响、外部影响、系统服务拒绝风险</li>\n</ul>\n</li>\n<li>数据影响：指压测产生的数据对线上影响 <ul>\n<li>方案1：数据清理</li>\n<li>方案2：数据隔离（逻辑隔离，物理隔离）</li>\n</ul>\n</li>\n<li>流量影响：指线上流量和压测流量共用一个模块互相影响 <ul>\n<li>线上切流量 </li>\n<li>压测流量标识</li>\n</ul>\n</li>\n<li>外部影响：线上压测影响外部基础服务或下游业务方 <ul>\n<li>专有逻辑打桩mock</li>\n</ul>\n</li>\n<li>系统服务拒绝风险：压挂了怎么办 <ul>\n<li>阶梯控制压力、做好预案、流量低峰进行</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"性能测试方案\"><a href=\"#性能测试方案\" class=\"headerlink\" title=\"性能测试方案\"></a>性能测试方案</h1><p>性能测试方案应该包含的内容：</p>\n<ol>\n<li>设计目标：实现的功能、性能目标</li>\n<li>系统环境： <ul>\n<li>被测系统与周边模块的联系（拓扑图）、被测系统所在机器的软硬件参数、测试环境的部署</li>\n</ul>\n</li>\n<li>接口或模块的压测目标： <ul>\n<li>线上接口访问量统计、压测场景分析、被测接口功能梳理、各接口压测目标</li>\n</ul>\n</li>\n<li>数据、脚本的准备：压力词表产出方式、压力计算、压力工具、服务支持（主要是需要开发做的）、计划的压测过程</li>\n<li>压测数据收集及系统监控</li>\n<li>风险评估：潜在的对其他系统的影响（如线上）、线下压测存在的不可抗力的不准确性、无法提前避免的情况</li>\n<li>如何决定压测环境的部署方式？ <ul>\n<li>目标和对应的测试环境： </li>\n<li>测试迭代会不会导致系统性能下降-&gt;线下单台 </li>\n<li>新模块的稳定性及极限压力-&gt;线下等比例缩放或线上 </li>\n<li>流量飙升-&gt;线下等比例缩放或线上</li>\n</ul>\n</li>\n<li>如何产出压测词表？ <ul>\n<li>按接口分别配置压力</li>\n<li>混压还是单压</li>\n<li>接口内区分不同类请求（真实数据还是数据构造）</li>\n<li>避免命中缓存热点或数据库热点</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"性能测试执行\"><a href=\"#性能测试执行\" class=\"headerlink\" title=\"性能测试执行\"></a>性能测试执行</h1><p>性能测试执行包括：</p>\n<ol>\n<li>测试工具准备：压测工具、第三方依赖mock、环境监控配置（007）</li>\n<li>测试词表（测试数据）准备：编写脚本拉取线上日志做处理、编写脚本直接构造测试词表、跑脚本插库、写redis queue</li>\n<li>测试环境搭建：严格按照测试方案搭建测试环境、注意不要配置连到线上、涉及请求第三方提前沟通、测试连通性，包括压测工具正确性（观察error日志）、注意服务的启动参数是否跟线上一致（cpu、内存等）</li>\n<li>起压：按照测试方案起压、时刻观察系统状态（系统监控、负载监控、error日志，业务日志）</li>\n<li>性能问题初步分析及定位：响应时间变长（cpu、内存、慢sql、数据库监控、业务日志、error日志）、模块挂掉（ cpu、内存、error日志）、返回报错（error日志）</li>\n</ol>\n<h1 id=\"性能测试报告\"><a href=\"#性能测试报告\" class=\"headerlink\" title=\"性能测试报告\"></a>性能测试报告</h1><p>性能测试报告应该包含如下内容（包括但不限于）:</p>\n<ol>\n<li>性能测试方案&amp;测试建模：作为链接或者附件放在测试报告里</li>\n<li>测试结论：被测系统是否满足性能要求、如果不满足，你的建议是什么、对于线上部署的建议（机器配置、数据库&#x2F;redis配置、配置参数）</li>\n<li>压测结果：压测得到的吞吐量、平均相应时间、超时率等</li>\n<li>问题列表&amp;优化方案： <ul>\n<li>发现了什么问题，如何解决的，解决前后性能对比，可能的话可以进行多轮测试</li>\n<li>如果有自己的分析，可以加上自己的分析过程</li>\n</ul>\n</li>\n<li>监控情况<br>测试报告示例：<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_2.png\"></li>\n</ol>\n<h1 id=\"xx五一活动压测实践\"><a href=\"#xx五一活动压测实践\" class=\"headerlink\" title=\"xx五一活动压测实践\"></a>xx五一活动压测实践</h1><h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h2><p>在五一出行高峰，基于IP使用、导航功能场景规划活动，希望借力五一自然流量高峰，提升IP使用人数及天频。活动包括两部分：</p>\n<p>趣味H5小游戏「前进吧，导航官」，引导用户在游戏中完成IP设置；<br>APP端内「集福利拼图得出行礼包」活动，吸引导航用户参与，提升导航功能渗透，进而提升月人天。<br>两个活动通过拼图发放连结，福利拼图可在小游戏中获得、也可在使用语音导航中获得。</p>\n<h2 id=\"压测场景分析\"><a href=\"#压测场景分析\" class=\"headerlink\" title=\"压测场景分析\"></a>压测场景分析</h2><p>基于测试建模和服务拓扑关系，进行压测接口和接口功能梳理。<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_3.png\"></p>\n<h2 id=\"确定需要压测的接口-x2F-场景\"><a href=\"#确定需要压测的接口-x2F-场景\" class=\"headerlink\" title=\"确定需要压测的接口&#x2F;场景\"></a>确定需要压测的接口&#x2F;场景</h2><p>确定要压测的接口，主要从以下3个方面考虑：<br>访问量大的接口：进入活动页面就会访问的接口<br>活动主页 info接口<br>活动奖品领取 grant接口<br>本次新增接口：本次拼图为新增功能，相关接口<br>拼图信息、拼图分享码生成、领取拼图、赠送拼图等<br>本次改动较多接口：抽奖接口</p>\n<p>以下为本次压测的具体压测接口和场景：<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_4.png\"></p>\n<h2 id=\"确定压测目标\"><a href=\"#确定压测目标\" class=\"headerlink\" title=\"确定压测目标\"></a>确定压测目标</h2><p>根据产品给出的量级预估<br>产品预估量级：每天大概Xw的曝光UV，PV可能Xw<br>预估公式：PV&#x2F;（8<em>3600）</em> 3 &#x3D; Xqps<br>参考往期活动<br>21年国庆活动info接口最高qps为X<br>21年十二月活动info接口最高qps为X<br>本次活动流量预估<br>产品给PV值很低，本次活动无业务流量峰值（固定时间开奖、提现等），参考往期活动峰值和经验，压测目标暂定访问量大的接口&gt;Xqps，其他接口&gt;Xqps，即满足需求<br>实际最高QPS：info接口 Xqps</p>\n<h2 id=\"压测环境\"><a href=\"#压测环境\" class=\"headerlink\" title=\"压测环境\"></a>压测环境</h2><p>压测环境：本次压测在测试环境进行<br>链路压测方案<br>方案一：去掉下游依赖，mock<br>方案二：直接请求or改造下游服务<br>方案选择<br>积分、商城服务（无修改）：直接请求<br>画像服务（有修改）：请求本次画像测试环境<br>登录、稽查服务：mock</p>\n<h2 id=\"压测工具-amp-压测用例编写\"><a href=\"#压测工具-amp-压测用例编写\" class=\"headerlink\" title=\"压测工具&amp;压测用例编写\"></a>压测工具&amp;压测用例编写</h2><p>使用现有平台或工具均可<br>优测平台：<a href=\"https://utest.21kunpeng.com/home\">https://utest.21kunpeng.com/home</a><br>新活动（无线上数据），编写用例直接构造测试词表</p>\n<h2 id=\"压测用例编写举例\"><a href=\"#压测用例编写举例\" class=\"headerlink\" title=\"压测用例编写举例\"></a>压测用例编写举例</h2><h3 id=\"测试场景一：合成拼图lottery接口\"><a href=\"#测试场景一：合成拼图lottery接口\" class=\"headerlink\" title=\"测试场景一：合成拼图lottery接口\"></a>测试场景一：合成拼图lottery接口</h3><p>场景分析：合成拼图的前提条件是需要有拼图碎片，所以需要先构造拼图数据（词表）<br>数据构造方法：1、写脚本插入写入；2、调抽奖接口获取<br>采用方法：经过分析，调接口构造数据的方法最简单：单独配置一个抽奖玩法，每次抽奖获取合成所需的8张拼图</p>\n<h3 id=\"测试场景二：导航官酷跑后发奖grant接口\"><a href=\"#测试场景二：导航官酷跑后发奖grant接口\" class=\"headerlink\" title=\"测试场景二：导航官酷跑后发奖grant接口\"></a>测试场景二：导航官酷跑后发奖grant接口</h3><p>场景分析：导航官酷跑游戏，先调用info接口，获取本次酷跑地图（在多少米获取金币），酷跑结束后，调用grant接口领取金币奖励。Grant接口的请求参数，需要使用之前info接口的返回值。</p>\n<h1 id=\"常见的性能问题举例\"><a href=\"#常见的性能问题举例\" class=\"headerlink\" title=\"常见的性能问题举例\"></a>常见的性能问题举例</h1><h2 id=\"数据库相关问题\"><a href=\"#数据库相关问题\" class=\"headerlink\" title=\"数据库相关问题\"></a>数据库相关问题</h2><h3 id=\"数据库连接池设置不合理-x2F-未设置-x2F-失效\"><a href=\"#数据库连接池设置不合理-x2F-未设置-x2F-失效\" class=\"headerlink\" title=\"数据库连接池设置不合理&#x2F;未设置&#x2F;失效\"></a>数据库连接池设置不合理&#x2F;未设置&#x2F;失效</h3><p>问题举例：五一活动中数据库连接池设置被误删除<br>问题现象：qps压不上去&#x2F;错误率上升，error日志：数据库连接失败等<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_5.png\"><br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_6.png\"></p>\n<h3 id=\"数据库索引问题：未使用索引，索引字段使用类型错误\"><a href=\"#数据库索引问题：未使用索引，索引字段使用类型错误\" class=\"headerlink\" title=\"数据库索引问题：未使用索引，索引字段使用类型错误\"></a>数据库索引问题：未使用索引，索引字段使用类型错误</h3><p>问题举例：五一活动中查询活动id字段，应使用string类型，实际使用int类型<br>问题现象： qps压不上去，平均相应时间变长，数据库存在慢查询、CPU过高</p>\n<p><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_7.png\"></p>\n<h3 id=\"数据库索引问题：索引设计过多，导致插入过慢\"><a href=\"#数据库索引问题：索引设计过多，导致插入过慢\" class=\"headerlink\" title=\"数据库索引问题：索引设计过多，导致插入过慢\"></a>数据库索引问题：索引设计过多，导致插入过慢</h3><p>问题举例：春节活动发现发奖代理db插入较慢，发现建表时字段设计过大，索引设计多，导致插入一行占用空间带</p>\n<h3 id=\"数据库表分区问题：未按照分区字段查询，导致全表扫描\"><a href=\"#数据库表分区问题：未按照分区字段查询，导致全表扫描\" class=\"headerlink\" title=\"数据库表分区问题：未按照分区字段查询，导致全表扫描\"></a>数据库表分区问题：未按照分区字段查询，导致全表扫描</h3><p>问题举例：五一活动查询抽奖表，该表按照user_id分区，但使用的是id作为查询条件<br>问题现象：qps压不上去，平均相应时间变长，数据库存在慢查询、CPU过高<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_8.png\"></p>\n<h2 id=\"接口逻辑问题\"><a href=\"#接口逻辑问题\" class=\"headerlink\" title=\"接口逻辑问题\"></a>接口逻辑问题</h2><h3 id=\"返回数据问题：\"><a href=\"#返回数据问题：\" class=\"headerlink\" title=\"返回数据问题：\"></a>返回数据问题：</h3><p>问题举例：首页、抽奖等接口返回回包过大（大于500kB）：通过前端添加请求参数，过滤本次活动无用数据<br>问题现象：回包过大<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_9.png\"></p>\n<h3 id=\"无关逻辑-x2F-调用：\"><a href=\"#无关逻辑-x2F-调用：\" class=\"headerlink\" title=\"无关逻辑&#x2F;调用：\"></a>无关逻辑&#x2F;调用：</h3><p>问题举例：春节活动无需用户画像功能，在代码中依然调用了该功能<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_10.png\"></p>\n<h2 id=\"调用第三方问题\"><a href=\"#调用第三方问题\" class=\"headerlink\" title=\"调用第三方问题\"></a>调用第三方问题</h2><h3 id=\"调用第三方服务错误：\"><a href=\"#调用第三方服务错误：\" class=\"headerlink\" title=\"调用第三方服务错误：\"></a>调用第三方服务错误：</h3><p>问题举例：调用画像服务接口错误，调用了内部接口，性能无法满足对外服务要求<br>问题现象：qps压不上去&#x2F;错误率上升，error日志：调用画像接口失败<br><img src=\"http://cdn.yuleweici.com/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_11.png\"></p>\n","slug":"后台测试入门-如何做后台性能测试","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/14/%E5%90%8E%E5%8F%B0%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8E%E5%8F%B0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","excerpt":"本文从性能测试基础理论，真实的后台测试实践举例，常见性能问题举例三个方面，帮你快速入门后台性能测试","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"后台","slug":"后台","permalink":"http://vwin.github.io/tags/%E5%90%8E%E5%8F%B0/"}]},{"title":"监控-Prometheus+Grafana实战","date":"2022-11-09T03:46:47.000Z","path":"2022/11/09/监控-Prometheus-Grafana实战/","text":"本文介绍了如何使用Prometheus+Grafana这个监控解决方案。 简介Prometheus是古希腊神话里泰坦族的一名神明，名字的意思是”先见之明”，下图中是Prometheus被宙斯惩罚，饱受肝脏日食夜长之苦。下面就是我们所了解的Prometheus，下面是其官网封面图引导语：From metrics to insight，从指标到洞察力，通过指标去洞察你的系统，为我们的系统提供指标收集和监控的开源解决方案。也就是说，Prometheus是一个数据监控的解决方案，让我们能随时掌握系统运行的状态，快速定位问题和排除故障。 Prometheus发展速度很快，12年开发完成，16年加入CNCF，成为继K8s之后第二个CNCF托管的项目，目前Github 42k的🌟，而且社区很活跃，维护频率很高，基本稳定在 1个月1个小版本的迭代速度 整体生态Prometheus提供了从指标暴露，到指标抓取、存储和可视化，以及最后的监控告警等一系列组件。 指标暴露每一个被Prometheus监控的服务都是一个Job，Prometheus为这些Job提供了官方的SDK ，利用这个SDK可以自定义并导出自己的业务指标，也可以使用Prometheus官方提供的各种常用组件和中间件的Exporter（比如常用的MySQL，Consul等等）。对于短时间执行的脚本任务或者不好直接Pull指标的服务，Prometheus提供了PushGateWay网关给这些任务将服务指标主动推Push到网关，Prometheus再从这个网关里Pull指标。 指标抓取上面提到了Push和Pull，其实这是两种指标抓取模型。 Pull模型：监控服务主动拉取被监控服务的指标，被监控服务一般通过主动暴露metrics端口或者通过Exporter的方式暴露指标，监控服务依赖服务发现模块发现被监控服务，从而去定期的抓取指标 Push模型：被监控服务主动将指标推送到监控服务，可能需要对指标做协议适配，必须得符合监控服务要求的指标格式，对于Prometheus中的指标抓取，采用的是Pull模型，默认是一分钟去拉取一次指标，通过Prometheus.yaml配置文件中的scrape_interval配置项配置，Prometheus对外都是用的Pull模型，一个是Pull Exporter的暴露的指标，一个是Pull PushGateway暴露的指标。 指标存储和查询指标抓取后会存储在内置的时序数据库中，Prometheus也提供了PromQL查询语言给我们做指标的查询，我们可以在Prometheus的WebUI上通过PromQL，可视化查询我们的指标，也可以很方便的接入第三方的可视化工具，例如grafana。 监控告警prometheus提供了alertmanageer基于promql来做系统的监控告警，当promql查询出来的指标超过我们定义的阈值时，prometheus会发送一条告警信息到alertmanager，manager会将告警下发到配置好的邮箱或者微信。 工作原理Prometheus的从被监控服务的注册到指标抓取到指标查询的流程分为五个步骤： 服务注册被监控服务在Prometheus中是一个Job存在，被监控服务的所有实例在Prometheus中是一个target的存在，所以被监控服务的注册就是在Prometheus中注册一个Job和其所有的target，这个注册分为： 静态注册 动态注册静态注册：静态的将服务的IP和抓取指标的端口号配置在Prometheus yaml文件的scrape_configs配置下12345scrape_configs:- job_name: &quot;prometheus&quot; static_configs: - targets: [&quot;localhost:9090&quot;] 以上就是注册了一个名为prometheus的服务，这个服务下有一个实例，暴露的抓取地址是localhost:9090 动态注册：动态注册就是在Prometheus yaml文件的scrape_configs配置下配置服务发现的地址和服务名，Prometheus会去该地址，根据你提供的服务名动态发现实例列表，在Prometheus中，支持consul，DNS，文件，K8s等多种服务发现机制。 基于consul的服务发现： 1234567- job_name: &quot;node_export_consul&quot; metrics_path: /node_metrics scheme: http consul_sd_configs: - server: localhost:8500 services: - node_exporter 我们consul的地址就是：localhost:8500，服务名是node_exporter，在这个服务下有一个exporter实例： localhost:9600 注意：如果是动态注册，最好加上这两配置，静态注册指标拉取的路径会默认的帮我们指定为 metrics_path:&#x2F;metrics，所以如果暴露的指标抓取路径不同或者是动态的服务注册，最好加上这两个配置。不然会报错“INVALID“ is not a valid start token，演示下，百度了一下，这里可能是数据格式不统一导致 12metrics_path: /node_metricsscheme: http 最后可以在webUI中查看发现的实例：目前，Prometheus支持多达二十多种服务发现协议： 1234567891011121314151617181920212223&lt;azure_sd_config&gt;&lt;consul_sd_config&gt;&lt;digitalocean_sd_config&gt;&lt;docker_sd_config&gt;&lt;dockerswarm_sd_config&gt;&lt;dns_sd_config&gt;&lt;ec2_sd_config&gt;&lt;openstack_sd_config&gt;&lt;file_sd_config&gt;&lt;gce_sd_config&gt;&lt;hetzner_sd_config&gt;&lt;http_sd_config&gt;&lt;kubernetes_sd_config&gt;&lt;kuma_sd_config&gt;&lt;lightsail_sd_config&gt;&lt;linode_sd_config&gt;&lt;marathon_sd_config&gt;&lt;nerve_sd_config&gt;&lt;serverset_sd_config&gt;&lt;triton_sd_config&gt;&lt;eureka_sd_config&gt;&lt;scaleway_sd_config&gt;&lt;static_config&gt; 配置更新在更新完Prometheus的配置文件后，我们需要更新我们的配置到程序内存里，这里的更新方式有两种，第一种简单粗暴，就是重启Prometheus，第二种是动态更新的方式。如何实现动态的更新Prometheus配置。第一步：首先要保证启动Prometheus的时候带上启动参数：–web.enable-lifecycle 12prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle 第二步：去更新我们的Prometheus配置 第三步：更新完配置后，我们可以通过Post请求的方式，动态更新配置： 12curl -v --request POST &#x27;http://localhost:9090/-/reload&#x27; 原理： Prometheus在web模块中，注册了一个handler 123456if o.EnableLifecycle &#123; router.Post(&quot;/-/quit&quot;, h.quit) router.Put(&quot;/-/quit&quot;, h.quit) router.Post(&quot;/-/reload&quot;, h.reload) // reload配置 router.Put(&quot;/-/reload&quot;, h.reload) &#125; 通过h.reload这个handler方法实现：这个handler就是往一个channle中发送一个信号： 1234567func (h *Handler) reload(w http.ResponseWriter, r *http.Request) &#123; rc := make(chan error) h.reloadCh &lt;- rc // 发送一个信号到channe了中 if err := &lt;-rc; err != nil &#123; http.Error(w, fmt.Sprintf(&quot;failed to reload config: %s&quot;, err), http.StatusInternalServerError) &#125;&#125; 在main函数中会去监听这个channel，只要有监听到信号，就会做配置的reload，重新将新配置加载到内存中 1234567case rc := &lt;-webHandler.Reload(): if err := reloadConfig(cfg.configFile, cfg.enableExpandExternalLabels, cfg.tsdb.EnableExemplarStorage, logger, noStepSubqueryInterval, reloaders...); err != nil &#123; level.Error(logger).Log(&quot;msg&quot;, &quot;Error reloading config&quot;, &quot;err&quot;, err) rc &lt;- err &#125; else &#123; rc &lt;- nil &#125; 指标抓取和存储Prometheus对指标的抓取采取主动Pull的方式，即周期性的请求被监控服务暴露的metrics接口或者是PushGateway，从而获取到Metrics指标，默认时间是15s抓取一次，配置项如下： 12global: scrape_interval: 15s 抓取到的指标会被以时间序列的形式保存在内存中，并且定时刷到磁盘上，默认是两个小时回刷一次。并且为了防止Prometheus 发生崩溃或重启时能够恢复数据，Prometheus也提供了类似MySQL中binlog一样的预写日志，当Prometheus崩溃重启时，会读这个预写日志来恢复数据。 Metric指标数据模型Prometheus采集的所有指标都是以时间序列的形式进行存储，每一个时间序列有三部分组成： 指标名和指标标签集合：metric_name{&lt;label1&#x3D;v1&gt;,&lt;label2&#x3D;v2&gt;….}，指标名：表示这个指标是监控哪一方面的状态，比如http_request_total表示：请求数量；指标标签，描述这个指标有哪些维度，比如http_request_total这个指标，有请求状态码code &#x3D; 200&#x2F;400&#x2F;500，请求方式：method &#x3D; get&#x2F;post等，实际上指标名称实际上是以标签的形式保存，这个标签是__name__，即：name&#x3D; 时间戳：描述当前时间序列的时间，单位：毫秒 样本值：当前监控指标的具体数值，比如http_request_total的值就是请求数是多少。 可以通过查看Prometheus的metrics接口查看所有上报的指标: 所有的指标也都是通过如下所示的格式来标识的： 123# HELP // HELP：这里描述的指标的信息，表示这个是一个什么指标，统计什么的# TYPE // TYPE：这个指标是什么类型的&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125; value // 指标的具体格式,&lt;指标名&gt;&#123;标签集合&#125; 指标值 指标类型Prometheus底层存储上其实并没有对指标做类型的区分，都是以时间序列的形式存储，但是为了方便用户的使用和理解不同监控指标之间的差异，Prometheus 定义了 4 种不同的指标类型：计数器counter，仪表盘gauge，直方图histogram，摘要summary Counter计数器： Counter类型和redis的自增命令一样，只增不减，通过Counter指标可以统计Http请求数量，请求错误数，接口调用次数等单调递增的数据。同时可以结合increase和rate等函数统计变化速率，后续我们会提到这些内置函数。 Gauge仪表盘： 和Counter不同，Gauge是可增可减的，可以反映一些动态变化的数据，例如当前内存占用，CPU利用，Gc次数等动态可上升可下降的数据，在Prometheus上通过Gauge，可以不用经过内置函数直观的反映数据的变化情况，如下图表示堆可分配的空间大小： 上面两种是数值指标，代表数据的变化情况，Histogram和Summary是统计类型的指标，表示数据的分布情况 Histogram直方图： Histogram是一种直方图类型，可以观察到指标在各个不同的区间范围的分布情况，如下图所示：可以观察到请求耗时在各个桶的分布 有一点要注意的是，Histogram是累计直方图，即每一个桶的是只有上区间，例如下图表示小于0.1毫秒（le&#x3D;”0.1”）的请求数量是18173个，小于0.2毫秒（le&#x3D;”0.2”）的请求是18182个，在le&#x3D;”0.2”这个桶中是包含了le&#x3D;”0.1”这个桶的数据，如果我们要拿到0.1毫秒到0.2毫秒的请求数量，可以通过两个桶想减得到。 在直方图中，还可以通过histogram_quantile函数求出百分位数，比如P50，P90，P99等数据 Summary摘要 Summary也是用来做统计分析的，和Histogram区别在于，Summary直接存储的就是百分位数，如下所示：可以直观的观察到样本的中位数，P90和P99 Summary的百分位数是客户端计算好直接让Prometheus抓取的，不需要Prometheus计算，直方图是通过内置函数histogram_quantile在Prometheus服务端计算求出 指标导出指标导出有两种方式，一种是使用Prometheus社区提供的定制好的Exporter对一些组件诸如MySQL，Kafka等的指标作导出，也可以利用社区提供的Client来自定义指标导出。 1github.com/prometheus/client_golang/prometheus/promhttp 自定义Prometheus exporter： 123456789101112package mainimport ( &quot;net/http&quot; &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;)func main() &#123; http.Handle(&quot;/metrics&quot;, promhttp.Handler()) http.ListenAndServe(&quot;:8080&quot;, nil)&#125; 访问：http://localhost:8080/metrics，即可看到导出的指标，这里我们没有自定义任何的指标，但是能看到一些内置的Go的运行时指标和promhttp相关的指标，这个Client默认为我们暴露的指标，go_：以 go_ 为前缀的指标是关于 Go 运行时相关的指标，比如垃圾回收时间、goroutine 数量等，这些都是 Go 客户端库特有的，其他语言的客户端库可能会暴露各自语言的其他运行时指标。promhttp_：来自 promhttp 工具包的相关指标，用于跟踪对指标请求的处理。 123456789101112131415161718192021222324package mainimport ( &quot;net/http&quot; &quot;github.com/prometheus/client_golang/prometheus&quot; &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;)func main() &#123; // 1.定义指标(类型,名字,帮助信息) myCounter := prometheus.NewCounter(prometheus.CounterOpts&#123; Name: &quot;my_counter_total&quot;, Help: &quot;自定义counter&quot;, &#125;) // 2.注册指标 prometheus.MustRegister(myCounter) // 3.设置指标值 myCounter.Add(23) http.Handle(&quot;/metrics&quot;, promhttp.Handler()) http.ListenAndServe(&quot;:8080&quot;, nil)&#125; 运行： 模拟下在业务中上报接口请求量 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;net/http&quot; &quot;github.com/prometheus/client_golang/prometheus&quot;)var ( MyCounter prometheus.Counter)// init 注册指标func init() &#123; // 1.定义指标（类型，名字，帮助信息） MyCounter = prometheus.NewCounter(prometheus.CounterOpts&#123; Name: &quot;my_counter_total&quot;, Help: &quot;自定义counter&quot;, &#125;) // 2.注册指标 prometheus.MustRegister(MyCounter)&#125;// Sayhellofunc Sayhello(w http.ResponseWriter, r *http.Request) &#123; // 接口请求量递增 MyCounter.Inc() fmt.Fprintf(w, &quot;Hello Wrold!&quot;)&#125; main.go： 1234567891011121314package mainimport ( &quot;net/http&quot; &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;)func main() &#123; http.Handle(&quot;/metrics&quot;, promhttp.Handler()) http.HandleFunc(&quot;/counter&quot;,Sayhello) http.ListenAndServe(&quot;:8080&quot;, nil)&#125; 一开始启动时，指标counter是0 调用：&#x2F;counter接口后，指标数据发生了变化，这样就可以简单实现了接口请求数的统计 对于其他指标定义方式是一样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243var ( MyCounter prometheus.Counter MyGauge prometheus.Gauge MyHistogram prometheus.Histogram MySummary prometheus.Summary)// init 注册指标func init() &#123; // 1.定义指标（类型，名字，帮助信息） MyCounter = prometheus.NewCounter(prometheus.CounterOpts&#123; Name: &quot;my_counter_total&quot;, Help: &quot;自定义counter&quot;, &#125;) // 定义gauge类型指标 MyGauge = prometheus.NewGauge(prometheus.GaugeOpts&#123; Name: &quot;my_gauge_num&quot;, Help: &quot;自定义gauge&quot;, &#125;) // 定义histogram MyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123; Name: &quot;my_histogram_bucket&quot;, Help: &quot;自定义histogram&quot;, Buckets: []float64&#123;0.1,0.2,0.3,0.4,0.5&#125;, // 需要指定桶 &#125;) // 定义Summary MySummary = prometheus.NewSummary(prometheus.SummaryOpts&#123; Name: &quot;my_summary_bucket&quot;, Help: &quot;自定义summary&quot;, // 这部分可以算好后在set Objectives: map[float64]float64&#123; 0.5: 0.05, 0.9: 0.01, 0.99: 0.001, &#125;, &#125;) // 2.注册指标 prometheus.MustRegister(MyCounter) prometheus.MustRegister(MyGauge) prometheus.MustRegister(MyHistogram) prometheus.MustRegister(MySummary)&#125; 上面的指标都是没有设置标签的，我们一般的指标都是带有标签的，如何设置指标的标签呢？ 如果我要设置带标签的counter类型指标，只需要将原来的NewCounter方法替换为NewCounterVec方法即可，并且传入标签集合 123456789101112MyCounter *prometheus.CounterVec// 1.定义指标（类型，名字，帮助信息）MyCounter = prometheus.NewCounterVec( prometheus.CounterOpts&#123; Name: &quot;my_counter_total&quot;, Help: &quot;自定义counter&quot;, &#125;, // 标签集合 []string&#123;&quot;label1&quot;,&quot;label2&quot;&#125;,)// 带标签的set指标值MyCounter.With(prometheus.Labels&#123;&quot;label1&quot;:&quot;1&quot;,&quot;label2&quot;:&quot;2&quot;&#125;).Inc() 其他同理 PromQL刚刚提到了Prometheus中指标有哪些类型以及如何导出我们的指标，现在指标导出到Prometheus了，利用其提供的PromQL可以查询我们导出的指标 PromQL是Prometheus为我们提供的函数式的查询语言，查询表达式有四种类型： 字符串：只作为某些内置函数的参数出现 标量：单一的数字值，可以是函数参数，也可以是函数的返回结果 瞬时向量：某一时刻的时序数据 区间向量：某一时间区间内的时序数据集合 瞬时查询直接通过指标名即可进行查询，查询结果是当前指标最新的时间序列，比如查询Gc累积消耗的时间： 1go_gc_duration_seconds_count 我们可以看到查询出来有多个同名指标结果 可以用{}做标签过滤查询：比如我们想查指定实例的指标 12go_gc_duration_seconds_count&#123;instance=&quot;127.0.0.1:9600&quot;&#125; 而且也支持则表达式，通过&#x3D;~指定正则表达式，如下所示：查询所有instance是localhost开头的指标 1go_gc_duration_seconds_count&#123;instance=~&quot;localhost.*&quot;&#125; 范围查询范围查询的结果集就是区间向量，可以通过[]指定时间来做范围查询查询5分钟内的Gc累积消耗时间 1go_gc_duration_seconds_count&#123;&#125;[5m] 注意：这里范围查询第一个点并不一定精确到刚刚好5分钟前的那个时序样本点，他是以5分钟作为一个区间，寻找这个区间的第一个点到最后一个样本点。 时间单位： d：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年 同样支持类似SQL中的offset查询，如下：查询一天前当前5分钟前的时序数据集 1go_gc_duration_seconds_count&#123;&#125;[5m] offset 1d 内置函数Prometheus内置了很多函数，这里主要记录下常用的几个函数的使用： rate和irate函数： rate函数可以用来求指标的平均变化速率 1rate函数=时间区间前后两个点的差 / 时间范围 一般rate函数可以用来求某个时间区间内的请求速率，也就是我们常说的QPS 但是rate函数只是算出来了某个时间区间内的平均速率，没办法反映突发变化，假设在一分钟的时间区间里，前50秒的请求量都是0到10左右，但是最后10秒的请求量暴增到100以上，这时候算出来的值可能无法很好的反映这个峰值变化。这个问题可以通过irate函数解决，irate函数求出来的就是瞬时变化率 1时间区间内最后两个样本点的差 / 最后两个样本点的时间差 可以通过图像看下两者的区别：irate函数的图像峰值变化大，rate函数变化较为平缓 rate函数： irate函数： 聚合函数：Sum() by() without() 也是上边的例子，我们在求指定接口的QPS的时候，可能会出现多个实例的QPS的计算结果，如下是存在多个接口，三个服务的QPS 1rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;, method=&quot;GET&quot;, status=&quot;200&quot;&#125;[5m]) 利用sum函数可以将三个QPS聚合，即可得到整个服务该接口的QPS：其实Sum就是将指标值做相加 但是这样直接的相加太笼统抽象了，可以配合by和without函数在sum的时候，基于某些标签分组，类似SQL中的group by 例如，我可以根据请求接口标签分组：这样拿到的就是具体接口的QPS 1sum(rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;, method=&quot;GET&quot;, status=&quot;200&quot;&#125;[5m])) by(path) 也可以不根据接口路径分组：通过without指定 1sum(rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;, method=&quot;GET&quot;, status=&quot;200&quot;&#125;[5m])) without(path) 可以通过histogram_quantile函数做数据统计：可以用来统计百分位数：第一个参数是百分位，第二个histogram指标，这样计算出来的就是中位数，即P50 12histogram_quantile(0.5,go_gc_pauses_seconds_total_bucket) 分享之前和同事一起发现的坑： 在刚刚写的自定义exporter上新增几个histogram的样本点 123MyHistogram.Observe(0.3)MyHistogram.Observe(0.4)MyHistogram.Observe(0.5) histogram的桶设置： 12345MyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123; Name: &quot;my_histogram_bucket&quot;, Help: &quot;自定义histogram&quot;, Buckets: []float64&#123;0,2.5,5,7.5,10&#125;, // 需要指定桶&#125;) 如果这样的话，所有指标都会直接进入到第一个桶，即0到2.5这个桶，如果我要计算中位数，那么这个中位数按照数学公式来算的话，肯定是在0到2.5之间的，而且肯定是0.3到0.5之间。 我用histogram_quantile函数计算下：计算结果是1.25，其实已经不对了。 1histogram_quantile(0.5,my_histogram_bucket_bucket) 我的指标都是不大于1的，为啥算出来的P50和P99都这么离谱呢？ 这是因为Prometheus他是不保存你具体的指标数值的，他会帮你把指标放到具体的桶，但是他不会保存你指标的值，计算的分位数是一个预估的值，怎么预估呢？就是假设每个桶内的样本分布是均匀的，线性分布来计算的，比如刚刚的P50，其实就是算排在第50%位置的样本值，因为刚刚所有的数据都落在了第一个桶，那么他在计算的时候就会假定这个50%值在第一个桶的中点，他就会假定这个数就是0.5 2.5，P99就是第一个桶的99%的位置，他就会假定这个数就是0.99 2.5 导致这个误差较大的原因就是我们的bucket设置的不合理。 重新定义桶： 123456// 定义histogramMyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123; Name: &quot;my_histogram_bucket&quot;, Help: &quot;自定义histogram&quot;, Buckets: []float64&#123;0.1,0.2,0.3,0.4,0.5&#125;, // 需要指定桶&#125;) 上报数据： 123MyHistogram.Observe(0.1)MyHistogram.Observe(0.3)MyHistogram.Observe(0.4) 重新计算P50，P99 桶设置的越合理，计算的误差越小 Grafana可视化除了可以利用Prometheus提供的webUI可视化我们的指标外，还可以接入Grafana来做指标的可视化。第一步，对接数据源： 配置好prometheus的地址： 第二步：创建仪表盘 编辑仪表盘 在metrics处编写PromQL即可完成查询和可视化 仪表盘编辑完后，可以导出对应的json文件，方便下次导入同样的仪表盘 监控告警AlertManager是prometheus提供的告警信息下发组件，包含了对告警信息的分组，下发，静默等策略 配置完成后可以在webui上看到对应的告警策略信息。告警规则也是基于PromQL进行定制的。 编写告警配置：当Http_srv这个服务挂了，Prometheus采集不到指标，并且持续时间1分钟，就会触发告警 12345678groups:- name: simulator-alert-rule rules: - alert: HttpSimulatorDown expr: sum(up&#123;job=&quot;http_srv&quot;&#125;) == 0 for: 1m labels: severity: critical 在prometheus.yml中配置告警配置文件，需要配置上alertmanager的地址和告警文件的地址 123456789# Alertmanager configurationalerting: alertmanagers: - static_configs: - targets: [&#x27;localhost:9093&#x27;]# Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.rule_files: - &quot;alert_rules.yml&quot; #- &quot;first_rules.yml&quot; 配置告警信息，例如告警发送地址，告警内容模版，分组策略等都在alertmanager的配置文件中配置： 1234567891011121314151617181920212223global: smtp_smarthost: &#x27;smtp.qq.com:465&#x27; smtp_from: &#x27;xxxx@qq.com&#x27; smtp_auth_username: &#x27;xxxx@qq.com&#x27; smtp_auth_password: &#x27;xxxx&#x27; smtp_require_tls: falseroute: group_interval: 1m repeat_interval: 1m receiver: &#x27;mail-receiver&#x27;# group_by //采用哪个标签作为分组# group_wait //分组等待的时间，收到报警不是立马发送出去，而是等待一段时间，看看同一组中是否有其他报警，如果有一并发送# group_interval //告警时间间隔# repeat_interval //重复告警时间间隔，可以减少发送告警的频率# receiver //接收者是谁# routes //子路由配置receivers:- name: &#x27;mail-receiver&#x27; email_configs: - to: &#x27;xxxx@qq.com&#x27; 当我kill进程： prometheus已经触发告警： 在等待1分钟，如果持续还是符合告警策略，则状态为从pending变为 FIRING会发送邮件到我的邮箱此时我的邮箱收到了一条告警消息 alertmanager也支持对告警进行静默，在alertmanager的WEBUI中配置即可 间隔了4分钟，没有收到告警，静默生效 一个小时没有收到告警信息 参考文献Pull or Push？监控系统如何选型-阿里云开发者社区为go应用添加prometheus监控指标 - SegmentFault 思否GitHub - prometheus&#x2F;client_golang: Prometheus instrumentation library for Go applicationsMaterial for MkDocs - Prometheus 入门到实战终于有人把Prometheus入门讲明白了 - DockOne.ioPrometheus报警AlertManager实战-阳明的博客|Kubernetes|Istio|Prometheus|Python|Golang|云原生如何热加载更新配置?技术分享：Prometheus是怎么存储数据的Prometheus 架构设计实战 Prometheus 搭建监控系统","raw":"---\ntitle: 监控-Prometheus+Grafana实战\ntoc: true\ndate: 2022-11-09 11:46:47\ntags: [Prometheus,Grafana,监控]\ncategories: [技术]\ndescription: 使用Prometheus+grafana搭建监控系统\n---\n\n本文介绍了如何使用Prometheus+Grafana这个监控解决方案。\n\n<!-- more -->\n# 简介\nPrometheus是古希腊神话里泰坦族的一名神明，名字的意思是\"先见之明\"，下图中是Prometheus被宙斯惩罚，饱受肝脏日食夜长之苦。\n下面就是我们所了解的Prometheus，下面是其官网封面图引导语：From metrics to insight，从指标到洞察力，通过指标去洞察你的系统，为我们的系统提供指标收集和监控的开源解决方案。也就是说，Prometheus是一个数据监控的解决方案，让我们能随时掌握系统运行的状态，快速定位问题和排除故障。\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img.png)\n\nPrometheus发展速度很快，12年开发完成，16年加入CNCF，成为继K8s之后第二个CNCF托管的项目，目前Github 42k的🌟，而且社区很活跃，维护频率很高，基本稳定在 1个月1个小版本的迭代速度\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_1.png)\n\n# 整体生态\nPrometheus提供了从指标暴露，到指标抓取、存储和可视化，以及最后的监控告警等一系列组件。\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_2.png)\n\n## 指标暴露\n每一个被Prometheus监控的服务都是一个Job，Prometheus为这些Job提供了官方的SDK ，利用这个SDK可以自定义并导出自己的业务指标，也可以使用Prometheus官方提供的各种常用组件和中间件的Exporter（比如常用的MySQL，Consul等等）。对于短时间执行的脚本任务或者不好直接Pull指标的服务，Prometheus提供了PushGateWay网关给这些任务将服务指标主动推Push到网关，Prometheus再从这个网关里Pull指标。\n\n## 指标抓取\n上面提到了Push和Pull，其实这是两种指标抓取模型。\n- Pull模型：监控服务主动拉取被监控服务的指标，被监控服务一般通过主动暴露metrics端口或者通过Exporter的方式暴露指标，监控服务依赖服务发现模块发现被监控服务，从而去定期的抓取指标\n  ![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_3.png)\n- Push模型：被监控服务主动将指标推送到监控服务，可能需要对指标做协议适配，必须得符合监控服务要求的指标格式，对于Prometheus中的指标抓取，采用的是Pull模型，默认是一分钟去拉取一次指标，通过Prometheus.yaml配置文件中的scrape_interval配置项配置，Prometheus对外都是用的Pull模型，一个是Pull Exporter的暴露的指标，一个是Pull PushGateway暴露的指标。\n  ![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_4.png)\n\n## 指标存储和查询\n指标抓取后会存储在内置的时序数据库中，Prometheus也提供了PromQL查询语言给我们做指标的查询，我们可以在Prometheus的WebUI上通过PromQL，可视化查询我们的指标，也可以很方便的接入第三方的可视化工具，例如grafana。\n\n## 监控告警\nprometheus提供了alertmanageer基于promql来做系统的监控告警，当promql查询出来的指标超过我们定义的阈值时，prometheus会发送一条告警信息到alertmanager，manager会将告警下发到配置好的邮箱或者微信。\n\n# 工作原理\nPrometheus的从被监控服务的注册到指标抓取到指标查询的流程分为五个步骤：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_5.png)\n\n## 服务注册\n被监控服务在Prometheus中是一个Job存在，被监控服务的所有实例在Prometheus中是一个target的存在，所以被监控服务的注册就是在Prometheus中注册一个Job和其所有的target，这个注册分为：\n- 静态注册\n- 动态注册\n静态注册：静态的将服务的IP和抓取指标的端口号配置在Prometheus yaml文件的scrape_configs配置下\n```shell\n\nscrape_configs:\n- job_name: \"prometheus\"\n  static_configs:\n  - targets: [\"localhost:9090\"]\n```\n\n以上就是注册了一个名为prometheus的服务，这个服务下有一个实例，暴露的抓取地址是localhost:9090 动态注册：动态注册就是在Prometheus yaml文件的scrape_configs配置下配置服务发现的地址和服务名，Prometheus会去该地址，根据你提供的服务名动态发现实例列表，在Prometheus中，支持consul，DNS，文件，K8s等多种服务发现机制。 基于consul的服务发现：\n```shell\n- job_name: \"node_export_consul\"\n  metrics_path: /node_metrics\n  scheme: http\n  consul_sd_configs:\n  - server: localhost:8500\n  services:\n  - node_exporter\n```\n我们consul的地址就是：localhost:8500，服务名是node_exporter，在这个服务下有一个exporter实例： localhost:9600\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_6.png)\n\n注意：如果是动态注册，最好加上这两配置，静态注册指标拉取的路径会默认的帮我们指定为 metrics_path:/metrics，所以如果暴露的指标抓取路径不同或者是动态的服务注册，最好加上这两个配置。不然会报错“INVALID“ is not a valid start token，演示下，百度了一下，这里可能是数据格式不统一导致\n```shell\nmetrics_path: /node_metrics\nscheme: http\n```\n\n最后可以在webUI中查看发现的实例：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_7.png)\n目前，Prometheus支持多达二十多种服务发现协议：\n```shell\n<azure_sd_config>\n<consul_sd_config>\n<digitalocean_sd_config>\n<docker_sd_config>\n<dockerswarm_sd_config>\n<dns_sd_config>\n<ec2_sd_config>\n<openstack_sd_config>\n<file_sd_config>\n<gce_sd_config>\n<hetzner_sd_config>\n<http_sd_config>\n<kubernetes_sd_config>\n<kuma_sd_config>\n<lightsail_sd_config>\n<linode_sd_config>\n<marathon_sd_config>\n<nerve_sd_config>\n<serverset_sd_config>\n<triton_sd_config>\n<eureka_sd_config>\n<scaleway_sd_config>\n<static_config>\n```\n\n## 配置更新\n在更新完Prometheus的配置文件后，我们需要更新我们的配置到程序内存里，这里的更新方式有两种，第一种简单粗暴，就是重启Prometheus，第二种是动态更新的方式。如何实现动态的更新Prometheus配置。 \n第一步：首先要保证启动Prometheus的时候带上启动参数：--web.enable-lifecycle\n```shell\nprometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle\n\n```\n第二步：去更新我们的Prometheus配置 第三步：更新完配置后，我们可以通过Post请求的方式，动态更新配置：\n```shell\ncurl -v --request POST 'http://localhost:9090/-/reload'\n\n```\n原理： Prometheus在web模块中，注册了一个handler\n\n```shell\nif o.EnableLifecycle {\n   router.Post(\"/-/quit\", h.quit)\n   router.Put(\"/-/quit\", h.quit)\n   router.Post(\"/-/reload\", h.reload)  // reload配置\n   router.Put(\"/-/reload\", h.reload)   \n} \n```\n\n通过h.reload这个handler方法实现：这个handler就是往一个channle中发送一个信号：\n\n```shell\nfunc (h *Handler) reload(w http.ResponseWriter, r *http.Request) {\n   rc := make(chan error)\n   h.reloadCh <- rc    // 发送一个信号到channe了中\n   if err := <-rc; err != nil {\n      http.Error(w, fmt.Sprintf(\"failed to reload config: %s\", err), http.StatusInternalServerError)\n   }\n}\n```\n\n在main函数中会去监听这个channel，只要有监听到信号，就会做配置的reload，重新将新配置加载到内存中\n\n```shell\ncase rc := <-webHandler.Reload():\n   if err := reloadConfig(cfg.configFile, cfg.enableExpandExternalLabels, cfg.tsdb.EnableExemplarStorage, logger, noStepSubqueryInterval, reloaders...); err != nil {\n      level.Error(logger).Log(\"msg\", \"Error reloading config\", \"err\", err)\n      rc <- err\n   } else {\n      rc <- nil\n   }\n```\n\n## 指标抓取和存储\nPrometheus对指标的抓取采取主动Pull的方式，即周期性的请求被监控服务暴露的metrics接口或者是PushGateway，从而获取到Metrics指标，默认时间是15s抓取一次，配置项如下：\n```shell\nglobal:\n scrape_interval: 15s\n```\n\n抓取到的指标会被以时间序列的形式保存在内存中，并且定时刷到磁盘上，默认是两个小时回刷一次。并且为了防止Prometheus 发生崩溃或重启时能够恢复数据，Prometheus也提供了类似MySQL中binlog一样的预写日志，当Prometheus崩溃重启时，会读这个预写日志来恢复数据。\n\n\n# Metric指标\n## 数据模型\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_8.png)\nPrometheus采集的所有指标都是以时间序列的形式进行存储，每一个时间序列有三部分组成：\n- 指标名和指标标签集合：metric_name{<label1=v1>,<label2=v2>....}，指标名：表示这个指标是监控哪一方面的状态，比如http_request_total表示：请求数量；指标标签，描述这个指标有哪些维度，比如http_request_total这个指标，有请求状态码code = 200/400/500，请求方式：method = get/post等，实际上指标名称实际上是以标签的形式保存，这个标签是__name__，即：__name__=<metric name>\n- 时间戳：描述当前时间序列的时间，单位：毫秒\n- 样本值：当前监控指标的具体数值，比如http_request_total的值就是请求数是多少。\n\n可以通过查看Prometheus的metrics接口查看所有上报的指标:\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_9.png)\n\n所有的指标也都是通过如下所示的格式来标识的：\n```shell\n# HELP    // HELP：这里描述的指标的信息，表示这个是一个什么指标，统计什么的\n# TYPE    // TYPE：这个指标是什么类型的\n<metric name>{<label name>=<label value>, ...}  value    // 指标的具体格式,<指标名>{标签集合} 指标值\n```\n\n## 指标类型\nPrometheus底层存储上其实并没有对指标做类型的区分，都是以时间序列的形式存储，但是为了方便用户的使用和理解不同监控指标之间的差异，Prometheus 定义了 4 种不同的指标类型：计数器counter，仪表盘gauge，直方图histogram，摘要summary\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_10.png)\n\nCounter计数器： Counter类型和redis的自增命令一样，只增不减，通过Counter指标可以统计Http请求数量，请求错误数，接口调用次数等单调递增的数据。同时可以结合increase和rate等函数统计变化速率，后续我们会提到这些内置函数。\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_11.png)\n\nGauge仪表盘： 和Counter不同，Gauge是可增可减的，可以反映一些动态变化的数据，例如当前内存占用，CPU利用，Gc次数等动态可上升可下降的数据，在Prometheus上通过Gauge，可以不用经过内置函数直观的反映数据的变化情况，如下图表示堆可分配的空间大小：  上面两种是数值指标，代表数据的变化情况，Histogram和Summary是统计类型的指标，表示数据的分布情况 Histogram直方图： Histogram是一种直方图类型，可以观察到指标在各个不同的区间范围的分布情况，如下图所示：可以观察到请求耗时在各个桶的分布\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_12.png)\n\n有一点要注意的是，Histogram是累计直方图，即每一个桶的是只有上区间，例如下图表示小于0.1毫秒（le=\"0.1\"）的请求数量是18173个，小于0.2毫秒（le=\"0.2\"）的请求是18182个，在le=\"0.2\"这个桶中是包含了le=\"0.1\"这个桶的数据，如果我们要拿到0.1毫秒到0.2毫秒的请求数量，可以通过两个桶想减得到。\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_13.png)\n\n在直方图中，还可以通过histogram_quantile函数求出百分位数，比如P50，P90，P99等数据\n\nSummary摘要 Summary也是用来做统计分析的，和Histogram区别在于，Summary直接存储的就是百分位数，如下所示：可以直观的观察到样本的中位数，P90和P99\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_14.png)\n\nSummary的百分位数是客户端计算好直接让Prometheus抓取的，不需要Prometheus计算，直方图是通过内置函数histogram_quantile在Prometheus服务端计算求出\n\n## 指标导出\n指标导出有两种方式，一种是使用Prometheus社区提供的定制好的Exporter对一些组件诸如MySQL，Kafka等的指标作导出，也可以利用社区提供的Client来自定义指标导出。\n```shell\ngithub.com/prometheus/client_golang/prometheus/promhttp\n```\n\n自定义Prometheus exporter：\n```shell\npackage main\n\nimport (\n   \"net/http\"\n\n   \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc main()  {\n   http.Handle(\"/metrics\", promhttp.Handler())\n   http.ListenAndServe(\":8080\", nil)\n}\n```\n\n访问：http://localhost:8080/metrics，即可看到导出的指标，这里我们没有自定义任何的指标，但是能看到一些内置的Go的运行时指标和promhttp相关的指标，这个Client默认为我们暴露的指标，go_：以 go_ 为前缀的指标是关于 Go 运行时相关的指标，比如垃圾回收时间、goroutine 数量等，这些都是 Go 客户端库特有的，其他语言的客户端库可能会暴露各自语言的其他运行时指标。promhttp_：来自 promhttp 工具包的相关指标，用于跟踪对指标请求的处理。\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_15.png)\n\n```shell\npackage main\n\nimport (\n   \"net/http\"\n\n   \"github.com/prometheus/client_golang/prometheus\"\n   \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc main() {\n\n   // 1.定义指标(类型,名字,帮助信息)\n   myCounter := prometheus.NewCounter(prometheus.CounterOpts{\n      Name: \"my_counter_total\",\n      Help: \"自定义counter\",\n   })\n   // 2.注册指标\n   prometheus.MustRegister(myCounter)\n   // 3.设置指标值\n   myCounter.Add(23)\n\n   http.Handle(\"/metrics\", promhttp.Handler())\n   http.ListenAndServe(\":8080\", nil)\n}\n```\n\n运行：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_16.png)\n\n模拟下在业务中上报接口请求量\n```shell\npackage main\n\nimport (\n   \"fmt\"\n   \"net/http\"\n\n   \"github.com/prometheus/client_golang/prometheus\"\n)\n\nvar (\n   MyCounter prometheus.Counter\n)\n\n// init 注册指标\nfunc init() {\n   // 1.定义指标（类型，名字，帮助信息）\n   MyCounter = prometheus.NewCounter(prometheus.CounterOpts{\n      Name: \"my_counter_total\",\n      Help: \"自定义counter\",\n   })\n   // 2.注册指标\n   prometheus.MustRegister(MyCounter)\n}\n\n// Sayhello\nfunc Sayhello(w http.ResponseWriter, r *http.Request) {\n   // 接口请求量递增\n   MyCounter.Inc()\n   fmt.Fprintf(w, \"Hello Wrold!\")\n}\n```\n\nmain.go：\n\n```shell\npackage main\n\nimport (\n   \"net/http\"\n\n   \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc main() {\n\n   http.Handle(\"/metrics\", promhttp.Handler())\n   http.HandleFunc(\"/counter\",Sayhello)\n   http.ListenAndServe(\":8080\", nil)\n}\n```\n\n一开始启动时，指标counter是0\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_17.png)\n\n调用：/counter接口后，指标数据发生了变化，这样就可以简单实现了接口请求数的统计\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_18.png)\n\n对于其他指标定义方式是一样的：\n```shell\nvar (\n   MyCounter prometheus.Counter\n   MyGauge prometheus.Gauge\n   MyHistogram prometheus.Histogram\n   MySummary prometheus.Summary\n)\n\n// init 注册指标\nfunc init() {\n   // 1.定义指标（类型，名字，帮助信息）\n   MyCounter = prometheus.NewCounter(prometheus.CounterOpts{\n      Name: \"my_counter_total\",\n      Help: \"自定义counter\",\n   })\n   // 定义gauge类型指标\n   MyGauge = prometheus.NewGauge(prometheus.GaugeOpts{\n      Name: \"my_gauge_num\",\n      Help: \"自定义gauge\",\n   })\n   // 定义histogram\n   MyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts{\n      Name: \"my_histogram_bucket\",\n      Help: \"自定义histogram\",\n      Buckets: []float64{0.1,0.2,0.3,0.4,0.5},   // 需要指定桶\n   })\n   // 定义Summary\n   MySummary = prometheus.NewSummary(prometheus.SummaryOpts{\n      Name: \"my_summary_bucket\",\n      Help: \"自定义summary\",\n      // 这部分可以算好后在set\n      Objectives: map[float64]float64{\n         0.5: 0.05,\n         0.9: 0.01,   \n         0.99: 0.001, \n      },\n   })\n\n   // 2.注册指标\n   prometheus.MustRegister(MyCounter)\n   prometheus.MustRegister(MyGauge)\n   prometheus.MustRegister(MyHistogram)\n   prometheus.MustRegister(MySummary)\n}\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_19.png)\n\n上面的指标都是没有设置标签的，我们一般的指标都是带有标签的，如何设置指标的标签呢？ 如果我要设置带标签的counter类型指标，只需要将原来的NewCounter方法替换为NewCounterVec方法即可，并且传入标签集合\n```\nMyCounter *prometheus.CounterVec\n// 1.定义指标（类型，名字，帮助信息）\nMyCounter = prometheus.NewCounterVec(\n   prometheus.CounterOpts{\n   Name: \"my_counter_total\",\n   Help: \"自定义counter\",\n   },\n   // 标签集合\n   []string{\"label1\",\"label2\"},\n)\n// 带标签的set指标值\nMyCounter.With(prometheus.Labels{\"label1\":\"1\",\"label2\":\"2\"}).Inc()\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_20.png)\n\n其他同理\n\n\n\n# PromQL\n刚刚提到了Prometheus中指标有哪些类型以及如何导出我们的指标，现在指标导出到Prometheus了，利用其提供的PromQL可以查询我们导出的指标 PromQL是Prometheus为我们提供的函数式的查询语言，查询表达式有四种类型：\n\n- 字符串：只作为某些内置函数的参数出现\n- 标量：单一的数字值，可以是函数参数，也可以是函数的返回结果\n- 瞬时向量：某一时刻的时序数据\n- 区间向量：某一时间区间内的时序数据集合\n\n## 瞬时查询\n直接通过指标名即可进行查询，查询结果是当前指标最新的时间序列，比如查询Gc累积消耗的时间：\n```shell\ngo_gc_duration_seconds_count\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_21.png)\n\n我们可以看到查询出来有多个同名指标结果 可以用{}做标签过滤查询：比如我们想查指定实例的指标\n```shell\ngo_gc_duration_seconds_count{instance=\"127.0.0.1:9600\"}\n\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_22.png)\n\n而且也支持则表达式，通过=~指定正则表达式，如下所示：查询所有instance是localhost开头的指标\n\n```shell\ngo_gc_duration_seconds_count{instance=~\"localhost.*\"}\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_23.png)\n\n## 范围查询\n范围查询的结果集就是区间向量，可以通过[]指定时间来做范围查询\n查询5分钟内的Gc累积消耗时间\n```shell\ngo_gc_duration_seconds_count{}[5m]\n```\n\n注意：这里范围查询第一个点并不一定精确到刚刚好5分钟前的那个时序样本点，他是以5分钟作为一个区间，寻找这个区间的第一个点到最后一个样本点。\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_24.png)\n\n时间单位：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_25.png)\n\nd：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年 同样支持类似SQL中的offset查询，如下：查询一天前当前5分钟前的时序数据集\n\n```shell\ngo_gc_duration_seconds_count{}[5m] offset 1d\n```\n\n## 内置函数\nPrometheus内置了很多函数，这里主要记录下常用的几个函数的使用： rate和irate函数： rate函数可以用来求指标的平均变化速率\n```shell\nrate函数=时间区间前后两个点的差 / 时间范围\n```\n一般rate函数可以用来求某个时间区间内的请求速率，也就是我们常说的QPS\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_26.png)\n\n但是rate函数只是算出来了某个时间区间内的平均速率，没办法反映突发变化，假设在一分钟的时间区间里，前50秒的请求量都是0到10左右，但是最后10秒的请求量暴增到100以上，这时候算出来的值可能无法很好的反映这个峰值变化。这个问题可以通过irate函数解决，irate函数求出来的就是瞬时变化率\n\n```shell\n时间区间内最后两个样本点的差 / 最后两个样本点的时间差\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_27.png)\n\n可以通过图像看下两者的区别：irate函数的图像峰值变化大，rate函数变化较为平缓 rate函数：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_28.png)\n\nirate函数：\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_29.png)\n\n聚合函数：Sum() by() without() 也是上边的例子，我们在求指定接口的QPS的时候，可能会出现多个实例的QPS的计算结果，如下是存在多个接口，三个服务的QPS\n\n```shell\nrate(demo_api_request_duration_seconds_count{job=\"demo\", method=\"GET\", status=\"200\"}[5m])\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_30.png)\n\n利用sum函数可以将三个QPS聚合，即可得到整个服务该接口的QPS：其实Sum就是将指标值做相加\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_31.png)\n\n但是这样直接的相加太笼统抽象了，可以配合by和without函数在sum的时候，基于某些标签分组，类似SQL中的group by 例如，我可以根据请求接口标签分组：这样拿到的就是具体接口的QPS\n\n```shell\nsum(rate(demo_api_request_duration_seconds_count{job=\"demo\", method=\"GET\", status=\"200\"}[5m])) by(path)\n```\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_32.png)\n\n也可以不根据接口路径分组：通过without指定\n\n```shell\nsum(rate(demo_api_request_duration_seconds_count{job=\"demo\", method=\"GET\", status=\"200\"}[5m])) without(path)\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_33.png)\n\n可以通过histogram_quantile函数做数据统计：可以用来统计百分位数：第一个参数是百分位，第二个histogram指标，这样计算出来的就是中位数，即P50\n\n```shell\nhistogram_quantile(0.5,go_gc_pauses_seconds_total_bucket)\n\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_34.png)\n\n分享之前和同事一起发现的坑： 在刚刚写的自定义exporter上新增几个histogram的样本点\n```shell\nMyHistogram.Observe(0.3)\nMyHistogram.Observe(0.4)\nMyHistogram.Observe(0.5)\n```\n\nhistogram的桶设置：\n```shell\nMyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts{\n   Name: \"my_histogram_bucket\",\n   Help: \"自定义histogram\",\n   Buckets: []float64{0,2.5,5,7.5,10},    // 需要指定桶\n})\n```\n\n如果这样的话，所有指标都会直接进入到第一个桶，即0到2.5这个桶，如果我要计算中位数，那么这个中位数按照数学公式来算的话，肯定是在0到2.5之间的，而且肯定是0.3到0.5之间。 我用histogram_quantile函数计算下：计算结果是1.25，其实已经不对了。\n```shell\nhistogram_quantile(0.5,my_histogram_bucket_bucket) \n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_35.png)\n\n我的指标都是不大于1的，为啥算出来的P50和P99都这么离谱呢？ 这是因为Prometheus他是不保存你具体的指标数值的，他会帮你把指标放到具体的桶，但是他不会保存你指标的值，计算的分位数是一个预估的值，怎么预估呢？就是假设每个桶内的样本分布是均匀的，线性分布来计算的，比如刚刚的P50，其实就是算排在第50%位置的样本值，因为刚刚所有的数据都落在了第一个桶，那么他在计算的时候就会假定这个50%值在第一个桶的中点，他就会假定这个数就是0.5 2.5，P99就是第一个桶的99%的位置，他就会假定这个数就是0.99 2.5 导致这个误差较大的原因就是我们的bucket设置的不合理。 重新定义桶：\n\n```shell\n// 定义histogram\nMyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts{\n   Name: \"my_histogram_bucket\",\n   Help: \"自定义histogram\",\n   Buckets: []float64{0.1,0.2,0.3,0.4,0.5},   // 需要指定桶\n})\n```\n\n上报数据：\n```shell\nMyHistogram.Observe(0.1)\nMyHistogram.Observe(0.3)\nMyHistogram.Observe(0.4)\n```\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_36.png)\n\n重新计算P50，P99\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_37.png)\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_38.png)\n\n桶设置的越合理，计算的误差越小\n\n# Grafana可视化\n除了可以利用Prometheus提供的webUI可视化我们的指标外，还可以接入Grafana来做指标的可视化。 \n第一步，对接数据源：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_39.png)\n\n配置好prometheus的地址：\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_40.png)\n\n第二步：创建仪表盘\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_41.png)\n\n编辑仪表盘\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_42.png)\n\n在metrics处编写PromQL即可完成查询和可视化\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_43.png)\n\n仪表盘编辑完后，可以导出对应的json文件，方便下次导入同样的仪表盘\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_44.png)\n\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_45.png)\n\n\n# 监控告警\nAlertManager是prometheus提供的告警信息下发组件，包含了对告警信息的分组，下发，静默等策略 配置完成后可以在webui上看到对应的告警策略信息。告警规则也是基于PromQL进行定制的。 编写告警配置：当Http_srv这个服务挂了，Prometheus采集不到指标，并且持续时间1分钟，就会触发告警\n\n```shell\ngroups:\n- name: simulator-alert-rule\n  rules:\n  - alert: HttpSimulatorDown\n    expr: sum(up{job=\"http_srv\"}) == 0 \n    for: 1m\n    labels:\n      severity: critical\n```\n\n在prometheus.yml中配置告警配置文件，需要配置上alertmanager的地址和告警文件的地址\n\n```shell\n# Alertmanager configuration\nalerting:\n  alertmanagers:\n  - static_configs:\n    - targets: ['localhost:9093']\n# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.\nrule_files:\n    - \"alert_rules.yml\"\n    #- \"first_rules.yml\"\n```\n\n配置告警信息，例如告警发送地址，告警内容模版，分组策略等都在alertmanager的配置文件中配置：\n\n```shell\nglobal:\n  smtp_smarthost: 'smtp.qq.com:465'\n  smtp_from: 'xxxx@qq.com'\n  smtp_auth_username: 'xxxx@qq.com'\n  smtp_auth_password: 'xxxx'\n  smtp_require_tls: false\n\nroute:\n  group_interval: 1m\n  repeat_interval: 1m\n  receiver: 'mail-receiver'\n\n#  group_by             //采用哪个标签作为分组\n#  group_wait           //分组等待的时间，收到报警不是立马发送出去，而是等待一段时间，看看同一组中是否有其他报警，如果有一并发送\n#  group_interval       //告警时间间隔\n#  repeat_interval      //重复告警时间间隔，可以减少发送告警的频率\n#  receiver             //接收者是谁\n#  routes               //子路由配置\nreceivers:\n- name: 'mail-receiver'\n  email_configs:\n    - to: 'xxxx@qq.com'\n\n```\n\n当我kill进程：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_46.png)\n\nprometheus已经触发告警：\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_47.png)\n\n在等待1分钟，如果持续还是符合告警策略，则状态为从pending变为 FIRING会发送邮件到我的邮箱\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_48.png)\n此时我的邮箱收到了一条告警消息\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_49.png)\n\nalertmanager也支持对告警进行静默，在alertmanager的WEBUI中配置即可\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_50.png)\n\n间隔了4分钟，没有收到告警，静默生效\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_51.png)\n\n一个小时没有收到告警信息\n![](http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_52.png)\n\n# 参考文献\n[Pull or Push？监控系统如何选型-阿里云开发者社区](https://developer.aliyun.com/article/786418)\n[为go应用添加prometheus监控指标 - SegmentFault 思否](https://segmentfault.com/a/1190000040792832)\n[GitHub - prometheus/client_golang: Prometheus instrumentation library for Go applications](https://github.com/prometheus/client_golang)\n[Material for MkDocs - Prometheus 入门到实战](https://p8s.io/docs/)\n[终于有人把Prometheus入门讲明白了 - DockOne.io](https://www.dockone.io/article/347688)\n[Prometheus报警AlertManager实战-阳明的博客|Kubernetes|Istio|Prometheus|Python|Golang|云原生](https://www.qikqiak.com/post/alertmanager-of-prometheus-in-practice/)\n[如何热加载更新配置?](https://songjiayang.gitbooks.io/prometheus/content/qa/hotreload.html)\n[技术分享：Prometheus是怎么存储数据的](https://www.youtube.com/watch?v=qB40kqhTyYM&t=2261s)\n[Prometheus 架构设计](https://www.youtube.com/watch?v=SOTxSSiLtuA&t=141s)\n[实战 Prometheus 搭建监控系统](https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html)","content":"<p>本文介绍了如何使用Prometheus+Grafana这个监控解决方案。</p>\n<span id=\"more\"></span>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Prometheus是古希腊神话里泰坦族的一名神明，名字的意思是”先见之明”，下图中是Prometheus被宙斯惩罚，饱受肝脏日食夜长之苦。<br>下面就是我们所了解的Prometheus，下面是其官网封面图引导语：From metrics to insight，从指标到洞察力，通过指标去洞察你的系统，为我们的系统提供指标收集和监控的开源解决方案。也就是说，Prometheus是一个数据监控的解决方案，让我们能随时掌握系统运行的状态，快速定位问题和排除故障。<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img.png\"></p>\n<p>Prometheus发展速度很快，12年开发完成，16年加入CNCF，成为继K8s之后第二个CNCF托管的项目，目前Github 42k的🌟，而且社区很活跃，维护频率很高，基本稳定在 1个月1个小版本的迭代速度</p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_1.png\"></p>\n<h1 id=\"整体生态\"><a href=\"#整体生态\" class=\"headerlink\" title=\"整体生态\"></a>整体生态</h1><p>Prometheus提供了从指标暴露，到指标抓取、存储和可视化，以及最后的监控告警等一系列组件。<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_2.png\"></p>\n<h2 id=\"指标暴露\"><a href=\"#指标暴露\" class=\"headerlink\" title=\"指标暴露\"></a>指标暴露</h2><p>每一个被Prometheus监控的服务都是一个Job，Prometheus为这些Job提供了官方的SDK ，利用这个SDK可以自定义并导出自己的业务指标，也可以使用Prometheus官方提供的各种常用组件和中间件的Exporter（比如常用的MySQL，Consul等等）。对于短时间执行的脚本任务或者不好直接Pull指标的服务，Prometheus提供了PushGateWay网关给这些任务将服务指标主动推Push到网关，Prometheus再从这个网关里Pull指标。</p>\n<h2 id=\"指标抓取\"><a href=\"#指标抓取\" class=\"headerlink\" title=\"指标抓取\"></a>指标抓取</h2><p>上面提到了Push和Pull，其实这是两种指标抓取模型。</p>\n<ul>\n<li>Pull模型：监控服务主动拉取被监控服务的指标，被监控服务一般通过主动暴露metrics端口或者通过Exporter的方式暴露指标，监控服务依赖服务发现模块发现被监控服务，从而去定期的抓取指标<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_3.png\"></li>\n<li>Push模型：被监控服务主动将指标推送到监控服务，可能需要对指标做协议适配，必须得符合监控服务要求的指标格式，对于Prometheus中的指标抓取，采用的是Pull模型，默认是一分钟去拉取一次指标，通过Prometheus.yaml配置文件中的scrape_interval配置项配置，Prometheus对外都是用的Pull模型，一个是Pull Exporter的暴露的指标，一个是Pull PushGateway暴露的指标。<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_4.png\"></li>\n</ul>\n<h2 id=\"指标存储和查询\"><a href=\"#指标存储和查询\" class=\"headerlink\" title=\"指标存储和查询\"></a>指标存储和查询</h2><p>指标抓取后会存储在内置的时序数据库中，Prometheus也提供了PromQL查询语言给我们做指标的查询，我们可以在Prometheus的WebUI上通过PromQL，可视化查询我们的指标，也可以很方便的接入第三方的可视化工具，例如grafana。</p>\n<h2 id=\"监控告警\"><a href=\"#监控告警\" class=\"headerlink\" title=\"监控告警\"></a>监控告警</h2><p>prometheus提供了alertmanageer基于promql来做系统的监控告警，当promql查询出来的指标超过我们定义的阈值时，prometheus会发送一条告警信息到alertmanager，manager会将告警下发到配置好的邮箱或者微信。</p>\n<h1 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h1><p>Prometheus的从被监控服务的注册到指标抓取到指标查询的流程分为五个步骤：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_5.png\"></p>\n<h2 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h2><p>被监控服务在Prometheus中是一个Job存在，被监控服务的所有实例在Prometheus中是一个target的存在，所以被监控服务的注册就是在Prometheus中注册一个Job和其所有的target，这个注册分为：</p>\n<ul>\n<li>静态注册</li>\n<li>动态注册<br>静态注册：静态的将服务的IP和抓取指标的端口号配置在Prometheus yaml文件的scrape_configs配置下<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">scrape_configs:</span><br><span class=\"line\">- job_name: &quot;prometheus&quot;</span><br><span class=\"line\">  static_configs:</span><br><span class=\"line\">  - targets: [&quot;localhost:9090&quot;]</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>以上就是注册了一个名为prometheus的服务，这个服务下有一个实例，暴露的抓取地址是localhost:9090 动态注册：动态注册就是在Prometheus yaml文件的scrape_configs配置下配置服务发现的地址和服务名，Prometheus会去该地址，根据你提供的服务名动态发现实例列表，在Prometheus中，支持consul，DNS，文件，K8s等多种服务发现机制。 基于consul的服务发现：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- job_name: &quot;node_export_consul&quot;</span><br><span class=\"line\">  metrics_path: /node_metrics</span><br><span class=\"line\">  scheme: http</span><br><span class=\"line\">  consul_sd_configs:</span><br><span class=\"line\">  - server: localhost:8500</span><br><span class=\"line\">  services:</span><br><span class=\"line\">  - node_exporter</span><br></pre></td></tr></table></figure>\n<p>我们consul的地址就是：localhost:8500，服务名是node_exporter，在这个服务下有一个exporter实例： localhost:9600</p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_6.png\"></p>\n<p>注意：如果是动态注册，最好加上这两配置，静态注册指标拉取的路径会默认的帮我们指定为 metrics_path:&#x2F;metrics，所以如果暴露的指标抓取路径不同或者是动态的服务注册，最好加上这两个配置。不然会报错“INVALID“ is not a valid start token，演示下，百度了一下，这里可能是数据格式不统一导致</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">metrics_path: /node_metrics</span><br><span class=\"line\">scheme: http</span><br></pre></td></tr></table></figure>\n\n<p>最后可以在webUI中查看发现的实例：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_7.png\"><br>目前，Prometheus支持多达二十多种服务发现协议：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;azure_sd_config&gt;</span><br><span class=\"line\">&lt;consul_sd_config&gt;</span><br><span class=\"line\">&lt;digitalocean_sd_config&gt;</span><br><span class=\"line\">&lt;docker_sd_config&gt;</span><br><span class=\"line\">&lt;dockerswarm_sd_config&gt;</span><br><span class=\"line\">&lt;dns_sd_config&gt;</span><br><span class=\"line\">&lt;ec2_sd_config&gt;</span><br><span class=\"line\">&lt;openstack_sd_config&gt;</span><br><span class=\"line\">&lt;file_sd_config&gt;</span><br><span class=\"line\">&lt;gce_sd_config&gt;</span><br><span class=\"line\">&lt;hetzner_sd_config&gt;</span><br><span class=\"line\">&lt;http_sd_config&gt;</span><br><span class=\"line\">&lt;kubernetes_sd_config&gt;</span><br><span class=\"line\">&lt;kuma_sd_config&gt;</span><br><span class=\"line\">&lt;lightsail_sd_config&gt;</span><br><span class=\"line\">&lt;linode_sd_config&gt;</span><br><span class=\"line\">&lt;marathon_sd_config&gt;</span><br><span class=\"line\">&lt;nerve_sd_config&gt;</span><br><span class=\"line\">&lt;serverset_sd_config&gt;</span><br><span class=\"line\">&lt;triton_sd_config&gt;</span><br><span class=\"line\">&lt;eureka_sd_config&gt;</span><br><span class=\"line\">&lt;scaleway_sd_config&gt;</span><br><span class=\"line\">&lt;static_config&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置更新\"><a href=\"#配置更新\" class=\"headerlink\" title=\"配置更新\"></a>配置更新</h2><p>在更新完Prometheus的配置文件后，我们需要更新我们的配置到程序内存里，这里的更新方式有两种，第一种简单粗暴，就是重启Prometheus，第二种是动态更新的方式。如何实现动态的更新Prometheus配置。<br>第一步：首先要保证启动Prometheus的时候带上启动参数：–web.enable-lifecycle</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第二步：去更新我们的Prometheus配置 第三步：更新完配置后，我们可以通过Post请求的方式，动态更新配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -v --request POST &#x27;http://localhost:9090/-/reload&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>原理： Prometheus在web模块中，注册了一个handler</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if o.EnableLifecycle &#123;</span><br><span class=\"line\">   router.Post(&quot;/-/quit&quot;, h.quit)</span><br><span class=\"line\">   router.Put(&quot;/-/quit&quot;, h.quit)</span><br><span class=\"line\">   router.Post(&quot;/-/reload&quot;, h.reload)  // reload配置</span><br><span class=\"line\">   router.Put(&quot;/-/reload&quot;, h.reload)   </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>通过h.reload这个handler方法实现：这个handler就是往一个channle中发送一个信号：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (h *Handler) reload(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">   rc := make(chan error)</span><br><span class=\"line\">   h.reloadCh &lt;- rc    // 发送一个信号到channe了中</span><br><span class=\"line\">   if err := &lt;-rc; err != nil &#123;</span><br><span class=\"line\">      http.Error(w, fmt.Sprintf(&quot;failed to reload config: %s&quot;, err), http.StatusInternalServerError)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在main函数中会去监听这个channel，只要有监听到信号，就会做配置的reload，重新将新配置加载到内存中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case rc := &lt;-webHandler.Reload():</span><br><span class=\"line\">   if err := reloadConfig(cfg.configFile, cfg.enableExpandExternalLabels, cfg.tsdb.EnableExemplarStorage, logger, noStepSubqueryInterval, reloaders...); err != nil &#123;</span><br><span class=\"line\">      level.Error(logger).Log(&quot;msg&quot;, &quot;Error reloading config&quot;, &quot;err&quot;, err)</span><br><span class=\"line\">      rc &lt;- err</span><br><span class=\"line\">   &#125; else &#123;</span><br><span class=\"line\">      rc &lt;- nil</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"指标抓取和存储\"><a href=\"#指标抓取和存储\" class=\"headerlink\" title=\"指标抓取和存储\"></a>指标抓取和存储</h2><p>Prometheus对指标的抓取采取主动Pull的方式，即周期性的请求被监控服务暴露的metrics接口或者是PushGateway，从而获取到Metrics指标，默认时间是15s抓取一次，配置项如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global:</span><br><span class=\"line\"> scrape_interval: 15s</span><br></pre></td></tr></table></figure>\n\n<p>抓取到的指标会被以时间序列的形式保存在内存中，并且定时刷到磁盘上，默认是两个小时回刷一次。并且为了防止Prometheus 发生崩溃或重启时能够恢复数据，Prometheus也提供了类似MySQL中binlog一样的预写日志，当Prometheus崩溃重启时，会读这个预写日志来恢复数据。</p>\n<h1 id=\"Metric指标\"><a href=\"#Metric指标\" class=\"headerlink\" title=\"Metric指标\"></a>Metric指标</h1><h2 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h2><p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_8.png\"><br>Prometheus采集的所有指标都是以时间序列的形式进行存储，每一个时间序列有三部分组成：</p>\n<ul>\n<li>指标名和指标标签集合：metric_name{&lt;label1&#x3D;v1&gt;,&lt;label2&#x3D;v2&gt;….}，指标名：表示这个指标是监控哪一方面的状态，比如http_request_total表示：请求数量；指标标签，描述这个指标有哪些维度，比如http_request_total这个指标，有请求状态码code &#x3D; 200&#x2F;400&#x2F;500，请求方式：method &#x3D; get&#x2F;post等，实际上指标名称实际上是以标签的形式保存，这个标签是__name__，即：<strong>name</strong>&#x3D;<metric name></metric></li>\n<li>时间戳：描述当前时间序列的时间，单位：毫秒</li>\n<li>样本值：当前监控指标的具体数值，比如http_request_total的值就是请求数是多少。</li>\n</ul>\n<p>可以通过查看Prometheus的metrics接口查看所有上报的指标:<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_9.png\"></p>\n<p>所有的指标也都是通过如下所示的格式来标识的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">HELP    // HELP：这里描述的指标的信息，表示这个是一个什么指标，统计什么的</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">TYPE    // TYPE：这个指标是什么类型的</span></span><br><span class=\"line\">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;  value    // 指标的具体格式,&lt;指标名&gt;&#123;标签集合&#125; 指标值</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"指标类型\"><a href=\"#指标类型\" class=\"headerlink\" title=\"指标类型\"></a>指标类型</h2><p>Prometheus底层存储上其实并没有对指标做类型的区分，都是以时间序列的形式存储，但是为了方便用户的使用和理解不同监控指标之间的差异，Prometheus 定义了 4 种不同的指标类型：计数器counter，仪表盘gauge，直方图histogram，摘要summary<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_10.png\"></p>\n<p>Counter计数器： Counter类型和redis的自增命令一样，只增不减，通过Counter指标可以统计Http请求数量，请求错误数，接口调用次数等单调递增的数据。同时可以结合increase和rate等函数统计变化速率，后续我们会提到这些内置函数。<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_11.png\"></p>\n<p>Gauge仪表盘： 和Counter不同，Gauge是可增可减的，可以反映一些动态变化的数据，例如当前内存占用，CPU利用，Gc次数等动态可上升可下降的数据，在Prometheus上通过Gauge，可以不用经过内置函数直观的反映数据的变化情况，如下图表示堆可分配的空间大小：  上面两种是数值指标，代表数据的变化情况，Histogram和Summary是统计类型的指标，表示数据的分布情况 Histogram直方图： Histogram是一种直方图类型，可以观察到指标在各个不同的区间范围的分布情况，如下图所示：可以观察到请求耗时在各个桶的分布<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_12.png\"></p>\n<p>有一点要注意的是，Histogram是累计直方图，即每一个桶的是只有上区间，例如下图表示小于0.1毫秒（le&#x3D;”0.1”）的请求数量是18173个，小于0.2毫秒（le&#x3D;”0.2”）的请求是18182个，在le&#x3D;”0.2”这个桶中是包含了le&#x3D;”0.1”这个桶的数据，如果我们要拿到0.1毫秒到0.2毫秒的请求数量，可以通过两个桶想减得到。<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_13.png\"></p>\n<p>在直方图中，还可以通过histogram_quantile函数求出百分位数，比如P50，P90，P99等数据</p>\n<p>Summary摘要 Summary也是用来做统计分析的，和Histogram区别在于，Summary直接存储的就是百分位数，如下所示：可以直观的观察到样本的中位数，P90和P99<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_14.png\"></p>\n<p>Summary的百分位数是客户端计算好直接让Prometheus抓取的，不需要Prometheus计算，直方图是通过内置函数histogram_quantile在Prometheus服务端计算求出</p>\n<h2 id=\"指标导出\"><a href=\"#指标导出\" class=\"headerlink\" title=\"指标导出\"></a>指标导出</h2><p>指标导出有两种方式，一种是使用Prometheus社区提供的定制好的Exporter对一些组件诸如MySQL，Kafka等的指标作导出，也可以利用社区提供的Client来自定义指标导出。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">github.com/prometheus/client_golang/prometheus/promhttp</span><br></pre></td></tr></table></figure>\n\n<p>自定义Prometheus exporter：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">   &quot;net/http&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">   &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main()  &#123;</span><br><span class=\"line\">   http.Handle(&quot;/metrics&quot;, promhttp.Handler())</span><br><span class=\"line\">   http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>访问：<a href=\"http://localhost:8080/metrics%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%AF%BC%E5%87%BA%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E6%B2%A1%E6%9C%89%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E4%BD%95%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%8C%E4%BD%86%E6%98%AF%E8%83%BD%E7%9C%8B%E5%88%B0%E4%B8%80%E4%BA%9B%E5%86%85%E7%BD%AE%E7%9A%84Go%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8C%87%E6%A0%87%E5%92%8Cpromhttp%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%8C%E8%BF%99%E4%B8%AAClient%E9%BB%98%E8%AE%A4%E4%B8%BA%E6%88%91%E4%BB%AC%E6%9A%B4%E9%9C%B2%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%8Cgo_%EF%BC%9A%E4%BB%A5\">http://localhost:8080/metrics，即可看到导出的指标，这里我们没有自定义任何的指标，但是能看到一些内置的Go的运行时指标和promhttp相关的指标，这个Client默认为我们暴露的指标，go_：以</a> go_ 为前缀的指标是关于 Go 运行时相关的指标，比如垃圾回收时间、goroutine 数量等，这些都是 Go 客户端库特有的，其他语言的客户端库可能会暴露各自语言的其他运行时指标。promhttp_：来自 promhttp 工具包的相关指标，用于跟踪对指标请求的处理。</p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_15.png\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">   &quot;net/http&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">   &quot;github.com/prometheus/client_golang/prometheus&quot;</span><br><span class=\"line\">   &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 1.定义指标(类型,名字,帮助信息)</span><br><span class=\"line\">   myCounter := prometheus.NewCounter(prometheus.CounterOpts&#123;</span><br><span class=\"line\">      Name: &quot;my_counter_total&quot;,</span><br><span class=\"line\">      Help: &quot;自定义counter&quot;,</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   // 2.注册指标</span><br><span class=\"line\">   prometheus.MustRegister(myCounter)</span><br><span class=\"line\">   // 3.设置指标值</span><br><span class=\"line\">   myCounter.Add(23)</span><br><span class=\"line\"></span><br><span class=\"line\">   http.Handle(&quot;/metrics&quot;, promhttp.Handler())</span><br><span class=\"line\">   http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_16.png\"></p>\n<p>模拟下在业务中上报接口请求量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">   &quot;fmt&quot;</span><br><span class=\"line\">   &quot;net/http&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">   &quot;github.com/prometheus/client_golang/prometheus&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">var (</span><br><span class=\"line\">   MyCounter prometheus.Counter</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// init 注册指标</span><br><span class=\"line\">func init() &#123;</span><br><span class=\"line\">   // 1.定义指标（类型，名字，帮助信息）</span><br><span class=\"line\">   MyCounter = prometheus.NewCounter(prometheus.CounterOpts&#123;</span><br><span class=\"line\">      Name: &quot;my_counter_total&quot;,</span><br><span class=\"line\">      Help: &quot;自定义counter&quot;,</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   // 2.注册指标</span><br><span class=\"line\">   prometheus.MustRegister(MyCounter)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Sayhello</span><br><span class=\"line\">func Sayhello(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">   // 接口请求量递增</span><br><span class=\"line\">   MyCounter.Inc()</span><br><span class=\"line\">   fmt.Fprintf(w, &quot;Hello Wrold!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>main.go：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">   &quot;net/http&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">   &quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   http.Handle(&quot;/metrics&quot;, promhttp.Handler())</span><br><span class=\"line\">   http.HandleFunc(&quot;/counter&quot;,Sayhello)</span><br><span class=\"line\">   http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一开始启动时，指标counter是0<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_17.png\"></p>\n<p>调用：&#x2F;counter接口后，指标数据发生了变化，这样就可以简单实现了接口请求数的统计<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_18.png\"></p>\n<p>对于其他指标定义方式是一样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var (</span><br><span class=\"line\">   MyCounter prometheus.Counter</span><br><span class=\"line\">   MyGauge prometheus.Gauge</span><br><span class=\"line\">   MyHistogram prometheus.Histogram</span><br><span class=\"line\">   MySummary prometheus.Summary</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// init 注册指标</span><br><span class=\"line\">func init() &#123;</span><br><span class=\"line\">   // 1.定义指标（类型，名字，帮助信息）</span><br><span class=\"line\">   MyCounter = prometheus.NewCounter(prometheus.CounterOpts&#123;</span><br><span class=\"line\">      Name: &quot;my_counter_total&quot;,</span><br><span class=\"line\">      Help: &quot;自定义counter&quot;,</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   // 定义gauge类型指标</span><br><span class=\"line\">   MyGauge = prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class=\"line\">      Name: &quot;my_gauge_num&quot;,</span><br><span class=\"line\">      Help: &quot;自定义gauge&quot;,</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   // 定义histogram</span><br><span class=\"line\">   MyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123;</span><br><span class=\"line\">      Name: &quot;my_histogram_bucket&quot;,</span><br><span class=\"line\">      Help: &quot;自定义histogram&quot;,</span><br><span class=\"line\">      Buckets: []float64&#123;0.1,0.2,0.3,0.4,0.5&#125;,   // 需要指定桶</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   // 定义Summary</span><br><span class=\"line\">   MySummary = prometheus.NewSummary(prometheus.SummaryOpts&#123;</span><br><span class=\"line\">      Name: &quot;my_summary_bucket&quot;,</span><br><span class=\"line\">      Help: &quot;自定义summary&quot;,</span><br><span class=\"line\">      // 这部分可以算好后在set</span><br><span class=\"line\">      Objectives: map[float64]float64&#123;</span><br><span class=\"line\">         0.5: 0.05,</span><br><span class=\"line\">         0.9: 0.01,   </span><br><span class=\"line\">         0.99: 0.001, </span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   // 2.注册指标</span><br><span class=\"line\">   prometheus.MustRegister(MyCounter)</span><br><span class=\"line\">   prometheus.MustRegister(MyGauge)</span><br><span class=\"line\">   prometheus.MustRegister(MyHistogram)</span><br><span class=\"line\">   prometheus.MustRegister(MySummary)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_19.png\"></p>\n<p>上面的指标都是没有设置标签的，我们一般的指标都是带有标签的，如何设置指标的标签呢？ 如果我要设置带标签的counter类型指标，只需要将原来的NewCounter方法替换为NewCounterVec方法即可，并且传入标签集合</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyCounter *prometheus.CounterVec</span><br><span class=\"line\">// 1.定义指标（类型，名字，帮助信息）</span><br><span class=\"line\">MyCounter = prometheus.NewCounterVec(</span><br><span class=\"line\">   prometheus.CounterOpts&#123;</span><br><span class=\"line\">   Name: &quot;my_counter_total&quot;,</span><br><span class=\"line\">   Help: &quot;自定义counter&quot;,</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   // 标签集合</span><br><span class=\"line\">   []string&#123;&quot;label1&quot;,&quot;label2&quot;&#125;,</span><br><span class=\"line\">)</span><br><span class=\"line\">// 带标签的set指标值</span><br><span class=\"line\">MyCounter.With(prometheus.Labels&#123;&quot;label1&quot;:&quot;1&quot;,&quot;label2&quot;:&quot;2&quot;&#125;).Inc()</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_20.png\"></p>\n<p>其他同理</p>\n<h1 id=\"PromQL\"><a href=\"#PromQL\" class=\"headerlink\" title=\"PromQL\"></a>PromQL</h1><p>刚刚提到了Prometheus中指标有哪些类型以及如何导出我们的指标，现在指标导出到Prometheus了，利用其提供的PromQL可以查询我们导出的指标 PromQL是Prometheus为我们提供的函数式的查询语言，查询表达式有四种类型：</p>\n<ul>\n<li>字符串：只作为某些内置函数的参数出现</li>\n<li>标量：单一的数字值，可以是函数参数，也可以是函数的返回结果</li>\n<li>瞬时向量：某一时刻的时序数据</li>\n<li>区间向量：某一时间区间内的时序数据集合</li>\n</ul>\n<h2 id=\"瞬时查询\"><a href=\"#瞬时查询\" class=\"headerlink\" title=\"瞬时查询\"></a>瞬时查询</h2><p>直接通过指标名即可进行查询，查询结果是当前指标最新的时间序列，比如查询Gc累积消耗的时间：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go_gc_duration_seconds_count</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_21.png\"></p>\n<p>我们可以看到查询出来有多个同名指标结果 可以用{}做标签过滤查询：比如我们想查指定实例的指标</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go_gc_duration_seconds_count&#123;instance=&quot;127.0.0.1:9600&quot;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_22.png\"></p>\n<p>而且也支持则表达式，通过&#x3D;~指定正则表达式，如下所示：查询所有instance是localhost开头的指标</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go_gc_duration_seconds_count&#123;instance=~&quot;localhost.*&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_23.png\"></p>\n<h2 id=\"范围查询\"><a href=\"#范围查询\" class=\"headerlink\" title=\"范围查询\"></a>范围查询</h2><p>范围查询的结果集就是区间向量，可以通过[]指定时间来做范围查询<br>查询5分钟内的Gc累积消耗时间</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go_gc_duration_seconds_count&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>\n\n<p>注意：这里范围查询第一个点并不一定精确到刚刚好5分钟前的那个时序样本点，他是以5分钟作为一个区间，寻找这个区间的第一个点到最后一个样本点。</p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_24.png\"></p>\n<p>时间单位：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_25.png\"></p>\n<p>d：天，h：小时，m：分钟，ms：毫秒，s：秒，w：周，y：年 同样支持类似SQL中的offset查询，如下：查询一天前当前5分钟前的时序数据集</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go_gc_duration_seconds_count&#123;&#125;[5m] offset 1d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内置函数\"><a href=\"#内置函数\" class=\"headerlink\" title=\"内置函数\"></a>内置函数</h2><p>Prometheus内置了很多函数，这里主要记录下常用的几个函数的使用： rate和irate函数： rate函数可以用来求指标的平均变化速率</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rate函数=时间区间前后两个点的差 / 时间范围</span><br></pre></td></tr></table></figure>\n<p>一般rate函数可以用来求某个时间区间内的请求速率，也就是我们常说的QPS<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_26.png\"></p>\n<p>但是rate函数只是算出来了某个时间区间内的平均速率，没办法反映突发变化，假设在一分钟的时间区间里，前50秒的请求量都是0到10左右，但是最后10秒的请求量暴增到100以上，这时候算出来的值可能无法很好的反映这个峰值变化。这个问题可以通过irate函数解决，irate函数求出来的就是瞬时变化率</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">时间区间内最后两个样本点的差 / 最后两个样本点的时间差</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_27.png\"></p>\n<p>可以通过图像看下两者的区别：irate函数的图像峰值变化大，rate函数变化较为平缓 rate函数：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_28.png\"></p>\n<p>irate函数：</p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_29.png\"></p>\n<p>聚合函数：Sum() by() without() 也是上边的例子，我们在求指定接口的QPS的时候，可能会出现多个实例的QPS的计算结果，如下是存在多个接口，三个服务的QPS</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;, method=&quot;GET&quot;, status=&quot;200&quot;&#125;[5m])</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_30.png\"></p>\n<p>利用sum函数可以将三个QPS聚合，即可得到整个服务该接口的QPS：其实Sum就是将指标值做相加<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_31.png\"></p>\n<p>但是这样直接的相加太笼统抽象了，可以配合by和without函数在sum的时候，基于某些标签分组，类似SQL中的group by 例如，我可以根据请求接口标签分组：这样拿到的就是具体接口的QPS</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;, method=&quot;GET&quot;, status=&quot;200&quot;&#125;[5m])) by(path)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_32.png\"></p>\n<p>也可以不根据接口路径分组：通过without指定</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(rate(demo_api_request_duration_seconds_count&#123;job=&quot;demo&quot;, method=&quot;GET&quot;, status=&quot;200&quot;&#125;[5m])) without(path)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_33.png\"></p>\n<p>可以通过histogram_quantile函数做数据统计：可以用来统计百分位数：第一个参数是百分位，第二个histogram指标，这样计算出来的就是中位数，即P50</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">histogram_quantile(0.5,go_gc_pauses_seconds_total_bucket)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_34.png\"></p>\n<p>分享之前和同事一起发现的坑： 在刚刚写的自定义exporter上新增几个histogram的样本点</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyHistogram.Observe(0.3)</span><br><span class=\"line\">MyHistogram.Observe(0.4)</span><br><span class=\"line\">MyHistogram.Observe(0.5)</span><br></pre></td></tr></table></figure>\n\n<p>histogram的桶设置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123;</span><br><span class=\"line\">   Name: &quot;my_histogram_bucket&quot;,</span><br><span class=\"line\">   Help: &quot;自定义histogram&quot;,</span><br><span class=\"line\">   Buckets: []float64&#123;0,2.5,5,7.5,10&#125;,    // 需要指定桶</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果这样的话，所有指标都会直接进入到第一个桶，即0到2.5这个桶，如果我要计算中位数，那么这个中位数按照数学公式来算的话，肯定是在0到2.5之间的，而且肯定是0.3到0.5之间。 我用histogram_quantile函数计算下：计算结果是1.25，其实已经不对了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">histogram_quantile(0.5,my_histogram_bucket_bucket) </span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_35.png\"></p>\n<p>我的指标都是不大于1的，为啥算出来的P50和P99都这么离谱呢？ 这是因为Prometheus他是不保存你具体的指标数值的，他会帮你把指标放到具体的桶，但是他不会保存你指标的值，计算的分位数是一个预估的值，怎么预估呢？就是假设每个桶内的样本分布是均匀的，线性分布来计算的，比如刚刚的P50，其实就是算排在第50%位置的样本值，因为刚刚所有的数据都落在了第一个桶，那么他在计算的时候就会假定这个50%值在第一个桶的中点，他就会假定这个数就是0.5 2.5，P99就是第一个桶的99%的位置，他就会假定这个数就是0.99 2.5 导致这个误差较大的原因就是我们的bucket设置的不合理。 重新定义桶：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义histogram</span><br><span class=\"line\">MyHistogram = prometheus.NewHistogram(prometheus.HistogramOpts&#123;</span><br><span class=\"line\">   Name: &quot;my_histogram_bucket&quot;,</span><br><span class=\"line\">   Help: &quot;自定义histogram&quot;,</span><br><span class=\"line\">   Buckets: []float64&#123;0.1,0.2,0.3,0.4,0.5&#125;,   // 需要指定桶</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>上报数据：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyHistogram.Observe(0.1)</span><br><span class=\"line\">MyHistogram.Observe(0.3)</span><br><span class=\"line\">MyHistogram.Observe(0.4)</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_36.png\"></p>\n<p>重新计算P50，P99<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_37.png\"></p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_38.png\"></p>\n<p>桶设置的越合理，计算的误差越小</p>\n<h1 id=\"Grafana可视化\"><a href=\"#Grafana可视化\" class=\"headerlink\" title=\"Grafana可视化\"></a>Grafana可视化</h1><p>除了可以利用Prometheus提供的webUI可视化我们的指标外，还可以接入Grafana来做指标的可视化。<br>第一步，对接数据源：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_39.png\"></p>\n<p>配置好prometheus的地址：</p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_40.png\"></p>\n<p>第二步：创建仪表盘<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_41.png\"></p>\n<p>编辑仪表盘<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_42.png\"></p>\n<p>在metrics处编写PromQL即可完成查询和可视化<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_43.png\"></p>\n<p>仪表盘编辑完后，可以导出对应的json文件，方便下次导入同样的仪表盘</p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_44.png\"></p>\n<p><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_45.png\"></p>\n<h1 id=\"监控告警-1\"><a href=\"#监控告警-1\" class=\"headerlink\" title=\"监控告警\"></a>监控告警</h1><p>AlertManager是prometheus提供的告警信息下发组件，包含了对告警信息的分组，下发，静默等策略 配置完成后可以在webui上看到对应的告警策略信息。告警规则也是基于PromQL进行定制的。 编写告警配置：当Http_srv这个服务挂了，Prometheus采集不到指标，并且持续时间1分钟，就会触发告警</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groups:</span><br><span class=\"line\">- name: simulator-alert-rule</span><br><span class=\"line\">  rules:</span><br><span class=\"line\">  - alert: HttpSimulatorDown</span><br><span class=\"line\">    expr: sum(up&#123;job=&quot;http_srv&quot;&#125;) == 0 </span><br><span class=\"line\">    for: 1m</span><br><span class=\"line\">    labels:</span><br><span class=\"line\">      severity: critical</span><br></pre></td></tr></table></figure>\n\n<p>在prometheus.yml中配置告警配置文件，需要配置上alertmanager的地址和告警文件的地址</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Alertmanager configuration</span></span><br><span class=\"line\">alerting:</span><br><span class=\"line\">  alertmanagers:</span><br><span class=\"line\">  - static_configs:</span><br><span class=\"line\">    - targets: [&#x27;localhost:9093&#x27;]</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Load rules once and periodically evaluate them according to the global <span class=\"string\">&#x27;evaluation_interval&#x27;</span>.</span></span><br><span class=\"line\">rule_files:</span><br><span class=\"line\">    - &quot;alert_rules.yml&quot;</span><br><span class=\"line\">    #- &quot;first_rules.yml&quot;</span><br></pre></td></tr></table></figure>\n\n<p>配置告警信息，例如告警发送地址，告警内容模版，分组策略等都在alertmanager的配置文件中配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global:</span><br><span class=\"line\">  smtp_smarthost: &#x27;smtp.qq.com:465&#x27;</span><br><span class=\"line\">  smtp_from: &#x27;xxxx@qq.com&#x27;</span><br><span class=\"line\">  smtp_auth_username: &#x27;xxxx@qq.com&#x27;</span><br><span class=\"line\">  smtp_auth_password: &#x27;xxxx&#x27;</span><br><span class=\"line\">  smtp_require_tls: false</span><br><span class=\"line\"></span><br><span class=\"line\">route:</span><br><span class=\"line\">  group_interval: 1m</span><br><span class=\"line\">  repeat_interval: 1m</span><br><span class=\"line\">  receiver: &#x27;mail-receiver&#x27;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"> group_by             //采用哪个标签作为分组</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"> group_wait           //分组等待的时间，收到报警不是立马发送出去，而是等待一段时间，看看同一组中是否有其他报警，如果有一并发送</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"> group_interval       //告警时间间隔</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"> repeat_interval      //重复告警时间间隔，可以减少发送告警的频率</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"> receiver             //接收者是谁</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"> routes               //子路由配置</span></span><br><span class=\"line\">receivers:</span><br><span class=\"line\">- name: &#x27;mail-receiver&#x27;</span><br><span class=\"line\">  email_configs:</span><br><span class=\"line\">    - to: &#x27;xxxx@qq.com&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当我kill进程：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_46.png\"></p>\n<p>prometheus已经触发告警：<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_47.png\"></p>\n<p>在等待1分钟，如果持续还是符合告警策略，则状态为从pending变为 FIRING会发送邮件到我的邮箱<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_48.png\"><br>此时我的邮箱收到了一条告警消息<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_49.png\"></p>\n<p>alertmanager也支持对告警进行静默，在alertmanager的WEBUI中配置即可<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_50.png\"></p>\n<p>间隔了4分钟，没有收到告警，静默生效<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_51.png\"></p>\n<p>一个小时没有收到告警信息<br><img src=\"http://cdn.yuleweici.com/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/img_52.png\"></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p><a href=\"https://developer.aliyun.com/article/786418\">Pull or Push？监控系统如何选型-阿里云开发者社区</a><br><a href=\"https://segmentfault.com/a/1190000040792832\">为go应用添加prometheus监控指标 - SegmentFault 思否</a><br><a href=\"https://github.com/prometheus/client_golang\">GitHub - prometheus&#x2F;client_golang: Prometheus instrumentation library for Go applications</a><br><a href=\"https://p8s.io/docs/\">Material for MkDocs - Prometheus 入门到实战</a><br><a href=\"https://www.dockone.io/article/347688\">终于有人把Prometheus入门讲明白了 - DockOne.io</a><br><a href=\"https://www.qikqiak.com/post/alertmanager-of-prometheus-in-practice/\">Prometheus报警AlertManager实战-阳明的博客|Kubernetes|Istio|Prometheus|Python|Golang|云原生</a><br><a href=\"https://songjiayang.gitbooks.io/prometheus/content/qa/hotreload.html\">如何热加载更新配置?</a><br><a href=\"https://www.youtube.com/watch?v=qB40kqhTyYM&t=2261s\">技术分享：Prometheus是怎么存储数据的</a><br><a href=\"https://www.youtube.com/watch?v=SOTxSSiLtuA&t=141s\">Prometheus 架构设计</a><br><a href=\"https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html\">实战 Prometheus 搭建监控系统</a></p>\n","slug":"监控-Prometheus-Grafana实战","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/09/%E7%9B%91%E6%8E%A7-Prometheus-Grafana%E5%AE%9E%E6%88%98/","excerpt":"本文介绍了如何使用Prometheus+Grafana这个监控解决方案。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Prometheus","slug":"Prometheus","permalink":"http://vwin.github.io/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","permalink":"http://vwin.github.io/tags/Grafana/"},{"name":"监控","slug":"监控","permalink":"http://vwin.github.io/tags/%E7%9B%91%E6%8E%A7/"}]},{"title":"Go-单测","date":"2022-11-04T10:55:50.000Z","path":"2022/11/04/Go-单测/","text":"单测系列-Go本文整理学习Go单测相关内容总结在Go中如何做单测，本文介绍了单测是什么以及Go常用的单测框架和工具 单元测试单元测试是什么单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、超类、抽象类等中的方法。单元测试就是软件开发中对最小单位进行正确性检验的测试工作。 不同地方对单元测试有的定义可能会有所不同，但有一些基本共识： 单元测试是比较底层的，关注代码的局部而不是整体。单元测试是开发人员在写代码时候写的。单元测试需要比其他测试运行得快。 单元测试的意义提高代码质量。代码测试都是为了帮助开发人员发现问题从而解决问题，提高代码质量。尽早发现问题。问题越早发现，解决的难度和成本就越低。保证重构正确性。随着功能的增加，重构（修改老代码）几乎是无法避免的。很多时候我们不敢重构的原因，就是担心其它模块因为依赖它而不工作。有了单元测试，只要在改完代码后运行一下单测就知道改动对整个系统的影响了，从而可以让我们放心的重构代码。简化调试过程。单元测试让我们可以轻松地知道是哪一部分代码出了问题。简化集成过程。由于各个单元已经被测试，在集成过程中进行的后续测试会更加容易。优化代码设计。编写测试用例会迫使开发人员仔细思考代码的设计和必须完成的工作，有利于开发人员加深对代码功能的理解，从而形成更合理的设计和结构。单元测试是最好的文档。单元测试覆盖了接口的所有使用方法，是最好的示例代码。而真正的文档包括注释很有可能和代码不同步，并且看不懂。 单元测试用例编写的原则理论原则快。单元测试是回归测试，可以在开发过程的任何时候运行，因此运行速度必须快一致性。代码没有改变的情况下，每次运行得结果应该保持确定且一致原子性。结果只有两种情况：Pass &#x2F; Fail用例独立。执行顺序不影响；用例间没有状态共享或者依赖关系；用例没有副作用（执行前后环境状态一致）单一职责。一个用例只负责一个场景隔离。功能可能依赖于数据库、web访问、环境变量、系统时间等；一个单元可能依赖于另一部分代码，用例应该解除这些依赖可读性。用例的名称、变量名等应该具有可读性，直接表现出该测试的目标自动化。单元测试需要全自动执行。测试程序不应该有用户输入；测试结果应该能直接被电脑获取，不应该由人来判断。 规约原则在实际编写代码过程中，不同的团队会有不同团队的风格，只要团队内部保持有一定的规约即可，比如： 单元测试文件名必须以xxx_test.go命名方法必须是TestXxx开头，建议风格保持一致（驼峰或者下划线）方法参数必须 t *testing.T测试文件和被测试文件必须在一个包中 衡量原则 单元测试是要写额外的代码的，这对开发同学的也是一个不小的工作负担，在一些项目中，我们合理的评估单元测试的编写，我认为我们不能走极端，当然理论上来说全写肯定时好的，但是从成本，效率上来说我们必须做出权衡，衡量原则如下： 优先编写核心组件和逻辑模块的测试用例逻辑类似的组件如果存在多个，优先编写其中一种逻辑组件的测试用例发现Bug时一定先编写测试用例进行Debug关键util工具类要编写测试用例，这些util工具适用的很频繁，所以这个原则也叫做热点原则，和第1点相呼应。测试用户应该独立，一个文件对应一个，而且不同的测试用例之间不要互相依赖。测试用例的保持更新 单元测试用例设计方法规范(规格)导出法规范(规格)导出法将需求”翻译“成测试用例。 123456例如，一个函数的设计需求如下：函数：一个计算平方根的函数输入： 实数输出： 实数要求： 当输入一个0或者比0大的实数时，返回其正的平方根；当输入一个小于0的实数时，显示错误信息“平方根非法—输入之小于0”，并返回0；库函数printf()可以用来输出错误信息。 在这个规范中有3个陈述，可以用两个测试用例来对应: 测试用例1：输入4，输出2。测试用例2：输入-1，输出0。 等价类划分法等价类划分法假定某一特定的等价类中的所有值对于测试目的来说是等价的，所以在每个等价类中找一个之作为测试用例。 按照 [输入条件][有效等价类][无效等价类] 建立等价类表，列出所有划分出的等价类为每一个等价类规定一个唯一的编号设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类。重复这一步，直到所有的有效等价类都被覆盖为止设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，直到所有的无效等价类都被覆盖为止例如，注册邮箱时要求用6~18个字符，可使用字母、数字、下划线，需以字母开头。 有效等价类 无效等价类 6~18个字符（1） 少于6个字符（2）多余18个字符（3）空（4） 包含字母、数字、下划线（5） 除字母、数字、下划线的特殊字符（6）非打印字符（7）中文字符 （8） 以字母开头（9） 以数字或下划线开头（10） 测试用例： 编号 输入数据 覆盖等价类 预期结果 1 test_111 （1）、（5）、（9） 合法输入 2 t_11 （2）、（5）、（9） 非法输入 3 testtesttest_12345678 （3）、（5）、（9） 非法输入 4 NULL （4） 非法输入 5 test!@1111 （1）、（6）、（9） 非法输入 6 test 1111 （1）、（7）、（9） 非法输入 7 test测试1111 （1）、（8）、（9） 非法输入 8 _test111 （1）、（5）、（10） 非法输入 边界值分析法边界值分析法使用与等价类测试方法相同的等价类划分，只是边界值分析假定错误更多地存在于两个划分的边界上。 边界值测试在软件变得复杂的时候也会变得不实用。边界值测试对于非向量类型的值(如枚举类型的值)也没有意义。 例如，和4.1相同的需求：划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0。由此得到以下测试用例： 输入 {最小负实数} 输入 {绝对值很小的负数} 输入 0 输入 {绝对值很小的正数} 输入 {最大正实数} 基本路径测试法基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。 基本路径测试法的基本步骤： 程序的控制流图：描述程序控制流的一种图示方法。 程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。 导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。 准备测试用例：确保基本路径集中的每一条路径的执行。 Golang的测试框架Golang有这几种比较常见的测试框架 1234测试框架 推荐指数Go自带的testing包 ★★★☆☆GoConvey ★★★★★testify ★★★☆☆ 从测试用例编写的简易难度上来说：testify 比 GoConvey 简单；GoConvey比Go自带的testing包简单。但在测试框架的选择上，我们更推荐GoConvey。因为： GoConvey和其他Stub&#x2F;Mock框架的兼容性相比Testify更好。Testify自带Mock框架，但是用这个框架Mock类需要自己写。像这样重复有规律的部分在GoMock中是一键自动生成的。 Go自带的testing包 testing 为 Go 语言 package 提供自动化测试的支持。通过 go test 命令，能够自动执行如下形式的任何函数： func TestXxx(*testing.T) 注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。 在这些函数中，使用 Error、Fail 或相关方法来发出失败信号。 要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 TestXxx 函数，如上所述。 将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 go test 命令时将被包含。 有关详细信息，请运行 go help test 和 go help testflag 了解。 第一个例子12345678910111213141516171819202122232425262728293031323334353637383940被测代码：func Fib(n int) int &#123; if n &lt; 2 &#123; return n &#125; return Fib(n-1) + Fib(n-2)&#125;测试代码：func TestFib(t *testing.T) &#123; var ( in = 7 expected = 13 ) actual := Fib(in) if actual != expected &#123; t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, in, actual, expected) &#125;&#125;执行 go test . ，输出：$ go test .ok chapter09/testing 0.007s表示测试通过。我们将 Fib 函数改为：func Fib(n int) int &#123; if n &lt; 2 &#123; return n &#125; return Fib(n-1) + Fib(n-1)&#125;再执行 go test . ，输出：$ go test .--- FAIL: TestFib (0.00s) t_test.go:16: Fib(10) = 64; expected 13FAILFAIL chapter09/testing 0.009s Table-Driven测试Table-Driven 的方式将多个case在同一个测试函数中测到： 123456789101112131415161718192021func TestFib(t *testing.T) &#123; var fibTests = []struct &#123; in int // input expected int // expected result &#125;&#123; &#123;1, 1&#125;, &#123;2, 1&#125;, &#123;3, 2&#125;, &#123;4, 3&#125;, &#123;5, 5&#125;, &#123;6, 8&#125;, &#123;7, 13&#125;, &#125; for _, tt := range fibTests &#123; actual := Fib(tt.in) if actual != tt.expected &#123; t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, tt.in, actual, tt.expected) &#125; &#125;&#125; Go自带testing包的更多用法 GoConvey：简单断言Convey适用于书写单元测试用例，并且可以兼容到testing框架中，go test命令或者使用goconvey命令访问localhost:8080的Web测试界面都可以查看测试结果。 123Convey(&quot;Convey return : &quot;, t, func() &#123; So(...)&#125;) 一般Convey用So来进行断言，断言的方式可以传入一个函数，或者使用自带的ShouldBeNil、ShouldEqual、ShouldNotBeNil函数等。 基本用法被测代码： 123456789101112131415161718192021222324252627282930func StringSliceEqual(a, b []string) bool &#123; if len(a) != len(b) &#123; return false &#125; if (a == nil) != (b == nil) &#123; return false &#125; for i, v := range a &#123; if v != b[i] &#123; return false &#125; &#125; return true&#125;测试代码import ( &quot;testing&quot; . &quot;github.com/smartystreets/goconvey/convey&quot;)func TestStringSliceEqual(t *testing.T) &#123; Convey(&quot;TestStringSliceEqual的描述&quot;, t, func() &#123; a := []string&#123;&quot;hello&quot;, &quot;goconvey&quot;&#125; b := []string&#123;&quot;hello&quot;, &quot;goconvey&quot;&#125; So(StringSliceEqual(a, b), ShouldBeTrue) &#125;)&#125; 双层嵌套12345678910111213141516171819import ( &quot;testing&quot; . &quot;github.com/smartystreets/goconvey/convey&quot;)func TestStringSliceEqual(t *testing.T) &#123; Convey(&quot;TestStringSliceEqual&quot;, t, func() &#123; Convey(&quot;true when a != nil &amp;&amp; b != nil&quot;, func() &#123; a := []string&#123;&quot;hello&quot;, &quot;goconvey&quot;&#125; b := []string&#123;&quot;hello&quot;, &quot;goconvey&quot;&#125; So(StringSliceEqual(a, b), ShouldBeTrue) &#125;) Convey(&quot;true when a ＝= nil &amp;&amp; b ＝= nil&quot;, func() &#123; So(StringSliceEqual(nil, nil), ShouldBeTrue) &#125;) &#125;)&#125;内层的Convey不需要再传入t *testing.T参数 GoConvey的更多用法 testifytestify提供了assert和require，让你可以简洁地写出 1if xxx &#123; t.Fail() &#125; assert1234567891011121314151617func TestSomething(t *testing.T) &#123; //断言相等 assert.Equal(t, 123, 123, &quot;they should be equal&quot;) //断言不相等 assert.NotEqual(t, 123, 456, &quot;they should not be equal&quot;) //对于nil的断言 assert.Nil(t, object) //对于非nil的断言 if assert.NotNil(t, object) &#123; // now we know that object isn&#x27;t nil, we are safe to make // further assertions without causing any errors assert.Equal(t, &quot;Something&quot;, object.Value) &#125; require require和assert失败、成功条件完全一致，区别在于assert只是返回布尔值（true、false），而require不符合断言时，会中断当前运行 常用的函数123456789101112131415161718192021222324252627func Equal(t TestingT, expected, actual interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc NotEqual(t TestingT, expected, actual interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc Nil(t TestingT, object interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc NotNil(t TestingT, object interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc Empty(t TestingT, object interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc NotEmpty(t TestingT, object interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc NoError(t TestingT, err error, msgAndArgs ...interface&#123;&#125;) boolfunc Error(t TestingT, err error, msgAndArgs ...interface&#123;&#125;) boolfunc Zero(t TestingT, i interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc NotZero(t TestingT, i interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc True(t TestingT, value bool, msgAndArgs ...interface&#123;&#125;) boolfunc False(t TestingT, value bool, msgAndArgs ...interface&#123;&#125;) boolfunc Len(t TestingT, object interface&#123;&#125;, length int, msgAndArgs ...interface&#123;&#125;) boolfunc NotContains(t TestingT, s, contains interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc NotContains(t TestingT, s, contains interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) boolfunc Subset(t TestingT, list, subset interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) (ok bool)func NotSubset(t TestingT, list, subset interface&#123;&#125;, msgAndArgs ...interface&#123;&#125;) (ok bool)func FileExists(t TestingT, path string, msgAndArgs ...interface&#123;&#125;) boolfunc DirExists(t TestingT, path string, msgAndArgs ...interface&#123;&#125;) bool testify的更多用法 Stub&#x2F;Mock框架Golang有以下Stub&#x2F;Mock框架： 123GoStubGoMockMonkey 一般来说，GoConvey可以和GoStub、GoMock、Monkey中的一个或多个搭配使用。 Testify本身有自己的Mock框架，可以用自己的也可以和这里列出来的Stub&#x2F;Mock框架搭配使用。 GoStubGoStub框架的使用场景很多，依次为： 基本场景：为一个全局变量打桩基本场景：为一个函数打桩基本场景：为一个过程打桩复合场景：由任意相同或不同的基本场景组合而成 为一个全局变量打桩假设num为被测函数中使用的一个全局整型变量，当前测试用例中假定num的值大于100，比如为150，则打桩的代码如下： 12stubs := Stub(&amp;num, 150)defer stubs.Reset() stubs是GoStub框架的函数接口Stub返回的对象，该对象有Reset操作，即将全局变量的值恢复为原值。 为一个函数打桩假设我们产品的既有代码中有下面的函数定义： 123456789101112func Exec(cmd string, args ...string) (string, error) &#123; ...&#125;若要想对Exec函数通过GoStub框架打桩，需要将Exec函数定义为匿名函数，同时将它赋值给Exec变量，重构后的代码如下：var Exec = func(cmd string, args ...string) (string, error) &#123; ...&#125;我们可以对Exec函数打桩，代码如下所示：stubs := StubFunc(&amp;Exec,&quot;xxx-vethName100-yyy&quot;, nil)defer stubs.Reset() 为一个过程打桩当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。我们对过程DestroyResource的打桩代码为： 12stubs := StubFunc(&amp;DestroyResource)defer stubs.Reset() GoStub的更多用法以及GoStub+GoConvey的组合使用方法 GoMockGoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的testing包良好集成，也能用于其它的测试环境中。GoMock测试框架包含了GoMock包和mockgen工具两部分，其中GoMock包完成对桩对象生命周期的管理，mockgen工具用来生成interface对应的Mock类源文件。 定义一个接口我们先定义一个打算mock的接口Repository。 Repository是领域驱动设计中战术设计的一个元素，用来存储领域对象，一般将对象持久化在数据库中，比如Aerospike，Redis或Etcd等。对于领域层来说，只知道对象在Repository中维护，并不care对象到底在哪持久化，这是基础设施层的职责。微服务在启动时，根据部署参数实例化Repository接口，比如AerospikeRepository，RedisRepository或EtcdRepository。 12345678package dbtype Repository interface &#123; Create(key string, value []byte) error Retrieve(key string) ([]byte, error) Update(key string, value []byte) error Delete(key string) error&#125; 生成mock类文件这下该mockgen工具登场了。mockgen有两种操作模式：源文件和反射。 源文件模式通过一个包含interface定义的文件生成mock类文件，它通过 -source 标识生效，-imports 和 -aux_files 标识在这种模式下也是有用的。举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546mockgen -source=foo.go [other options] 反射模式通过构建一个程序用反射理解接口生成一个mock类文件，它通过两个非标志参数生效：导入路径和用逗号分隔的符号列表（多个interface）。举例：mockgen database/sql/driver Conn,Driver生成的mock_repository.go文件：// Automatically generated by MockGen. DO NOT EDIT!// Source: infra/db (interfaces: Repository)package mock_dbimport ( gomock &quot;github.com/golang/mock/gomock&quot;)// MockRepository is a mock of Repository interfacetype MockRepository struct &#123; ctrl *gomock.Controller recorder *MockRepositoryMockRecorder&#125;// MockRepositoryMockRecorder is the mock recorder for MockRepositorytype MockRepositoryMockRecorder struct &#123; mock *MockRepository&#125;// NewMockRepository creates a new mock instancefunc NewMockRepository(ctrl *gomock.Controller) *MockRepository &#123; mock := &amp;MockRepository&#123;ctrl: ctrl&#125; mock.recorder = &amp;MockRepositoryMockRecorder&#123;mock&#125; return mock&#125;// EXPECT returns an object that allows the caller to indicate expected usefunc (_m *MockRepository) EXPECT() *MockRepositoryMockRecorder &#123; return _m.recorder&#125;// Create mocks base methodfunc (_m *MockRepository) Create(_param0 string, _param1 []byte) error &#123; ret := _m.ctrl.Call(_m, &quot;Create&quot;, _param0, _param1) ret0, _ := ret[0].(error) return ret0&#125;... 使用mock对象进行打桩测试导入mock相关的包123456import ( &quot;testing&quot; . &quot;github.com/golang/mock/gomock&quot; &quot;test/mock/db&quot; ...) mock控制器mock控制器通过NewController接口生成，是mock生态系统的顶层控制，它定义了mock对象的作用域和生命周期，以及它们的期望。多个协程同时调用控制器的方法是安全的。当用例结束后，控制器会检查所有剩余期望的调用是否满足条件。 控制器的代码如下所示： 12345678ctrl := NewController(t)defer ctrl.Finish() mock对象创建时需要注入控制器，如果有多个mock对象则注入同一个控制器，如下所示：ctrl := NewController(t)defer ctrl.Finish()mockRepo := mock_db.NewMockRepository(ctrl)mockHttp := mock_api.NewHttpMethod(ctrl) mock对象的行为注入对于mock对象的行为注入，控制器是通过map来维护的，一个方法对应map的一项。因为一个方法在一个用例中可能调用多次，所以map的值类型是数组切片。当mock对象进行行为注入时，控制器会将行为Add。当该方法被调用时，控制器会将该行为Remove。 假设有这样一个场景：先Retrieve领域对象失败，然后Create领域对象成功，再次Retrieve领域对象就能成功。这个场景对应的mock对象的行为注入代码如下所示： 12345678910111213141516171819mockRepo.EXPECT().Retrieve(Any()).Return(nil, ErrAny)mockRepo.EXPECT().Create(Any(), Any()).Return(nil)mockRepo.EXPECT().Retrieve(Any()).Return(objBytes, nil) objBytes是领域对象的序列化结果，比如：obj := Movie&#123;...&#125;objBytes, err := json.Marshal(obj)... 当批量Create对象时，可以使用Times关键字：mockRepo.EXPECT().Create(Any(), Any()).Return(nil).Times(5) 当批量Retrieve对象时，需要注入多次mock行为:mockRepo.EXPECT().Retrieve(Any()).Return(objBytes1, nil)mockRepo.EXPECT().Retrieve(Any()).Return(objBytes2, nil)mockRepo.EXPECT().Retrieve(Any()).Return(objBytes3, nil)mockRepo.EXPECT().Retrieve(Any()).Return(objBytes4, nil)mockRepo.EXPECT().Retrieve(Any()).Return(objBytes5, nil)GoMock的更多用法以及GoStub+GoConvey+GoMock的组合使用方法 Monkey至此，我们已经知道： 1234全局变量可通过GoStub框架打桩过程可通过GoStub框架打桩函数可通过GoStub框架打桩interface可通过GoMock框架打桩 但还有两个问题比较棘手：方法（成员函数）无法通过GoStub框架打桩，当产品代码的OO设计比较多时，打桩点可能离被测函数比较远，导致UT用例写起来比较痛过程或函数通过GoStub框架打桩时，对产品代码有侵入性Monkey是Golang的一个猴子补丁（monkeypatching）框架，在运行时通过汇编语句重写可执行文件，将待打桩函数或方法的实现跳转到桩实现，原理和热补丁类似。通过Monkey，我们可以解决函数或方法的打桩问题，但Monkey不是线程安全的，不要将Monkey用于并发的测试中。 Monkey框架的使用场景很多，依次为： 基本场景：为一个函数打桩基本场景：为一个过程打桩基本场景：为一个方法打桩复合场景：由任意相同或不同的基本场景组合而成特殊场景：桩中桩的一个案例另有GoMonkey框架https://github.com/agiledragon/gomonkey，对比Monkey来说，写法更简单，有兴趣的读者可以尝试使用。 为一个函数打桩Exec是infra层的一个操作函数，实现很简单，代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849func Exec(cmd string, args ...string) (string, error) &#123; cmdpath, err := exec.LookPath(cmd) if err != nil &#123; fmt.Errorf(&quot;exec.LookPath err: %v, cmd: %s&quot;, err, cmd) return &quot;&quot;, infra.ErrExecLookPathFailed &#125; var output []byte output, err = exec.Command(cmdpath, args...).CombinedOutput() if err != nil &#123; fmt.Errorf(&quot;exec.Command.CombinedOutput err: %v, cmd: %s&quot;, err, cmd) return &quot;&quot;, infra.ErrExecCombinedOutputFailed &#125; fmt.Println(&quot;CMD[&quot;, cmdpath, &quot;]ARGS[&quot;, args, &quot;]OUT[&quot;, string(output), &quot;]&quot;) return string(output), nil&#125;Monkey的API非常简单和直接，我们直接看打桩代码：import ( &quot;testing&quot; . &quot;github.com/smartystreets/goconvey/convey&quot; . &quot;github.com/bouk/monkey&quot; &quot;infra/osencap&quot;)const any = &quot;any&quot;func TestExec(t *testing.T) &#123; Convey(&quot;test has digit&quot;, t, func() &#123; Convey(&quot;for succ&quot;, func() &#123; outputExpect := &quot;xxx-vethName100-yyy&quot; guard := Patch( osencap.Exec, func(_ string, _ ...string) (string, error) &#123; return outputExpect, nil &#125;) defer guard.Unpatch() output, err := osencap.Exec(any, any) So(output, ShouldEqual, outputExpect) So(err, ShouldBeNil) &#125;) &#125;)&#125;Patch是Monkey提供给用户用于函数打桩的API：第一个参数是目标函数的函数名第二个参数是桩函数的函数名，习惯用法是匿名函数或闭包返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁 为一个过程打桩当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。我们对过程DestroyResource的打桩代码为： 1234guard := Patch(DestroyResource, func(_ string) &#123;&#125;)defer guard.Unpatch() 为一个方法打桩当微服务有多个实例时，先通过Etcd选举一个Master实例，然后Master实例为所有实例较均匀的分配任务，并将任务分配结果Set到Etcd，最后Master和Node实例Watch到任务列表，并过滤出自身需要处理的任务列表。 我们用类Etcd的方法Get来模拟获取任务列表的功能，入参为instanceId： 12345678910111213141516171819202122232425type Etcd struct &#123;&#125;func (e *Etcd) Get(instanceId string) []string &#123; taskList := make([]string, 0) ... return taskList我们对Get方法的打桩代码如下：var e *Etcdguard := PatchInstanceMethod( reflect.TypeOf(e), &quot;Get&quot;, func(_ *Etcd, _ string) []string &#123; return []string&#123;&quot;task1&quot;, &quot;task5&quot;, &quot;task8&quot;&#125; &#125;)defer guard.Unpatch() PatchInstanceMethod API是Monkey提供给用户用于方法打桩的API：在使用前，先要定义一个目标类的指针变量x第一个参数是reflect.TypeOf(x)第二个参数是字符串形式的函数名返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁Monkey的更多用法以及Monkey和前几种框架的组合使用方法 Mock场景最佳实践实例函数Mock：MonkeyMonkey用于对依赖的函数进行Mock替换，从而可以完成仅针对当前模块的单元测试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758例子：test包是真实的函数mock_test包是即将用于mock的函数test.go:package testimport &quot;fmt&quot;func PrintAdd(a, b uint32) string &#123; return fmt.Sprintf(&quot;a:%v+b:%v&quot;, a, b)&#125;type SumTest struct &#123;&#125;func (*SumTest)PrintSum(a, b uint32) string &#123; return fmt.Sprintf(&quot;a:%v+b:%v&quot;, a, b)&#125;mock_test.go:package mock_testimport &quot;fmt&quot;import &quot;test/24_mock/test&quot;func PrintAdd(a, b uint32) string &#123; return fmt.Sprintf(&quot;a:%v+b:%v=%v&quot;, a, b, a+b)&#125;//对应test文件夹下的PrintSumfunc PrintSum(_ *test.SumTest, a, b uint32) string &#123; return fmt.Sprintf(&quot;a:%v+b:%v=%v&quot;, a, b,a+b)&#125;main.go:func test1() &#123; monkey.Patch(test.PrintAdd, mock_test.PrintAdd) p := test.PrintAdd(1, 2) fmt.Println(p) monkey.UnpatchAll() //解除所有替换 p = test.PrintAdd(1, 2) fmt.Println(p)&#125;func test2() &#123; structSum := &amp;test.SumTest&#123;&#125; //para1:获取实例的反射类型,para2:被替换的方法名,para3:替换方法 monkey.PatchInstanceMethod(reflect.TypeOf(structSum), &quot;PrintSum&quot;, mock_test.PrintSum) p := structSum.PrintSum(1, 2) fmt.Println(p) monkey.UnpatchAll() //解除所有替换 p = structSum.PrintSum(1, 2) fmt.Println(p)&#125; 未实现函数Mock：GoMock假设场景：Company公司、Person人。 公司可以开会。公司内部的人继承了Talker讨论者接口，拥有SayHello说话的方法。 假如现在要测试这个场景，在所有类都实现的情况下，测试应该是这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//正常测试func TestCompany_Meeting(t *testing.T) &#123;//直接调用Person类的New方法，创建一个Person对象 talker := NewPerson(&quot;小微&quot;, &quot;语音服务助手&quot;) company := NewCompany(talker) t.Log(company.Meeting(&quot;lyt&quot;, &quot;intern&quot;))&#125; 但现在Person类并未实现，则可以通过GoMock工具来模拟一个Person对象。 定义一个Talker.gopackage pojotype Talker interface &#123; SayHello(word, role string) (response string)&#125;根据该接口，用mockgen命令生成一个Mock对象mockgen [-source] [-destination] [-package] ... Talker.go 接着进行测试用例的编写：NewController(): 新建Mock控制器NewMockXXX(): 新建Mock对象，这里是调用NewMockTalker()talker.EXPECT().XXX().XXX()..：撰写一些断言测试之前Mock建立的对象传入到待测方法当中测试结果通过testing框架返回//通过Mock测试func TestCompany_Meeting2(t *testing.T) &#123; //新建Mock控制器 ctrl := gomock.NewController(t) //新建Mock对象-Talker talker := mock_pojo.NewMockTalker(ctrl) //断言 talker.EXPECT().SayHello(gomock.Eq(&quot;震天嚎&quot;), gomock.Eq(&quot;学生&quot;)).Return(&quot;Hello Faker(身份：学生), welcome to GoLand IDE. My name is 震天嚎&quot;) //mock对象传入方法 company := NewCompany(talker) //Pass的例子 t.Log(company.Meeting(&quot;震天嚎&quot;, &quot;学生&quot;)) //报错的例子 //t.Log(company.Meeting(&quot;小白&quot;, &quot;学生&quot;))&#125; 系统内置函数Mock：Monkey1234567891011121314monkey.Patch(json.Unmarshal, mockUnmarshal)，用Monkey的patch来mock系统内置函数func mockUnmarshal(b []byte, v interface&#123;&#125;) error&#123; v = &amp;Common.LoginMessage&#123; UserId: 1, UserName: &quot;admin&quot;, UserPwd: &quot;admin&quot;, &#125; return nil&#125;如果需要取消替换，可以使用monkey.UnPatch(target interface&#123;&#125;) //解除单个Patchmonkey.UnPatchAll() //解除所有Patch 数据库行为Mock：sqlmock1234567891011121314151617181920212223242526func TestSql(t *testing.T) &#123; db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual)) if err != nil &#123; fmt.Println(&quot;fail to open sqlmock db: &quot;, err) &#125; defer db.Close() rows := sqlmock.NewRows([]string&#123;&quot;id&quot;, &quot;pwd&quot;&#125;). AddRow(1, &quot;apple&quot;). AddRow(2, &quot;banana&quot;) mock.ExpectQuery(&quot;SELECT id, pwd FROM users&quot;).WillReturnRows(rows) res, err := db.Query(&quot;SELECT id, pwd FROM users&quot;) if err != nil &#123; fmt.Println(&quot;fail to match expected sql.&quot;) return &#125; defer res.Close() for res.Next() &#123; var id int var pwd string res.Scan(&amp;id, &amp;pwd) fmt.Printf(&quot;Sql Result:\\tid = %d, password = %s.\\n&quot;,id, pwd) &#125; if res.Err() != nil &#123; fmt.Println(&quot;Result Return Error!&quot;, res.Err()) &#125;&#125; 服务器行为Mock：httptest使用net&#x2F;http&#x2F;httptest模拟服务器行为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586func TestHttp(t *testing.T) &#123; handler := func(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, &quot;&#123; \\&quot;status\\&quot;: \\&quot;expected service response\\&quot;&#125;&quot;) &#125; req := httptest.NewRequest(&quot;GET&quot;, &quot;https://test.net&quot;, nil) w := httptest.NewRecorder() handler(w, req)//处理该Request resp := w.Result() body, _ := ioutil.ReadAll(resp.Body) fmt.Println(resp.StatusCode) fmt.Println(resp.Header.Get(&quot;Content-Type&quot;)) fmt.Println(string(body))&#125; 这里只使用了Monkey的Patch进行简单测试，但在更一般的情况下，更多的函数还是通过实例函数来编写的，对这部分函数要用PatchInstanceMethod才可以进行替换。`func PatchInstanceMethod(target reflect.Type, methodName string, replacement interface&#123;&#125;)`接收三个参数：reflect.Tpye通过新建一个待测实例对象，调用reflect包的TypeOf()方法就可以得到methodName是待测实例对象的函数名replacement是用于替换的函数实现如下：var ts *utils.Transfermonkey.PatchInstanceMethod(reflect.TypeOf(ts), &quot;WritePkg&quot;, func(_ *utils.Transfer, _ []byte) error &#123; return nil&#125;)假设有如下一个函数ServerProcessLogin，用于接收用户名密码，向当前连接的服务器请求登陆，测试如下：func TestServerProcessLogin(t *testing.T) &#123; mess := &amp;Common.Message&#123; Type: Common.LoginMesType, Data: &quot;default&quot;, &#125; user := &amp;UserProcess&#123; Conn: nil, &#125; //对涉及到的单元以外系统函数打Patch monkey.Patch(json.Unmarshal, mockUnmarshal) monkey.Patch(json.Marshal, mockMarshal) //单元测试不涉及实际服务器，故对实例函数Login，WritePkg打Patch var udao *model.UserDao monkey.PatchInstanceMethod(reflect.TypeOf(udao), &quot;Login&quot;, func(_ *model.UserDao, _ int, _ string) (*Common.User,error) &#123; return &amp;Common.User&#123; UserId: 1, UserName: &quot;admin&quot;, UserPwd: &quot;admin&quot;, &#125;, nil &#125;) var ts *utils.Transfer monkey.PatchInstanceMethod(reflect.TypeOf(ts),&quot;WritePkg&quot;, func(_ *utils.Transfer, _ []byte) error &#123; return nil &#125;) //执行测试 convey.Convey(&quot;Test Server Login.&quot;, t, func() &#123; err := user.ServerProcessLogin(mess) convey.So(err, convey.ShouldBeNil) &#125;) monkey.UnpatchAll() return&#125;//用于替换的函数func mockUnmarshal(b []byte, v interface&#123;&#125;) error&#123; v = &amp;Common.LoginMessage&#123; UserId: 1, UserName: &quot;admin&quot;, UserPwd: &quot;admin&quot;, &#125; return nil&#125;func mockMarshal(v interface&#123;&#125;) ([]byte, error) &#123; var rer = []byte&#123; &#x27;a&#x27;,&#x27;d&#x27;,&#x27;m&#x27;,&#x27;i&#x27;,&#x27;n&#x27;, &#125; return rer, nil&#125; 具体案例：聊天室概览该项目是一个具有登录、查看在线用户、私聊、群聊等功能的命令行聊天室Demo。 项目分为Client、Server子项目，都通过model、Controllor(Processor）、View（Main）来进行功能划分。还有一个Common包放置通用性的工具类。 1234567891011├─Client│ ├─main│ ├─model│ ├─processor│ └─utils├─Common└─Server ├─main ├─model ├─processor └─utils 预期目的：对实现的功能模块补充单元测试代码，度量确保每一个模块的功能的正确性、完整性、健壮性，并在未来修改代码后也能第一时间自测验收。 单元测试应包括模块接口测试、模块局部数据结构测试、模块异常处理测试。 对于接口测试，应对接口的传入参数测试样例设计进行全面的考察，判断每一个参数是否有是有必要的，参数间有没有冗余，进入函数体前引用的指针是否有错等等。 对于局部数据结构测试，应检查局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整性、正确性。局部数据结构往往是错误的根源，应仔细设计测试用例。 对于异常处理，主要有如下几种常见错误 输出的出错信息提示不足 对异常没有进行处理 出错信息与实际不相符 出错信息中未能准确定位出错信息 以上几种错误，都是模块中经常会出现的错误，要针对这些错误来进行边界条件测试检查，只有异常处理机制正确，日后软件的维护和迭代才会更加高效。 在本案例中，Model层对服务层提供的接口不多，就WritePkg，ReadPkg两个核心函数，在服务层对其进行封装抽象为具体的业务逻辑。由于涉及网络连接，所以对其进行的测试必须编写桩函数。在服务层，涉及到对多个网络连接调用、数据库调用其它模块依赖，所以也要为其进行Mock。 由于涉及Mock和桩函数编写，可以使用GoStub、Monkey两个包进行这些工作，它们较简洁地实现了很多实用的测试方式，只需要用户编写依赖的接口文件、用于替换的Mock函数，就可以仅在测试过程中替换掉系统函数或者其它依赖的功能模块，使得单元测试起到它应有的作用。 Model层、数据库相关测试由于是单元测试，所以需要获取一个Mock数据库实例，测试增删改查SQL语句是否可执行。userDao_test.go代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const ( sql1 = &quot;SELECT id, pwd FROM users&quot; sql2 = &quot;DELETE FROM users where id &gt; 600 and id &lt; 700&quot; sql3 = &quot;update users set pwd = newPwd where id = 1 and id = 2&quot; sql4 = &quot;INSERT INTO users (id, pwd) VALUES (405, &#x27;Lyt&#x27;)&quot;)func TestGetUserById(t *testing.T) &#123; db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual)) if err != nil &#123; fmt.Println(&quot;fail to open sqlmock db: &quot;, err) &#125; defer db.Close() rows1 := sqlmock.NewRows([]string&#123;&quot;id&quot;, &quot;pwd&quot;&#125;). AddRow(1, &quot;apple&quot;). AddRow(2, &quot;banana&quot;) rows2 := sqlmock.NewRows([]string&#123;&quot;id&quot;, &quot;pwd&quot;&#125;). AddRow(601, &quot;goland&quot;). AddRow(602, &quot;java&quot;) rows3 := sqlmock.NewRows([]string&#123;&quot;id&quot;, &quot;pwd&quot;&#125;). AddRow(1, &quot;newPwd&quot;). AddRow(2, &quot;newPwd&quot;) rows4 := sqlmock.NewRows([]string&#123;&quot;id&quot;, &quot;pwd&quot;&#125;). AddRow(405, &quot;Lyt&quot;) mock.ExpectQuery(sql1).WillReturnRows(rows1) mock.ExpectQuery(sql2).WillReturnRows(rows2) mock.ExpectQuery(sql3).WillReturnRows(rows3) mock.ExpectQuery(sql4).WillReturnRows(rows4) assert.New(t) var tests = []struct&#123; inputSql string expected interface&#123;&#125; &#125; &#123; &#123;sql1,nil&#125;, &#123;sql2,nil&#125;, &#123;sql3,nil&#125;, &#123;sql4, nil&#125;, &#125; for _, test := range tests &#123; res, err := db.Query(test.inputSql) assert.Equal(t, err, test.expected) for res.Next() &#123; var id int var pwd string res.Scan(&amp;id, &amp;pwd) fmt.Printf(&quot;Sql Result:\\tid = %d, password = %s.\\n&quot;,id, pwd) &#125; assert.Equal(t, res.Err(), test.expected) &#125;&#125; 私聊功能测试由于涉及底层数据库交互时需要发送JSON转码字符串（WritePkg函数），因此将其Mock处理，只需关注本函数逻辑是否正确即可。smsProcess_test.go如下： 1234567891011121314func TestSmsProcess_SendOnePerson(t *testing.T) &#123; var conn net.Conn tf := &amp;utils.Transfer&#123; Conn: conn, &#125; monkey.PatchInstanceMethod(reflect.TypeOf(tf), &quot;WritePkg&quot;, func(_ *utils.Transfer,_ []byte) error&#123; return nil &#125;) convey.Convey(&quot;test send one person:&quot;, t, func() &#123; err := tf.WritePkg([]byte&#123;&#125;) convey.So(err, convey.ShouldBeNil) fmt.Println(&quot;OK.&quot;) &#125;)&#125; 登录功能测试登录涉及服务器连接操作，服务器的连接逻辑可通过httptest包来进行检测，Mock一个HTTP连接，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970func TestHttp(t *testing.T) &#123; handler := func(w http.ResponseWriter, r *http.Request) &#123; // here we write our expected response, in this case, we return a // JSON string which is typical when dealing with REST APIs io.WriteString(w, &quot;&#123; \\&quot;status\\&quot;: \\&quot;expected service response\\&quot;&#125;&quot;) &#125; req := httptest.NewRequest(&quot;GET&quot;, &quot;https://test.net&quot;, nil) w := httptest.NewRecorder() handler(w, req) resp := w.Result() body, _ := ioutil.ReadAll(resp.Body) fmt.Println(resp.StatusCode) fmt.Println(resp.Header.Get(&quot;Content-Type&quot;)) fmt.Println(string(body))&#125; 为登录模块编写用于测试替换的函数以及单元测试主体，userProcess_test.go代码如下：func mockUnmarshal(b []byte, v interface&#123;&#125;) error &#123; v = &amp;Common.LoginMessage&#123; UserId: 1, UserName: &quot;admin&quot;, UserPwd: &quot;admin&quot;, &#125; return nil&#125;func mockMarshal(v interface&#123;&#125;) ([]byte, error) &#123; var rer = []byte&#123; &#x27;a&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#125; return rer, nil&#125;func TestServerProcessLogin(t *testing.T) &#123; mess := &amp;Common.Message&#123; Type: Common.LoginMesType, Data: &quot;default&quot;, &#125; user := &amp;UserProcess&#123; Conn: nil, &#125; //对涉及到的单元以外系统函数打Patch monkey.Patch(json.Unmarshal, mockUnmarshal) monkey.Patch(json.Marshal, mockMarshal) //对实例函数打Patch var udao *model.UserDao monkey.PatchInstanceMethod(reflect.TypeOf(udao), &quot;Login&quot;, func(_ *model.UserDao, _ int, _ string) (*Common.User, error) &#123; return &amp;Common.User&#123; UserId: 1, UserName: &quot;admin&quot;, UserPwd: &quot;admin&quot;, &#125;, nil &#125;) var ts *utils.Transfer monkey.PatchInstanceMethod(reflect.TypeOf(ts), &quot;WritePkg&quot;, func(_ *utils.Transfer, _ []byte) error &#123; return nil &#125;) //执行测试 convey.Convey(&quot;Test Server Login.&quot;, t, func() &#123; err := user.ServerProcessLogin(mess) convey.So(err, convey.ShouldBeNil) &#125;) monkey.UnpatchAll() return&#125; 工具类测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960utils_test.gofunc mockRead(conn net.Conn, _ []byte) (int, error) &#123; return 4, nil&#125;func mockMarshal(v interface&#123;&#125;) ([]byte, error) &#123; return []byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;, nil&#125;func mockUnmarshal(data []byte, v interface&#123;&#125;) error &#123; return nil&#125;func TestTransfer_ReadPkg(t *testing.T) &#123; monkey.Patch(net.Conn.Read, mockRead) monkey.Patch(json.Marshal, mockMarshal) monkey.Patch(json.Unmarshal, mockUnmarshal) listen, _ := net.Listen(&quot;tcp&quot;, &quot;localhost:8888&quot;) defer listen.Close() go net.Dial(&quot;tcp&quot;, &quot;localhost:8888&quot;) var c net.Conn for &#123; c, _ = listen.Accept() if c != nil &#123; break &#125; &#125; transfer := &amp;Transfer&#123; Conn: c, Buf : [8096]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;, &#125; convey.Convey(&quot;test ReadPkg&quot;, t, func() &#123; mes, err := transfer.ReadPkg() convey.So(err, convey.ShouldBeNil) convey.So(mes, convey.ShouldEqual, &quot;ab&quot;) &#125;) monkey.UnpatchAll()&#125;func TestTransfer_WritePkg(t *testing.T) &#123; monkey.Patch(json.Marshal, mockMarshal) monkey.Patch(json.Unmarshal, mockUnmarshal) transfer := &amp;Transfer&#123; Conn: nil, Buf : [8096]byte&#123;&#125;, &#125; convey.Convey(&quot;test ReadPkg&quot;, t, func() &#123; err := transfer.WritePkg([]byte&#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;) convey.So(err, convey.ShouldBeNil) &#125;) monkey.UnpatchAll()&#125; 项目总结在编写桩模块时会发现，模块之间的调用关系在工程规模并不大的本案例中，也依然比较复杂，需要开发相应桩函数，代码量会增加许多，也会消耗一些开发人员的时间，因此反推到之前流程的开发实践中，可以得出结论就是提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。 Go单元测试框架是相当易用的，其它的第三方库基本都是建立在testing原生框架的基础上进行的增补扩充，在日常开发中，原生包可以满足基本需求，但同样也有缺陷，原生包不提供断言的语法使得代码中的这种片段非常多： 123if err != nil&#123; //...&#125; 所以引入了convey、assert包的断言语句，用于简化判断逻辑，使得程序更加易读。 在完成项目单测时，遇到了不少问题，比较重要的比如由于架构分层不够清晰，还是有部分耦合代码，导致单测时需要屏蔽的模块太多，代码写起来不便。因此还是需要倒推到开发模块之前，就要设计更好的结构，在开发的过程中遵循相应的规则，通过测试先行的思想，使开发的工程具有更好的可测试性。 开发过程中遇到的场景肯定不局限于本文所讨论的范围，有关更丰富的最佳实践案例可以参照： go-sqlmockgo-mock 结语实践小结 单元测试大多是由开发人员进行编写，本篇文章旨在指引，不在于面面俱到，具体的单元测试框架的使用语法，开发同学可以自行Google。 以测试的角度，推行单元测试是不易的，最佳的方式莫过于开发人员，在一定的指引之后，以实际项目出发进行实践，然后自行总结具体的case，有针对性、有感染力进行内部分享，测试同学及时提供测试用例的指引和规范的约束。 基于interface的mock是最佳实践。《单元测试的艺术》有讲，作者经验很丰富。google认为单测的核心轮子就是mock技术和测试运行框架。golang自带运行框架，官方直接搞个gomock补全了两个核心。gomock对expect，而且支持expect几次，等等细节的支持，功能强大。 Table-Driven是最佳实践。测试还小的时候，直接gotests生成。挺好。被测数据空间大，就把被测数据放进testdata。gotests+convey，我认为是最佳实践。 推荐阅读书籍《google的软件测试之道》书籍《单元测试的艺术》","raw":"---\ntitle: Go-单测\ntoc: true\ndate: 2022-11-04 18:55:50\ntags: [单测,go]\ncategories: [技术]\ndescription: 如何做单元测试-Golang\n---\n\n单测系列-Go\n本文整理学习Go单测相关内容\n总结在Go中如何做单测，本文介绍了单测是什么以及Go常用的单测框架和工具\n<!-- more -->\n\n## 单元测试\n\n### 单元测试是什么\n单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、超类、抽象类等中的方法。单元测试就是软件开发中对最小单位进行正确性检验的测试工作。\n\n不同地方对单元测试有的定义可能会有所不同，但有一些基本共识：\n\n单元测试是比较底层的，关注代码的局部而不是整体。\n单元测试是开发人员在写代码时候写的。\n单元测试需要比其他测试运行得快。\n\n### 单元测试的意义\n提高代码质量。代码测试都是为了帮助开发人员发现问题从而解决问题，提高代码质量。\n尽早发现问题。问题越早发现，解决的难度和成本就越低。\n保证重构正确性。随着功能的增加，重构（修改老代码）几乎是无法避免的。很多时候我们不敢重构的原因，就是担心其它模块因为依赖它而不工作。有了单元测试，只要在改完代码后运行一下单测就知道改动对整个系统的影响了，从而可以让我们放心的重构代码。\n简化调试过程。单元测试让我们可以轻松地知道是哪一部分代码出了问题。\n简化集成过程。由于各个单元已经被测试，在集成过程中进行的后续测试会更加容易。\n优化代码设计。编写测试用例会迫使开发人员仔细思考代码的设计和必须完成的工作，有利于开发人员加深对代码功能的理解，从而形成更合理的设计和结构。\n单元测试是最好的文档。单元测试覆盖了接口的所有使用方法，是最好的示例代码。而真正的文档包括注释很有可能和代码不同步，并且看不懂。\n \n\n### 单元测试用例编写的原则\n#### 理论原则\n快。单元测试是回归测试，可以在开发过程的任何时候运行，因此运行速度必须快\n一致性。代码没有改变的情况下，每次运行得结果应该保持确定且一致\n原子性。结果只有两种情况：Pass / Fail\n用例独立。执行顺序不影响；用例间没有状态共享或者依赖关系；用例没有副作用（执行前后环境状态一致）\n单一职责。一个用例只负责一个场景\n隔离。功能可能依赖于数据库、web访问、环境变量、系统时间等；一个单元可能依赖于另一部分代码，用例应该解除这些依赖\n可读性。用例的名称、变量名等应该具有可读性，直接表现出该测试的目标\n自动化。单元测试需要全自动执行。测试程序不应该有用户输入；测试结果应该能直接被电脑获取，不应该由人来判断。\n#### 规约原则\n在实际编写代码过程中，不同的团队会有不同团队的风格，只要团队内部保持有一定的规约即可，比如：\n\n单元测试文件名必须以xxx_test.go命名\n方法必须是TestXxx开头，建议风格保持一致（驼峰或者下划线）\n方法参数必须 t *testing.T\n测试文件和被测试文件必须在一个包中\n#### 衡量原则\n　　单元测试是要写额外的代码的，这对开发同学的也是一个不小的工作负担，在一些项目中，我们合理的评估单元测试的编写，我认为我们不能走极端，当然理论上来说全写肯定时好的，但是从成本，效率上来说我们必须做出权衡，衡量原则如下：\n\n优先编写核心组件和逻辑模块的测试用例\n逻辑类似的组件如果存在多个，优先编写其中一种逻辑组件的测试用例\n发现Bug时一定先编写测试用例进行Debug\n关键util工具类要编写测试用例，这些util工具适用的很频繁，所以这个原则也叫做热点原则，和第1点相呼应。\n测试用户应该独立，一个文件对应一个，而且不同的测试用例之间不要互相依赖。\n测试用例的保持更新\n \n\n### 单元测试用例设计方法\n#### 规范(规格)导出法\n规范(规格)导出法将需求”翻译“成测试用例。\n\n```\n例如，一个函数的设计需求如下：\n\n函数：一个计算平方根的函数\n输入： 实数\n输出： 实数\n要求： 当输入一个0或者比0大的实数时，返回其正的平方根；当输入一个小于0的实数时，显示错误信息“平方根非法—输入之小于0”，并返回0；库函数printf()可以用来输出错误信息。\n```\n\n在这个规范中有3个陈述，可以用两个测试用例来对应:\n\n测试用例1：输入4，输出2。\n测试用例2：输入-1，输出0。\n#### 等价类划分法\n等价类划分法假定某一特定的等价类中的所有值对于测试目的来说是等价的，所以在每个等价类中找一个之作为测试用例。\n\n按照 [输入条件][有效等价类][无效等价类] 建立等价类表，列出所有划分出的等价类\n为每一个等价类规定一个唯一的编号\n设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类。重复这一步，直到所有的有效等价类都被覆盖为止\n设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，直到所有的无效等价类都被覆盖为止\n例如，注册邮箱时要求用6~18个字符，可使用字母、数字、下划线，需以字母开头。\n\n| 有效等价类          | 无效等价类                                      |\n|----------------|--------------------------------------------|\n| 6~18个字符（1）     | 少于6个字符（2）<br>多余18个字符（3）<br>空（4）            |\n| 包含字母、数字、下划线（5） | 除字母、数字、下划线的特殊字符（6）<br>非打印字符（7）<br>中文字符 （8） |\n| 以字母开头（9）\t      | 以数字或下划线开头（10）                              |\n\n测试用例：\n\n| 编号  | 输入数据                  | 覆盖等价类        | 预期结果 |\n|-----|-----------------------|--------------|------|\n| 1   | test_111              | （1）、（5）、（9）  | 合法输入 |\n| 2   | t_11                  | （2）、（5）、（9）  | 非法输入 |\n| 3   | testtesttest_12345678 | （3）、（5）、（9）  | 非法输入 |\n| 4   | NULL                  | （4）          | 非法输入 |\n| 5   | test!@1111            | （1）、（6）、（9）  | 非法输入 |\n| 6   | test 1111             | （1）、（7）、（9）  | 非法输入 |\n| 7   | test测试1111            | （1）、（8）、（9）  | 非法输入 |\n| 8   | _test111              | （1）、（5）、（10） | 非法输入 |\n\n\n#### 边界值分析法\n边界值分析法使用与等价类测试方法相同的等价类划分，只是边界值分析假定\n错误更多地存在于两个划分的边界上。\n\n边界值测试在软件变得复杂的时候也会变得不实用。边界值测试对于非向量类型的值(如枚举类型的值)也没有意义。\n\n例如，和4.1相同的需求：\n划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0。由此得到以下测试用例：\n\n- 输入 {最小负实数}\n- 输入 {绝对值很小的负数}\n- 输入 0\n- 输入 {绝对值很小的正数}\n- 输入 {最大正实数}\n\n#### 基本路径测试法\n基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。\n\n基本路径测试法的基本步骤：\n\n程序的控制流图：描述程序控制流的一种图示方法。\n- 程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。\n- 导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。\n- 准备测试用例：确保基本路径集中的每一条路径的执行。\n \n\n## Golang的测试框架\nGolang有这几种比较常见的测试框架\n\n```\n测试框架\t推荐指数\nGo自带的testing包\t★★★☆☆\nGoConvey\t★★★★★\ntestify\t★★★☆☆\n```\n\n从测试用例编写的简易难度上来说：testify 比 GoConvey 简单；GoConvey比Go自带的testing包简单。\n但在测试框架的选择上，我们更推荐GoConvey。因为：\n\nGoConvey和其他Stub/Mock框架的兼容性相比Testify更好。\nTestify自带Mock框架，但是用这个框架Mock类需要自己写。像这样重复有规律的部分在GoMock中是一键自动生成的。\n### Go自带的testing包\n　　testing 为 Go 语言 package 提供自动化测试的支持。通过 go test 命令，能够自动执行如下形式的任何函数：\n\nfunc TestXxx(*testing.T)\n　　注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。\n\n　　在这些函数中，使用 Error、Fail 或相关方法来发出失败信号。\n\n　　要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 TestXxx 函数，如上所述。 将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 go test 命令时将被包含。 有关详细信息，请运行 go help test 和 go help testflag 了解。\n\n#### 第一个例子\n```go\n被测代码：\n\nfunc Fib(n int) int {\n        if n < 2 {\n                return n\n        }\n        return Fib(n-1) + Fib(n-2)\n}\n测试代码：\n\nfunc TestFib(t *testing.T) {\n    var (\n        in       = 7\n        expected = 13\n    )\n    actual := Fib(in)\n    if actual != expected {\n        t.Errorf(\"Fib(%d) = %d; expected %d\", in, actual, expected)\n    }\n}\n执行 go test . ，输出：\n\n$ go test .\nok      chapter09/testing    0.007s\n表示测试通过。\n我们将 Fib 函数改为：\n\nfunc Fib(n int) int {\n        if n < 2 {\n                return n\n        }\n        return Fib(n-1) + Fib(n-1)\n}\n再执行 go test . ，输出：\n\n$ go test .\n--- FAIL: TestFib (0.00s)\n    t_test.go:16: Fib(10) = 64; expected 13\nFAIL\nFAIL    chapter09/testing    0.009s\n```\n\n#### Table-Driven测试\nTable-Driven 的方式将多个case在同一个测试函数中测到：\n```go\nfunc TestFib(t *testing.T) {\n   var fibTests = []struct {\n       in       int // input\n       expected int // expected result\n   }{\n       {1, 1},\n       {2, 1},\n       {3, 2},\n       {4, 3},\n       {5, 5},\n       {6, 8},\n       {7, 13},\n   }\n\n   for _, tt := range fibTests {\n       actual := Fib(tt.in)\n       if actual != tt.expected {\n           t.Errorf(\"Fib(%d) = %d; expected %d\", tt.in, actual, tt.expected)\n       }\n   }\n}\n```\nGo自带testing包的更多用法\n\n### GoConvey：简单断言\nConvey适用于书写单元测试用例，并且可以兼容到testing框架中，go test命令或者使用goconvey命令访问localhost:8080的Web测试界面都可以查看测试结果。\n```go\nConvey(\"Convey return : \", t, func() {\n        So(...)\n}) \n```\n一般Convey用So来进行断言，断言的方式可以传入一个函数，或者使用自带的ShouldBeNil、ShouldEqual、ShouldNotBeNil函数等。\n\n#### 基本用法\n被测代码：\n```go\nfunc StringSliceEqual(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n\n    if (a == nil) != (b == nil) {\n        return false\n    }\n\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}\n测试代码\n\nimport (\n    \"testing\"\n    . \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc TestStringSliceEqual(t *testing.T) {\n    Convey(\"TestStringSliceEqual的描述\", t, func() {\n        a := []string{\"hello\", \"goconvey\"}\n        b := []string{\"hello\", \"goconvey\"}\n        So(StringSliceEqual(a, b), ShouldBeTrue)\n    })\n}\n```\n\n#### 双层嵌套\n```go\nimport (\n    \"testing\"\n    . \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc TestStringSliceEqual(t *testing.T) {\n    Convey(\"TestStringSliceEqual\", t, func() {\n        Convey(\"true when a != nil  && b != nil\", func() {\n            a := []string{\"hello\", \"goconvey\"}\n            b := []string{\"hello\", \"goconvey\"}\n            So(StringSliceEqual(a, b), ShouldBeTrue)\n        })\n\n        Convey(\"true when a ＝= nil  && b ＝= nil\", func() {\n            So(StringSliceEqual(nil, nil), ShouldBeTrue)\n        })\n    })\n}\n内层的Convey不需要再传入t *testing.T参数\n```\n\nGoConvey的更多用法\n\n### testify\ntestify提供了assert和require，让你可以简洁地写出\n```go\nif xxx { t.Fail() }\n```\n\n#### assert\n```go\nfunc TestSomething(t *testing.T) {\n\n  //断言相等\n  assert.Equal(t, 123, 123, \"they should be equal\")\n\n  //断言不相等\n  assert.NotEqual(t, 123, 456, \"they should not be equal\")\n\n  //对于nil的断言\n  assert.Nil(t, object)\n\n  //对于非nil的断言\n  if assert.NotNil(t, object) {\n\t// now we know that object isn't nil, we are safe to make\n\t// further assertions without causing any errors\n\tassert.Equal(t, \"Something\", object.Value)\n  }\n```\n#### require\n　　require和assert失败、成功条件完全一致，区别在于assert只是返回布尔值（true、false），而require不符合断言时，会中断当前运行\n\n#### 常用的函数\n```go\nfunc Equal(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool\nfunc NotEqual(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool\n\nfunc Nil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool\nfunc NotNil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool\n\nfunc Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool\nfunc NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool\n\nfunc NoError(t TestingT, err error, msgAndArgs ...interface{}) bool\nfunc Error(t TestingT, err error, msgAndArgs ...interface{}) bool\n\nfunc Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool\nfunc NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool\n\nfunc True(t TestingT, value bool, msgAndArgs ...interface{}) bool\nfunc False(t TestingT, value bool, msgAndArgs ...interface{}) bool\n\nfunc Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{}) bool\n\nfunc NotContains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool\nfunc NotContains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool\nfunc Subset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool)\nfunc NotSubset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool)\n\nfunc FileExists(t TestingT, path string, msgAndArgs ...interface{}) bool\nfunc DirExists(t TestingT, path string, msgAndArgs ...interface{}) bool\n```\ntestify的更多用法\n\n \n\n## Stub/Mock框架\nGolang有以下Stub/Mock框架：\n```\nGoStub\nGoMock\nMonkey\n```\n一般来说，GoConvey可以和GoStub、GoMock、Monkey中的一个或多个搭配使用。　　\nTestify本身有自己的Mock框架，可以用自己的也可以和这里列出来的Stub/Mock框架搭配使用。\n \n### GoStub\nGoStub框架的使用场景很多，依次为：\n\n基本场景：为一个全局变量打桩\n基本场景：为一个函数打桩\n基本场景：为一个过程打桩\n复合场景：由任意相同或不同的基本场景组合而成\n\n#### 为一个全局变量打桩\n假设num为被测函数中使用的一个全局整型变量，当前测试用例中假定num的值大于100，比如为150，则打桩的代码如下：\n```go\nstubs := Stub(&num, 150)\ndefer stubs.Reset()\n```\nstubs是GoStub框架的函数接口Stub返回的对象，该对象有Reset操作，即将全局变量的值恢复为原值。\n\n#### 为一个函数打桩\n假设我们产品的既有代码中有下面的函数定义：\n```go\nfunc Exec(cmd string, args ...string) (string, error) {\n    ...\n}\n若要想对Exec函数通过GoStub框架打桩，需要将Exec函数定义为匿名函数，同时将它赋值给Exec变量，重构后的代码如下：\n\nvar Exec = func(cmd string, args ...string) (string, error) {\n    ...\n}\n我们可以对Exec函数打桩，代码如下所示：\n\nstubs := StubFunc(&Exec,\"xxx-vethName100-yyy\", nil)\ndefer stubs.Reset()\n```\n\n#### 为一个过程打桩\n当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。\n我们对过程DestroyResource的打桩代码为：\n```go\nstubs := StubFunc(&DestroyResource)\ndefer stubs.Reset()\n```\nGoStub的更多用法以及GoStub+GoConvey的组合使用方法\n\n### GoMock\nGoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的testing包良好集成，也能用于其它的测试环境中。GoMock测试框架包含了GoMock包和mockgen工具两部分，其中GoMock包完成对桩对象生命周期的管理，mockgen工具用来生成interface对应的Mock类源文件。\n\n#### 定义一个接口\n我们先定义一个打算mock的接口Repository。\n\nRepository是领域驱动设计中战术设计的一个元素，用来存储领域对象，一般将对象持久化在数据库中，比如Aerospike，Redis或Etcd等。对于领域层来说，只知道对象在Repository中维护，并不care对象到底在哪持久化，这是基础设施层的职责。微服务在启动时，根据部署参数实例化Repository接口，比如AerospikeRepository，RedisRepository或EtcdRepository。\n```go\npackage db\n\ntype Repository interface {\n    Create(key string, value []byte) error\n    Retrieve(key string) ([]byte, error)\n    Update(key string, value []byte) error\n    Delete(key string) error\n}\n```\n#### 生成mock类文件\n这下该mockgen工具登场了。mockgen有两种操作模式：源文件和反射。\n\n源文件模式通过一个包含interface定义的文件生成mock类文件，它通过 -source 标识生效，-imports 和 -aux_files 标识在这种模式下也是有用的。\n举例：\n```go\nmockgen -source=foo.go [other options]\n　　反射模式通过构建一个程序用反射理解接口生成一个mock类文件，它通过两个非标志参数生效：导入路径和用逗号分隔的符号列表（多个interface）。\n举例：\n\nmockgen database/sql/driver Conn,Driver\n生成的mock_repository.go文件：\n\n// Automatically generated by MockGen. DO NOT EDIT!\n// Source: infra/db (interfaces: Repository)\n\npackage mock_db\n\nimport (\n    gomock \"github.com/golang/mock/gomock\"\n)\n\n// MockRepository is a mock of Repository interface\ntype MockRepository struct {\n    ctrl     *gomock.Controller\n    recorder *MockRepositoryMockRecorder\n}\n\n// MockRepositoryMockRecorder is the mock recorder for MockRepository\ntype MockRepositoryMockRecorder struct {\n    mock *MockRepository\n}\n\n// NewMockRepository creates a new mock instance\nfunc NewMockRepository(ctrl *gomock.Controller) *MockRepository {\n    mock := &MockRepository{ctrl: ctrl}\n    mock.recorder = &MockRepositoryMockRecorder{mock}\n    return mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (_m *MockRepository) EXPECT() *MockRepositoryMockRecorder {\n    return _m.recorder\n}\n\n// Create mocks base method\nfunc (_m *MockRepository) Create(_param0 string, _param1 []byte) error {\n    ret := _m.ctrl.Call(_m, \"Create\", _param0, _param1)\n    ret0, _ := ret[0].(error)\n    return ret0\n}\n...\n```\n\n#### 使用mock对象进行打桩测试\n##### 导入mock相关的包\n```go\nimport (\n    \"testing\"\n    . \"github.com/golang/mock/gomock\"\n    \"test/mock/db\"\n    ...\n)\n```\n##### mock控制器\nmock控制器通过NewController接口生成，是mock生态系统的顶层控制，它定义了mock对象的作用域和生命周期，以及它们的期望。多个协程同时调用控制器的方法是安全的。\n当用例结束后，控制器会检查所有剩余期望的调用是否满足条件。\n\n控制器的代码如下所示：\n```go\nctrl := NewController(t)\ndefer ctrl.Finish()\n　　mock对象创建时需要注入控制器，如果有多个mock对象则注入同一个控制器，如下所示：\n\nctrl := NewController(t)\ndefer ctrl.Finish()\nmockRepo := mock_db.NewMockRepository(ctrl)\nmockHttp := mock_api.NewHttpMethod(ctrl)\n```\n\n##### mock对象的行为注入\n对于mock对象的行为注入，控制器是通过map来维护的，一个方法对应map的一项。因为一个方法在一个用例中可能调用多次，所以map的值类型是数组切片。当mock对象进行行为注入时，控制器会将行为Add。当该方法被调用时，控制器会将该行为Remove。\n\n假设有这样一个场景：先Retrieve领域对象失败，然后Create领域对象成功，再次Retrieve领域对象就能成功。这个场景对应的mock对象的行为注入代码如下所示：\n```go\nmockRepo.EXPECT().Retrieve(Any()).Return(nil, ErrAny)\nmockRepo.EXPECT().Create(Any(), Any()).Return(nil)\nmockRepo.EXPECT().Retrieve(Any()).Return(objBytes, nil)\n　　objBytes是领域对象的序列化结果，比如：\n\nobj := Movie{...}\nobjBytes, err := json.Marshal(obj)\n...\n　　当批量Create对象时，可以使用Times关键字：\n\nmockRepo.EXPECT().Create(Any(), Any()).Return(nil).Times(5)\n　　当批量Retrieve对象时，需要注入多次mock行为:\n\nmockRepo.EXPECT().Retrieve(Any()).Return(objBytes1, nil)\nmockRepo.EXPECT().Retrieve(Any()).Return(objBytes2, nil)\nmockRepo.EXPECT().Retrieve(Any()).Return(objBytes3, nil)\nmockRepo.EXPECT().Retrieve(Any()).Return(objBytes4, nil)\nmockRepo.EXPECT().Retrieve(Any()).Return(objBytes5, nil)\nGoMock的更多用法以及GoStub+GoConvey+GoMock的组合使用方法\n```\n\n## Monkey\n至此，我们已经知道：\n```\n全局变量可通过GoStub框架打桩\n过程可通过GoStub框架打桩\n函数可通过GoStub框架打桩\ninterface可通过GoMock框架打桩\n```\n\n但还有两个问题比较棘手：\n方法（成员函数）无法通过GoStub框架打桩，当产品代码的OO设计比较多时，打桩点可能离被测函数比较远，导致UT用例写起来比较痛\n过程或函数通过GoStub框架打桩时，对产品代码有侵入性\nMonkey是Golang的一个猴子补丁（monkeypatching）框架，在运行时通过汇编语句重写可执行文件，将待打桩函数或方法的实现跳转到桩实现，原理和热补丁类似。通过Monkey，我们可以解决函数或方法的打桩问题，但Monkey不是线程安全的，不要将Monkey用于并发的测试中。\n\nMonkey框架的使用场景很多，依次为：\n\n基本场景：为一个函数打桩\n基本场景：为一个过程打桩\n基本场景：为一个方法打桩\n复合场景：由任意相同或不同的基本场景组合而成\n特殊场景：桩中桩的一个案例\n另有GoMonkey框架https://github.com/agiledragon/gomonkey，对比Monkey来说，写法更简单，有兴趣的读者可以尝试使用。\n### 为一个函数打桩\nExec是infra层的一个操作函数，实现很简单，代码如下所示：\n```go\nfunc Exec(cmd string, args ...string) (string, error) {\n    cmdpath, err := exec.LookPath(cmd)\n    if err != nil {\n        fmt.Errorf(\"exec.LookPath err: %v, cmd: %s\", err, cmd)\n        return \"\", infra.ErrExecLookPathFailed\n    }\n\n    var output []byte\n    output, err = exec.Command(cmdpath, args...).CombinedOutput()\n    if err != nil {\n        fmt.Errorf(\"exec.Command.CombinedOutput err: %v, cmd: %s\", err, cmd)\n        return \"\", infra.ErrExecCombinedOutputFailed\n    }\n    fmt.Println(\"CMD[\", cmdpath, \"]ARGS[\", args, \"]OUT[\", string(output), \"]\")\n    return string(output), nil\n}\nMonkey的API非常简单和直接，我们直接看打桩代码：\n\nimport (\n    \"testing\"\n    . \"github.com/smartystreets/goconvey/convey\"\n    . \"github.com/bouk/monkey\"\n    \"infra/osencap\"\n)\n\nconst any = \"any\"\n\nfunc TestExec(t *testing.T) {\n    Convey(\"test has digit\", t, func() {\n        Convey(\"for succ\", func() {\n            outputExpect := \"xxx-vethName100-yyy\"\n            guard := Patch(\n            \tosencap.Exec, \n            \tfunc(_ string, _ ...string) (string, error) {\n                \treturn outputExpect, nil\n            \t})\n            defer guard.Unpatch()\n            output, err := osencap.Exec(any, any)\n            So(output, ShouldEqual, outputExpect)\n            So(err, ShouldBeNil)\n        })\n    })\n}\nPatch是Monkey提供给用户用于函数打桩的API：\n\n第一个参数是目标函数的函数名\n第二个参数是桩函数的函数名，习惯用法是匿名函数或闭包\n返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁\n\n```\n\n### 为一个过程打桩\n当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。\n我们对过程DestroyResource的打桩代码为：\n```go\nguard := Patch(DestroyResource, func(_ string) {\n\n})\ndefer guard.Unpatch()\n```\n\n### 为一个方法打桩\n当微服务有多个实例时，先通过Etcd选举一个Master实例，然后Master实例为所有实例较均匀的分配任务，并将任务分配结果Set到Etcd，最后Master和Node实例Watch到任务列表，并过滤出自身需要处理的任务列表。\n\n我们用类Etcd的方法Get来模拟获取任务列表的功能，入参为instanceId：\n```go\ntype Etcd struct {\n\n}\n\nfunc (e *Etcd) Get(instanceId string) []string {\n    taskList := make([]string, 0)\n    ...\n    return taskList\n我们对Get方法的打桩代码如下：\n\nvar e *Etcd\nguard := PatchInstanceMethod(\n\treflect.TypeOf(e), \n\t\"Get\", \n\tfunc(_ *Etcd, _ string) []string {\n\t\treturn []string{\"task1\", \"task5\", \"task8\"}\n\t})\ndefer guard.Unpatch()\n　　PatchInstanceMethod API是Monkey提供给用户用于方法打桩的API：\n\n在使用前，先要定义一个目标类的指针变量x\n第一个参数是reflect.TypeOf(x)\n第二个参数是字符串形式的函数名\n返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁\nMonkey的更多用法以及Monkey和前几种框架的组合使用方法\n```\n \n\n## Mock场景最佳实践\n### 实例函数Mock：Monkey\nMonkey用于对依赖的函数进行Mock替换，从而可以完成仅针对当前模块的单元测试。\n```go\n例子：\n\ntest包是真实的函数\nmock_test包是即将用于mock的函数\n\ntest.go:\n\npackage test\n\nimport \"fmt\"\n\nfunc PrintAdd(a, b uint32) string {\n return fmt.Sprintf(\"a:%v+b:%v\", a, b)\n}\n\n\ntype SumTest struct {\n}\n\nfunc (*SumTest)PrintSum(a, b uint32) string {\n return fmt.Sprintf(\"a:%v+b:%v\", a, b)\n}\nmock_test.go:\n\npackage mock_test\n\nimport \"fmt\"\nimport \"test/24_mock/test\"\n\nfunc PrintAdd(a, b uint32) string {\n return fmt.Sprintf(\"a:%v+b:%v=%v\", a, b, a+b)\n}\n\n//对应test文件夹下的PrintSum\nfunc PrintSum(_ *test.SumTest, a, b uint32) string {\n return fmt.Sprintf(\"a:%v+b:%v=%v\", a, b,a+b)\n}\nmain.go:\n\nfunc test1() {\n     monkey.Patch(test.PrintAdd, mock_test.PrintAdd)\n     p := test.PrintAdd(1, 2)\n     fmt.Println(p)\n     monkey.UnpatchAll() //解除所有替换\n     p = test.PrintAdd(1, 2)\n     fmt.Println(p)\n}\n\nfunc test2() {\n     structSum := &test.SumTest{}\n     //para1:获取实例的反射类型,para2:被替换的方法名,para3:替换方法\n     monkey.PatchInstanceMethod(reflect.TypeOf(structSum), \"PrintSum\", mock_test.PrintSum)\n     p := structSum.PrintSum(1, 2)\n     fmt.Println(p)\n     monkey.UnpatchAll() //解除所有替换\n     p = structSum.PrintSum(1, 2)\n     fmt.Println(p)\n}\n```\n### 未实现函数Mock：GoMock\n假设场景：Company公司、Person人。\n\n公司可以开会。\n公司内部的人继承了Talker讨论者接口，拥有SayHello说话的方法。\n\n假如现在要测试这个场景，在所有类都实现的情况下，测试应该是这样的：\n```go\n//正常测试\nfunc TestCompany_Meeting(t *testing.T) {\n//直接调用Person类的New方法，创建一个Person对象\n\ttalker := NewPerson(\"小微\", \"语音服务助手\")\n\tcompany := NewCompany(talker)\n\tt.Log(company.Meeting(\"lyt\", \"intern\"))\n}\n\n\n　　但现在Person类并未实现，则可以通过GoMock工具来模拟一个Person对象。\n\n　　定义一个Talker.go\npackage pojo\n\ntype Talker interface {\n   SayHello(word, role string) (response string)\n}\n根据该接口，用mockgen命令生成一个Mock对象\n\nmockgen [-source] [-destination] [-package] ... Talker.go\n　　接着进行测试用例的编写：\n\nNewController(): 新建Mock控制器\nNewMockXXX(): 新建Mock对象，这里是调用NewMockTalker()\ntalker.EXPECT().XXX().XXX()..：撰写一些断言测试\n之前Mock建立的对象传入到待测方法当中\n测试结果通过testing框架返回\n//通过Mock测试\nfunc TestCompany_Meeting2(t *testing.T) {\n\n   //新建Mock控制器\n   ctrl := gomock.NewController(t)\n   //新建Mock对象-Talker\n   talker := mock_pojo.NewMockTalker(ctrl)\n\n   //断言\n   talker.EXPECT().SayHello(gomock.Eq(\"震天嚎\"), gomock.Eq(\"学生\")).Return(\"Hello Faker(身份：学生), welcome to GoLand IDE. My name is 震天嚎\")\n   //mock对象传入方法\n   company := NewCompany(talker)\n\n   //Pass的例子\n   t.Log(company.Meeting(\"震天嚎\", \"学生\"))\n\n   //报错的例子\n   //t.Log(company.Meeting(\"小白\", \"学生\"))\n\n}\n```\n\n### 系统内置函数Mock：Monkey\n```go\nmonkey.Patch(json.Unmarshal, mockUnmarshal)，用Monkey的patch来mock系统内置函数\n\nfunc mockUnmarshal(b []byte, v interface{}) error{\n   v = &Common.LoginMessage{\n      UserId: 1,\n      UserName: \"admin\",\n      UserPwd: \"admin\",\n   }\n   return nil\n}\n如果需要取消替换，可以使用\n\nmonkey.UnPatch(target interface{})\t//解除单个Patch\nmonkey.UnPatchAll()    \t\t\t\t//解除所有Patch\n```\n\n### 数据库行为Mock：sqlmock\n```go\nfunc TestSql(t *testing.T) {\n   db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))\n   if err != nil {\n      fmt.Println(\"fail to open sqlmock db: \", err)\n   }\n   defer db.Close()\n   rows := sqlmock.NewRows([]string{\"id\", \"pwd\"}).\n      AddRow(1, \"apple\").\n      AddRow(2, \"banana\")\n   mock.ExpectQuery(\"SELECT id, pwd FROM users\").WillReturnRows(rows)\n   res, err := db.Query(\"SELECT id, pwd FROM users\")\n   if err != nil {\n      fmt.Println(\"fail to match expected sql.\")\n      return\n   }\n   defer res.Close()\n   for res.Next() {\n      var id int\n      var pwd string\n      res.Scan(&id, &pwd)\n      fmt.Printf(\"Sql Result:\\tid = %d, password = %s.\\n\",id, pwd)\n   }\n   if res.Err() != nil {\n      fmt.Println(\"Result Return Error!\", res.Err())\n   }\n}\n```\n\n### 服务器行为Mock：httptest\n\n使用net/http/httptest模拟服务器行为\n```go\nfunc TestHttp(t *testing.T) {\n   handler := func(w http.ResponseWriter, r *http.Request) {\n      io.WriteString(w, \"{ \\\"status\\\": \\\"expected service response\\\"}\")\n   }\n\n   req := httptest.NewRequest(\"GET\", \"https://test.net\", nil)\n   w := httptest.NewRecorder()\n   handler(w, req)//处理该Request\n\n   resp := w.Result()\n   body, _ := ioutil.ReadAll(resp.Body)\n   fmt.Println(resp.StatusCode)\n   fmt.Println(resp.Header.Get(\"Content-Type\"))\n   fmt.Println(string(body))\n}\n　　这里只使用了Monkey的Patch进行简单测试，但在更一般的情况下，更多的函数还是通过实例函数来编写的，对这部分函数要用PatchInstanceMethod才可以进行替换。\n\n`\nfunc PatchInstanceMethod(target reflect.Type, methodName string, replacement interface{})\n`接收三个参数：\n\nreflect.Tpye通过新建一个待测实例对象，调用reflect包的TypeOf()方法就可以得到\nmethodName是待测实例对象的函数名\nreplacement是用于替换的函数\n实现如下：\n\nvar ts *utils.Transfer\nmonkey.PatchInstanceMethod(reflect.TypeOf(ts), \"WritePkg\", func(_ *utils.Transfer, _ []byte) error {\n      return nil\n})\n假设有如下一个函数ServerProcessLogin，用于接收用户名密码，向当前连接的服务器请求登陆，测试如下：\n\nfunc TestServerProcessLogin(t *testing.T) {\n   mess := &Common.Message{\n      Type: Common.LoginMesType,\n      Data: \"default\",\n   }\n   user := &UserProcess{\n      Conn: nil,\n   }\n\n   //对涉及到的单元以外系统函数打Patch\n   monkey.Patch(json.Unmarshal, mockUnmarshal)\n   monkey.Patch(json.Marshal, mockMarshal)\n\n   //单元测试不涉及实际服务器，故对实例函数Login，WritePkg打Patch\n   var udao *model.UserDao\n   monkey.PatchInstanceMethod(reflect.TypeOf(udao), \"Login\", func(_ *model.UserDao, _ int, _ string) (*Common.User,error) {\n      return &Common.User{\n         UserId: 1,\n         UserName: \"admin\",\n         UserPwd: \"admin\",\n      }, nil\n   })\n    \n   var ts *utils.Transfer\n   monkey.PatchInstanceMethod(reflect.TypeOf(ts),\"WritePkg\", func(_ *utils.Transfer, _ []byte) error {\n      return nil\n   })\n\n   //执行测试\n   convey.Convey(\"Test Server Login.\", t, func() {\n      err := user.ServerProcessLogin(mess)\n      convey.So(err, convey.ShouldBeNil)\n   })\n\n   monkey.UnpatchAll()\n   return\n}\n\n//用于替换的函数\nfunc mockUnmarshal(b []byte, v interface{}) error{\n   v = &Common.LoginMessage{\n      UserId: 1,\n      UserName: \"admin\",\n      UserPwd: \"admin\",\n   }\n   return nil\n}\n\nfunc mockMarshal(v interface{}) ([]byte, error) {\n   var rer = []byte{\n      'a','d','m','i','n',\n   }\n   return rer, nil\n}\n```\n\n## 具体案例：聊天室\n### 概览\n该项目是一个具有登录、查看在线用户、私聊、群聊等功能的命令行聊天室Demo。\n\n项目分为Client、Server子项目，都通过model、Controllor(Processor）、View（Main）来进行功能划分。还有一个Common包放置通用性的工具类。\n```go\n├─Client\n│  ├─main\n│  ├─model\n│  ├─processor\n│  └─utils\n├─Common\n└─Server\n    ├─main\n    ├─model\n    ├─processor\n    └─utils\n```\n预期目的：对实现的功能模块补充单元测试代码，度量确保每一个模块的功能的正确性、完整性、健壮性，并在未来修改代码后也能第一时间自测验收。\n\n单元测试应包括模块接口测试、模块局部数据结构测试、模块异常处理测试。\n\n对于接口测试，应对接口的传入参数测试样例设计进行全面的考察，判断每一个参数是否有是有必要的，参数间有没有冗余，进入函数体前引用的指针是否有错等等。\n\n对于局部数据结构测试，应检查局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整性、正确性。局部数据结构往往是错误的根源，应仔细设计测试用例。\n\n对于异常处理，主要有如下几种常见错误\n\n- 输出的出错信息提示不足\n- 对异常没有进行处理\n- 出错信息与实际不相符\n- 出错信息中未能准确定位出错信息\n\n以上几种错误，都是模块中经常会出现的错误，要针对这些错误来进行边界条件测试检查，只有异常处理机制正确，日后软件的维护和迭代才会更加高效。\n\n在本案例中，Model层对服务层提供的接口不多，就WritePkg，ReadPkg两个核心函数，在服务层对其进行封装抽象为具体的业务逻辑。由于涉及网络连接，所以对其进行的测试必须编写桩函数。在服务层，涉及到对多个网络连接调用、数据库调用其它模块依赖，所以也要为其进行Mock。\n\n由于涉及Mock和桩函数编写，可以使用GoStub、Monkey两个包进行这些工作，它们较简洁地实现了很多实用的测试方式，只需要用户编写依赖的接口文件、用于替换的Mock函数，就可以仅在测试过程中替换掉系统函数或者其它依赖的功能模块，使得单元测试起到它应有的作用。\n\n### Model层、数据库相关测试\n由于是单元测试，所以需要获取一个Mock数据库实例，测试增删改查SQL语句是否可执行。userDao_test.go代码如下：\n```go\nconst (\n   sql1 = \"SELECT id, pwd FROM users\"\n   sql2 = \"DELETE FROM users where id > 600 and id < 700\"\n   sql3 = \"update users set pwd = newPwd where id = 1 and id = 2\"\n   sql4 = \"INSERT INTO users (id, pwd) VALUES (405, 'Lyt')\"\n)\n\nfunc TestGetUserById(t *testing.T) {\n   db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))\n   if err != nil {\n      fmt.Println(\"fail to open sqlmock db: \", err)\n   }\n   defer db.Close()\n   rows1 := sqlmock.NewRows([]string{\"id\", \"pwd\"}).\n      AddRow(1, \"apple\").\n      AddRow(2, \"banana\")\n   rows2 := sqlmock.NewRows([]string{\"id\", \"pwd\"}).\n      AddRow(601, \"goland\").\n      AddRow(602, \"java\")\n   rows3 := sqlmock.NewRows([]string{\"id\", \"pwd\"}).\n      AddRow(1, \"newPwd\").\n      AddRow(2, \"newPwd\")\n   rows4 := sqlmock.NewRows([]string{\"id\", \"pwd\"}).\n      AddRow(405, \"Lyt\")\n\n   mock.ExpectQuery(sql1).WillReturnRows(rows1)\n   mock.ExpectQuery(sql2).WillReturnRows(rows2)\n   mock.ExpectQuery(sql3).WillReturnRows(rows3)\n   mock.ExpectQuery(sql4).WillReturnRows(rows4)\n\n   assert.New(t)\n   var tests = []struct{\n      inputSql string\n      expected interface{}\n   } {\n      {sql1,nil},\n      {sql2,nil},\n      {sql3,nil},\n      {sql4, nil},\n   }\n\n   for _, test := range tests {\n      res, err := db.Query(test.inputSql)\n      assert.Equal(t, err, test.expected)\n\n      for res.Next() {\n         var id int\n         var pwd string\n         res.Scan(&id, &pwd)\n         fmt.Printf(\"Sql Result:\\tid = %d, password = %s.\\n\",id, pwd)\n      }\n      assert.Equal(t, res.Err(), test.expected)\n   }\n}\n```\n\n### 私聊功能测试\n由于涉及底层数据库交互时需要发送JSON转码字符串（WritePkg函数），因此将其Mock处理，只需关注本函数逻辑是否正确即可。smsProcess_test.go如下：\n```go\nfunc TestSmsProcess_SendOnePerson(t *testing.T) {\n   var conn net.Conn\n   tf := &utils.Transfer{\n      Conn: conn,\n   }\n   monkey.PatchInstanceMethod(reflect.TypeOf(tf), \"WritePkg\", func(_ *utils.Transfer,_ []byte) error{\n      return nil\n   })\n   convey.Convey(\"test send one person:\", t, func() {\n      err := tf.WritePkg([]byte{})\n      convey.So(err, convey.ShouldBeNil)\n      fmt.Println(\"OK.\")\n   })\n}\n```\n\n### 登录功能测试\n登录涉及服务器连接操作，服务器的连接逻辑可通过httptest包来进行检测，Mock一个HTTP连接，示例代码如下：\n```go\nfunc TestHttp(t *testing.T) {\n   handler := func(w http.ResponseWriter, r *http.Request) {\n      // here we write our expected response, in this case, we return a\n      // JSON string which is typical when dealing with REST APIs\n      io.WriteString(w, \"{ \\\"status\\\": \\\"expected service response\\\"}\")\n   }\n\n   req := httptest.NewRequest(\"GET\", \"https://test.net\", nil)\n   w := httptest.NewRecorder()\n   handler(w, req)\n\n   resp := w.Result()\n   body, _ := ioutil.ReadAll(resp.Body)\n   fmt.Println(resp.StatusCode)\n   fmt.Println(resp.Header.Get(\"Content-Type\"))\n   fmt.Println(string(body))\n}\n　　为登录模块编写用于测试替换的函数以及单元测试主体，userProcess_test.go代码如下：\n\nfunc mockUnmarshal(b []byte, v interface{}) error {\n   v = &Common.LoginMessage{\n      UserId:   1,\n      UserName: \"admin\",\n      UserPwd:  \"admin\",\n   }\n   return nil\n}\n\nfunc mockMarshal(v interface{}) ([]byte, error) {\n   var rer = []byte{\n      'a', 'd', 'm', 'i', 'n',\n   }\n   return rer, nil\n}\n\nfunc TestServerProcessLogin(t *testing.T) {\n   mess := &Common.Message{\n      Type: Common.LoginMesType,\n      Data: \"default\",\n   }\n   user := &UserProcess{\n      Conn: nil,\n   }\n\n   //对涉及到的单元以外系统函数打Patch\n   monkey.Patch(json.Unmarshal, mockUnmarshal)\n   monkey.Patch(json.Marshal, mockMarshal)\n\n   //对实例函数打Patch\n   var udao *model.UserDao\n   monkey.PatchInstanceMethod(reflect.TypeOf(udao), \"Login\", func(_ *model.UserDao, _ int, _ string) (*Common.User, error) {\n      return &Common.User{\n         UserId:   1,\n         UserName: \"admin\",\n         UserPwd:  \"admin\",\n      }, nil\n   })\n\n   var ts *utils.Transfer\n   monkey.PatchInstanceMethod(reflect.TypeOf(ts), \"WritePkg\", func(_ *utils.Transfer, _ []byte) error {\n      return nil\n   })\n   //执行测试\n   convey.Convey(\"Test Server Login.\", t, func() {\n      err := user.ServerProcessLogin(mess)\n      convey.So(err, convey.ShouldBeNil)\n   })\n   monkey.UnpatchAll()\n   return\n}\n```\n### 工具类测试\n```go\nutils_test.go\n\nfunc mockRead(conn net.Conn, _ []byte) (int, error) {\n   return 4, nil\n}\n\nfunc mockMarshal(v interface{}) ([]byte, error) {\n   return []byte{'a', 'b', 'c', 'd'}, nil\n}\n\nfunc mockUnmarshal(data []byte, v interface{}) error {\n   return nil\n}\n\nfunc TestTransfer_ReadPkg(t *testing.T) {\n\n   monkey.Patch(net.Conn.Read, mockRead)\n   monkey.Patch(json.Marshal, mockMarshal)\n   monkey.Patch(json.Unmarshal, mockUnmarshal)\n\n   listen, _ := net.Listen(\"tcp\", \"localhost:8888\")\n   defer listen.Close()\n   go net.Dial(\"tcp\", \"localhost:8888\")\n   var c net.Conn\n   for {\n\n      c, _ = listen.Accept()\n      if c != nil {\n         break\n      }\n   }\n\n\n   transfer := &Transfer{\n      Conn: c,\n      Buf : [8096]byte{'a', 'b', 'c', 'd'},\n   }\n   convey.Convey(\"test ReadPkg\", t, func() {\n      mes, err := transfer.ReadPkg()\n      convey.So(err, convey.ShouldBeNil)\n      convey.So(mes, convey.ShouldEqual, \"ab\")\n   })\n   monkey.UnpatchAll()\n\n}\n\nfunc TestTransfer_WritePkg(t *testing.T) {\n\n   monkey.Patch(json.Marshal, mockMarshal)\n   monkey.Patch(json.Unmarshal, mockUnmarshal)\n   transfer := &Transfer{\n      Conn: nil,\n      Buf : [8096]byte{},\n   }\n   convey.Convey(\"test ReadPkg\", t, func() {\n      err := transfer.WritePkg([]byte{'a', 'b'})\n      convey.So(err, convey.ShouldBeNil)\n   })\n   monkey.UnpatchAll()\n}\n```\n\n### 项目总结\n在编写桩模块时会发现，模块之间的调用关系在工程规模并不大的本案例中，也依然比较复杂，需要开发相应桩函数，代码量会增加许多，也会消耗一些开发人员的时间，因此反推到之前流程的开发实践中，可以得出结论就是提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。\n\nGo单元测试框架是相当易用的，其它的第三方库基本都是建立在testing原生框架的基础上进行的增补扩充，在日常开发中，原生包可以满足基本需求，但同样也有缺陷，原生包不提供断言的语法使得代码中的这种片段非常多：\n```go\nif err != nil{\n\t//...\n}\n```\n所以引入了convey、assert包的断言语句，用于简化判断逻辑，使得程序更加易读。\n\n在完成项目单测时，遇到了不少问题，比较重要的比如由于架构分层不够清晰，还是有部分耦合代码，导致单测时需要屏蔽的模块太多，代码写起来不便。因此还是需要倒推到开发模块之前，就要设计更好的结构，在开发的过程中遵循相应的规则，通过测试先行的思想，使开发的工程具有更好的可测试性。\n\n开发过程中遇到的场景肯定不局限于本文所讨论的范围，有关更丰富的最佳实践案例可以参照：\n\ngo-sqlmock\ngo-mock\n\n## 结语\n### 实践小结\n1. 单元测试大多是由开发人员进行编写，本篇文章旨在指引，不在于面面俱到，具体的单元测试框架的使用语法，开发同学可以自行Google。\n2. 以测试的角度，推行单元测试是不易的，最佳的方式莫过于开发人员，在一定的指引之后，以实际项目出发进行实践，然后自行总结具体的case，有针对性、有感染力进行内部分享，测试同学及时提供测试用例的指引和规范的约束。\n3. 基于interface的mock是最佳实践。《单元测试的艺术》有讲，作者经验很丰富。google认为单测的核心轮子就是mock技术和测试运行框架。golang自带运行框架，官方直接搞个gomock补全了两个核心。gomock对expect，而且支持expect几次，等等细节的支持，功能强大。\n4. Table-Driven是最佳实践。测试还小的时候，直接gotests生成。挺好。被测数据空间大，就把被测数据放进testdata。gotests+convey，我认为是最佳实践。\n\n### 推荐阅读\n书籍《google的软件测试之道》\n书籍《单元测试的艺术》","content":"<p>单测系列-Go<br>本文整理学习Go单测相关内容<br>总结在Go中如何做单测，本文介绍了单测是什么以及Go常用的单测框架和工具</p>\n<span id=\"more\"></span>\n\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><h3 id=\"单元测试是什么\"><a href=\"#单元测试是什么\" class=\"headerlink\" title=\"单元测试是什么\"></a>单元测试是什么</h3><p>单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、超类、抽象类等中的方法。单元测试就是软件开发中对最小单位进行正确性检验的测试工作。</p>\n<p>不同地方对单元测试有的定义可能会有所不同，但有一些基本共识：</p>\n<p>单元测试是比较底层的，关注代码的局部而不是整体。<br>单元测试是开发人员在写代码时候写的。<br>单元测试需要比其他测试运行得快。</p>\n<h3 id=\"单元测试的意义\"><a href=\"#单元测试的意义\" class=\"headerlink\" title=\"单元测试的意义\"></a>单元测试的意义</h3><p>提高代码质量。代码测试都是为了帮助开发人员发现问题从而解决问题，提高代码质量。<br>尽早发现问题。问题越早发现，解决的难度和成本就越低。<br>保证重构正确性。随着功能的增加，重构（修改老代码）几乎是无法避免的。很多时候我们不敢重构的原因，就是担心其它模块因为依赖它而不工作。有了单元测试，只要在改完代码后运行一下单测就知道改动对整个系统的影响了，从而可以让我们放心的重构代码。<br>简化调试过程。单元测试让我们可以轻松地知道是哪一部分代码出了问题。<br>简化集成过程。由于各个单元已经被测试，在集成过程中进行的后续测试会更加容易。<br>优化代码设计。编写测试用例会迫使开发人员仔细思考代码的设计和必须完成的工作，有利于开发人员加深对代码功能的理解，从而形成更合理的设计和结构。<br>单元测试是最好的文档。单元测试覆盖了接口的所有使用方法，是最好的示例代码。而真正的文档包括注释很有可能和代码不同步，并且看不懂。</p>\n<h3 id=\"单元测试用例编写的原则\"><a href=\"#单元测试用例编写的原则\" class=\"headerlink\" title=\"单元测试用例编写的原则\"></a>单元测试用例编写的原则</h3><h4 id=\"理论原则\"><a href=\"#理论原则\" class=\"headerlink\" title=\"理论原则\"></a>理论原则</h4><p>快。单元测试是回归测试，可以在开发过程的任何时候运行，因此运行速度必须快<br>一致性。代码没有改变的情况下，每次运行得结果应该保持确定且一致<br>原子性。结果只有两种情况：Pass &#x2F; Fail<br>用例独立。执行顺序不影响；用例间没有状态共享或者依赖关系；用例没有副作用（执行前后环境状态一致）<br>单一职责。一个用例只负责一个场景<br>隔离。功能可能依赖于数据库、web访问、环境变量、系统时间等；一个单元可能依赖于另一部分代码，用例应该解除这些依赖<br>可读性。用例的名称、变量名等应该具有可读性，直接表现出该测试的目标<br>自动化。单元测试需要全自动执行。测试程序不应该有用户输入；测试结果应该能直接被电脑获取，不应该由人来判断。</p>\n<h4 id=\"规约原则\"><a href=\"#规约原则\" class=\"headerlink\" title=\"规约原则\"></a>规约原则</h4><p>在实际编写代码过程中，不同的团队会有不同团队的风格，只要团队内部保持有一定的规约即可，比如：</p>\n<p>单元测试文件名必须以xxx_test.go命名<br>方法必须是TestXxx开头，建议风格保持一致（驼峰或者下划线）<br>方法参数必须 t *testing.T<br>测试文件和被测试文件必须在一个包中</p>\n<h4 id=\"衡量原则\"><a href=\"#衡量原则\" class=\"headerlink\" title=\"衡量原则\"></a>衡量原则</h4><p>　　单元测试是要写额外的代码的，这对开发同学的也是一个不小的工作负担，在一些项目中，我们合理的评估单元测试的编写，我认为我们不能走极端，当然理论上来说全写肯定时好的，但是从成本，效率上来说我们必须做出权衡，衡量原则如下：</p>\n<p>优先编写核心组件和逻辑模块的测试用例<br>逻辑类似的组件如果存在多个，优先编写其中一种逻辑组件的测试用例<br>发现Bug时一定先编写测试用例进行Debug<br>关键util工具类要编写测试用例，这些util工具适用的很频繁，所以这个原则也叫做热点原则，和第1点相呼应。<br>测试用户应该独立，一个文件对应一个，而且不同的测试用例之间不要互相依赖。<br>测试用例的保持更新</p>\n<h3 id=\"单元测试用例设计方法\"><a href=\"#单元测试用例设计方法\" class=\"headerlink\" title=\"单元测试用例设计方法\"></a>单元测试用例设计方法</h3><h4 id=\"规范-规格-导出法\"><a href=\"#规范-规格-导出法\" class=\"headerlink\" title=\"规范(规格)导出法\"></a>规范(规格)导出法</h4><p>规范(规格)导出法将需求”翻译“成测试用例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如，一个函数的设计需求如下：</span><br><span class=\"line\"></span><br><span class=\"line\">函数：一个计算平方根的函数</span><br><span class=\"line\">输入： 实数</span><br><span class=\"line\">输出： 实数</span><br><span class=\"line\">要求： 当输入一个0或者比0大的实数时，返回其正的平方根；当输入一个小于0的实数时，显示错误信息“平方根非法—输入之小于0”，并返回0；库函数printf()可以用来输出错误信息。</span><br></pre></td></tr></table></figure>\n\n<p>在这个规范中有3个陈述，可以用两个测试用例来对应:</p>\n<p>测试用例1：输入4，输出2。<br>测试用例2：输入-1，输出0。</p>\n<h4 id=\"等价类划分法\"><a href=\"#等价类划分法\" class=\"headerlink\" title=\"等价类划分法\"></a>等价类划分法</h4><p>等价类划分法假定某一特定的等价类中的所有值对于测试目的来说是等价的，所以在每个等价类中找一个之作为测试用例。</p>\n<p>按照 [输入条件][有效等价类][无效等价类] 建立等价类表，列出所有划分出的等价类<br>为每一个等价类规定一个唯一的编号<br>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类。重复这一步，直到所有的有效等价类都被覆盖为止<br>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，直到所有的无效等价类都被覆盖为止<br>例如，注册邮箱时要求用6~18个字符，可使用字母、数字、下划线，需以字母开头。</p>\n<table>\n<thead>\n<tr>\n<th>有效等价类</th>\n<th>无效等价类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>6~18个字符（1）</td>\n<td>少于6个字符（2）<br>多余18个字符（3）<br>空（4）</td>\n</tr>\n<tr>\n<td>包含字母、数字、下划线（5）</td>\n<td>除字母、数字、下划线的特殊字符（6）<br>非打印字符（7）<br>中文字符 （8）</td>\n</tr>\n<tr>\n<td>以字母开头（9）</td>\n<td>以数字或下划线开头（10）</td>\n</tr>\n</tbody></table>\n<p>测试用例：</p>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>输入数据</th>\n<th>覆盖等价类</th>\n<th>预期结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>test_111</td>\n<td>（1）、（5）、（9）</td>\n<td>合法输入</td>\n</tr>\n<tr>\n<td>2</td>\n<td>t_11</td>\n<td>（2）、（5）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>3</td>\n<td>testtesttest_12345678</td>\n<td>（3）、（5）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>4</td>\n<td>NULL</td>\n<td>（4）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>5</td>\n<td>test!@1111</td>\n<td>（1）、（6）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>6</td>\n<td>test 1111</td>\n<td>（1）、（7）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>7</td>\n<td>test测试1111</td>\n<td>（1）、（8）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>8</td>\n<td>_test111</td>\n<td>（1）、（5）、（10）</td>\n<td>非法输入</td>\n</tr>\n</tbody></table>\n<h4 id=\"边界值分析法\"><a href=\"#边界值分析法\" class=\"headerlink\" title=\"边界值分析法\"></a>边界值分析法</h4><p>边界值分析法使用与等价类测试方法相同的等价类划分，只是边界值分析假定<br>错误更多地存在于两个划分的边界上。</p>\n<p>边界值测试在软件变得复杂的时候也会变得不实用。边界值测试对于非向量类型的值(如枚举类型的值)也没有意义。</p>\n<p>例如，和4.1相同的需求：<br>划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0。由此得到以下测试用例：</p>\n<ul>\n<li>输入 {最小负实数}</li>\n<li>输入 {绝对值很小的负数}</li>\n<li>输入 0</li>\n<li>输入 {绝对值很小的正数}</li>\n<li>输入 {最大正实数}</li>\n</ul>\n<h4 id=\"基本路径测试法\"><a href=\"#基本路径测试法\" class=\"headerlink\" title=\"基本路径测试法\"></a>基本路径测试法</h4><p>基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。</p>\n<p>基本路径测试法的基本步骤：</p>\n<p>程序的控制流图：描述程序控制流的一种图示方法。</p>\n<ul>\n<li>程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。</li>\n<li>导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。</li>\n<li>准备测试用例：确保基本路径集中的每一条路径的执行。</li>\n</ul>\n<h2 id=\"Golang的测试框架\"><a href=\"#Golang的测试框架\" class=\"headerlink\" title=\"Golang的测试框架\"></a>Golang的测试框架</h2><p>Golang有这几种比较常见的测试框架</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">测试框架\t推荐指数</span><br><span class=\"line\">Go自带的testing包\t★★★☆☆</span><br><span class=\"line\">GoConvey\t★★★★★</span><br><span class=\"line\">testify\t★★★☆☆</span><br></pre></td></tr></table></figure>\n\n<p>从测试用例编写的简易难度上来说：testify 比 GoConvey 简单；GoConvey比Go自带的testing包简单。<br>但在测试框架的选择上，我们更推荐GoConvey。因为：</p>\n<p>GoConvey和其他Stub&#x2F;Mock框架的兼容性相比Testify更好。<br>Testify自带Mock框架，但是用这个框架Mock类需要自己写。像这样重复有规律的部分在GoMock中是一键自动生成的。</p>\n<h3 id=\"Go自带的testing包\"><a href=\"#Go自带的testing包\" class=\"headerlink\" title=\"Go自带的testing包\"></a>Go自带的testing包</h3><p>　　testing 为 Go 语言 package 提供自动化测试的支持。通过 go test 命令，能够自动执行如下形式的任何函数：</p>\n<p>func TestXxx(*testing.T)<br>　　注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。</p>\n<p>　　在这些函数中，使用 Error、Fail 或相关方法来发出失败信号。</p>\n<p>　　要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 TestXxx 函数，如上所述。 将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 go test 命令时将被包含。 有关详细信息，请运行 go help test 和 go help testflag 了解。</p>\n<h4 id=\"第一个例子\"><a href=\"#第一个例子\" class=\"headerlink\" title=\"第一个例子\"></a>第一个例子</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">被测代码：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> n</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Fib(n<span class=\"number\">-1</span>) + Fib(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">测试代码：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestFib</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> (</span><br><span class=\"line\">        in       = <span class=\"number\">7</span></span><br><span class=\"line\">        expected = <span class=\"number\">13</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    actual := Fib(in)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> actual != expected &#123;</span><br><span class=\"line\">        t.Errorf(<span class=\"string\">&quot;Fib(%d) = %d; expected %d&quot;</span>, in, actual, expected)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">执行 <span class=\"keyword\">go</span> test . ，输出：</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"keyword\">go</span> test .</span><br><span class=\"line\">ok      chapter09/testing    <span class=\"number\">0.007</span>s</span><br><span class=\"line\">表示测试通过。</span><br><span class=\"line\">我们将 Fib 函数改为：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> n</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Fib(n<span class=\"number\">-1</span>) + Fib(n<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">再执行 <span class=\"keyword\">go</span> test . ，输出：</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"keyword\">go</span> test .</span><br><span class=\"line\">--- FAIL: TestFib (<span class=\"number\">0.00</span>s)</span><br><span class=\"line\">    t_test.<span class=\"keyword\">go</span>:<span class=\"number\">16</span>: Fib(<span class=\"number\">10</span>) = <span class=\"number\">64</span>; expected <span class=\"number\">13</span></span><br><span class=\"line\">FAIL</span><br><span class=\"line\">FAIL    chapter09/testing    <span class=\"number\">0.009</span>s</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Table-Driven测试\"><a href=\"#Table-Driven测试\" class=\"headerlink\" title=\"Table-Driven测试\"></a>Table-Driven测试</h4><p>Table-Driven 的方式将多个case在同一个测试函数中测到：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestFib</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> fibTests = []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">       in       <span class=\"type\">int</span> <span class=\"comment\">// input</span></span><br><span class=\"line\">       expected <span class=\"type\">int</span> <span class=\"comment\">// expected result</span></span><br><span class=\"line\">   &#125;&#123;</span><br><span class=\"line\">       &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">       &#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">       &#123;<span class=\"number\">3</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">       &#123;<span class=\"number\">4</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">       &#123;<span class=\"number\">5</span>, <span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">       &#123;<span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">       &#123;<span class=\"number\">7</span>, <span class=\"number\">13</span>&#125;,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> _, tt := <span class=\"keyword\">range</span> fibTests &#123;</span><br><span class=\"line\">       actual := Fib(tt.in)</span><br><span class=\"line\">       <span class=\"keyword\">if</span> actual != tt.expected &#123;</span><br><span class=\"line\">           t.Errorf(<span class=\"string\">&quot;Fib(%d) = %d; expected %d&quot;</span>, tt.in, actual, tt.expected)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go自带testing包的更多用法</p>\n<h3 id=\"GoConvey：简单断言\"><a href=\"#GoConvey：简单断言\" class=\"headerlink\" title=\"GoConvey：简单断言\"></a>GoConvey：简单断言</h3><p>Convey适用于书写单元测试用例，并且可以兼容到testing框架中，go test命令或者使用goconvey命令访问localhost:8080的Web测试界面都可以查看测试结果。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Convey(<span class=\"string\">&quot;Convey return : &quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        So(...)</span><br><span class=\"line\">&#125;) </span><br></pre></td></tr></table></figure>\n<p>一般Convey用So来进行断言，断言的方式可以传入一个函数，或者使用自带的ShouldBeNil、ShouldEqual、ShouldNotBeNil函数等。</p>\n<h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p>被测代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">StringSliceEqual</span><span class=\"params\">(a, b []<span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(a) != <span class=\"built_in\">len</span>(b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == <span class=\"literal\">nil</span>) != (b == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v != b[i] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">测试代码</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">    . <span class=\"string\">&quot;github.com/smartystreets/goconvey/convey&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestStringSliceEqual</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    Convey(<span class=\"string\">&quot;TestStringSliceEqual的描述&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        a := []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;goconvey&quot;</span>&#125;</span><br><span class=\"line\">        b := []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;goconvey&quot;</span>&#125;</span><br><span class=\"line\">        So(StringSliceEqual(a, b), ShouldBeTrue)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"双层嵌套\"><a href=\"#双层嵌套\" class=\"headerlink\" title=\"双层嵌套\"></a>双层嵌套</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">    . <span class=\"string\">&quot;github.com/smartystreets/goconvey/convey&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestStringSliceEqual</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    Convey(<span class=\"string\">&quot;TestStringSliceEqual&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        Convey(<span class=\"string\">&quot;true when a != nil  &amp;&amp; b != nil&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            a := []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;goconvey&quot;</span>&#125;</span><br><span class=\"line\">            b := []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;goconvey&quot;</span>&#125;</span><br><span class=\"line\">            So(StringSliceEqual(a, b), ShouldBeTrue)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        Convey(<span class=\"string\">&quot;true when a ＝= nil  &amp;&amp; b ＝= nil&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            So(StringSliceEqual(<span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>), ShouldBeTrue)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">内层的Convey不需要再传入t *testing.T参数</span><br></pre></td></tr></table></figure>\n\n<p>GoConvey的更多用法</p>\n<h3 id=\"testify\"><a href=\"#testify\" class=\"headerlink\" title=\"testify\"></a>testify</h3><p>testify提供了assert和require，让你可以简洁地写出</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> xxx &#123; t.Fail() &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a>assert</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSomething</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//断言相等</span></span><br><span class=\"line\">  assert.Equal(t, <span class=\"number\">123</span>, <span class=\"number\">123</span>, <span class=\"string\">&quot;they should be equal&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//断言不相等</span></span><br><span class=\"line\">  assert.NotEqual(t, <span class=\"number\">123</span>, <span class=\"number\">456</span>, <span class=\"string\">&quot;they should not be equal&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//对于nil的断言</span></span><br><span class=\"line\">  assert.Nil(t, object)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//对于非nil的断言</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> assert.NotNil(t, object) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// now we know that object isn&#x27;t nil, we are safe to make</span></span><br><span class=\"line\">\t<span class=\"comment\">// further assertions without causing any errors</span></span><br><span class=\"line\">\tassert.Equal(t, <span class=\"string\">&quot;Something&quot;</span>, object.Value)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"require\"></a>require</h4><p>　　require和assert失败、成功条件完全一致，区别在于assert只是返回布尔值（true、false），而require不符合断言时，会中断当前运行</p>\n<h4 id=\"常用的函数\"><a href=\"#常用的函数\" class=\"headerlink\" title=\"常用的函数\"></a>常用的函数</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Equal</span><span class=\"params\">(t TestingT, expected, actual <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotEqual</span><span class=\"params\">(t TestingT, expected, actual <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Nil</span><span class=\"params\">(t TestingT, object <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotNil</span><span class=\"params\">(t TestingT, object <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Empty</span><span class=\"params\">(t TestingT, object <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotEmpty</span><span class=\"params\">(t TestingT, object <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NoError</span><span class=\"params\">(t TestingT, err <span class=\"type\">error</span>, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Error</span><span class=\"params\">(t TestingT, err <span class=\"type\">error</span>, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Zero</span><span class=\"params\">(t TestingT, i <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotZero</span><span class=\"params\">(t TestingT, i <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">True</span><span class=\"params\">(t TestingT, value <span class=\"type\">bool</span>, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">False</span><span class=\"params\">(t TestingT, value <span class=\"type\">bool</span>, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Len</span><span class=\"params\">(t TestingT, object <span class=\"keyword\">interface</span>&#123;&#125;, length <span class=\"type\">int</span>, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotContains</span><span class=\"params\">(t TestingT, s, contains <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotContains</span><span class=\"params\">(t TestingT, s, contains <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Subset</span><span class=\"params\">(t TestingT, list, subset <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> (ok <span class=\"type\">bool</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotSubset</span><span class=\"params\">(t TestingT, list, subset <span class=\"keyword\">interface</span>&#123;&#125;, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> (ok <span class=\"type\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FileExists</span><span class=\"params\">(t TestingT, path <span class=\"type\">string</span>, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DirExists</span><span class=\"params\">(t TestingT, path <span class=\"type\">string</span>, msgAndArgs ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br></pre></td></tr></table></figure>\n<p>testify的更多用法</p>\n<h2 id=\"Stub-x2F-Mock框架\"><a href=\"#Stub-x2F-Mock框架\" class=\"headerlink\" title=\"Stub&#x2F;Mock框架\"></a>Stub&#x2F;Mock框架</h2><p>Golang有以下Stub&#x2F;Mock框架：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GoStub</span><br><span class=\"line\">GoMock</span><br><span class=\"line\">Monkey</span><br></pre></td></tr></table></figure>\n<p>一般来说，GoConvey可以和GoStub、GoMock、Monkey中的一个或多个搭配使用。　　<br>Testify本身有自己的Mock框架，可以用自己的也可以和这里列出来的Stub&#x2F;Mock框架搭配使用。</p>\n<h3 id=\"GoStub\"><a href=\"#GoStub\" class=\"headerlink\" title=\"GoStub\"></a>GoStub</h3><p>GoStub框架的使用场景很多，依次为：</p>\n<p>基本场景：为一个全局变量打桩<br>基本场景：为一个函数打桩<br>基本场景：为一个过程打桩<br>复合场景：由任意相同或不同的基本场景组合而成</p>\n<h4 id=\"为一个全局变量打桩\"><a href=\"#为一个全局变量打桩\" class=\"headerlink\" title=\"为一个全局变量打桩\"></a>为一个全局变量打桩</h4><p>假设num为被测函数中使用的一个全局整型变量，当前测试用例中假定num的值大于100，比如为150，则打桩的代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stubs := Stub(&amp;num, <span class=\"number\">150</span>)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>\n<p>stubs是GoStub框架的函数接口Stub返回的对象，该对象有Reset操作，即将全局变量的值恢复为原值。</p>\n<h4 id=\"为一个函数打桩\"><a href=\"#为一个函数打桩\" class=\"headerlink\" title=\"为一个函数打桩\"></a>为一个函数打桩</h4><p>假设我们产品的既有代码中有下面的函数定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Exec</span><span class=\"params\">(cmd <span class=\"type\">string</span>, args ...<span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">若要想对Exec函数通过GoStub框架打桩，需要将Exec函数定义为匿名函数，同时将它赋值给Exec变量，重构后的代码如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Exec = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(cmd <span class=\"type\">string</span>, args ...<span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">我们可以对Exec函数打桩，代码如下所示：</span><br><span class=\"line\"></span><br><span class=\"line\">stubs := StubFunc(&amp;Exec,<span class=\"string\">&quot;xxx-vethName100-yyy&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为一个过程打桩\"><a href=\"#为一个过程打桩\" class=\"headerlink\" title=\"为一个过程打桩\"></a>为一个过程打桩</h4><p>当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。<br>我们对过程DestroyResource的打桩代码为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stubs := StubFunc(&amp;DestroyResource)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>\n<p>GoStub的更多用法以及GoStub+GoConvey的组合使用方法</p>\n<h3 id=\"GoMock\"><a href=\"#GoMock\" class=\"headerlink\" title=\"GoMock\"></a>GoMock</h3><p>GoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的testing包良好集成，也能用于其它的测试环境中。GoMock测试框架包含了GoMock包和mockgen工具两部分，其中GoMock包完成对桩对象生命周期的管理，mockgen工具用来生成interface对应的Mock类源文件。</p>\n<h4 id=\"定义一个接口\"><a href=\"#定义一个接口\" class=\"headerlink\" title=\"定义一个接口\"></a>定义一个接口</h4><p>我们先定义一个打算mock的接口Repository。</p>\n<p>Repository是领域驱动设计中战术设计的一个元素，用来存储领域对象，一般将对象持久化在数据库中，比如Aerospike，Redis或Etcd等。对于领域层来说，只知道对象在Repository中维护，并不care对象到底在哪持久化，这是基础设施层的职责。微服务在启动时，根据部署参数实例化Repository接口，比如AerospikeRepository，RedisRepository或EtcdRepository。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Repository <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Create(key <span class=\"type\">string</span>, value []<span class=\"type\">byte</span>) <span class=\"type\">error</span></span><br><span class=\"line\">    Retrieve(key <span class=\"type\">string</span>) ([]<span class=\"type\">byte</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">    Update(key <span class=\"type\">string</span>, value []<span class=\"type\">byte</span>) <span class=\"type\">error</span></span><br><span class=\"line\">    Delete(key <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成mock类文件\"><a href=\"#生成mock类文件\" class=\"headerlink\" title=\"生成mock类文件\"></a>生成mock类文件</h4><p>这下该mockgen工具登场了。mockgen有两种操作模式：源文件和反射。</p>\n<p>源文件模式通过一个包含interface定义的文件生成mock类文件，它通过 -source 标识生效，-imports 和 -aux_files 标识在这种模式下也是有用的。<br>举例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mockgen -source=foo.<span class=\"keyword\">go</span> [other options]</span><br><span class=\"line\">　　反射模式通过构建一个程序用反射理解接口生成一个mock类文件，它通过两个非标志参数生效：导入路径和用逗号分隔的符号列表（多个<span class=\"keyword\">interface</span>）。</span><br><span class=\"line\">举例：</span><br><span class=\"line\"></span><br><span class=\"line\">mockgen database/sql/driver Conn,Driver</span><br><span class=\"line\">生成的mock_repository.<span class=\"keyword\">go</span>文件：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Automatically generated by MockGen. DO NOT EDIT!</span></span><br><span class=\"line\"><span class=\"comment\">// Source: infra/db (interfaces: Repository)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> mock_db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    gomock <span class=\"string\">&quot;github.com/golang/mock/gomock&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MockRepository is a mock of Repository interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MockRepository <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ctrl     *gomock.Controller</span><br><span class=\"line\">    recorder *MockRepositoryMockRecorder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MockRepositoryMockRecorder is the mock recorder for MockRepository</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MockRepositoryMockRecorder <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    mock *MockRepository</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewMockRepository creates a new mock instance</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewMockRepository</span><span class=\"params\">(ctrl *gomock.Controller)</span></span> *MockRepository &#123;</span><br><span class=\"line\">    mock := &amp;MockRepository&#123;ctrl: ctrl&#125;</span><br><span class=\"line\">    mock.recorder = &amp;MockRepositoryMockRecorder&#123;mock&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mock</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EXPECT returns an object that allows the caller to indicate expected use</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(_m *MockRepository)</span></span> EXPECT() *MockRepositoryMockRecorder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _m.recorder</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create mocks base method</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(_m *MockRepository)</span></span> Create(_param0 <span class=\"type\">string</span>, _param1 []<span class=\"type\">byte</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    ret := _m.ctrl.Call(_m, <span class=\"string\">&quot;Create&quot;</span>, _param0, _param1)</span><br><span class=\"line\">    ret0, _ := ret[<span class=\"number\">0</span>].(<span class=\"type\">error</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用mock对象进行打桩测试\"><a href=\"#使用mock对象进行打桩测试\" class=\"headerlink\" title=\"使用mock对象进行打桩测试\"></a>使用mock对象进行打桩测试</h4><h5 id=\"导入mock相关的包\"><a href=\"#导入mock相关的包\" class=\"headerlink\" title=\"导入mock相关的包\"></a>导入mock相关的包</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">    . <span class=\"string\">&quot;github.com/golang/mock/gomock&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;test/mock/db&quot;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h5 id=\"mock控制器\"><a href=\"#mock控制器\" class=\"headerlink\" title=\"mock控制器\"></a>mock控制器</h5><p>mock控制器通过NewController接口生成，是mock生态系统的顶层控制，它定义了mock对象的作用域和生命周期，以及它们的期望。多个协程同时调用控制器的方法是安全的。<br>当用例结束后，控制器会检查所有剩余期望的调用是否满足条件。</p>\n<p>控制器的代码如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl := NewController(t)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\">　　mock对象创建时需要注入控制器，如果有多个mock对象则注入同一个控制器，如下所示：</span><br><span class=\"line\"></span><br><span class=\"line\">ctrl := NewController(t)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\">mockRepo := mock_db.NewMockRepository(ctrl)</span><br><span class=\"line\">mockHttp := mock_api.NewHttpMethod(ctrl)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"mock对象的行为注入\"><a href=\"#mock对象的行为注入\" class=\"headerlink\" title=\"mock对象的行为注入\"></a>mock对象的行为注入</h5><p>对于mock对象的行为注入，控制器是通过map来维护的，一个方法对应map的一项。因为一个方法在一个用例中可能调用多次，所以map的值类型是数组切片。当mock对象进行行为注入时，控制器会将行为Add。当该方法被调用时，控制器会将该行为Remove。</p>\n<p>假设有这样一个场景：先Retrieve领域对象失败，然后Create领域对象成功，再次Retrieve领域对象就能成功。这个场景对应的mock对象的行为注入代码如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mockRepo.EXPECT().Retrieve(Any()).Return(<span class=\"literal\">nil</span>, ErrAny)</span><br><span class=\"line\">mockRepo.EXPECT().Create(Any(), Any()).Return(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">mockRepo.EXPECT().Retrieve(Any()).Return(objBytes, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">　　objBytes是领域对象的序列化结果，比如：</span><br><span class=\"line\"></span><br><span class=\"line\">obj := Movie&#123;...&#125;</span><br><span class=\"line\">objBytes, err := json.Marshal(obj)</span><br><span class=\"line\">...</span><br><span class=\"line\">　　当批量Create对象时，可以使用Times关键字：</span><br><span class=\"line\"></span><br><span class=\"line\">mockRepo.EXPECT().Create(Any(), Any()).Return(<span class=\"literal\">nil</span>).Times(<span class=\"number\">5</span>)</span><br><span class=\"line\">　　当批量Retrieve对象时，需要注入多次mock行为:</span><br><span class=\"line\"></span><br><span class=\"line\">mockRepo.EXPECT().Retrieve(Any()).Return(objBytes1, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">mockRepo.EXPECT().Retrieve(Any()).Return(objBytes2, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">mockRepo.EXPECT().Retrieve(Any()).Return(objBytes3, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">mockRepo.EXPECT().Retrieve(Any()).Return(objBytes4, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">mockRepo.EXPECT().Retrieve(Any()).Return(objBytes5, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">GoMock的更多用法以及GoStub+GoConvey+GoMock的组合使用方法</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Monkey\"><a href=\"#Monkey\" class=\"headerlink\" title=\"Monkey\"></a>Monkey</h2><p>至此，我们已经知道：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全局变量可通过GoStub框架打桩</span><br><span class=\"line\">过程可通过GoStub框架打桩</span><br><span class=\"line\">函数可通过GoStub框架打桩</span><br><span class=\"line\">interface可通过GoMock框架打桩</span><br></pre></td></tr></table></figure>\n\n<p>但还有两个问题比较棘手：<br>方法（成员函数）无法通过GoStub框架打桩，当产品代码的OO设计比较多时，打桩点可能离被测函数比较远，导致UT用例写起来比较痛<br>过程或函数通过GoStub框架打桩时，对产品代码有侵入性<br>Monkey是Golang的一个猴子补丁（monkeypatching）框架，在运行时通过汇编语句重写可执行文件，将待打桩函数或方法的实现跳转到桩实现，原理和热补丁类似。通过Monkey，我们可以解决函数或方法的打桩问题，但Monkey不是线程安全的，不要将Monkey用于并发的测试中。</p>\n<p>Monkey框架的使用场景很多，依次为：</p>\n<p>基本场景：为一个函数打桩<br>基本场景：为一个过程打桩<br>基本场景：为一个方法打桩<br>复合场景：由任意相同或不同的基本场景组合而成<br>特殊场景：桩中桩的一个案例<br>另有GoMonkey框架<a href=\"https://github.com/agiledragon/gomonkey%EF%BC%8C%E5%AF%B9%E6%AF%94Monkey%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%86%99%E6%B3%95%E6%9B%B4%E7%AE%80%E5%8D%95%EF%BC%8C%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84%E8%AF%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E3%80%82\">https://github.com/agiledragon/gomonkey，对比Monkey来说，写法更简单，有兴趣的读者可以尝试使用。</a></p>\n<h3 id=\"为一个函数打桩-1\"><a href=\"#为一个函数打桩-1\" class=\"headerlink\" title=\"为一个函数打桩\"></a>为一个函数打桩</h3><p>Exec是infra层的一个操作函数，实现很简单，代码如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Exec</span><span class=\"params\">(cmd <span class=\"type\">string</span>, args ...<span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    cmdpath, err := exec.LookPath(cmd)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Errorf(<span class=\"string\">&quot;exec.LookPath err: %v, cmd: %s&quot;</span>, err, cmd)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, infra.ErrExecLookPathFailed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> output []<span class=\"type\">byte</span></span><br><span class=\"line\">    output, err = exec.Command(cmdpath, args...).CombinedOutput()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Errorf(<span class=\"string\">&quot;exec.Command.CombinedOutput err: %v, cmd: %s&quot;</span>, err, cmd)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, infra.ErrExecCombinedOutputFailed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;CMD[&quot;</span>, cmdpath, <span class=\"string\">&quot;]ARGS[&quot;</span>, args, <span class=\"string\">&quot;]OUT[&quot;</span>, <span class=\"type\">string</span>(output), <span class=\"string\">&quot;]&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">string</span>(output), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Monkey的API非常简单和直接，我们直接看打桩代码：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">    . <span class=\"string\">&quot;github.com/smartystreets/goconvey/convey&quot;</span></span><br><span class=\"line\">    . <span class=\"string\">&quot;github.com/bouk/monkey&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;infra/osencap&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> any = <span class=\"string\">&quot;any&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestExec</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    Convey(<span class=\"string\">&quot;test has digit&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        Convey(<span class=\"string\">&quot;for succ&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            outputExpect := <span class=\"string\">&quot;xxx-vethName100-yyy&quot;</span></span><br><span class=\"line\">            guard := Patch(</span><br><span class=\"line\">            \tosencap.Exec, </span><br><span class=\"line\">            \t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ <span class=\"type\">string</span>, _ ...<span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">return</span> outputExpect, <span class=\"literal\">nil</span></span><br><span class=\"line\">            \t&#125;)</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> guard.Unpatch()</span><br><span class=\"line\">            output, err := osencap.Exec(any, any)</span><br><span class=\"line\">            So(output, ShouldEqual, outputExpect)</span><br><span class=\"line\">            So(err, ShouldBeNil)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Patch是Monkey提供给用户用于函数打桩的API：</span><br><span class=\"line\"></span><br><span class=\"line\">第一个参数是目标函数的函数名</span><br><span class=\"line\">第二个参数是桩函数的函数名，习惯用法是匿名函数或闭包</span><br><span class=\"line\">返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为一个过程打桩-1\"><a href=\"#为一个过程打桩-1\" class=\"headerlink\" title=\"为一个过程打桩\"></a>为一个过程打桩</h3><p>当一个函数没有返回值时，该函数我们一般称为过程。很多时候，我们将资源清理类函数定义为过程。<br>我们对过程DestroyResource的打桩代码为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guard := Patch(DestroyResource, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> guard.Unpatch()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为一个方法打桩\"><a href=\"#为一个方法打桩\" class=\"headerlink\" title=\"为一个方法打桩\"></a>为一个方法打桩</h3><p>当微服务有多个实例时，先通过Etcd选举一个Master实例，然后Master实例为所有实例较均匀的分配任务，并将任务分配结果Set到Etcd，最后Master和Node实例Watch到任务列表，并过滤出自身需要处理的任务列表。</p>\n<p>我们用类Etcd的方法Get来模拟获取任务列表的功能，入参为instanceId：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Etcd <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Etcd)</span></span> Get(instanceId <span class=\"type\">string</span>) []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    taskList := <span class=\"built_in\">make</span>([]<span class=\"type\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> taskList</span><br><span class=\"line\">我们对Get方法的打桩代码如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> e *Etcd</span><br><span class=\"line\">guard := PatchInstanceMethod(</span><br><span class=\"line\">\treflect.TypeOf(e), </span><br><span class=\"line\">\t<span class=\"string\">&quot;Get&quot;</span>, </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ *Etcd, _ <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;task1&quot;</span>, <span class=\"string\">&quot;task5&quot;</span>, <span class=\"string\">&quot;task8&quot;</span>&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> guard.Unpatch()</span><br><span class=\"line\">　　PatchInstanceMethod API是Monkey提供给用户用于方法打桩的API：</span><br><span class=\"line\"></span><br><span class=\"line\">在使用前，先要定义一个目标类的指针变量x</span><br><span class=\"line\">第一个参数是reflect.TypeOf(x)</span><br><span class=\"line\">第二个参数是字符串形式的函数名</span><br><span class=\"line\">返回值是一个PatchGuard对象指针，主要用于在测试结束时删除当前的补丁</span><br><span class=\"line\">Monkey的更多用法以及Monkey和前几种框架的组合使用方法</span><br></pre></td></tr></table></figure>\n<h2 id=\"Mock场景最佳实践\"><a href=\"#Mock场景最佳实践\" class=\"headerlink\" title=\"Mock场景最佳实践\"></a>Mock场景最佳实践</h2><h3 id=\"实例函数Mock：Monkey\"><a href=\"#实例函数Mock：Monkey\" class=\"headerlink\" title=\"实例函数Mock：Monkey\"></a>实例函数Mock：Monkey</h3><p>Monkey用于对依赖的函数进行Mock替换，从而可以完成仅针对当前模块的单元测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子：</span><br><span class=\"line\"></span><br><span class=\"line\">test包是真实的函数</span><br><span class=\"line\">mock_test包是即将用于mock的函数</span><br><span class=\"line\"></span><br><span class=\"line\">test.<span class=\"keyword\">go</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PrintAdd</span><span class=\"params\">(a, b <span class=\"type\">uint32</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;a:%v+b:%v&quot;</span>, a, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SumTest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*SumTest)</span></span>PrintSum(a, b <span class=\"type\">uint32</span>) <span class=\"type\">string</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;a:%v+b:%v&quot;</span>, a, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mock_test.<span class=\"keyword\">go</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> mock_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;test/24_mock/test&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PrintAdd</span><span class=\"params\">(a, b <span class=\"type\">uint32</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;a:%v+b:%v=%v&quot;</span>, a, b, a+b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对应test文件夹下的PrintSum</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PrintSum</span><span class=\"params\">(_ *test.SumTest, a, b <span class=\"type\">uint32</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;a:%v+b:%v=%v&quot;</span>, a, b,a+b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">main.<span class=\"keyword\">go</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">     monkey.Patch(test.PrintAdd, mock_test.PrintAdd)</span><br><span class=\"line\">     p := test.PrintAdd(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">     fmt.Println(p)</span><br><span class=\"line\">     monkey.UnpatchAll() <span class=\"comment\">//解除所有替换</span></span><br><span class=\"line\">     p = test.PrintAdd(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">     fmt.Println(p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">     structSum := &amp;test.SumTest&#123;&#125;</span><br><span class=\"line\">     <span class=\"comment\">//para1:获取实例的反射类型,para2:被替换的方法名,para3:替换方法</span></span><br><span class=\"line\">     monkey.PatchInstanceMethod(reflect.TypeOf(structSum), <span class=\"string\">&quot;PrintSum&quot;</span>, mock_test.PrintSum)</span><br><span class=\"line\">     p := structSum.PrintSum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">     fmt.Println(p)</span><br><span class=\"line\">     monkey.UnpatchAll() <span class=\"comment\">//解除所有替换</span></span><br><span class=\"line\">     p = structSum.PrintSum(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">     fmt.Println(p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"未实现函数Mock：GoMock\"><a href=\"#未实现函数Mock：GoMock\" class=\"headerlink\" title=\"未实现函数Mock：GoMock\"></a>未实现函数Mock：GoMock</h3><p>假设场景：Company公司、Person人。</p>\n<p>公司可以开会。<br>公司内部的人继承了Talker讨论者接口，拥有SayHello说话的方法。</p>\n<p>假如现在要测试这个场景，在所有类都实现的情况下，测试应该是这样的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//正常测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCompany_Meeting</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//直接调用Person类的New方法，创建一个Person对象</span></span><br><span class=\"line\">\ttalker := NewPerson(<span class=\"string\">&quot;小微&quot;</span>, <span class=\"string\">&quot;语音服务助手&quot;</span>)</span><br><span class=\"line\">\tcompany := NewCompany(talker)</span><br><span class=\"line\">\tt.Log(company.Meeting(<span class=\"string\">&quot;lyt&quot;</span>, <span class=\"string\">&quot;intern&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　但现在Person类并未实现，则可以通过GoMock工具来模拟一个Person对象。</span><br><span class=\"line\"></span><br><span class=\"line\">　　定义一个Talker.<span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> pojo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Talker <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">   SayHello(word, role <span class=\"type\">string</span>) (response <span class=\"type\">string</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">根据该接口，用mockgen命令生成一个Mock对象</span><br><span class=\"line\"></span><br><span class=\"line\">mockgen [-source] [-destination] [-<span class=\"keyword\">package</span>] ... Talker.<span class=\"keyword\">go</span></span><br><span class=\"line\">　　接着进行测试用例的编写：</span><br><span class=\"line\"></span><br><span class=\"line\">NewController(): 新建Mock控制器</span><br><span class=\"line\">NewMockXXX(): 新建Mock对象，这里是调用NewMockTalker()</span><br><span class=\"line\">talker.EXPECT().XXX().XXX()..：撰写一些断言测试</span><br><span class=\"line\">之前Mock建立的对象传入到待测方法当中</span><br><span class=\"line\">测试结果通过testing框架返回</span><br><span class=\"line\"><span class=\"comment\">//通过Mock测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCompany_Meeting2</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//新建Mock控制器</span></span><br><span class=\"line\">   ctrl := gomock.NewController(t)</span><br><span class=\"line\">   <span class=\"comment\">//新建Mock对象-Talker</span></span><br><span class=\"line\">   talker := mock_pojo.NewMockTalker(ctrl)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//断言</span></span><br><span class=\"line\">   talker.EXPECT().SayHello(gomock.Eq(<span class=\"string\">&quot;震天嚎&quot;</span>), gomock.Eq(<span class=\"string\">&quot;学生&quot;</span>)).Return(<span class=\"string\">&quot;Hello Faker(身份：学生), welcome to GoLand IDE. My name is 震天嚎&quot;</span>)</span><br><span class=\"line\">   <span class=\"comment\">//mock对象传入方法</span></span><br><span class=\"line\">   company := NewCompany(talker)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//Pass的例子</span></span><br><span class=\"line\">   t.Log(company.Meeting(<span class=\"string\">&quot;震天嚎&quot;</span>, <span class=\"string\">&quot;学生&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//报错的例子</span></span><br><span class=\"line\">   <span class=\"comment\">//t.Log(company.Meeting(&quot;小白&quot;, &quot;学生&quot;))</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"系统内置函数Mock：Monkey\"><a href=\"#系统内置函数Mock：Monkey\" class=\"headerlink\" title=\"系统内置函数Mock：Monkey\"></a>系统内置函数Mock：Monkey</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey.Patch(json.Unmarshal, mockUnmarshal)，用Monkey的patch来mock系统内置函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockUnmarshal</span><span class=\"params\">(b []<span class=\"type\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span>&#123;</span><br><span class=\"line\">   v = &amp;Common.LoginMessage&#123;</span><br><span class=\"line\">      UserId: <span class=\"number\">1</span>,</span><br><span class=\"line\">      UserName: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">      UserPwd: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">如果需要取消替换，可以使用</span><br><span class=\"line\"></span><br><span class=\"line\">monkey.UnPatch(target <span class=\"keyword\">interface</span>&#123;&#125;)\t<span class=\"comment\">//解除单个Patch</span></span><br><span class=\"line\">monkey.UnPatchAll()    \t\t\t\t<span class=\"comment\">//解除所有Patch</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据库行为Mock：sqlmock\"><a href=\"#数据库行为Mock：sqlmock\" class=\"headerlink\" title=\"数据库行为Mock：sqlmock\"></a>数据库行为Mock：sqlmock</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSql</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;fail to open sqlmock db: &quot;</span>, err)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> db.Close()</span><br><span class=\"line\">   rows := sqlmock.NewRows([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;pwd&quot;</span>&#125;).</span><br><span class=\"line\">      AddRow(<span class=\"number\">1</span>, <span class=\"string\">&quot;apple&quot;</span>).</span><br><span class=\"line\">      AddRow(<span class=\"number\">2</span>, <span class=\"string\">&quot;banana&quot;</span>)</span><br><span class=\"line\">   mock.ExpectQuery(<span class=\"string\">&quot;SELECT id, pwd FROM users&quot;</span>).WillReturnRows(rows)</span><br><span class=\"line\">   res, err := db.Query(<span class=\"string\">&quot;SELECT id, pwd FROM users&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;fail to match expected sql.&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> res.Close()</span><br><span class=\"line\">   <span class=\"keyword\">for</span> res.Next() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> id <span class=\"type\">int</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> pwd <span class=\"type\">string</span></span><br><span class=\"line\">      res.Scan(&amp;id, &amp;pwd)</span><br><span class=\"line\">      fmt.Printf(<span class=\"string\">&quot;Sql Result:\\tid = %d, password = %s.\\n&quot;</span>,id, pwd)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> res.Err() != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;Result Return Error!&quot;</span>, res.Err())</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务器行为Mock：httptest\"><a href=\"#服务器行为Mock：httptest\" class=\"headerlink\" title=\"服务器行为Mock：httptest\"></a>服务器行为Mock：httptest</h3><p>使用net&#x2F;http&#x2F;httptest模拟服务器行为</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestHttp</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   handler := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">      io.WriteString(w, <span class=\"string\">&quot;&#123; \\&quot;status\\&quot;: \\&quot;expected service response\\&quot;&#125;&quot;</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   req := httptest.NewRequest(<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;https://test.net&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">   w := httptest.NewRecorder()</span><br><span class=\"line\">   handler(w, req)<span class=\"comment\">//处理该Request</span></span><br><span class=\"line\"></span><br><span class=\"line\">   resp := w.Result()</span><br><span class=\"line\">   body, _ := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">   fmt.Println(resp.StatusCode)</span><br><span class=\"line\">   fmt.Println(resp.Header.Get(<span class=\"string\">&quot;Content-Type&quot;</span>))</span><br><span class=\"line\">   fmt.Println(<span class=\"type\">string</span>(body))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">　　这里只使用了Monkey的Patch进行简单测试，但在更一般的情况下，更多的函数还是通过实例函数来编写的，对这部分函数要用PatchInstanceMethod才可以进行替换。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">func PatchInstanceMethod(target reflect.Type, methodName string, replacement interface&#123;&#125;)</span></span><br><span class=\"line\"><span class=\"string\">`</span>接收三个参数：</span><br><span class=\"line\"></span><br><span class=\"line\">reflect.Tpye通过新建一个待测实例对象，调用reflect包的TypeOf()方法就可以得到</span><br><span class=\"line\">methodName是待测实例对象的函数名</span><br><span class=\"line\">replacement是用于替换的函数</span><br><span class=\"line\">实现如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ts *utils.Transfer</span><br><span class=\"line\">monkey.PatchInstanceMethod(reflect.TypeOf(ts), <span class=\"string\">&quot;WritePkg&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ *utils.Transfer, _ []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">假设有如下一个函数ServerProcessLogin，用于接收用户名密码，向当前连接的服务器请求登陆，测试如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestServerProcessLogin</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   mess := &amp;Common.Message&#123;</span><br><span class=\"line\">      Type: Common.LoginMesType,</span><br><span class=\"line\">      Data: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   user := &amp;UserProcess&#123;</span><br><span class=\"line\">      Conn: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//对涉及到的单元以外系统函数打Patch</span></span><br><span class=\"line\">   monkey.Patch(json.Unmarshal, mockUnmarshal)</span><br><span class=\"line\">   monkey.Patch(json.Marshal, mockMarshal)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//单元测试不涉及实际服务器，故对实例函数Login，WritePkg打Patch</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> udao *model.UserDao</span><br><span class=\"line\">   monkey.PatchInstanceMethod(reflect.TypeOf(udao), <span class=\"string\">&quot;Login&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ *model.UserDao, _ <span class=\"type\">int</span>, _ <span class=\"type\">string</span>)</span></span> (*Common.User,<span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &amp;Common.User&#123;</span><br><span class=\"line\">         UserId: <span class=\"number\">1</span>,</span><br><span class=\"line\">         UserName: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">         UserPwd: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">      &#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">var</span> ts *utils.Transfer</span><br><span class=\"line\">   monkey.PatchInstanceMethod(reflect.TypeOf(ts),<span class=\"string\">&quot;WritePkg&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ *utils.Transfer, _ []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//执行测试</span></span><br><span class=\"line\">   convey.Convey(<span class=\"string\">&quot;Test Server Login.&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      err := user.ServerProcessLogin(mess)</span><br><span class=\"line\">      convey.So(err, convey.ShouldBeNil)</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   monkey.UnpatchAll()</span><br><span class=\"line\">   <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于替换的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockUnmarshal</span><span class=\"params\">(b []<span class=\"type\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span>&#123;</span><br><span class=\"line\">   v = &amp;Common.LoginMessage&#123;</span><br><span class=\"line\">      UserId: <span class=\"number\">1</span>,</span><br><span class=\"line\">      UserName: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">      UserPwd: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockMarshal</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> ([]<span class=\"type\">byte</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> rer = []<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;m&#x27;</span>,<span class=\"string\">&#x27;i&#x27;</span>,<span class=\"string\">&#x27;n&#x27;</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> rer, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"具体案例：聊天室\"><a href=\"#具体案例：聊天室\" class=\"headerlink\" title=\"具体案例：聊天室\"></a>具体案例：聊天室</h2><h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>该项目是一个具有登录、查看在线用户、私聊、群聊等功能的命令行聊天室Demo。</p>\n<p>项目分为Client、Server子项目，都通过model、Controllor(Processor）、View（Main）来进行功能划分。还有一个Common包放置通用性的工具类。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├─Client</span><br><span class=\"line\">│  ├─main</span><br><span class=\"line\">│  ├─model</span><br><span class=\"line\">│  ├─processor</span><br><span class=\"line\">│  └─utils</span><br><span class=\"line\">├─Common</span><br><span class=\"line\">└─Server</span><br><span class=\"line\">    ├─main</span><br><span class=\"line\">    ├─model</span><br><span class=\"line\">    ├─processor</span><br><span class=\"line\">    └─utils</span><br></pre></td></tr></table></figure>\n<p>预期目的：对实现的功能模块补充单元测试代码，度量确保每一个模块的功能的正确性、完整性、健壮性，并在未来修改代码后也能第一时间自测验收。</p>\n<p>单元测试应包括模块接口测试、模块局部数据结构测试、模块异常处理测试。</p>\n<p>对于接口测试，应对接口的传入参数测试样例设计进行全面的考察，判断每一个参数是否有是有必要的，参数间有没有冗余，进入函数体前引用的指针是否有错等等。</p>\n<p>对于局部数据结构测试，应检查局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整性、正确性。局部数据结构往往是错误的根源，应仔细设计测试用例。</p>\n<p>对于异常处理，主要有如下几种常见错误</p>\n<ul>\n<li>输出的出错信息提示不足</li>\n<li>对异常没有进行处理</li>\n<li>出错信息与实际不相符</li>\n<li>出错信息中未能准确定位出错信息</li>\n</ul>\n<p>以上几种错误，都是模块中经常会出现的错误，要针对这些错误来进行边界条件测试检查，只有异常处理机制正确，日后软件的维护和迭代才会更加高效。</p>\n<p>在本案例中，Model层对服务层提供的接口不多，就WritePkg，ReadPkg两个核心函数，在服务层对其进行封装抽象为具体的业务逻辑。由于涉及网络连接，所以对其进行的测试必须编写桩函数。在服务层，涉及到对多个网络连接调用、数据库调用其它模块依赖，所以也要为其进行Mock。</p>\n<p>由于涉及Mock和桩函数编写，可以使用GoStub、Monkey两个包进行这些工作，它们较简洁地实现了很多实用的测试方式，只需要用户编写依赖的接口文件、用于替换的Mock函数，就可以仅在测试过程中替换掉系统函数或者其它依赖的功能模块，使得单元测试起到它应有的作用。</p>\n<h3 id=\"Model层、数据库相关测试\"><a href=\"#Model层、数据库相关测试\" class=\"headerlink\" title=\"Model层、数据库相关测试\"></a>Model层、数据库相关测试</h3><p>由于是单元测试，所以需要获取一个Mock数据库实例，测试增删改查SQL语句是否可执行。userDao_test.go代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">   sql1 = <span class=\"string\">&quot;SELECT id, pwd FROM users&quot;</span></span><br><span class=\"line\">   sql2 = <span class=\"string\">&quot;DELETE FROM users where id &gt; 600 and id &lt; 700&quot;</span></span><br><span class=\"line\">   sql3 = <span class=\"string\">&quot;update users set pwd = newPwd where id = 1 and id = 2&quot;</span></span><br><span class=\"line\">   sql4 = <span class=\"string\">&quot;INSERT INTO users (id, pwd) VALUES (405, &#x27;Lyt&#x27;)&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetUserById</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;fail to open sqlmock db: &quot;</span>, err)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> db.Close()</span><br><span class=\"line\">   rows1 := sqlmock.NewRows([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;pwd&quot;</span>&#125;).</span><br><span class=\"line\">      AddRow(<span class=\"number\">1</span>, <span class=\"string\">&quot;apple&quot;</span>).</span><br><span class=\"line\">      AddRow(<span class=\"number\">2</span>, <span class=\"string\">&quot;banana&quot;</span>)</span><br><span class=\"line\">   rows2 := sqlmock.NewRows([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;pwd&quot;</span>&#125;).</span><br><span class=\"line\">      AddRow(<span class=\"number\">601</span>, <span class=\"string\">&quot;goland&quot;</span>).</span><br><span class=\"line\">      AddRow(<span class=\"number\">602</span>, <span class=\"string\">&quot;java&quot;</span>)</span><br><span class=\"line\">   rows3 := sqlmock.NewRows([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;pwd&quot;</span>&#125;).</span><br><span class=\"line\">      AddRow(<span class=\"number\">1</span>, <span class=\"string\">&quot;newPwd&quot;</span>).</span><br><span class=\"line\">      AddRow(<span class=\"number\">2</span>, <span class=\"string\">&quot;newPwd&quot;</span>)</span><br><span class=\"line\">   rows4 := sqlmock.NewRows([]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;id&quot;</span>, <span class=\"string\">&quot;pwd&quot;</span>&#125;).</span><br><span class=\"line\">      AddRow(<span class=\"number\">405</span>, <span class=\"string\">&quot;Lyt&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   mock.ExpectQuery(sql1).WillReturnRows(rows1)</span><br><span class=\"line\">   mock.ExpectQuery(sql2).WillReturnRows(rows2)</span><br><span class=\"line\">   mock.ExpectQuery(sql3).WillReturnRows(rows3)</span><br><span class=\"line\">   mock.ExpectQuery(sql4).WillReturnRows(rows4)</span><br><span class=\"line\"></span><br><span class=\"line\">   assert.New(t)</span><br><span class=\"line\">   <span class=\"keyword\">var</span> tests = []<span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">      inputSql <span class=\"type\">string</span></span><br><span class=\"line\">      expected <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">   &#125; &#123;</span><br><span class=\"line\">      &#123;sql1,<span class=\"literal\">nil</span>&#125;,</span><br><span class=\"line\">      &#123;sql2,<span class=\"literal\">nil</span>&#125;,</span><br><span class=\"line\">      &#123;sql3,<span class=\"literal\">nil</span>&#125;,</span><br><span class=\"line\">      &#123;sql4, <span class=\"literal\">nil</span>&#125;,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> _, test := <span class=\"keyword\">range</span> tests &#123;</span><br><span class=\"line\">      res, err := db.Query(test.inputSql)</span><br><span class=\"line\">      assert.Equal(t, err, test.expected)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> res.Next() &#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> id <span class=\"type\">int</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> pwd <span class=\"type\">string</span></span><br><span class=\"line\">         res.Scan(&amp;id, &amp;pwd)</span><br><span class=\"line\">         fmt.Printf(<span class=\"string\">&quot;Sql Result:\\tid = %d, password = %s.\\n&quot;</span>,id, pwd)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      assert.Equal(t, res.Err(), test.expected)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"私聊功能测试\"><a href=\"#私聊功能测试\" class=\"headerlink\" title=\"私聊功能测试\"></a>私聊功能测试</h3><p>由于涉及底层数据库交互时需要发送JSON转码字符串（WritePkg函数），因此将其Mock处理，只需关注本函数逻辑是否正确即可。smsProcess_test.go如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSmsProcess_SendOnePerson</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> conn net.Conn</span><br><span class=\"line\">   tf := &amp;utils.Transfer&#123;</span><br><span class=\"line\">      Conn: conn,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   monkey.PatchInstanceMethod(reflect.TypeOf(tf), <span class=\"string\">&quot;WritePkg&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ *utils.Transfer,_ []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   convey.Convey(<span class=\"string\">&quot;test send one person:&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      err := tf.WritePkg([]<span class=\"type\">byte</span>&#123;&#125;)</span><br><span class=\"line\">      convey.So(err, convey.ShouldBeNil)</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;OK.&quot;</span>)</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"登录功能测试\"><a href=\"#登录功能测试\" class=\"headerlink\" title=\"登录功能测试\"></a>登录功能测试</h3><p>登录涉及服务器连接操作，服务器的连接逻辑可通过httptest包来进行检测，Mock一个HTTP连接，示例代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestHttp</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   handler := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// here we write our expected response, in this case, we return a</span></span><br><span class=\"line\">      <span class=\"comment\">// JSON string which is typical when dealing with REST APIs</span></span><br><span class=\"line\">      io.WriteString(w, <span class=\"string\">&quot;&#123; \\&quot;status\\&quot;: \\&quot;expected service response\\&quot;&#125;&quot;</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   req := httptest.NewRequest(<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;https://test.net&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">   w := httptest.NewRecorder()</span><br><span class=\"line\">   handler(w, req)</span><br><span class=\"line\"></span><br><span class=\"line\">   resp := w.Result()</span><br><span class=\"line\">   body, _ := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">   fmt.Println(resp.StatusCode)</span><br><span class=\"line\">   fmt.Println(resp.Header.Get(<span class=\"string\">&quot;Content-Type&quot;</span>))</span><br><span class=\"line\">   fmt.Println(<span class=\"type\">string</span>(body))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">　　为登录模块编写用于测试替换的函数以及单元测试主体，userProcess_test.<span class=\"keyword\">go</span>代码如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockUnmarshal</span><span class=\"params\">(b []<span class=\"type\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">   v = &amp;Common.LoginMessage&#123;</span><br><span class=\"line\">      UserId:   <span class=\"number\">1</span>,</span><br><span class=\"line\">      UserName: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">      UserPwd:  <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockMarshal</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> ([]<span class=\"type\">byte</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> rer = []<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> rer, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestServerProcessLogin</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">   mess := &amp;Common.Message&#123;</span><br><span class=\"line\">      Type: Common.LoginMesType,</span><br><span class=\"line\">      Data: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   user := &amp;UserProcess&#123;</span><br><span class=\"line\">      Conn: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//对涉及到的单元以外系统函数打Patch</span></span><br><span class=\"line\">   monkey.Patch(json.Unmarshal, mockUnmarshal)</span><br><span class=\"line\">   monkey.Patch(json.Marshal, mockMarshal)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//对实例函数打Patch</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> udao *model.UserDao</span><br><span class=\"line\">   monkey.PatchInstanceMethod(reflect.TypeOf(udao), <span class=\"string\">&quot;Login&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ *model.UserDao, _ <span class=\"type\">int</span>, _ <span class=\"type\">string</span>)</span></span> (*Common.User, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &amp;Common.User&#123;</span><br><span class=\"line\">         UserId:   <span class=\"number\">1</span>,</span><br><span class=\"line\">         UserName: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">         UserPwd:  <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">      &#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">var</span> ts *utils.Transfer</span><br><span class=\"line\">   monkey.PatchInstanceMethod(reflect.TypeOf(ts), <span class=\"string\">&quot;WritePkg&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(_ *utils.Transfer, _ []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   <span class=\"comment\">//执行测试</span></span><br><span class=\"line\">   convey.Convey(<span class=\"string\">&quot;Test Server Login.&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      err := user.ServerProcessLogin(mess)</span><br><span class=\"line\">      convey.So(err, convey.ShouldBeNil)</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   monkey.UnpatchAll()</span><br><span class=\"line\">   <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"工具类测试\"><a href=\"#工具类测试\" class=\"headerlink\" title=\"工具类测试\"></a>工具类测试</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">utils_test.<span class=\"keyword\">go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockRead</span><span class=\"params\">(conn net.Conn, _ []<span class=\"type\">byte</span>)</span></span> (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">4</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockMarshal</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> ([]<span class=\"type\">byte</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> []<span class=\"type\">byte</span>&#123;<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mockUnmarshal</span><span class=\"params\">(data []<span class=\"type\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransfer_ReadPkg</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   monkey.Patch(net.Conn.Read, mockRead)</span><br><span class=\"line\">   monkey.Patch(json.Marshal, mockMarshal)</span><br><span class=\"line\">   monkey.Patch(json.Unmarshal, mockUnmarshal)</span><br><span class=\"line\"></span><br><span class=\"line\">   listen, _ := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;localhost:8888&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> listen.Close()</span><br><span class=\"line\">   <span class=\"keyword\">go</span> net.Dial(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;localhost:8888&quot;</span>)</span><br><span class=\"line\">   <span class=\"keyword\">var</span> c net.Conn</span><br><span class=\"line\">   <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      c, _ = listen.Accept()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> c != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   transfer := &amp;Transfer&#123;</span><br><span class=\"line\">      Conn: c,</span><br><span class=\"line\">      Buf : [<span class=\"number\">8096</span>]<span class=\"type\">byte</span>&#123;<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>&#125;,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   convey.Convey(<span class=\"string\">&quot;test ReadPkg&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      mes, err := transfer.ReadPkg()</span><br><span class=\"line\">      convey.So(err, convey.ShouldBeNil)</span><br><span class=\"line\">      convey.So(mes, convey.ShouldEqual, <span class=\"string\">&quot;ab&quot;</span>)</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   monkey.UnpatchAll()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransfer_WritePkg</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   monkey.Patch(json.Marshal, mockMarshal)</span><br><span class=\"line\">   monkey.Patch(json.Unmarshal, mockUnmarshal)</span><br><span class=\"line\">   transfer := &amp;Transfer&#123;</span><br><span class=\"line\">      Conn: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">      Buf : [<span class=\"number\">8096</span>]<span class=\"type\">byte</span>&#123;&#125;,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   convey.Convey(<span class=\"string\">&quot;test ReadPkg&quot;</span>, t, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      err := transfer.WritePkg([]<span class=\"type\">byte</span>&#123;<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>&#125;)</span><br><span class=\"line\">      convey.So(err, convey.ShouldBeNil)</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\">   monkey.UnpatchAll()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"项目总结\"><a href=\"#项目总结\" class=\"headerlink\" title=\"项目总结\"></a>项目总结</h3><p>在编写桩模块时会发现，模块之间的调用关系在工程规模并不大的本案例中，也依然比较复杂，需要开发相应桩函数，代码量会增加许多，也会消耗一些开发人员的时间，因此反推到之前流程的开发实践中，可以得出结论就是提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。</p>\n<p>Go单元测试框架是相当易用的，其它的第三方库基本都是建立在testing原生框架的基础上进行的增补扩充，在日常开发中，原生包可以满足基本需求，但同样也有缺陷，原生包不提供断言的语法使得代码中的这种片段非常多：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以引入了convey、assert包的断言语句，用于简化判断逻辑，使得程序更加易读。</p>\n<p>在完成项目单测时，遇到了不少问题，比较重要的比如由于架构分层不够清晰，还是有部分耦合代码，导致单测时需要屏蔽的模块太多，代码写起来不便。因此还是需要倒推到开发模块之前，就要设计更好的结构，在开发的过程中遵循相应的规则，通过测试先行的思想，使开发的工程具有更好的可测试性。</p>\n<p>开发过程中遇到的场景肯定不局限于本文所讨论的范围，有关更丰富的最佳实践案例可以参照：</p>\n<p>go-sqlmock<br>go-mock</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><h3 id=\"实践小结\"><a href=\"#实践小结\" class=\"headerlink\" title=\"实践小结\"></a>实践小结</h3><ol>\n<li>单元测试大多是由开发人员进行编写，本篇文章旨在指引，不在于面面俱到，具体的单元测试框架的使用语法，开发同学可以自行Google。</li>\n<li>以测试的角度，推行单元测试是不易的，最佳的方式莫过于开发人员，在一定的指引之后，以实际项目出发进行实践，然后自行总结具体的case，有针对性、有感染力进行内部分享，测试同学及时提供测试用例的指引和规范的约束。</li>\n<li>基于interface的mock是最佳实践。《单元测试的艺术》有讲，作者经验很丰富。google认为单测的核心轮子就是mock技术和测试运行框架。golang自带运行框架，官方直接搞个gomock补全了两个核心。gomock对expect，而且支持expect几次，等等细节的支持，功能强大。</li>\n<li>Table-Driven是最佳实践。测试还小的时候，直接gotests生成。挺好。被测数据空间大，就把被测数据放进testdata。gotests+convey，我认为是最佳实践。</li>\n</ol>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><p>书籍《google的软件测试之道》<br>书籍《单元测试的艺术》</p>\n","slug":"Go-单测","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/04/Go-%E5%8D%95%E6%B5%8B/","excerpt":"单测系列-Go本文整理学习Go单测相关内容总结在Go中如何做单测，本文介绍了单测是什么以及Go常用的单测框架和工具","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"单测","slug":"单测","permalink":"http://vwin.github.io/tags/%E5%8D%95%E6%B5%8B/"},{"name":"go","slug":"go","permalink":"http://vwin.github.io/tags/go/"}]},{"title":"Python-单测","date":"2022-11-03T11:48:27.000Z","path":"2022/11/03/Python-单测/","text":"单测系列-Python总结在Python中如何做单测，本文介绍了Python常用的单测框架和工具 常用Python单测框架 Unittest Nose Pytest 特点 Python标准库中自带的单元测试框架。 Python的一个第三方单元测试框架，带插件的unittest。nose停止维护了，nose2并不支持nose的全部功能。 Python的一个第三方单元测试框架，丰富的插件生态，兼容unittest和nose测试集， 社区繁荣 Mock框架 unittest.mock unittest.mock pytest-mock 推荐指数 ★★★★☆ ★★☆☆☆ ★★★★★ 若你不想安装或不允许第三方库，那么 unittest 是最好也是唯一的选择。反之，pytest 无疑是最佳选择，众多 Python 开源项目（如大名鼎鼎的 requests）都是使用 pytest 作为单元测试框架。甚至，连 nose2 在官方文档上都建议大家使用 pytest。我们知道，nose已经进入了维护模式，取代者是nose2。相比nose2，pytest的生态无疑更具优势，社区的活跃度也更高。 总体来说，unittest用例格式复杂，兼容性无，插件少，二次开发方便。pytest更加方便快捷，用例格式简单，可以执行unittest风格的测试用例，较好的兼容性，插件丰富。 unittest基本概念unittest中最核心的四个概念是：test fixture、test case、test suite、test runner 。 test fixture：表示执行一个或多个测试所需的准备，以及任何关联的清理操作。例如这可能涉及创建临时或代理数据库、目录或启动服务器进程。 test case：测试用例是最小的测试单元。它检查特定的输入集的响应。单元测试提供了一个基类测试用例，可用于创建新的测试用例。 test suite：测试套件是测试用例、测试套件或两者的集合，用于归档需要一起执行的测试。 test runner：是一个用于执行和输出结果的组件。这个运行器可能使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。 编写规则编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。对每一类测试都需要编写一个test_xxx()方法。 简单示例目录结构123456789101112$ tree ..├── README.md├── requirements.txt└── src├── demo│ └── calculator.py└── tests└── demo├── __init__.py├── test_calculator_unittest.py└── test_calculator_unittest_with_fixture.py 计算器实现代码12345678910111213class Calculator: def add(self, a, b): return a + b def sub(self, a, b): return a - b def mul(self, a, b): return a * b def div(self, a, b): return a / b 计算器测试代码1234567891011121314151617181920212223242526272829303132333435import unittestfrom src.demo.calculator import Calculatorclass TestCalculator(unittest.TestCase): def test_add(self): c = Calculator() result = c.add(3, 5) self.assertEqual(result, 8) def test_sub(self): c = Calculator() result = c.sub(10, 5) self.assertEqual(result, 5) def test_mul(self): c = Calculator() result = c.mul(5, 7) self.assertEqual(result, 35) def test_div(self): c = Calculator() result = c.div(10, 5) self.assertEqual(result, 2)if __name__ == &#x27;__main__&#x27;: unittest.main()# 执行结果Ran 4 tests in 0.002sOK 用例前置和后置基于unittest的四个概念的理解，上述简单用例，可以修改为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import unittestfrom src.demo.calculator import Calculatorclass TestCalculatorWithFixture(unittest.TestCase): # 测试用例前置动作 def setUp(self): print(&quot;test start&quot;) # 测试用例后置动作 def tearDown(self): print(&quot;test end&quot;) def test_add(self): c = Calculator() result = c.add(3, 5) self.assertEqual(result, 8) def test_sub(self): c = Calculator() result = c.sub(10, 5) self.assertEqual(result, 5) def test_mul(self): c = Calculator() result = c.mul(5, 7) self.assertEqual(result, 35) def test_div(self): c = Calculator() result = c.div(10, 5) self.assertEqual(result, 2)if __name__ == &#x27;__main__&#x27;: # 创建测试套件 suit = unittest.TestSuite() suit.addTest(TestCalculatorWithFixture(&quot;test_add&quot;)) suit.addTest(TestCalculatorWithFixture(&quot;test_sub&quot;)) suit.addTest(TestCalculatorWithFixture(&quot;test_mul&quot;)) suit.addTest(TestCalculatorWithFixture(&quot;test_div&quot;)) # 创建测试运行器 runner = unittest.TestRunner() runner.run(suit) 参数化标准库的unittest自身不支持参数化测试，可以通过第三方库来支持：parameterized和ddt。 其中parameterized只需要一个装饰器@parameterized.expand，ddt需要三个装饰器@ddt、@data、@unpack，它们生成的test分别有一个名字，ddt会携带具体的参数信息。 parameterized123456789101112131415161718192021222324252627282930313233import unittestfrom parameterized import parameterized, paramfrom src.demo.calculator import Calculatorclass TestCalculator(unittest.TestCase): @parameterized.expand([ param(3, 5, 8), param(1, 2, 3), param(2, 2, 4) ]) def test_add(self, num1, num2, total): c = Calculator() result = c.add(num1, num2) self.assertEqual(result, total)if __name__ == &#x27;__main__&#x27;: unittest.main()# 执行结果test_add_0 (__main__.TestCalculator) ... oktest_add_1 (__main__.TestCalculator) ... oktest_add_2 (__main__.TestCalculator) ... ok----------------------------------------------------------------------Ran 3 tests in 0.000sOK ddt123456789101112131415161718192021222324252627282930import unittestfrom ddt import data, unpack, ddtfrom src.demo.calculator import Calculator@ddtclass TestCalculator(unittest.TestCase): @data((3, 5, 8),(1, 2, 3),(2, 2, 4)) @unpack def test_add(self, num1, num2, total): c = Calculator() result = c.add(num1, num2) self.assertEqual(result, total)if __name__ == &#x27;__main__&#x27;: unittest.main()# 执行结果test_add_1__3__5__8_ (__main__.TestCalculator) ... oktest_add_2__1__2__3_ (__main__.TestCalculator) ... oktest_add_3__2__2__4_ (__main__.TestCalculator) ... ok----------------------------------------------------------------------Ran 3 tests in 0.000sOK 断言unittest提供了丰富的断言，常用的包括： assertEqual、assertNotEqual、assertTrue、assertFalse、assertIn、assertNotIn等。 具体可以直接看源码提供的方法： nosenose已经进入维护模式，从github nose上可以看到，nose最近的一次代码提交还是在2016年5月4日。 继承nose的是nose2，但要注意的是，nose2并不支持nose的全部功能，它们的区别可以看这里。nose2的主要目的是扩展Python的标准单元测试库unittest，因此它的定位是“带插件的unittest”。nose2提供的插件，例如测试用例加载器，覆盖度报告生成器，并行测试等内置插件和第三方插件，让单元测试变得更加完善。 nose2的社区没有pytest的活跃，要使用高级框架，推荐使用pytest，因此下文不做过多详述。 编写规则nose2的测试用例并不限制于类，也可以直接使用函数。任何函数和类，只要名称匹配一定的条件(例如，以test开头或以test结尾等)，都会被自动识别为测试用例；为了兼容unittest, 所有的基于unitest编写的测试用例，也会被nose自动识别为。 简单示例计算器代码参考unittest的计算器代码部分。 计算器测试代码1234567891011121314151617181920212223242526272829303132333435363738import nose2from src.demo.calculator import Calculatordef test_add(): c = Calculator() result = c.add(3, 5) assert result == 8def test_sub(): c = Calculator() result = c.sub(10, 5) assert result == 5def test_mul(): c = Calculator() result = c.mul(5, 7) assert result == 35def test_div(): c = Calculator() result = c.div(10, 5) assert result == 2if __name__ == &#x27;__main__&#x27;: nose2.main()# 执行结果....----------------------------------------------------------------------Ran 4 tests in 0.000sOK 参数化123456789101112131415161718192021import nose2from nose2.tools import paramsfrom src.demo.calculator import Calculatortest_data = [ &#123;&quot;nums&quot;: (3, 5), &quot;total&quot;: 8&#125;, &#123;&quot;nums&quot;: (1, 2), &quot;total&quot;: 3&#125;, &#123;&quot;nums&quot;: (2, 2), &quot;total&quot;: 4&#125;]@params(*test_data)def test_add(data): c = Calculator() result = c.add(*data[&#x27;nums&#x27;]) assert result == data[&#x27;total&#x27;]if __name__ == &#x27;__main__&#x27;: nose2.main() pytest编写规则 测试文件以test_开头（以test结尾也可以） 测试类以Test开头，并且不能带有 init 方法 测试函数以test_开头 断言使用基本的assert即可 可以通过下面的命令，查看 Pytest 收集到哪些测试用例：1$ py.test --collect-only 简单示例计算器代码参考unittest的计算器代码部分。 计算器实现代码1234567891011121314151617181920212223242526272829303132333435363738394041import pytestfrom src.demo.calculator import Calculatorclass TestCalculator(): def test_add(self): c = Calculator() result = c.add(3, 5) assert result == 8 def test_sub(self): c = Calculator() result = c.sub(10, 5) assert result == 5 def test_mul(self): c = Calculator() result = c.mul(5, 7) assert result == 35 def test_div(self): c = Calculator() result = c.div(10, 5) assert result == 2if __name__ == &#x27;__main__&#x27;: pytest.main([&#x27;-s&#x27;, &#x27;test_calculator_pytest.py&#x27;])# 执行结果============================= test session starts ==============================platform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1rootdir: python-ut/src/tests/demoplugins: metadata-1.11.0, html-3.1.1collected 4 itemstest_calculator_pytest.py ....============================== 4 passed in 0.01s =============================== 用例前置和后置加上fixture夹具，有几种方式： 将夹具函数名称作为参数传递到测试用例函数当中 @pytest.mark.usefixtures(“夹具函数名称”) @pytest.fixture(autouse&#x3D;True)，设置了autouse，就可以不用上述两种手动方式，默认就会使用夹具1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import pytestfrom src.demo.calculator import Calculator@pytest.fixture()def set_up(): print(&quot;[pytest with fixture] start&quot;) yield print(&quot;[pytest with fixture] end&quot;)class TestCalculator(): def test_add(self, set_up): c = Calculator() result = c.add(3, 5) assert result == 8 def test_sub(self, set_up): c = Calculator() result = c.sub(10, 5) assert result == 5 @pytest.mark.usefixtures(&quot;set_up&quot;) def test_mul(self): c = Calculator() result = c.mul(5, 7) assert result == 35 @pytest.mark.usefixtures(&quot;set_up&quot;) def test_div(self): c = Calculator() result = c.div(10, 5) assert result == 2if __name__ == &#x27;__main__&#x27;: pytest.main([&#x27;-s&#x27;, &#x27;test_calculator_pytest_with_fixture.py&#x27;]) # 执行结果：============================= test session starts ==============================platform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1rootdir: python-ut/src/tests/demoplugins: metadata-1.11.0, html-3.1.1collected 4 itemstest_calculator_pytest_with_fixture.py [pytest with fixture] start.[pytest with fixture] end[pytest with fixture] start.[pytest with fixture] end[pytest with fixture] start.[pytest with fixture] end[pytest with fixture] start.[pytest with fixture] end============================== 4 passed in 0.01s =============================== 参数化基础知识如果只有一个参数，里面则是值的列表，比如@pytest.mark.parametrize(“num1”, [3, 5, 8])如果有多个参数，则需要用元祖来存放值，一个元祖对应一组参数的值，比如@pytest.mark.parametrize(“num1, num2, total”, [(3, 5, 8), (1, 2, 3), (2, 2, 4)])当装饰器 @pytest.mark.parametrize 装饰测试类时，会将数据集合传递给类的所有测试用例方法一个函数或一个类可以装饰多个 @pytest.mark.parametrize，当参数化有多个装饰器时，用例数是N*M… 参数化测试1234567891011121314151617181920212223242526import pytestfrom src.demo.calculator import Calculatorclass TestCalculator(): @pytest.mark.parametrize(&quot;num1, num2, total&quot;, [(3, 5, 8), (1, 2, 3), (2, 2, 4)]) def test_add(self, num1, num2, total): c = Calculator() result = c.add(num1, num2) assert result == totalif __name__ == &#x27;__main__&#x27;: pytest.main([&#x27;test_calculator_pytest_with_parameterize.py&#x27;])# 执行结果：============================= test session starts ==============================platform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1rootdir: python-ut/src/tests/demoplugins: metadata-1.11.0, html-3.1.1collected 3 itemstest_calculator_pytest_with_paramtrize.py ...============================== 3 passed in 0.01s =============================== 参数化标记数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TestCalculator(): @pytest.mark.parametrize(&quot;num1, num2, total&quot;, [ pytest.param(5, 1, 4, marks=pytest.mark.passed), pytest.param(5, 2, 4, marks=pytest.mark.fail), (5, 4, 1) ]) def test_sub(self, num1, num2, total): c = Calculator() result = c.sub(num1, num2) assert result == totalif __name__ == &#x27;__main__&#x27;: pytest.main([&#x27;test_calculator_pytest_with_parameterize.py&#x27;])# 执行结果：============================= test session starts ==============================platform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1rootdir: python-ut/src/tests/demoplugins: metadata-1.11.0, html-3.1.1collected 3 itemstest_calculator_pytest_with_paramtrize.py .F. [100%]=================================== FAILURES ===================================________________________ TestCalculator.test_sub[5-2-4] ________________________self = &lt;demo.test_calculator_pytest_with_paramtrize.TestCalculator object at 0x110813d00&gt;num1 = 5, num2 = 2, total = 4 @pytest.mark.parametrize(&quot;num1, num2, total&quot;, [ pytest.param(5, 1, 4, marks=pytest.mark.passed), pytest.param(5, 2, 4, marks=pytest.mark.fail), (5, 4, 1) ]) def test_sub(self, num1, num2, total): c = Calculator() result = c.sub(num1, num2)&gt; assert result == totalE assert 3 == 4test_calculator_pytest_with_paramtrize.py:21: AssertionError=========================== short test summary info ============================FAILED test_calculator_pytest_with_paramtrize.py::TestCalculator::test_sub[5-2-4]=================== 1 failed, 2 passed, 2 warnings in 0.04s ==================== 断言在unittest单元测试框架中提供了丰富的断言方法，例如assertEqual()、assertIn()、assertTrue()、assertIs()等，而pytest单元测试框架中并没提供特殊的断言方法，而是直接使用python的assert进行断言。 assert可以使用&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D;等符号来比较相等、不相等、小于、大于、大于等于和小于等于。 断言包含和不包含，使用assert a in b和assert a not in b 断言真假，使用assert condition和assert not condition 断言异常，使用pytest.raise获取信息12345678910# 详细断言异常def test_zero_division_long(): with pytest.raises(ZeroDivisionError) as excinfo: 1 / 0 # 断言异常类型 type assert excinfo.type == ZeroDivisionError # 断言异常 value 值 assert &quot;division by zero&quot; in str(excinfo.value) 重跑需要安装额外的插件pytest-rerunfailures 12345678910111213141516import pytest@pytest.mark.flaky(reruns=5)def test_example(): import random assert random.choice([True, False, False])执行结果:collecting ... collected 1 item11_reruns.py::test_example RERUN [100%]11_reruns.py::test_example PASSED [100%]========================= 1 passed, 1 rerun in 0.05s ========================== Mockmockmock原是python的第三方库，python3以后mock模块已经整合到了unittest测试框架中。 如果使用的是python3.3以后版本，那么不用单独安装，使用的时候在文件开头引入from unittest import mock即可。 如果使用的是python2，需要先pip install mock安装后再import mock即可。 Mock一个方法123456789101112131415161718192021222324import unittestfrom unittest import mockfrom src.demo.calculator import Calculatordef multiple(a, b): return a * bclass TestCalculator(unittest.TestCase): @mock.patch(&#x27;test_calculator_mock.multiple&#x27;) def test_function_multiple(self, mock_multiple): mock_return = 1 mock_multiple.return_value = mock_return result = multiple(3, 5) self.assertEqual(result, mock_return)if __name__ == &#x27;__main__&#x27;: unittest.main() Mock一个对象里面的方法分别给出了普通写法和注解写法，以及side_effect关键参数的效果案例。 12345678910111213141516171819202122232425262728293031323334353637383940import unittestfrom unittest import mockfrom src.demo.calculator import Calculatorclass TestCalculator(unittest.TestCase): def test_add(self): c = Calculator() mock_return = 10 c.add = mock.Mock(return_value=mock_return) result = c.add(3, 5) self.assertEqual(result, mock_return) def test_add_with_side_effect(self): c = Calculator() mock_return = 10 # 传递side_effect关键字参数, 会覆盖return_value参数值, 使用真实的add方法测试 c.add = mock.Mock(return_value=mock_return, side_effect=c.add) result = c.add(3, 5) self.assertEqual(result, 8) @mock.patch.object(Calculator, &#x27;add&#x27;) def test_add_with_annotation(self, mock_add): c = Calculator() mock_return = 10 mock_add.return_value = mock_return result = c.add(3, 5) self.assertEqual(result, mock_return)if __name__ == &#x27;__main__&#x27;: unittest.main() Mock每次调用返回不同的值123456789101112131415161718192021import unittestfrom unittest import mockfrom src.demo.calculator import Calculatorclass TestCalculator(unittest.TestCase): @mock.patch.object(Calculator, &#x27;add&#x27;) def test_add_with_different_return(self, mock_add): c = Calculator() mock_return = [10, 8] mock_add.side_effect = mock_return result1 = c.add(3, 5) result2 = c.add(3, 5) self.assertEqual(result1, mock_return[0]) self.assertEqual(result2, mock_return[1])if __name__ == &#x27;__main__&#x27;: unittest.main() Mock抛出异常的方法123456789101112131415161718192021222324252627282930import unittestfrom unittest import mockfrom src.demo.calculator import Calculator# 被调用函数def multiple(a, b):return a * b# 实际调用函数def is_error(a, b):try: return multiple(a, b)except Exception as e: return -1class TestCalculator(unittest.TestCase): @mock.patch(&#x27;test_calculator_mock.multiple&#x27;) def test_function_multiple_exception(self, mock_multiple): mock_multiple.side_effect = Exception result = is_error(3, 5) self.assertEqual(result, -1)if __name__ == &#x27;__main__&#x27;: unittest.main() Mock多个方法123456789101112131415161718192021222324import unittestfrom unittest import mockfrom src.demo.calculator import Calculatordef multiple(a, b):return a * bclass TestCalculator(unittest.TestCase): @mock.patch.object(Calculator, &#x27;add&#x27;) @mock.patch(&#x27;test_calculator_mock.multiple&#x27;) def test_both(self, mock_multiple, mock_add): c = Calculator() mock_add.return_value = 1 mock_multiple.return_value = 2 self.assertEqual(c.add(3, 5), 1) self.assertEqual(multiple(3, 5), 2)if __name__ == &#x27;__main__&#x27;: unittest.main() pytest-mock如果项目本身使用的框架是 pytest，则 Mock 更建议使用 pytest-mock 这个插件，它提供了一个名为mocker的fixture，仅在当前测试funciton或method生效，而不用自行包装。 mocker和mock.patch有相同的api，支持相同的参数。 简单示例12345678910111213141516171819import pytestfrom src.demo.calculator import Calculatorclass TestCalculator(): def test_add(self, mocker): c = Calculator() mock_return = 10 mocker.patch.object(c, &#x27;add&#x27;, return_value=mock_return) result = c.add(3, 5) assert result == mock_returnif __name__ == &#x27;__main__&#x27;: pytest.main([&#x27;-s&#x27;, &#x27;test_calculator_pytest_mock.py&#x27;]) mock方法和域123456789101112131415161718192021class ForTest: field = &#x27;origin&#x27; def method(): passdef test_for_test(mocker): test = ForTest() # 方法 mock_method = mocker.patch.object(test, &#x27;method&#x27;) test.method() # 检查行为 assert mock_method.called # 域 assert &#x27;origin&#x27; == test.field mocker.patch.object(test, &#x27;field&#x27;, &#x27;mocked&#x27;) # 检查结果 assert &#x27;mocked&#x27; == test.field monkeypatchmonkeypatch是pytest框架内置的固件，有时候，测试用例需要调用某些依赖于全局配置的功能，或者这些功能本身又调用了某些不容易测试的代码（例如：网络接入）。monkeypatch提供了一些方法，用于安全地修补和模拟测试中的功能： 123456789monkeypatch.setattr(obj, name, value, raising=True)monkeypatch.delattr(obj, name, raising=True)monkeypatch.setitem(mapping, name, value)monkeypatch.delitem(obj, name, raising=True)monkeypatch.setenv(name, value, prepend=False)monkeypatch.delenv(name, raising=True)monkeypatch.syspath_prepend(path)monkeypatch.chdir(path) 主要考虑以下情形： 修改测试的函数行为或类的属性 修改字典的值 修改测试环境的环境变量 在测试期间，用于修改和 更改当前工作目录的上下文。 单元测试覆盖率报告 coverage 是 Python 推荐使用的覆盖率统计工具。 pytest-cov 是 pytest 的插件，它可以让你在 pytest 中使用 cpverage.py。 HtmlTestRunner，需要在代码里面写入一点配置，但是报告生成比较美观。 coverage和pytest-cov只需要配置，就可直接使用，不需要测试代码配合。 coverage安装1pip install coverage 详情可参考：https://coverage.readthedocs.io/en/coverage-5.5/ 运行1coverage run -m unittest discover 运行结束之后，会生成一个覆盖率统计结果文件（data file）.coverage文件，在pycharm里可识别为一个数据库： 结果report1coverage report -m 执行结果如下： 12345678$ coverage report -mName Stmts Miss Cover Missing---------------------------------------------------------------------------------------------src/tests/demo/test_calculator_pytest_with_fixture.py 28 16 43% 8-10, 15-17, 20-22, 26-28, 32-34, 38src/tests/demo/test_calculator_pytest_with_parameterize.py 15 7 53% 9-11, 19-21, 25src/tests/demo/test_calculator_unittest.py 22 1 95% 31src/tests/demo/test_calculator_unittest_with_ddt.py 13 1 92% 18 html会生成htmlcov&#x2F;index.html文件，在浏览器查看： 1coverage html 点击各个py文件，可以查看详细情况。 html-testRunner安装1pip install html-testRunner 详细说明可参考HtmlTestRunner: https://github.com/oldani/HtmlTestRunner 运行在代码中加上HTMLTestRunner，如下 12345678910111213import HtmlTestRunner# some tests hereif __name__ == &#x27;__main__&#x27;:unittest.main(testRunner=HtmlTestRunner.HTMLTestRunner())如果是在测试套件中运行，换成HTMLTestRunner即可：# 创建测试运行器# runner = unittest.TestRunner()runner = HTMLTestRunner()runner.run(suit) 结果默认会生成reports&#x2F; 文件夹，按照时间显示报告： pytest-cov安装1pip install pytest-cov 详细可参考pytest-cov: https://github.com/pytest-dev/pytest-cov 运行1pytest --cov --cov-report=html 或者指定目录： 1pytest --cov=src --cov-report=html 结果会生成htmlcov&#x2F;index.html文件，在浏览器查看，类似于coverage的报告。 可能的问题报告没生成如果出现不了报告，pycharm运行的时候，记得选择python，而不是Python tests 在Pycharm中配置覆盖率展示可选择unittest和pytest为默认runner 可显示覆盖率窗口： 情景示例概览项目介绍一个简单的博客系统，包含： 创建文章 获取文章 获取文章列表 项目结构1234567891011121314151617181920212223├── README.md├── requirements.txt└── src├── blog│ ├── __init__.py│ ├── app.py│ ├── commands.py│ ├── database.db│ ├── init_db.py│ ├── models.py│ └── queries.py└── tests└── blog├── __init__.py├── conftest.py├── schemas│ ├── Article.json│ ├── ArticleList.json│ └── __init__.py├── test_app.py├── test_commands.py└── test_queries.py 关键技术 Flask，web框架 SQLite，轻量级数据库，文件格式 pytest，单元测试框架 Pydantic，数据校验 Service测试创建文章models.py如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import osimport sqlite3import uuidfrom typing import Listfrom pydantic import BaseModel, EmailStr, Fieldclass NotFound(Exception):passclass Article(BaseModel): id: str = Field(default_factory=lambda: str(uuid.uuid4())) author: EmailStr title: str content: str @classmethod def get_by_id(cls, article_id: str): con = sqlite3.connect(os.getenv(&#x27;DATABASE_NAME&#x27;, &#x27;database.db&#x27;)) con.row_factory = sqlite3.Row cur = con.cursor() cur.execute(&quot;SELECT * FROM articles WHERE id=?&quot;, (article_id,)) record = cur.fetchone() if record is None: raise NotFound article = cls(**record) # Row can be unpacked as dict con.close() return article @classmethod def get_by_title(cls, title: str): con = sqlite3.connect(os.getenv(&#x27;DATABASE_NAME&#x27;, &#x27;database.db&#x27;)) con.row_factory = sqlite3.Row cur = con.cursor() cur.execute(&quot;SELECT * FROM articles WHERE title = ?&quot;, (title,)) record = cur.fetchone() if record is None: raise NotFound article = cls(**record) # Row can be unpacked as dict con.close() return article @classmethod def list(cls) -&gt; List[&#x27;Article&#x27;]: con = sqlite3.connect(os.getenv(&#x27;DATABASE_NAME&#x27;, &#x27;database.db&#x27;)) con.row_factory = sqlite3.Row cur = con.cursor() cur.execute(&quot;SELECT * FROM articles&quot;) records = cur.fetchall() articles = [cls(**record) for record in records] con.close() return articles def save(self) -&gt; &#x27;Article&#x27;: with sqlite3.connect(os.getenv(&#x27;DATABASE_NAME&#x27;, &#x27;database.db&#x27;)) as con: cur = con.cursor() cur.execute( &quot;INSERT INTO articles (id,author,title,content) VALUES(?, ?, ?, ?)&quot;, (self.id, self.author, self.title, self.content) ) con.commit() return self @classmethod def create_table(cls, database_name=&#x27;database.db&#x27;): conn = sqlite3.connect(database_name) conn.execute( &#x27;CREATE TABLE IF NOT EXISTS articles (id TEXT, author TEXT, title TEXT, content TEXT)&#x27; ) conn.close() commands.py如下： 123456789101112131415161718192021222324252627282930from pydantic import BaseModel, EmailStrfrom src.blog.models import Article, NotFoundclass AlreadyExists(Exception): passclass CreateArticleCommand(BaseModel): author: EmailStr title: str content: str def execute(self) -&gt; Article: try: Article.get_by_title(self.title) raise AlreadyExists except NotFound: pass article = Article( author=self.author, title=self.title, content=self.title ).save() return article 单元测试test_commands.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import pytestfrom src.blog.commands import CreateArticleCommand, AlreadyExistsfrom src.blog.models import Articledef test_create_article(): &quot;&quot;&quot; GIVEN CreateArticleCommand with a valid properties author, title and content WHEN the execute method is called THEN a new Article must exist in the database with the same attributes &quot;&quot;&quot; cmd = CreateArticleCommand( author=&#x27;john@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super awesome article&#x27; ) article = cmd.execute() db_article = Article.get_by_id(article.id) assert db_article.id == article.id assert db_article.author == article.author assert db_article.title == article.title assert db_article.content == article.contentdef test_create_article_with_mock(monkeypatch): &quot;&quot;&quot; GIVEN CreateArticleCommand with valid properties author, title and content WHEN the execute method is called THEN a new Article must exist in the database with same attributes &quot;&quot;&quot; article = Article( author=&#x27;john@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super awesome article&#x27; ) monkeypatch.setattr( Article, &#x27;save&#x27;, lambda self: article ) cmd = CreateArticleCommand( author=&#x27;john@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super awesome article&#x27; ) db_article = cmd.execute() assert db_article.id == article.id assert db_article.author == article.author assert db_article.title == article.title assert db_article.content == article.contentdef test_create_article_already_exists(): &quot;&quot;&quot; GIVEN CreateArticleCommand with a title of some article in database WHEN the execute method is called THEN the AlreadyExists exception must be raised &quot;&quot;&quot; Article( author=&#x27;jane@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super extra awesome article&#x27; ).save() cmd = CreateArticleCommand( author=&#x27;john@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super awesome article&#x27; ) with pytest.raises(AlreadyExists): cmd.execute() 当多次运行时候，需要清理数据库，那么需要使用到用例前置和后置： confest.py: 1234567891011121314151617import osimport tempfileimport pytestfrom src.blog.models import Article@pytest.fixture(autouse=True)def database(): _, file_name = tempfile.mkstemp() os.environ[&#x27;DATABASE_NAME&#x27;] = file_name Article.create_table(database_name=file_name) yield os.unlink(file_name) 再次运行，执行结果： 1234567891011$ python3 -m pytest src/tests/blog/test_commands.py=================== test session starts ======================platform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1rootdir: python-utplugins: metadata-1.11.0, html-3.1.1, mock-3.5.1collected 3 itemssrc/tests/blog/test_commands.py ... [100%]===================== 3 passed in 0.02s ======================= 获取文章列表queries.py： 123456789101112131415from typing import Listfrom pydantic import BaseModelfrom src.blog.models import Articleclass ListArticlesQuery(BaseModel): def execute(self) -&gt; List[Article]: articles = Article.list() return articles 单元测试test_queries.py： 12345678910111213141516171819202122232425from src.blog.models import Articlefrom src.blog.queries import ListArticlesQuery, GetArticleByIDQuerydef test_list_articles(): &quot;&quot;&quot; GIVEN 2 articles stored in the database WHEN the execute method is called THEN it should return 2 articles &quot;&quot;&quot; Article( author=&#x27;jane@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super extra awesome article&#x27; ).save() Article( author=&#x27;jane@doe.com&#x27;, title=&#x27;Another Article&#x27;, content=&#x27;Super awesome article&#x27; ).save() query = ListArticlesQuery() assert len(query.execute()) == 2 其他功能测试应用入口app.py： 12345678910111213141516171819202122232425262728293031323334353637383940from flask import Flask, jsonify, requestfrom src.blog.commands import CreateArticleCommandfrom src.blog.queries import GetArticleByIDQuery, ListArticlesQueryfrom pydantic import ValidationErrorapp = Flask(__name__)@app.route(&#x27;/articles/&#x27;, methods=[&#x27;POST&#x27;])def create_article(): cmd = CreateArticleCommand(**request.json) return jsonify(cmd.execute().dict())@app.route(&#x27;/articles/&lt;article_id&gt;/&#x27;, methods=[&#x27;GET&#x27;])def get_article(article_id): query = GetArticleByIDQuery( id=article_id ) return jsonify(query.execute().dict())@app.route(&#x27;/articles/&#x27;, methods=[&#x27;GET&#x27;])def list_articles(): query = ListArticlesQuery() records = [record.dict() for record in query.execute()] return jsonify(records)@app.errorhandler(ValidationError)def handle_validation_exception(error): response = jsonify(error.errors()) response.status_code = 400 return responseif __name__ == &#x27;__main__&#x27;: app.run() 暴露json schema，校验响应payload： Article.json 1234567891011121314151617181920212223242526&#123; &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;, &quot;title&quot;: &quot;Article&quot;, &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;author&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;&#125;, &quot;required&quot;: [ &quot;id&quot;, &quot;author&quot;, &quot;title&quot;, &quot;content&quot; ]&#125; ArticleList.json 123456789&#123; &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;, &quot;title&quot;: &quot;ArticleList&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: &#123; &quot;$ref&quot;: &quot;file:Article.json&quot; &#125;&#125; 从应用本身，串起来整个流程的测试，测试test_app.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import jsonimport pathlibimport pytestfrom jsonschema import validate, RefResolverfrom src.blog.app import appfrom src.blog.models import Article@pytest.fixturedef client():app.config[&#x27;TESTING&#x27;] = True with app.test_client() as client: yield clientdef validate_payload(payload, schema_name): &quot;&quot;&quot; Validate payload with selected schema &quot;&quot;&quot; schemas_dir = str( f&#x27;&#123;pathlib.Path(__file__).parent.absolute()&#125;/schemas&#x27; ) schema = json.loads(pathlib.Path(f&#x27;&#123;schemas_dir&#125;/&#123;schema_name&#125;&#x27;).read_text()) validate( payload, schema, resolver=RefResolver( &#x27;file://&#x27; + str(pathlib.Path(f&#x27;&#123;schemas_dir&#125;/&#123;schema_name&#125;&#x27;).absolute()), schema # it&#x27;s used to resolve file: inside schemas correctly ) )def test_create_article(client): &quot;&quot;&quot; GIVEN request data for new article WHEN endpoint /articles/ is called THEN it should return Article in json format matching schema &quot;&quot;&quot; data = &#123; &#x27;author&#x27;: &#x27;john@doe.com&#x27;, &#x27;title&#x27;: &#x27;New Article&#x27;, &#x27;content&#x27;: &#x27;Some extra awesome content&#x27; &#125; response = client.post( &#x27;/articles/&#x27;, data=json.dumps(data), content_type=&#x27;application/json&#x27;, ) validate_payload(response.json, &#x27;Article.json&#x27;)def test_get_article(client): &quot;&quot;&quot; GIVEN ID of article stored in the database WHEN endpoint /articles/&lt;id-of-article&gt;/ is called THEN it should return Article in json format matching schema &quot;&quot;&quot; article = Article( author=&#x27;jane@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super extra awesome article&#x27; ).save() response = client.get( f&#x27;/articles/&#123;article.id&#125;/&#x27;, content_type=&#x27;application/json&#x27;, ) validate_payload(response.json, &#x27;Article.json&#x27;)def test_list_articles(client): &quot;&quot;&quot; GIVEN articles stored in the database WHEN endpoint /articles/ is called THEN it should return list of Article in json format matching schema &quot;&quot;&quot; Article( author=&#x27;jane@doe.com&#x27;, title=&#x27;New Article&#x27;, content=&#x27;Super extra awesome article&#x27; ).save() response = client.get( &#x27;/articles/&#x27;, content_type=&#x27;application/json&#x27;, ) validate_payload(response.json, &#x27;ArticleList.json&#x27;)@pytest.mark.parametrize(&#x27;data&#x27;,[ &#123; &#x27;author&#x27;: &#x27;John Doe&#x27;, &#x27;title&#x27;: &#x27;New Article&#x27;, &#x27;content&#x27;: &#x27;Some extra awesome content&#x27; &#125;, &#123; &#x27;author&#x27;: &#x27;John Doe&#x27;, &#x27;title&#x27;: &#x27;New Article&#x27;, &#125;, &#123; &#x27;author&#x27;: &#x27;John Doe&#x27;, &#x27;title&#x27;: None, &#x27;content&#x27;: &#x27;Some extra awesome content&#x27; &#125;])def test_create_article_bad_request(client, data): &quot;&quot;&quot; GIVEN request data with invalid values or missing attributes WHEN endpoint /create-article/ is called THEN it should return status 400 and JSON body &quot;&quot;&quot; response = client.post( &#x27;/articles/&#x27;, data=json.dumps(data), content_type=&#x27;application/json&#x27;, ) assert response.status_code == 400 assert response.json is not None 小结自此，上面的web小应用基本可以完成，包含了基本的服务层单元测试、数据库模拟、mock创建文章以及参数化请求验证。代码示例：Python情景示例代码: https://github.com/vwin/python-ut 结语小结Python的单元测试框架中，Python库本身提供了unittest，也有第三方框架进行了封装。原生的库插件少，二次开发非常方便。第三方框架融合了不少插件，上手简单。Python属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态地逐行解释运行，虽然其本身的结构灵活多变，但是仍然不妨碍我们用单元测试保证其质量、权衡其设计、设置其有形和无形的约束，为开发保驾护航。 相关阅读Python Testing Tools TaxonomyModern Test-Driven Development in Python","raw":"---\ntitle: Python-单测\ntoc: true\ndate: 2022-11-03 19:48:27\ntags: [python,单测,pytest,unittest]\ncategories: [技术]\ndescription:\n---\n单测系列-Python\n总结在Python中如何做单测，本文介绍了Python常用的单测框架和工具\n\n<!-- more -->\n\n# 常用Python单测框架\n\n|         | Unittest             | Nose                                                           | Pytest                                              |\n|---------|----------------------|----------------------------------------------------------------|-----------------------------------------------------|\n| 特点      | Python标准库中自带的单元测试框架。 | Python的一个第三方单元测试框架，带插件的unittest。nose停止维护了，nose2并不支持nose的全部功能。\t | Python的一个第三方单元测试框架，丰富的插件生态，兼容unittest和nose测试集， 社区繁荣 |\n| Mock框架\t | unittest.mock\t       | unittest.mock\t                                                 | pytest-mock                                         |\n| 推荐指数\t   | ★★★★☆\t               | ★★☆☆☆\t                                                         | ★★★★★                                               |\n\n若你不想安装或不允许第三方库，那么 unittest 是最好也是唯一的选择。反之，pytest 无疑是最佳选择，众多 Python 开源项目（如大名鼎鼎的 requests）都是使用 pytest 作为单元测试框架。甚至，连 nose2 在官方文档上都建议大家使用 pytest。我们知道，nose已经进入了维护模式，取代者是nose2。相比nose2，pytest的生态无疑更具优势，社区的活跃度也更高。\n\n总体来说，unittest用例格式复杂，兼容性无，插件少，二次开发方便。pytest更加方便快捷，用例格式简单，可以执行unittest风格的测试用例，较好的兼容性，插件丰富。\n\n# unittest\n## 基本概念\nunittest中最核心的四个概念是：test fixture、test case、test suite、test runner 。\n\n- test fixture：表示执行一个或多个测试所需的准备，以及任何关联的清理操作。例如这可能涉及创建临时或代理数据库、目录或启动服务器进程。\n- test case：测试用例是最小的测试单元。它检查特定的输入集的响应。单元测试提供了一个基类测试用例，可用于创建新的测试用例。\n- test suite：测试套件是测试用例、测试套件或两者的集合，用于归档需要一起执行的测试。\n- test runner：是一个用于执行和输出结果的组件。这个运行器可能使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。\n\n## 编写规则\n编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。\n以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。\n对每一类测试都需要编写一个test_xxx()方法。\n\n## 简单示例\n### 目录结构\n```text\n$ tree .\n.\n├── README.md\n├── requirements.txt\n└── src\n├── demo\n│   └── calculator.py\n└── tests\n└── demo\n├── __init__.py\n├── test_calculator_unittest.py\n└── test_calculator_unittest_with_fixture.py\n```\n### 计算器实现代码\n```python\nclass Calculator:\n\n    def add(self, a, b):\n        return a + b\n\n    def sub(self, a, b):\n        return a - b\n\n    def mul(self, a, b):\n        return a * b\n\n    def div(self, a, b):\n        return a / b\n```\n\n\n### 计算器测试代码\n```python\n\nimport unittest\n\nfrom src.demo.calculator import Calculator\n\n\nclass TestCalculator(unittest.TestCase):\n    def test_add(self):\n        c = Calculator()\n        result = c.add(3, 5)\n        self.assertEqual(result, 8)\n\n    def test_sub(self):\n        c = Calculator()\n        result = c.sub(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_mul(self):\n        c = Calculator()\n        result = c.mul(5, 7)\n        self.assertEqual(result, 35)\n\n    def test_div(self):\n        c = Calculator()\n        result = c.div(10, 5)\n        self.assertEqual(result, 2)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n# 执行结果\nRan 4 tests in 0.002s\n\nOK\n```\n\n\n\n## 用例前置和后置\n\n基于unittest的四个概念的理解，上述简单用例，可以修改为：\n```python\n\nimport unittest\n\nfrom src.demo.calculator import Calculator\n\n\nclass TestCalculatorWithFixture(unittest.TestCase):\n    # 测试用例前置动作\n    def setUp(self):\n        print(\"test start\")\n\n    # 测试用例后置动作\n    def tearDown(self):\n        print(\"test end\")\n\n    def test_add(self):\n        c = Calculator()\n        result = c.add(3, 5)\n        self.assertEqual(result, 8)\n\n    def test_sub(self):\n        c = Calculator()\n        result = c.sub(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_mul(self):\n        c = Calculator()\n        result = c.mul(5, 7)\n        self.assertEqual(result, 35)\n\n    def test_div(self):\n        c = Calculator()\n        result = c.div(10, 5)\n        self.assertEqual(result, 2)\n\n\nif __name__ == '__main__':\n    # 创建测试套件\n    suit = unittest.TestSuite()\n    suit.addTest(TestCalculatorWithFixture(\"test_add\"))\n    suit.addTest(TestCalculatorWithFixture(\"test_sub\"))\n    suit.addTest(TestCalculatorWithFixture(\"test_mul\"))\n    suit.addTest(TestCalculatorWithFixture(\"test_div\"))\n    # 创建测试运行器\n    runner = unittest.TestRunner()\n    runner.run(suit)\n```\n\n## 参数化\n标准库的unittest自身不支持参数化测试，可以通过第三方库来支持：parameterized和ddt。\n\n其中parameterized只需要一个装饰器@parameterized.expand，ddt需要三个装饰器@ddt、@data、@unpack，它们生成的test分别有一个名字，ddt会携带具体的参数信息。\n\n### parameterized\n```python\n\nimport unittest\n\nfrom parameterized import parameterized, param\n\nfrom src.demo.calculator import Calculator\n\n\nclass TestCalculator(unittest.TestCase):\n    @parameterized.expand([\n    param(3, 5, 8),\n    param(1, 2, 3),\n    param(2, 2, 4)\n    ])\n    def test_add(self, num1, num2, total):\n    c = Calculator()\n    result = c.add(num1, num2)\n    self.assertEqual(result, total)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n# 执行结果\n\ntest_add_0 (__main__.TestCalculator) ... ok\ntest_add_1 (__main__.TestCalculator) ... ok\ntest_add_2 (__main__.TestCalculator) ... ok\n\n----------------------------------------------------------------------\nRan 3 tests in 0.000s\n\nOK\n```\n\n### ddt\n```python\n\nimport unittest\n\nfrom ddt import data, unpack, ddt\n\nfrom src.demo.calculator import Calculator\n\n@ddt\nclass TestCalculator(unittest.TestCase):\n    @data((3, 5, 8),(1, 2, 3),(2, 2, 4))\n    @unpack\n    def test_add(self, num1, num2, total):\n    c = Calculator()\n    result = c.add(num1, num2)\n    self.assertEqual(result, total)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n# 执行结果\n\ntest_add_1__3__5__8_ (__main__.TestCalculator) ... ok\ntest_add_2__1__2__3_ (__main__.TestCalculator) ... ok\ntest_add_3__2__2__4_ (__main__.TestCalculator) ... ok\n\n----------------------------------------------------------------------\nRan 3 tests in 0.000s\n\nOK\n```\n\n## 断言\nunittest提供了丰富的断言，常用的包括：\n\nassertEqual、assertNotEqual、assertTrue、assertFalse、assertIn、assertNotIn等。\n\n具体可以直接看源码提供的方法：\n\n![](http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img.png)\n\n# nose\nnose已经进入维护模式，从github nose上可以看到，nose最近的一次代码提交还是在2016年5月4日。\n\n继承nose的是nose2，但要注意的是，nose2并不支持nose的全部功能，它们的区别可以看这里。nose2的主要目的是扩展Python的标准单元测试库unittest，因此它的定位是“带插件的unittest”。nose2提供的插件，例如测试用例加载器，覆盖度报告生成器，并行测试等内置插件和第三方插件，让单元测试变得更加完善。\n\nnose2的社区没有pytest的活跃，要使用高级框架，推荐使用pytest，因此下文不做过多详述。\n\n## 编写规则\nnose2的测试用例并不限制于类，也可以直接使用函数。\n任何函数和类，只要名称匹配一定的条件(例如，以test开头或以test结尾等)，都会被自动识别为测试用例；\n为了兼容unittest, 所有的基于unitest编写的测试用例，也会被nose自动识别为。\n## 简单示例\n### 计算器代码\n参考unittest的计算器代码部分。\n\n### 计算器测试代码\n```python\nimport nose2\n\nfrom src.demo.calculator import Calculator\n\n\ndef test_add():\n    c = Calculator()\n    result = c.add(3, 5)\n    assert result == 8\n\n\ndef test_sub():\n    c = Calculator()\n    result = c.sub(10, 5)\n    assert result == 5\n\n\ndef test_mul():\n    c = Calculator()\n    result = c.mul(5, 7)\n    assert result == 35\n\n\ndef test_div():\n    c = Calculator()\n    result = c.div(10, 5)\n    assert result == 2\n\n\nif __name__ == '__main__':\n    nose2.main()\n\n# 执行结果\n....\n----------------------------------------------------------------------\nRan 4 tests in 0.000s\n\nOK\n```\n\n## 参数化\n\n```python\nimport nose2\nfrom nose2.tools import params\n\nfrom src.demo.calculator import Calculator\n\ntest_data = [\n    {\"nums\": (3, 5), \"total\": 8},\n    {\"nums\": (1, 2), \"total\": 3},\n    {\"nums\": (2, 2), \"total\": 4}\n]\n\n\n@params(*test_data)\ndef test_add(data):\n    c = Calculator()\n    result = c.add(*data['nums'])\n    assert result == data['total']\n\n\nif __name__ == '__main__':\n    nose2.main()\n```\n\n# pytest\n\n## 编写规则\n- 测试文件以test_开头（以test结尾也可以） \n- 测试类以Test开头，并且不能带有 init 方法 \n- 测试函数以test_开头 \n- 断言使用基本的assert即可 \n- 可以通过下面的命令，查看 Pytest 收集到哪些测试用例：\n```shell\n$ py.test --collect-only\n```\n\n## 简单示例\n### 计算器代码\n参考unittest的计算器代码部分。\n\n### 计算器实现代码\n```python\n\nimport pytest\n\nfrom src.demo.calculator import Calculator\n\n\nclass TestCalculator():\n    def test_add(self):\n        c = Calculator()\n        result = c.add(3, 5)\n        assert result == 8\n\n    def test_sub(self):\n        c = Calculator()\n        result = c.sub(10, 5)\n        assert result == 5\n\n    def test_mul(self):\n        c = Calculator()\n        result = c.mul(5, 7)\n        assert result == 35\n\n    def test_div(self):\n        c = Calculator()\n        result = c.div(10, 5)\n        assert result == 2\n\n\nif __name__ == '__main__':\n    pytest.main(['-s', 'test_calculator_pytest.py'])\n\n# 执行结果\n============================= test session starts ==============================\nplatform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\nrootdir: python-ut/src/tests/demo\nplugins: metadata-1.11.0, html-3.1.1\ncollected 4 items\n\ntest_calculator_pytest.py ....\n\n============================== 4 passed in 0.01s ===============================\n```\n\n## 用例前置和后置\n加上fixture夹具，有几种方式：\n\n将夹具函数名称作为参数传递到测试用例函数当中\n- @pytest.mark.usefixtures(\"夹具函数名称\")\n- @pytest.fixture(autouse=True)，设置了autouse，就可以不用上述两种手动方式，默认就会使用夹具\n```python\nimport pytest\n\nfrom src.demo.calculator import Calculator\n\n\n@pytest.fixture()\ndef set_up():\n    print(\"[pytest with fixture] start\")\n    yield\n    print(\"[pytest with fixture] end\")\n\n\nclass TestCalculator():\n    def test_add(self, set_up):\n        c = Calculator()\n        result = c.add(3, 5)\n        assert result == 8\n\n    def test_sub(self, set_up):\n        c = Calculator()\n        result = c.sub(10, 5)\n        assert result == 5\n\n    @pytest.mark.usefixtures(\"set_up\")\n    def test_mul(self):\n        c = Calculator()\n        result = c.mul(5, 7)\n        assert result == 35\n\n    @pytest.mark.usefixtures(\"set_up\")\n    def test_div(self):\n        c = Calculator()\n        result = c.div(10, 5)\n        assert result == 2\n\n\nif __name__ == '__main__':\n    pytest.main(['-s', 'test_calculator_pytest_with_fixture.py'])\n    \n    \n# 执行结果：\n\n============================= test session starts ==============================\nplatform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\nrootdir: python-ut/src/tests/demo\nplugins: metadata-1.11.0, html-3.1.1\ncollected 4 items\n\ntest_calculator_pytest_with_fixture.py [pytest with fixture] start\n.[pytest with fixture] end\n[pytest with fixture] start\n.[pytest with fixture] end\n[pytest with fixture] start\n.[pytest with fixture] end\n[pytest with fixture] start\n.[pytest with fixture] end\n\n\n============================== 4 passed in 0.01s ===============================\n```\n\n## 参数化\n### 基础知识\n如果只有一个参数，里面则是值的列表，比如@pytest.mark.parametrize(\"num1\", [3, 5, 8])\n如果有多个参数，则需要用元祖来存放值，一个元祖对应一组参数的值，比如@pytest.mark.parametrize(\"num1, num2, total\", [(3, 5, 8), (1, 2, 3), (2, 2, 4)])\n当装饰器 @pytest.mark.parametrize 装饰测试类时，会将数据集合传递给类的所有测试用例方法\n一个函数或一个类可以装饰多个 @pytest.mark.parametrize，当参数化有多个装饰器时，用例数是N*M...\n### 参数化测试\n\n```python\nimport pytest\n\nfrom src.demo.calculator import Calculator\n\n\nclass TestCalculator():\n    @pytest.mark.parametrize(\"num1, num2, total\", [(3, 5, 8), (1, 2, 3), (2, 2, 4)])\n    def test_add(self, num1, num2, total):\n        c = Calculator()\n        result = c.add(num1, num2)\n        assert result == total\n\nif __name__ == '__main__':\n    pytest.main(['test_calculator_pytest_with_parameterize.py'])\n\n# 执行结果：\n\n============================= test session starts ==============================\nplatform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\nrootdir: python-ut/src/tests/demo\nplugins: metadata-1.11.0, html-3.1.1\ncollected 3 items\n\ntest_calculator_pytest_with_paramtrize.py ...\n\n============================== 3 passed in 0.01s ===============================\n```\n\n### 参数化标记数据\n```python\n\nclass TestCalculator():\n    @pytest.mark.parametrize(\"num1, num2, total\", [\n        pytest.param(5, 1, 4, marks=pytest.mark.passed),\n        pytest.param(5, 2, 4, marks=pytest.mark.fail),\n        (5, 4, 1)\n    ])\n    def test_sub(self, num1, num2, total):\n        c = Calculator()\n        result = c.sub(num1, num2)\n        assert result == total\n\n\nif __name__ == '__main__':\n    pytest.main(['test_calculator_pytest_with_parameterize.py'])\n\n\n# 执行结果：\n\n============================= test session starts ==============================\nplatform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\nrootdir: python-ut/src/tests/demo\nplugins: metadata-1.11.0, html-3.1.1\ncollected 3 items\n\ntest_calculator_pytest_with_paramtrize.py .F.                            [100%]\n\n=================================== FAILURES ===================================\n________________________ TestCalculator.test_sub[5-2-4] ________________________\n\nself = <demo.test_calculator_pytest_with_paramtrize.TestCalculator object at 0x110813d00>\nnum1 = 5, num2 = 2, total = 4\n\n    @pytest.mark.parametrize(\"num1, num2, total\", [\n        pytest.param(5, 1, 4, marks=pytest.mark.passed),\n        pytest.param(5, 2, 4, marks=pytest.mark.fail),\n        (5, 4, 1)\n    ])\n    def test_sub(self, num1, num2, total):\n        c = Calculator()\n        result = c.sub(num1, num2)\n>       assert result == total\nE       assert 3 == 4\n\ntest_calculator_pytest_with_paramtrize.py:21: AssertionError\n=========================== short test summary info ============================\nFAILED test_calculator_pytest_with_paramtrize.py::TestCalculator::test_sub[5-2-4]\n=================== 1 failed, 2 passed, 2 warnings in 0.04s ====================\n```\n\n## 断言\n在unittest单元测试框架中提供了丰富的断言方法，例如assertEqual()、assertIn()、assertTrue()、assertIs()等，而pytest单元测试框架中并没提供特殊的断言方法，而是直接使用python的assert进行断言。\n\n- assert可以使用==、!=、<、>、>=、<=等符号来比较相等、不相等、小于、大于、大于等于和小于等于。\n- 断言包含和不包含，使用assert a in b和assert a not in b\n- 断言真假，使用assert condition和assert not condition\n- 断言异常，使用pytest.raise获取信息\n```python\n\n# 详细断言异常\ndef test_zero_division_long():\n    with pytest.raises(ZeroDivisionError) as excinfo:\n        1 / 0\n\n    # 断言异常类型 type\n    assert excinfo.type == ZeroDivisionError\n    # 断言异常 value 值\n    assert \"division by zero\" in str(excinfo.value)\n```\n\n## 重跑\n需要安装额外的插件pytest-rerunfailures\n```python\n\nimport pytest\n\n\n@pytest.mark.flaky(reruns=5)\ndef test_example():\n    import random\n    assert random.choice([True, False, False])\n执行结果:\n\ncollecting ... collected 1 item\n\n11_reruns.py::test_example RERUN                                         [100%]\n11_reruns.py::test_example PASSED                                        [100%]\n\n========================= 1 passed, 1 rerun in 0.05s ==========================\n```\n\n\n# Mock\n## mock\nmock原是python的第三方库，python3以后mock模块已经整合到了unittest测试框架中。\n\n如果使用的是python3.3以后版本，那么不用单独安装，使用的时候在文件开头引入from unittest import mock即可。\n\n如果使用的是python2，需要先pip install mock安装后再import mock即可。\n\n### Mock一个方法\n```python\nimport unittest\nfrom unittest import mock\n\nfrom src.demo.calculator import Calculator\n\n\ndef multiple(a, b):\n    return a * b\n\n\nclass TestCalculator(unittest.TestCase):\n    @mock.patch('test_calculator_mock.multiple')\n    def test_function_multiple(self, mock_multiple):\n        mock_return = 1\n        mock_multiple.return_value = mock_return\n\n        result = multiple(3, 5)\n\n        self.assertEqual(result, mock_return)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n```\n\n### Mock一个对象里面的方法\n分别给出了普通写法和注解写法，以及side_effect关键参数的效果案例。\n```python\n\nimport unittest\nfrom unittest import mock\n\nfrom src.demo.calculator import Calculator\n\n\nclass TestCalculator(unittest.TestCase):\n    def test_add(self):\n        c = Calculator()\n        mock_return = 10\n        c.add = mock.Mock(return_value=mock_return)\n\n        result = c.add(3, 5)\n\n        self.assertEqual(result, mock_return)\n\n    def test_add_with_side_effect(self):\n        c = Calculator()\n        mock_return = 10\n        # 传递side_effect关键字参数, 会覆盖return_value参数值, 使用真实的add方法测试\n        c.add = mock.Mock(return_value=mock_return, side_effect=c.add)\n\n        result = c.add(3, 5)\n\n        self.assertEqual(result, 8)\n        \n    @mock.patch.object(Calculator, 'add')\n    def test_add_with_annotation(self, mock_add):\n        c = Calculator()\n        mock_return = 10\n        mock_add.return_value = mock_return\n\n        result = c.add(3, 5)\n\n        self.assertEqual(result, mock_return)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n\n### Mock每次调用返回不同的值\n```python\nimport unittest\nfrom unittest import mock\n\nfrom src.demo.calculator import Calculator\n\nclass TestCalculator(unittest.TestCase):\n    @mock.patch.object(Calculator, 'add')\n    def test_add_with_different_return(self, mock_add):\n        c = Calculator()\n        mock_return = [10, 8]\n        mock_add.side_effect = mock_return\n\n        result1 = c.add(3, 5)\n        result2 = c.add(3, 5)\n\n        self.assertEqual(result1, mock_return[0])\n        self.assertEqual(result2, mock_return[1])\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n### Mock抛出异常的方法\n```python\n\nimport unittest\nfrom unittest import mock\n\nfrom src.demo.calculator import Calculator\n\n# 被调用函数\ndef multiple(a, b):\nreturn a * b\n\n# 实际调用函数\ndef is_error(a, b):\ntry:\n    return multiple(a, b)\nexcept Exception as e:\n    return -1\n\n\nclass TestCalculator(unittest.TestCase):\n    @mock.patch('test_calculator_mock.multiple')\n    def test_function_multiple_exception(self, mock_multiple):\n        mock_multiple.side_effect = Exception\n\n        result = is_error(3, 5)\n\n        self.assertEqual(result, -1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n\n### Mock多个方法\n```python\n\nimport unittest\nfrom unittest import mock\n\nfrom src.demo.calculator import Calculator\n\n\ndef multiple(a, b):\nreturn a * b\n\nclass TestCalculator(unittest.TestCase):\n    @mock.patch.object(Calculator, 'add')\n    @mock.patch('test_calculator_mock.multiple')\n    def test_both(self, mock_multiple, mock_add):\n        c = Calculator()\n        mock_add.return_value = 1\n        mock_multiple.return_value = 2\n\n        self.assertEqual(c.add(3, 5), 1)\n        self.assertEqual(multiple(3, 5), 2)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n## pytest-mock\n如果项目本身使用的框架是 pytest，则 Mock 更建议使用 pytest-mock 这个插件，它提供了一个名为mocker的fixture，仅在当前测试funciton或method生效，而不用自行包装。\n\nmocker和mock.patch有相同的api，支持相同的参数。\n### 简单示例\n```python\n\nimport pytest\n\nfrom src.demo.calculator import Calculator\n\nclass TestCalculator():\n\n    def test_add(self, mocker):\n        c = Calculator()\n        mock_return = 10\n        mocker.patch.object(c, 'add', return_value=mock_return)\n\n        result = c.add(3, 5)\n\n        assert result == mock_return\n\n\nif __name__ == '__main__':\n    pytest.main(['-s', 'test_calculator_pytest_mock.py'])\n```\n\n### mock方法和域\n```python\n\nclass ForTest:\n    field = 'origin'\n\n    def method():\n        pass\n\n\ndef test_for_test(mocker):\n    test = ForTest()\n    # 方法\n    mock_method = mocker.patch.object(test, 'method')\n    test.method()\n    # 检查行为\n    assert mock_method.called\n\n    # 域\n    assert 'origin' == test.field\n    mocker.patch.object(test, 'field', 'mocked')\n    # 检查结果\n    assert 'mocked' == test.field\n```\n\n## monkeypatch\nmonkeypatch是pytest框架内置的固件，有时候，测试用例需要调用某些依赖于全局配置的功能，或者这些功能本身又调用了某些不容易测试的代码（例如：网络接入）。monkeypatch提供了一些方法，用于安全地修补和模拟测试中的功能：\n```python\n\nmonkeypatch.setattr(obj, name, value, raising=True)\nmonkeypatch.delattr(obj, name, raising=True)\nmonkeypatch.setitem(mapping, name, value)\nmonkeypatch.delitem(obj, name, raising=True)\nmonkeypatch.setenv(name, value, prepend=False)\nmonkeypatch.delenv(name, raising=True)\nmonkeypatch.syspath_prepend(path)\nmonkeypatch.chdir(path)\n```\n\n主要考虑以下情形：\n\n- 修改测试的函数行为或类的属性\n- 修改字典的值\n- 修改测试环境的环境变量\n- 在测试期间，用于修改和 更改当前工作目录的上下文。\n\n# 单元测试覆盖率报告\n- coverage 是 Python 推荐使用的覆盖率统计工具。\n- pytest-cov 是 pytest 的插件，它可以让你在 pytest 中使用 cpverage.py。\n- HtmlTestRunner，需要在代码里面写入一点配置，但是报告生成比较美观。\n- coverage和pytest-cov只需要配置，就可直接使用，不需要测试代码配合。\n\n## coverage\n### 安装\n```shell\npip install coverage\n```\n详情可参考：https://coverage.readthedocs.io/en/coverage-5.5/\n\n### 运行\n```shell\ncoverage run -m unittest discover\n```\n运行结束之后，会生成一个覆盖率统计结果文件（data file）.coverage文件，在pycharm里可识别为一个数据库：\n\n![](http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_1.png)\n### 结果\n#### report\n\n```shell\ncoverage report -m\n```\n执行结果如下：\n\n```shell\n\n$ coverage report -m\nName                                                            Stmts   Miss  Cover   Missing\n---------------------------------------------------------------------------------------------\nsrc/tests/demo/test_calculator_pytest_with_fixture.py              28     16    43%   8-10, 15-17, 20-22, 26-28, 32-34, 38\nsrc/tests/demo/test_calculator_pytest_with_parameterize.py         15      7    53%   9-11, 19-21, 25\nsrc/tests/demo/test_calculator_unittest.py                         22      1    95%   31\nsrc/tests/demo/test_calculator_unittest_with_ddt.py                13      1    92%   18\n```\n\n#### html\n\n会生成htmlcov/index.html文件，在浏览器查看：\n```shell\ncoverage html\n```\n点击各个py文件，可以查看详细情况。\n\n## html-testRunner\n### 安装\n```shell\npip install html-testRunner \n```\n详细说明可参考HtmlTestRunner: https://github.com/oldani/HtmlTestRunner\n\n\n### 运行\n在代码中加上HTMLTestRunner，如下\n```python\n\nimport HtmlTestRunner\n\n# some tests here\n\nif __name__ == '__main__':\nunittest.main(testRunner=HtmlTestRunner.HTMLTestRunner())\n如果是在测试套件中运行，换成HTMLTestRunner即可：\n\n# 创建测试运行器\n# runner = unittest.TestRunner()\nrunner = HTMLTestRunner()\nrunner.run(suit)\n```\n\n\n### 结果\n默认会生成reports/ 文件夹，按照时间显示报告：\n![](http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_2.png)\n\n## pytest-cov\n### 安装\n```shell\npip install pytest-cov\n```\n详细可参考pytest-cov: https://github.com/pytest-dev/pytest-cov\n\n### 运行\n```shell\npytest --cov --cov-report=html   \n```\n或者指定目录：\n```shell\npytest --cov=src --cov-report=html   \n```\n### 结果\n会生成htmlcov/index.html文件，在浏览器查看，类似于coverage的报告。\n\n## 可能的问题\n### 报告没生成\n如果出现不了报告，pycharm运行的时候，记得选择python，而不是Python tests\n![](http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_3.png)\n\n### 在Pycharm中配置覆盖率展示\n可选择unittest和pytest为默认runner\n![](http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_4.png)\n\n可显示覆盖率窗口：\n![](http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_5.png)\n\n# 情景示例\n## 概览\n### 项目介绍\n一个简单的博客系统，包含：\n\n- 创建文章\n- 获取文章\n- 获取文章列表\n\n### 项目结构\n```text\n\n├── README.md\n├── requirements.txt\n└── src\n├── blog\n│   ├── __init__.py\n│   ├── app.py\n│   ├── commands.py\n│   ├── database.db\n│   ├── init_db.py\n│   ├── models.py\n│   └── queries.py\n└── tests\n└── blog\n├── __init__.py\n├── conftest.py\n├── schemas\n│   ├── Article.json\n│   ├── ArticleList.json\n│   └── __init__.py\n├── test_app.py\n├── test_commands.py\n└── test_queries.py\n```\n\n### 关键技术\n- Flask，web框架\n- SQLite，轻量级数据库，文件格式\n- pytest，单元测试框架\n- Pydantic，数据校验\n\n\n## Service测试\n### 创建文章\n\nmodels.py如下：\n```python\n\nimport os\nimport sqlite3\nimport uuid\nfrom typing import List\n\nfrom pydantic import BaseModel, EmailStr, Field\n\n\nclass NotFound(Exception):\npass\n\n\nclass Article(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    author: EmailStr\n    title: str\n    content: str\n\n    @classmethod\n    def get_by_id(cls, article_id: str):\n        con = sqlite3.connect(os.getenv('DATABASE_NAME', 'database.db'))\n        con.row_factory = sqlite3.Row\n\n        cur = con.cursor()\n        cur.execute(\"SELECT * FROM articles WHERE id=?\", (article_id,))\n\n        record = cur.fetchone()\n\n        if record is None:\n            raise NotFound\n\n        article = cls(**record)  # Row can be unpacked as dict\n        con.close()\n\n        return article\n\n    @classmethod\n    def get_by_title(cls, title: str):\n        con = sqlite3.connect(os.getenv('DATABASE_NAME', 'database.db'))\n        con.row_factory = sqlite3.Row\n\n        cur = con.cursor()\n        cur.execute(\"SELECT * FROM articles WHERE title = ?\", (title,))\n\n        record = cur.fetchone()\n\n        if record is None:\n            raise NotFound\n\n        article = cls(**record)  # Row can be unpacked as dict\n        con.close()\n\n        return article\n\n    @classmethod\n    def list(cls) -> List['Article']:\n        con = sqlite3.connect(os.getenv('DATABASE_NAME', 'database.db'))\n        con.row_factory = sqlite3.Row\n\n        cur = con.cursor()\n        cur.execute(\"SELECT * FROM articles\")\n\n        records = cur.fetchall()\n        articles = [cls(**record) for record in records]\n        con.close()\n\n        return articles\n\n    def save(self) -> 'Article':\n        with sqlite3.connect(os.getenv('DATABASE_NAME', 'database.db')) as con:\n            cur = con.cursor()\n            cur.execute(\n                \"INSERT INTO articles (id,author,title,content) VALUES(?, ?, ?, ?)\",\n                (self.id, self.author, self.title, self.content)\n            )\n            con.commit()\n\n        return self\n\n    @classmethod\n    def create_table(cls, database_name='database.db'):\n        conn = sqlite3.connect(database_name)\n\n        conn.execute(\n            'CREATE TABLE IF NOT EXISTS articles (id TEXT, author TEXT, title TEXT, content TEXT)'\n        )\n        conn.close()\n\n```\n\n\ncommands.py如下：\n```python\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom src.blog.models import Article, NotFound\n\n\nclass AlreadyExists(Exception):\n    pass\n\n\nclass CreateArticleCommand(BaseModel):\n    author: EmailStr\n    title: str\n    content: str\n\n    def execute(self) -> Article:\n        try:\n            Article.get_by_title(self.title)\n            raise AlreadyExists\n        except NotFound:\n            pass\n\n        article = Article(\n            author=self.author,\n            title=self.title,\n            content=self.title\n        ).save()\n\n        return article\n\n```\n\n单元测试test_commands.py：\n```python\n\nimport pytest\n\nfrom src.blog.commands import CreateArticleCommand, AlreadyExists\nfrom src.blog.models import Article\n\n\ndef test_create_article():\n    \"\"\"\n    GIVEN CreateArticleCommand with a valid properties author, title and content\n    WHEN the execute method is called\n    THEN a new Article must exist in the database with the same attributes\n    \"\"\"\n    cmd = CreateArticleCommand(\n    author='john@doe.com',\n    title='New Article',\n    content='Super awesome article'\n    )\n\n    article = cmd.execute()\n\n    db_article = Article.get_by_id(article.id)\n\n    assert db_article.id == article.id\n    assert db_article.author == article.author\n    assert db_article.title == article.title\n    assert db_article.content == article.content\n\n\ndef test_create_article_with_mock(monkeypatch):\n    \"\"\"\n    GIVEN CreateArticleCommand with valid properties author, title and content\n    WHEN the execute method is called\n    THEN a new Article must exist in the database with same attributes\n    \"\"\"\n    article = Article(\n    author='john@doe.com',\n    title='New Article',\n    content='Super awesome article'\n    )\n    monkeypatch.setattr(\n    Article,\n    'save',\n    lambda self: article\n    )\n    cmd = CreateArticleCommand(\n    author='john@doe.com',\n    title='New Article',\n    content='Super awesome article'\n    )\n\n    db_article = cmd.execute()\n\n    assert db_article.id == article.id\n    assert db_article.author == article.author\n    assert db_article.title == article.title\n    assert db_article.content == article.content\n\n\ndef test_create_article_already_exists():\n    \"\"\"\n    GIVEN CreateArticleCommand with a title of some article in database\n    WHEN the execute method is called\n    THEN the AlreadyExists exception must be raised\n    \"\"\"\n\n    Article(\n        author='jane@doe.com',\n        title='New Article',\n        content='Super extra awesome article'\n    ).save()\n\n    cmd = CreateArticleCommand(\n        author='john@doe.com',\n        title='New Article',\n        content='Super awesome article'\n    )\n\n    with pytest.raises(AlreadyExists):\n        cmd.execute()\n\n```\n\n\n当多次运行时候，需要清理数据库，那么需要使用到用例前置和后置：\n\nconfest.py:\n```python\n\nimport os\nimport tempfile\n\nimport pytest\n\nfrom src.blog.models import Article\n\n\n@pytest.fixture(autouse=True)\ndef database():\n    _, file_name = tempfile.mkstemp()\n    os.environ['DATABASE_NAME'] = file_name\n    Article.create_table(database_name=file_name)\n    yield\n    os.unlink(file_name)\n\n```\n\n再次运行，执行结果：\n```shell\n\n$ python3 -m pytest src/tests/blog/test_commands.py\n=================== test session starts ======================\nplatform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\nrootdir: python-ut\nplugins: metadata-1.11.0, html-3.1.1, mock-3.5.1\ncollected 3 items\n\nsrc/tests/blog/test_commands.py ...                                                                                                                                                                                                                                                                              [100%]\n\n===================== 3 passed in 0.02s =======================\n```\n\n\n### 获取文章列表\nqueries.py：\n```python\n\nfrom typing import List\n\nfrom pydantic import BaseModel\n\nfrom src.blog.models import Article\n\n\nclass ListArticlesQuery(BaseModel):\n\n    def execute(self) -> List[Article]:\n        articles = Article.list()\n\n        return articles\n\n```\n\n单元测试test_queries.py：\n```python\n\nfrom src.blog.models import Article\nfrom src.blog.queries import ListArticlesQuery, GetArticleByIDQuery\n\n\ndef test_list_articles():\n    \"\"\"\n    GIVEN 2 articles stored in the database\n    WHEN the execute method is called\n    THEN it should return 2 articles\n    \"\"\"\n    Article(\n    author='jane@doe.com',\n    title='New Article',\n    content='Super extra awesome article'\n    ).save()\n    Article(\n    author='jane@doe.com',\n    title='Another Article',\n    content='Super awesome article'\n    ).save()\n\n    query = ListArticlesQuery()\n\n    assert len(query.execute()) == 2\n```\n\n## 其他功能测试\n应用入口app.py：\n```python\n\nfrom flask import Flask, jsonify, request\n\nfrom src.blog.commands import CreateArticleCommand\nfrom src.blog.queries import GetArticleByIDQuery, ListArticlesQuery\nfrom pydantic import ValidationError\n\napp = Flask(__name__)\n\n\n@app.route('/articles/', methods=['POST'])\ndef create_article():\n    cmd = CreateArticleCommand(**request.json)\n    return jsonify(cmd.execute().dict())\n\n\n@app.route('/articles/<article_id>/', methods=['GET'])\ndef get_article(article_id):\n    query = GetArticleByIDQuery(\n    id=article_id\n    )\n    return jsonify(query.execute().dict())\n\n\n@app.route('/articles/', methods=['GET'])\ndef list_articles():\n    query = ListArticlesQuery()\n    records = [record.dict() for record in query.execute()]\n    return jsonify(records)\n\n\n@app.errorhandler(ValidationError)\ndef handle_validation_exception(error):\n    response = jsonify(error.errors())\n    response.status_code = 400\n    return response\n\n\nif __name__ == '__main__':\n    app.run()\n```\n\n暴露json schema，校验响应payload：\n\nArticle.json\n```json\n\n{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"Article\",\n    \"type\": \"object\",\n    \"properties\": {\n    \"id\": {\n        \"type\": \"string\"\n    },\n    \"author\": {\n        \"type\": \"string\"\n    },\n    \"title\": {\n        \"type\": \"string\"\n    },\n    \"content\": {\n        \"type\": \"string\"\n    }\n},\n    \"required\": [\n        \"id\",\n        \"author\",\n        \"title\",\n        \"content\"\n    ]\n}\n```\n\nArticleList.json\n```json\n\n{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"ArticleList\",\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"file:Article.json\"\n    }\n}\n```\n从应用本身，串起来整个流程的测试，测试test_app.py：\n```python\nimport json\nimport pathlib\n\nimport pytest\nfrom jsonschema import validate, RefResolver\n\nfrom src.blog.app import app\nfrom src.blog.models import Article\n\n\n@pytest.fixture\ndef client():\napp.config['TESTING'] = True\n\n    with app.test_client() as client:\n        yield client\n\n\ndef validate_payload(payload, schema_name):\n    \"\"\"\n    Validate payload with selected schema\n    \"\"\"\n    schemas_dir = str(\n        f'{pathlib.Path(__file__).parent.absolute()}/schemas'\n    )\n    schema = json.loads(pathlib.Path(f'{schemas_dir}/{schema_name}').read_text())\n    validate(\n        payload,\n        schema,\n        resolver=RefResolver(\n            'file://' + str(pathlib.Path(f'{schemas_dir}/{schema_name}').absolute()),\n            schema  # it's used to resolve file: inside schemas correctly\n        )\n    )\n\n\ndef test_create_article(client):\n    \"\"\"\n    GIVEN request data for new article\n    WHEN endpoint /articles/ is called\n    THEN it should return Article in json format matching schema\n    \"\"\"\n    data = {\n        'author': 'john@doe.com',\n        'title': 'New Article',\n        'content': 'Some extra awesome content'\n    }\n    response = client.post(\n        '/articles/',\n        data=json.dumps(data),\n        content_type='application/json',\n    )\n\n    validate_payload(response.json, 'Article.json')\n\n\ndef test_get_article(client):\n    \"\"\"\n    GIVEN ID of article stored in the database\n    WHEN endpoint /articles/<id-of-article>/ is called\n    THEN it should return Article in json format matching schema\n    \"\"\"\n    article = Article(\n        author='jane@doe.com',\n        title='New Article',\n        content='Super extra awesome article'\n    ).save()\n    response = client.get(\n        f'/articles/{article.id}/',\n        content_type='application/json',\n    )\n\n    validate_payload(response.json, 'Article.json')\n\n\ndef test_list_articles(client):\n    \"\"\"\n    GIVEN articles stored in the database\n    WHEN endpoint /articles/ is called\n    THEN it should return list of Article in json format matching schema\n    \"\"\"\n    Article(\n        author='jane@doe.com',\n        title='New Article',\n        content='Super extra awesome article'\n    ).save()\n    response = client.get(\n        '/articles/',\n        content_type='application/json',\n    )\n\n    validate_payload(response.json, 'ArticleList.json')\n\n\n@pytest.mark.parametrize(\n'data',\n[\n    {\n        'author': 'John Doe',\n        'title': 'New Article',\n        'content': 'Some extra awesome content'\n    },\n    {\n        'author': 'John Doe',\n        'title': 'New Article',\n    },\n    {\n        'author': 'John Doe',\n        'title': None,\n        'content': 'Some extra awesome content'\n    }\n]\n)\ndef test_create_article_bad_request(client, data):\n    \"\"\"\n    GIVEN request data with invalid values or missing attributes\n    WHEN endpoint /create-article/ is called\n    THEN it should return status 400 and JSON body\n    \"\"\"\n    response = client.post(\n        '/articles/',\n        data=json.dumps(data),\n        content_type='application/json',\n    )\n\n    assert response.status_code == 400\n    assert response.json is not None\n```\n\n小结\n自此，上面的web小应用基本可以完成，包含了基本的服务层单元测试、数据库模拟、mock创建文章以及参数化请求验证。\n代码示例：Python情景示例代码: https://github.com/vwin/python-ut\n\n# 结语\n## 小结\nPython的单元测试框架中，Python库本身提供了unittest，也有第三方框架进行了封装。原生的库插件少，二次开发非常方便。第三方框架融合了不少插件，上手简单。\nPython属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态地逐行解释运行，虽然其本身的结构灵活多变，但是仍然不妨碍我们用单元测试保证其质量、权衡其设计、设置其有形和无形的约束，为开发保驾护航。\n\n\n## 相关阅读\n[Python Testing Tools Taxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy)\n[Modern Test-Driven Development in Python](https://testdriven.io/blog/modern-tdd/#when-should-you-use-mocks)","content":"<p>单测系列-Python<br>总结在Python中如何做单测，本文介绍了Python常用的单测框架和工具</p>\n<span id=\"more\"></span>\n\n<h1 id=\"常用Python单测框架\"><a href=\"#常用Python单测框架\" class=\"headerlink\" title=\"常用Python单测框架\"></a>常用Python单测框架</h1><table>\n<thead>\n<tr>\n<th></th>\n<th>Unittest</th>\n<th>Nose</th>\n<th>Pytest</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>特点</td>\n<td>Python标准库中自带的单元测试框架。</td>\n<td>Python的一个第三方单元测试框架，带插件的unittest。nose停止维护了，nose2并不支持nose的全部功能。</td>\n<td>Python的一个第三方单元测试框架，丰富的插件生态，兼容unittest和nose测试集， 社区繁荣</td>\n</tr>\n<tr>\n<td>Mock框架</td>\n<td>unittest.mock</td>\n<td>unittest.mock</td>\n<td>pytest-mock</td>\n</tr>\n<tr>\n<td>推荐指数</td>\n<td>★★★★☆</td>\n<td>★★☆☆☆</td>\n<td>★★★★★</td>\n</tr>\n</tbody></table>\n<p>若你不想安装或不允许第三方库，那么 unittest 是最好也是唯一的选择。反之，pytest 无疑是最佳选择，众多 Python 开源项目（如大名鼎鼎的 requests）都是使用 pytest 作为单元测试框架。甚至，连 nose2 在官方文档上都建议大家使用 pytest。我们知道，nose已经进入了维护模式，取代者是nose2。相比nose2，pytest的生态无疑更具优势，社区的活跃度也更高。</p>\n<p>总体来说，unittest用例格式复杂，兼容性无，插件少，二次开发方便。pytest更加方便快捷，用例格式简单，可以执行unittest风格的测试用例，较好的兼容性，插件丰富。</p>\n<h1 id=\"unittest\"><a href=\"#unittest\" class=\"headerlink\" title=\"unittest\"></a>unittest</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>unittest中最核心的四个概念是：test fixture、test case、test suite、test runner 。</p>\n<ul>\n<li>test fixture：表示执行一个或多个测试所需的准备，以及任何关联的清理操作。例如这可能涉及创建临时或代理数据库、目录或启动服务器进程。</li>\n<li>test case：测试用例是最小的测试单元。它检查特定的输入集的响应。单元测试提供了一个基类测试用例，可用于创建新的测试用例。</li>\n<li>test suite：测试套件是测试用例、测试套件或两者的集合，用于归档需要一起执行的测试。</li>\n<li>test runner：是一个用于执行和输出结果的组件。这个运行器可能使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。</li>\n</ul>\n<h2 id=\"编写规则\"><a href=\"#编写规则\" class=\"headerlink\" title=\"编写规则\"></a>编写规则</h2><p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。<br>以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。<br>对每一类测试都需要编写一个test_xxx()方法。</p>\n<h2 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h2><h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree .</span><br><span class=\"line\">.</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── requirements.txt</span><br><span class=\"line\">└── src</span><br><span class=\"line\">├── demo</span><br><span class=\"line\">│   └── calculator.py</span><br><span class=\"line\">└── tests</span><br><span class=\"line\">└── demo</span><br><span class=\"line\">├── __init__.py</span><br><span class=\"line\">├── test_calculator_unittest.py</span><br><span class=\"line\">└── test_calculator_unittest_with_fixture.py</span><br></pre></td></tr></table></figure>\n<h3 id=\"计算器实现代码\"><a href=\"#计算器实现代码\" class=\"headerlink\" title=\"计算器实现代码\"></a>计算器实现代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">self, a, b</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sub</span>(<span class=\"params\">self, a, b</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a - b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">mul</span>(<span class=\"params\">self, a, b</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a * b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">div</span>(<span class=\"params\">self, a, b</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a / b</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"计算器测试代码\"><a href=\"#计算器测试代码\" class=\"headerlink\" title=\"计算器测试代码\"></a>计算器测试代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_sub</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.sub(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_mul</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.mul(<span class=\"number\">5</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">35</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_div</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.div(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\">Ran <span class=\"number\">4</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.002</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"用例前置和后置\"><a href=\"#用例前置和后置\" class=\"headerlink\" title=\"用例前置和后置\"></a>用例前置和后置</h2><p>基于unittest的四个概念的理解，上述简单用例，可以修改为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculatorWithFixture</span>(unittest.TestCase):</span><br><span class=\"line\">    <span class=\"comment\"># 测试用例前置动作</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">setUp</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;test start&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 测试用例后置动作</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">tearDown</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;test end&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_sub</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.sub(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_mul</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.mul(<span class=\"number\">5</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">35</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_div</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.div(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 创建测试套件</span></span><br><span class=\"line\">    suit = unittest.TestSuite()</span><br><span class=\"line\">    suit.addTest(TestCalculatorWithFixture(<span class=\"string\">&quot;test_add&quot;</span>))</span><br><span class=\"line\">    suit.addTest(TestCalculatorWithFixture(<span class=\"string\">&quot;test_sub&quot;</span>))</span><br><span class=\"line\">    suit.addTest(TestCalculatorWithFixture(<span class=\"string\">&quot;test_mul&quot;</span>))</span><br><span class=\"line\">    suit.addTest(TestCalculatorWithFixture(<span class=\"string\">&quot;test_div&quot;</span>))</span><br><span class=\"line\">    <span class=\"comment\"># 创建测试运行器</span></span><br><span class=\"line\">    runner = unittest.TestRunner()</span><br><span class=\"line\">    runner.run(suit)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数化\"><a href=\"#参数化\" class=\"headerlink\" title=\"参数化\"></a>参数化</h2><p>标准库的unittest自身不支持参数化测试，可以通过第三方库来支持：parameterized和ddt。</p>\n<p>其中parameterized只需要一个装饰器@parameterized.expand，ddt需要三个装饰器@ddt、@data、@unpack，它们生成的test分别有一个名字，ddt会携带具体的参数信息。</p>\n<h3 id=\"parameterized\"><a href=\"#parameterized\" class=\"headerlink\" title=\"parameterized\"></a>parameterized</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> parameterized <span class=\"keyword\">import</span> parameterized, param</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\"><span class=\"meta\">    @parameterized.expand(<span class=\"params\">[</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    param(<span class=\"params\"><span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span></span>),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    param(<span class=\"params\"><span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span>),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    param(<span class=\"params\"><span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span></span>)</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    ]</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self, num1, num2, total</span>):</span><br><span class=\"line\">    c = Calculator()</span><br><span class=\"line\">    result = c.add(num1, num2)</span><br><span class=\"line\">    self.assertEqual(result, total)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">test_add_0 (__main__.TestCalculator) ... ok</span><br><span class=\"line\">test_add_1 (__main__.TestCalculator) ... ok</span><br><span class=\"line\">test_add_2 (__main__.TestCalculator) ... ok</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran <span class=\"number\">3</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.000</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ddt\"><a href=\"#ddt\" class=\"headerlink\" title=\"ddt\"></a>ddt</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> ddt <span class=\"keyword\">import</span> data, unpack, ddt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ddt</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\"><span class=\"meta\">    @data(<span class=\"params\">(<span class=\"params\"><span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span></span>),(<span class=\"params\"><span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span>),(<span class=\"params\"><span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span></span>)</span>)</span></span><br><span class=\"line\"><span class=\"meta\">    @unpack</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self, num1, num2, total</span>):</span><br><span class=\"line\">    c = Calculator()</span><br><span class=\"line\">    result = c.add(num1, num2)</span><br><span class=\"line\">    self.assertEqual(result, total)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">test_add_1__3__5__8_ (__main__.TestCalculator) ... ok</span><br><span class=\"line\">test_add_2__1__2__3_ (__main__.TestCalculator) ... ok</span><br><span class=\"line\">test_add_3__2__2__4_ (__main__.TestCalculator) ... ok</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran <span class=\"number\">3</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.000</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><p>unittest提供了丰富的断言，常用的包括：</p>\n<p>assertEqual、assertNotEqual、assertTrue、assertFalse、assertIn、assertNotIn等。</p>\n<p>具体可以直接看源码提供的方法：</p>\n<p><img src=\"http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img.png\"></p>\n<h1 id=\"nose\"><a href=\"#nose\" class=\"headerlink\" title=\"nose\"></a>nose</h1><p>nose已经进入维护模式，从github nose上可以看到，nose最近的一次代码提交还是在2016年5月4日。</p>\n<p>继承nose的是nose2，但要注意的是，nose2并不支持nose的全部功能，它们的区别可以看这里。nose2的主要目的是扩展Python的标准单元测试库unittest，因此它的定位是“带插件的unittest”。nose2提供的插件，例如测试用例加载器，覆盖度报告生成器，并行测试等内置插件和第三方插件，让单元测试变得更加完善。</p>\n<p>nose2的社区没有pytest的活跃，要使用高级框架，推荐使用pytest，因此下文不做过多详述。</p>\n<h2 id=\"编写规则-1\"><a href=\"#编写规则-1\" class=\"headerlink\" title=\"编写规则\"></a>编写规则</h2><p>nose2的测试用例并不限制于类，也可以直接使用函数。<br>任何函数和类，只要名称匹配一定的条件(例如，以test开头或以test结尾等)，都会被自动识别为测试用例；<br>为了兼容unittest, 所有的基于unitest编写的测试用例，也会被nose自动识别为。</p>\n<h2 id=\"简单示例-1\"><a href=\"#简单示例-1\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h2><h3 id=\"计算器代码\"><a href=\"#计算器代码\" class=\"headerlink\" title=\"计算器代码\"></a>计算器代码</h3><p>参考unittest的计算器代码部分。</p>\n<h3 id=\"计算器测试代码-1\"><a href=\"#计算器测试代码-1\" class=\"headerlink\" title=\"计算器测试代码\"></a>计算器测试代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nose2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>():</span><br><span class=\"line\">    c = Calculator()</span><br><span class=\"line\">    result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result == <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_sub</span>():</span><br><span class=\"line\">    c = Calculator()</span><br><span class=\"line\">    result = c.sub(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result == <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_mul</span>():</span><br><span class=\"line\">    c = Calculator()</span><br><span class=\"line\">    result = c.mul(<span class=\"number\">5</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result == <span class=\"number\">35</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_div</span>():</span><br><span class=\"line\">    c = Calculator()</span><br><span class=\"line\">    result = c.div(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result == <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    nose2.main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\">....</span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran <span class=\"number\">4</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.000</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数化-1\"><a href=\"#参数化-1\" class=\"headerlink\" title=\"参数化\"></a>参数化</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nose2</span><br><span class=\"line\"><span class=\"keyword\">from</span> nose2.tools <span class=\"keyword\">import</span> params</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\">test_data = [</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;nums&quot;</span>: (<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"string\">&quot;total&quot;</span>: <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;nums&quot;</span>: (<span class=\"number\">1</span>, <span class=\"number\">2</span>), <span class=\"string\">&quot;total&quot;</span>: <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;nums&quot;</span>: (<span class=\"number\">2</span>, <span class=\"number\">2</span>), <span class=\"string\">&quot;total&quot;</span>: <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@params(<span class=\"params\">*test_data</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    c = Calculator()</span><br><span class=\"line\">    result = c.add(*data[<span class=\"string\">&#x27;nums&#x27;</span>])</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result == data[<span class=\"string\">&#x27;total&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    nose2.main()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"pytest\"><a href=\"#pytest\" class=\"headerlink\" title=\"pytest\"></a>pytest</h1><h2 id=\"编写规则-2\"><a href=\"#编写规则-2\" class=\"headerlink\" title=\"编写规则\"></a>编写规则</h2><ul>\n<li>测试文件以test_开头（以test结尾也可以） </li>\n<li>测试类以Test开头，并且不能带有 init 方法 </li>\n<li>测试函数以test_开头 </li>\n<li>断言使用基本的assert即可 </li>\n<li>可以通过下面的命令，查看 Pytest 收集到哪些测试用例：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">py.test --collect-only</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"简单示例-2\"><a href=\"#简单示例-2\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h2><h3 id=\"计算器代码-1\"><a href=\"#计算器代码-1\" class=\"headerlink\" title=\"计算器代码\"></a>计算器代码</h3><p>参考unittest的计算器代码部分。</p>\n<h3 id=\"计算器实现代码-1\"><a href=\"#计算器实现代码-1\" class=\"headerlink\" title=\"计算器实现代码\"></a>计算器实现代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_sub</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.sub(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_mul</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.mul(<span class=\"number\">5</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">35</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_div</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.div(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main([<span class=\"string\">&#x27;-s&#x27;</span>, <span class=\"string\">&#x27;test_calculator_pytest.py&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\">============================= test session starts ==============================</span><br><span class=\"line\">platform darwin -- Python <span class=\"number\">3.8</span><span class=\"number\">.3</span>, pytest-<span class=\"number\">6.2</span><span class=\"number\">.2</span>, py-<span class=\"number\">1.10</span><span class=\"number\">.0</span>, pluggy-<span class=\"number\">0.13</span><span class=\"number\">.1</span></span><br><span class=\"line\">rootdir: python-ut/src/tests/demo</span><br><span class=\"line\">plugins: metadata-<span class=\"number\">1.11</span><span class=\"number\">.0</span>, html-<span class=\"number\">3.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">collected <span class=\"number\">4</span> items</span><br><span class=\"line\"></span><br><span class=\"line\">test_calculator_pytest.py ....</span><br><span class=\"line\"></span><br><span class=\"line\">============================== <span class=\"number\">4</span> passed <span class=\"keyword\">in</span> <span class=\"number\">0.01</span>s ===============================</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用例前置和后置-1\"><a href=\"#用例前置和后置-1\" class=\"headerlink\" title=\"用例前置和后置\"></a>用例前置和后置</h2><p>加上fixture夹具，有几种方式：</p>\n<p>将夹具函数名称作为参数传递到测试用例函数当中</p>\n<ul>\n<li>@pytest.mark.usefixtures(“夹具函数名称”)</li>\n<li>@pytest.fixture(autouse&#x3D;True)，设置了autouse，就可以不用上述两种手动方式，默认就会使用夹具<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.fixture()</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">set_up</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[pytest with fixture] start&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[pytest with fixture] end&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self, set_up</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_sub</span>(<span class=\"params\">self, set_up</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.sub(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.usefixtures(<span class=\"params\"><span class=\"string\">&quot;set_up&quot;</span></span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_mul</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.mul(<span class=\"number\">5</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">35</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.usefixtures(<span class=\"params\"><span class=\"string\">&quot;set_up&quot;</span></span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_div</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.div(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main([<span class=\"string\">&#x27;-s&#x27;</span>, <span class=\"string\">&#x27;test_calculator_pytest_with_fixture.py&#x27;</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 执行结果：</span></span><br><span class=\"line\"></span><br><span class=\"line\">============================= test session starts ==============================</span><br><span class=\"line\">platform darwin -- Python <span class=\"number\">3.8</span><span class=\"number\">.3</span>, pytest-<span class=\"number\">6.2</span><span class=\"number\">.2</span>, py-<span class=\"number\">1.10</span><span class=\"number\">.0</span>, pluggy-<span class=\"number\">0.13</span><span class=\"number\">.1</span></span><br><span class=\"line\">rootdir: python-ut/src/tests/demo</span><br><span class=\"line\">plugins: metadata-<span class=\"number\">1.11</span><span class=\"number\">.0</span>, html-<span class=\"number\">3.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">collected <span class=\"number\">4</span> items</span><br><span class=\"line\"></span><br><span class=\"line\">test_calculator_pytest_with_fixture.py [pytest <span class=\"keyword\">with</span> fixture] start</span><br><span class=\"line\">.[pytest <span class=\"keyword\">with</span> fixture] end</span><br><span class=\"line\">[pytest <span class=\"keyword\">with</span> fixture] start</span><br><span class=\"line\">.[pytest <span class=\"keyword\">with</span> fixture] end</span><br><span class=\"line\">[pytest <span class=\"keyword\">with</span> fixture] start</span><br><span class=\"line\">.[pytest <span class=\"keyword\">with</span> fixture] end</span><br><span class=\"line\">[pytest <span class=\"keyword\">with</span> fixture] start</span><br><span class=\"line\">.[pytest <span class=\"keyword\">with</span> fixture] end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">============================== <span class=\"number\">4</span> passed <span class=\"keyword\">in</span> <span class=\"number\">0.01</span>s ===============================</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"参数化-2\"><a href=\"#参数化-2\" class=\"headerlink\" title=\"参数化\"></a>参数化</h2><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><p>如果只有一个参数，里面则是值的列表，比如@pytest.mark.parametrize(“num1”, [3, 5, 8])<br>如果有多个参数，则需要用元祖来存放值，一个元祖对应一组参数的值，比如@pytest.mark.parametrize(“num1, num2, total”, [(3, 5, 8), (1, 2, 3), (2, 2, 4)])<br>当装饰器 @pytest.mark.parametrize 装饰测试类时，会将数据集合传递给类的所有测试用例方法<br>一个函数或一个类可以装饰多个 @pytest.mark.parametrize，当参数化有多个装饰器时，用例数是N*M…</p>\n<h3 id=\"参数化测试\"><a href=\"#参数化测试\" class=\"headerlink\" title=\"参数化测试\"></a>参数化测试</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>():</span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.parametrize(<span class=\"params\"><span class=\"string\">&quot;num1, num2, total&quot;</span>, [(<span class=\"params\"><span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span></span>), (<span class=\"params\"><span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span>), (<span class=\"params\"><span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span></span>)]</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self, num1, num2, total</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.add(num1, num2)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == total</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main([<span class=\"string\">&#x27;test_calculator_pytest_with_parameterize.py&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果：</span></span><br><span class=\"line\"></span><br><span class=\"line\">============================= test session starts ==============================</span><br><span class=\"line\">platform darwin -- Python <span class=\"number\">3.8</span><span class=\"number\">.3</span>, pytest-<span class=\"number\">6.2</span><span class=\"number\">.2</span>, py-<span class=\"number\">1.10</span><span class=\"number\">.0</span>, pluggy-<span class=\"number\">0.13</span><span class=\"number\">.1</span></span><br><span class=\"line\">rootdir: python-ut/src/tests/demo</span><br><span class=\"line\">plugins: metadata-<span class=\"number\">1.11</span><span class=\"number\">.0</span>, html-<span class=\"number\">3.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">collected <span class=\"number\">3</span> items</span><br><span class=\"line\"></span><br><span class=\"line\">test_calculator_pytest_with_paramtrize.py ...</span><br><span class=\"line\"></span><br><span class=\"line\">============================== <span class=\"number\">3</span> passed <span class=\"keyword\">in</span> <span class=\"number\">0.01</span>s ===============================</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数化标记数据\"><a href=\"#参数化标记数据\" class=\"headerlink\" title=\"参数化标记数据\"></a>参数化标记数据</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>():</span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.parametrize(<span class=\"params\"><span class=\"string\">&quot;num1, num2, total&quot;</span>, [</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        pytest.param(<span class=\"params\"><span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, marks=pytest.mark.passed</span>),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        pytest.param(<span class=\"params\"><span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, marks=pytest.mark.fail</span>),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        (<span class=\"params\"><span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span></span>)</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    ]</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_sub</span>(<span class=\"params\">self, num1, num2, total</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.sub(num1, num2)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == total</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main([<span class=\"string\">&#x27;test_calculator_pytest_with_parameterize.py&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果：</span></span><br><span class=\"line\"></span><br><span class=\"line\">============================= test session starts ==============================</span><br><span class=\"line\">platform darwin -- Python <span class=\"number\">3.8</span><span class=\"number\">.3</span>, pytest-<span class=\"number\">6.2</span><span class=\"number\">.2</span>, py-<span class=\"number\">1.10</span><span class=\"number\">.0</span>, pluggy-<span class=\"number\">0.13</span><span class=\"number\">.1</span></span><br><span class=\"line\">rootdir: python-ut/src/tests/demo</span><br><span class=\"line\">plugins: metadata-<span class=\"number\">1.11</span><span class=\"number\">.0</span>, html-<span class=\"number\">3.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">collected <span class=\"number\">3</span> items</span><br><span class=\"line\"></span><br><span class=\"line\">test_calculator_pytest_with_paramtrize.py .F.                            [<span class=\"number\">100</span>%]</span><br><span class=\"line\"></span><br><span class=\"line\">=================================== FAILURES ===================================</span><br><span class=\"line\">________________________ TestCalculator.test_sub[<span class=\"number\">5</span>-<span class=\"number\">2</span>-<span class=\"number\">4</span>] ________________________</span><br><span class=\"line\"></span><br><span class=\"line\">self = &lt;demo.test_calculator_pytest_with_paramtrize.TestCalculator <span class=\"built_in\">object</span> at <span class=\"number\">0x110813d00</span>&gt;</span><br><span class=\"line\">num1 = <span class=\"number\">5</span>, num2 = <span class=\"number\">2</span>, total = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.parametrize(<span class=\"params\"><span class=\"string\">&quot;num1, num2, total&quot;</span>, [</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        pytest.param(<span class=\"params\"><span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, marks=pytest.mark.passed</span>),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        pytest.param(<span class=\"params\"><span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, marks=pytest.mark.fail</span>),</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        (<span class=\"params\"><span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span></span>)</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    ]</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_sub</span>(<span class=\"params\">self, num1, num2, total</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        result = c.sub(num1, num2)</span><br><span class=\"line\">&gt;       <span class=\"keyword\">assert</span> result == total</span><br><span class=\"line\">E       <span class=\"keyword\">assert</span> <span class=\"number\">3</span> == <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">test_calculator_pytest_with_paramtrize.py:<span class=\"number\">21</span>: AssertionError</span><br><span class=\"line\">=========================== short test summary info ============================</span><br><span class=\"line\">FAILED test_calculator_pytest_with_paramtrize.py::TestCalculator::test_sub[<span class=\"number\">5</span>-<span class=\"number\">2</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\">=================== <span class=\"number\">1</span> failed, <span class=\"number\">2</span> passed, <span class=\"number\">2</span> warnings <span class=\"keyword\">in</span> <span class=\"number\">0.04</span>s ====================</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"断言-1\"><a href=\"#断言-1\" class=\"headerlink\" title=\"断言\"></a>断言</h2><p>在unittest单元测试框架中提供了丰富的断言方法，例如assertEqual()、assertIn()、assertTrue()、assertIs()等，而pytest单元测试框架中并没提供特殊的断言方法，而是直接使用python的assert进行断言。</p>\n<ul>\n<li>assert可以使用&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D;等符号来比较相等、不相等、小于、大于、大于等于和小于等于。</li>\n<li>断言包含和不包含，使用assert a in b和assert a not in b</li>\n<li>断言真假，使用assert condition和assert not condition</li>\n<li>断言异常，使用pytest.raise获取信息<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 详细断言异常</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_zero_division_long</span>():</span><br><span class=\"line\">    <span class=\"keyword\">with</span> pytest.raises(ZeroDivisionError) <span class=\"keyword\">as</span> excinfo:</span><br><span class=\"line\">        <span class=\"number\">1</span> / <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 断言异常类型 type</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> excinfo.<span class=\"built_in\">type</span> == ZeroDivisionError</span><br><span class=\"line\">    <span class=\"comment\"># 断言异常 value 值</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">&quot;division by zero&quot;</span> <span class=\"keyword\">in</span> <span class=\"built_in\">str</span>(excinfo.value)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"重跑\"><a href=\"#重跑\" class=\"headerlink\" title=\"重跑\"></a>重跑</h2><p>需要安装额外的插件pytest-rerunfailures</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.mark.flaky(<span class=\"params\">reruns=<span class=\"number\">5</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_example</span>():</span><br><span class=\"line\">    <span class=\"keyword\">import</span> random</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> random.choice([<span class=\"literal\">True</span>, <span class=\"literal\">False</span>, <span class=\"literal\">False</span>])</span><br><span class=\"line\">执行结果:</span><br><span class=\"line\"></span><br><span class=\"line\">collecting ... collected <span class=\"number\">1</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">11_reruns.py::test_example RERUN                                         [<span class=\"number\">100</span>%]</span><br><span class=\"line\">11_reruns.py::test_example PASSED                                        [<span class=\"number\">100</span>%]</span><br><span class=\"line\"></span><br><span class=\"line\">========================= <span class=\"number\">1</span> passed, <span class=\"number\">1</span> rerun <span class=\"keyword\">in</span> <span class=\"number\">0.05</span>s ==========================</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Mock\"><a href=\"#Mock\" class=\"headerlink\" title=\"Mock\"></a>Mock</h1><h2 id=\"mock\"><a href=\"#mock\" class=\"headerlink\" title=\"mock\"></a>mock</h2><p>mock原是python的第三方库，python3以后mock模块已经整合到了unittest测试框架中。</p>\n<p>如果使用的是python3.3以后版本，那么不用单独安装，使用的时候在文件开头引入from unittest import mock即可。</p>\n<p>如果使用的是python2，需要先pip install mock安装后再import mock即可。</p>\n<h3 id=\"Mock一个方法\"><a href=\"#Mock一个方法\" class=\"headerlink\" title=\"Mock一个方法\"></a>Mock一个方法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">multiple</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\"><span class=\"meta\">    @mock.patch(<span class=\"params\"><span class=\"string\">&#x27;test_calculator_mock.multiple&#x27;</span></span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_function_multiple</span>(<span class=\"params\">self, mock_multiple</span>):</span><br><span class=\"line\">        mock_return = <span class=\"number\">1</span></span><br><span class=\"line\">        mock_multiple.return_value = mock_return</span><br><span class=\"line\"></span><br><span class=\"line\">        result = multiple(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.assertEqual(result, mock_return)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mock一个对象里面的方法\"><a href=\"#Mock一个对象里面的方法\" class=\"headerlink\" title=\"Mock一个对象里面的方法\"></a>Mock一个对象里面的方法</h3><p>分别给出了普通写法和注解写法，以及side_effect关键参数的效果案例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        mock_return = <span class=\"number\">10</span></span><br><span class=\"line\">        c.add = mock.Mock(return_value=mock_return)</span><br><span class=\"line\"></span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.assertEqual(result, mock_return)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add_with_side_effect</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        mock_return = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"comment\"># 传递side_effect关键字参数, 会覆盖return_value参数值, 使用真实的add方法测试</span></span><br><span class=\"line\">        c.add = mock.Mock(return_value=mock_return, side_effect=c.add)</span><br><span class=\"line\"></span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">8</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">    @mock.patch.object(<span class=\"params\">Calculator, <span class=\"string\">&#x27;add&#x27;</span></span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add_with_annotation</span>(<span class=\"params\">self, mock_add</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        mock_return = <span class=\"number\">10</span></span><br><span class=\"line\">        mock_add.return_value = mock_return</span><br><span class=\"line\"></span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.assertEqual(result, mock_return)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Mock每次调用返回不同的值\"><a href=\"#Mock每次调用返回不同的值\" class=\"headerlink\" title=\"Mock每次调用返回不同的值\"></a>Mock每次调用返回不同的值</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\"><span class=\"meta\">    @mock.patch.object(<span class=\"params\">Calculator, <span class=\"string\">&#x27;add&#x27;</span></span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add_with_different_return</span>(<span class=\"params\">self, mock_add</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        mock_return = [<span class=\"number\">10</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">        mock_add.side_effect = mock_return</span><br><span class=\"line\"></span><br><span class=\"line\">        result1 = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        result2 = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.assertEqual(result1, mock_return[<span class=\"number\">0</span>])</span><br><span class=\"line\">        self.assertEqual(result2, mock_return[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mock抛出异常的方法\"><a href=\"#Mock抛出异常的方法\" class=\"headerlink\" title=\"Mock抛出异常的方法\"></a>Mock抛出异常的方法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 被调用函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">multiple</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\"><span class=\"keyword\">return</span> a * b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实际调用函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_error</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> multiple(a, b)</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\"><span class=\"meta\">    @mock.patch(<span class=\"params\"><span class=\"string\">&#x27;test_calculator_mock.multiple&#x27;</span></span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_function_multiple_exception</span>(<span class=\"params\">self, mock_multiple</span>):</span><br><span class=\"line\">        mock_multiple.side_effect = Exception</span><br><span class=\"line\"></span><br><span class=\"line\">        result = is_error(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.assertEqual(result, -<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Mock多个方法\"><a href=\"#Mock多个方法\" class=\"headerlink\" title=\"Mock多个方法\"></a>Mock多个方法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">multiple</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\"><span class=\"keyword\">return</span> a * b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>(unittest.TestCase):</span><br><span class=\"line\"><span class=\"meta\">    @mock.patch.object(<span class=\"params\">Calculator, <span class=\"string\">&#x27;add&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"meta\">    @mock.patch(<span class=\"params\"><span class=\"string\">&#x27;test_calculator_mock.multiple&#x27;</span></span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_both</span>(<span class=\"params\">self, mock_multiple, mock_add</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        mock_add.return_value = <span class=\"number\">1</span></span><br><span class=\"line\">        mock_multiple.return_value = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        self.assertEqual(c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.assertEqual(multiple(<span class=\"number\">3</span>, <span class=\"number\">5</span>), <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"pytest-mock\"><a href=\"#pytest-mock\" class=\"headerlink\" title=\"pytest-mock\"></a>pytest-mock</h2><p>如果项目本身使用的框架是 pytest，则 Mock 更建议使用 pytest-mock 这个插件，它提供了一个名为mocker的fixture，仅在当前测试funciton或method生效，而不用自行包装。</p>\n<p>mocker和mock.patch有相同的api，支持相同的参数。</p>\n<h3 id=\"简单示例-3\"><a href=\"#简单示例-3\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.demo.calculator <span class=\"keyword\">import</span> Calculator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCalculator</span>():</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_add</span>(<span class=\"params\">self, mocker</span>):</span><br><span class=\"line\">        c = Calculator()</span><br><span class=\"line\">        mock_return = <span class=\"number\">10</span></span><br><span class=\"line\">        mocker.patch.<span class=\"built_in\">object</span>(c, <span class=\"string\">&#x27;add&#x27;</span>, return_value=mock_return)</span><br><span class=\"line\"></span><br><span class=\"line\">        result = c.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> result == mock_return</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main([<span class=\"string\">&#x27;-s&#x27;</span>, <span class=\"string\">&#x27;test_calculator_pytest_mock.py&#x27;</span>])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mock方法和域\"><a href=\"#mock方法和域\" class=\"headerlink\" title=\"mock方法和域\"></a>mock方法和域</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ForTest</span>:</span><br><span class=\"line\">    field = <span class=\"string\">&#x27;origin&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">method</span>():</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_for_test</span>(<span class=\"params\">mocker</span>):</span><br><span class=\"line\">    test = ForTest()</span><br><span class=\"line\">    <span class=\"comment\"># 方法</span></span><br><span class=\"line\">    mock_method = mocker.patch.<span class=\"built_in\">object</span>(test, <span class=\"string\">&#x27;method&#x27;</span>)</span><br><span class=\"line\">    test.method()</span><br><span class=\"line\">    <span class=\"comment\"># 检查行为</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> mock_method.called</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 域</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">&#x27;origin&#x27;</span> == test.field</span><br><span class=\"line\">    mocker.patch.<span class=\"built_in\">object</span>(test, <span class=\"string\">&#x27;field&#x27;</span>, <span class=\"string\">&#x27;mocked&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 检查结果</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"string\">&#x27;mocked&#x27;</span> == test.field</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"monkeypatch\"><a href=\"#monkeypatch\" class=\"headerlink\" title=\"monkeypatch\"></a>monkeypatch</h2><p>monkeypatch是pytest框架内置的固件，有时候，测试用例需要调用某些依赖于全局配置的功能，或者这些功能本身又调用了某些不容易测试的代码（例如：网络接入）。monkeypatch提供了一些方法，用于安全地修补和模拟测试中的功能：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">monkeypatch.<span class=\"built_in\">setattr</span>(obj, name, value, raising=<span class=\"literal\">True</span>)</span><br><span class=\"line\">monkeypatch.<span class=\"built_in\">delattr</span>(obj, name, raising=<span class=\"literal\">True</span>)</span><br><span class=\"line\">monkeypatch.setitem(mapping, name, value)</span><br><span class=\"line\">monkeypatch.delitem(obj, name, raising=<span class=\"literal\">True</span>)</span><br><span class=\"line\">monkeypatch.setenv(name, value, prepend=<span class=\"literal\">False</span>)</span><br><span class=\"line\">monkeypatch.delenv(name, raising=<span class=\"literal\">True</span>)</span><br><span class=\"line\">monkeypatch.syspath_prepend(path)</span><br><span class=\"line\">monkeypatch.chdir(path)</span><br></pre></td></tr></table></figure>\n\n<p>主要考虑以下情形：</p>\n<ul>\n<li>修改测试的函数行为或类的属性</li>\n<li>修改字典的值</li>\n<li>修改测试环境的环境变量</li>\n<li>在测试期间，用于修改和 更改当前工作目录的上下文。</li>\n</ul>\n<h1 id=\"单元测试覆盖率报告\"><a href=\"#单元测试覆盖率报告\" class=\"headerlink\" title=\"单元测试覆盖率报告\"></a>单元测试覆盖率报告</h1><ul>\n<li>coverage 是 Python 推荐使用的覆盖率统计工具。</li>\n<li>pytest-cov 是 pytest 的插件，它可以让你在 pytest 中使用 cpverage.py。</li>\n<li>HtmlTestRunner，需要在代码里面写入一点配置，但是报告生成比较美观。</li>\n<li>coverage和pytest-cov只需要配置，就可直接使用，不需要测试代码配合。</li>\n</ul>\n<h2 id=\"coverage\"><a href=\"#coverage\" class=\"headerlink\" title=\"coverage\"></a>coverage</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install coverage</span><br></pre></td></tr></table></figure>\n<p>详情可参考：<a href=\"https://coverage.readthedocs.io/en/coverage-5.5/\">https://coverage.readthedocs.io/en/coverage-5.5/</a></p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coverage run -m unittest discover</span><br></pre></td></tr></table></figure>\n<p>运行结束之后，会生成一个覆盖率统计结果文件（data file）.coverage文件，在pycharm里可识别为一个数据库：</p>\n<p><img src=\"http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_1.png\"></p>\n<h3 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h3><h4 id=\"report\"><a href=\"#report\" class=\"headerlink\" title=\"report\"></a>report</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coverage report -m</span><br></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">coverage report -m</span></span><br><span class=\"line\">Name                                                            Stmts   Miss  Cover   Missing</span><br><span class=\"line\">---------------------------------------------------------------------------------------------</span><br><span class=\"line\">src/tests/demo/test_calculator_pytest_with_fixture.py              28     16    43%   8-10, 15-17, 20-22, 26-28, 32-34, 38</span><br><span class=\"line\">src/tests/demo/test_calculator_pytest_with_parameterize.py         15      7    53%   9-11, 19-21, 25</span><br><span class=\"line\">src/tests/demo/test_calculator_unittest.py                         22      1    95%   31</span><br><span class=\"line\">src/tests/demo/test_calculator_unittest_with_ddt.py                13      1    92%   18</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h4><p>会生成htmlcov&#x2F;index.html文件，在浏览器查看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coverage html</span><br></pre></td></tr></table></figure>\n<p>点击各个py文件，可以查看详细情况。</p>\n<h2 id=\"html-testRunner\"><a href=\"#html-testRunner\" class=\"headerlink\" title=\"html-testRunner\"></a>html-testRunner</h2><h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install html-testRunner </span><br></pre></td></tr></table></figure>\n<p>详细说明可参考HtmlTestRunner: <a href=\"https://github.com/oldani/HtmlTestRunner\">https://github.com/oldani/HtmlTestRunner</a></p>\n<h3 id=\"运行-1\"><a href=\"#运行-1\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>在代码中加上HTMLTestRunner，如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> HtmlTestRunner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># some tests here</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">unittest.main(testRunner=HtmlTestRunner.HTMLTestRunner())</span><br><span class=\"line\">如果是在测试套件中运行，换成HTMLTestRunner即可：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建测试运行器</span></span><br><span class=\"line\"><span class=\"comment\"># runner = unittest.TestRunner()</span></span><br><span class=\"line\">runner = HTMLTestRunner()</span><br><span class=\"line\">runner.run(suit)</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"结果-1\"><a href=\"#结果-1\" class=\"headerlink\" title=\"结果\"></a>结果</h3><p>默认会生成reports&#x2F; 文件夹，按照时间显示报告：<br><img src=\"http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_2.png\"></p>\n<h2 id=\"pytest-cov\"><a href=\"#pytest-cov\" class=\"headerlink\" title=\"pytest-cov\"></a>pytest-cov</h2><h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pytest-cov</span><br></pre></td></tr></table></figure>\n<p>详细可参考pytest-cov: <a href=\"https://github.com/pytest-dev/pytest-cov\">https://github.com/pytest-dev/pytest-cov</a></p>\n<h3 id=\"运行-2\"><a href=\"#运行-2\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pytest --cov --cov-report=html   </span><br></pre></td></tr></table></figure>\n<p>或者指定目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pytest --cov=src --cov-report=html   </span><br></pre></td></tr></table></figure>\n<h3 id=\"结果-2\"><a href=\"#结果-2\" class=\"headerlink\" title=\"结果\"></a>结果</h3><p>会生成htmlcov&#x2F;index.html文件，在浏览器查看，类似于coverage的报告。</p>\n<h2 id=\"可能的问题\"><a href=\"#可能的问题\" class=\"headerlink\" title=\"可能的问题\"></a>可能的问题</h2><h3 id=\"报告没生成\"><a href=\"#报告没生成\" class=\"headerlink\" title=\"报告没生成\"></a>报告没生成</h3><p>如果出现不了报告，pycharm运行的时候，记得选择python，而不是Python tests<br><img src=\"http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_3.png\"></p>\n<h3 id=\"在Pycharm中配置覆盖率展示\"><a href=\"#在Pycharm中配置覆盖率展示\" class=\"headerlink\" title=\"在Pycharm中配置覆盖率展示\"></a>在Pycharm中配置覆盖率展示</h3><p>可选择unittest和pytest为默认runner<br><img src=\"http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_4.png\"></p>\n<p>可显示覆盖率窗口：<br><img src=\"http://cdn.yuleweici.com/Python-%E5%8D%95%E6%B5%8B/img_5.png\"></p>\n<h1 id=\"情景示例\"><a href=\"#情景示例\" class=\"headerlink\" title=\"情景示例\"></a>情景示例</h1><h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><h3 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h3><p>一个简单的博客系统，包含：</p>\n<ul>\n<li>创建文章</li>\n<li>获取文章</li>\n<li>获取文章列表</li>\n</ul>\n<h3 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── requirements.txt</span><br><span class=\"line\">└── src</span><br><span class=\"line\">├── blog</span><br><span class=\"line\">│   ├── __init__.py</span><br><span class=\"line\">│   ├── app.py</span><br><span class=\"line\">│   ├── commands.py</span><br><span class=\"line\">│   ├── database.db</span><br><span class=\"line\">│   ├── init_db.py</span><br><span class=\"line\">│   ├── models.py</span><br><span class=\"line\">│   └── queries.py</span><br><span class=\"line\">└── tests</span><br><span class=\"line\">└── blog</span><br><span class=\"line\">├── __init__.py</span><br><span class=\"line\">├── conftest.py</span><br><span class=\"line\">├── schemas</span><br><span class=\"line\">│   ├── Article.json</span><br><span class=\"line\">│   ├── ArticleList.json</span><br><span class=\"line\">│   └── __init__.py</span><br><span class=\"line\">├── test_app.py</span><br><span class=\"line\">├── test_commands.py</span><br><span class=\"line\">└── test_queries.py</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键技术\"><a href=\"#关键技术\" class=\"headerlink\" title=\"关键技术\"></a>关键技术</h3><ul>\n<li>Flask，web框架</li>\n<li>SQLite，轻量级数据库，文件格式</li>\n<li>pytest，单元测试框架</li>\n<li>Pydantic，数据校验</li>\n</ul>\n<h2 id=\"Service测试\"><a href=\"#Service测试\" class=\"headerlink\" title=\"Service测试\"></a>Service测试</h2><h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><p>models.py如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sqlite3</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> <span class=\"type\">List</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pydantic <span class=\"keyword\">import</span> BaseModel, EmailStr, Field</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NotFound</span>(<span class=\"title class_ inherited__\">Exception</span>):</span><br><span class=\"line\"><span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Article</span>(<span class=\"title class_ inherited__\">BaseModel</span>):</span><br><span class=\"line\">    <span class=\"built_in\">id</span>: <span class=\"built_in\">str</span> = Field(default_factory=<span class=\"keyword\">lambda</span>: <span class=\"built_in\">str</span>(uuid.uuid4()))</span><br><span class=\"line\">    author: EmailStr</span><br><span class=\"line\">    title: <span class=\"built_in\">str</span></span><br><span class=\"line\">    content: <span class=\"built_in\">str</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_by_id</span>(<span class=\"params\">cls, article_id: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">        con = sqlite3.connect(os.getenv(<span class=\"string\">&#x27;DATABASE_NAME&#x27;</span>, <span class=\"string\">&#x27;database.db&#x27;</span>))</span><br><span class=\"line\">        con.row_factory = sqlite3.Row</span><br><span class=\"line\"></span><br><span class=\"line\">        cur = con.cursor()</span><br><span class=\"line\">        cur.execute(<span class=\"string\">&quot;SELECT * FROM articles WHERE id=?&quot;</span>, (article_id,))</span><br><span class=\"line\"></span><br><span class=\"line\">        record = cur.fetchone()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> record <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> NotFound</span><br><span class=\"line\"></span><br><span class=\"line\">        article = cls(**record)  <span class=\"comment\"># Row can be unpacked as dict</span></span><br><span class=\"line\">        con.close()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> article</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_by_title</span>(<span class=\"params\">cls, title: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">        con = sqlite3.connect(os.getenv(<span class=\"string\">&#x27;DATABASE_NAME&#x27;</span>, <span class=\"string\">&#x27;database.db&#x27;</span>))</span><br><span class=\"line\">        con.row_factory = sqlite3.Row</span><br><span class=\"line\"></span><br><span class=\"line\">        cur = con.cursor()</span><br><span class=\"line\">        cur.execute(<span class=\"string\">&quot;SELECT * FROM articles WHERE title = ?&quot;</span>, (title,))</span><br><span class=\"line\"></span><br><span class=\"line\">        record = cur.fetchone()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> record <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> NotFound</span><br><span class=\"line\"></span><br><span class=\"line\">        article = cls(**record)  <span class=\"comment\"># Row can be unpacked as dict</span></span><br><span class=\"line\">        con.close()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> article</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">list</span>(<span class=\"params\">cls</span>) -&gt; <span class=\"type\">List</span>[<span class=\"string\">&#x27;Article&#x27;</span>]:</span><br><span class=\"line\">        con = sqlite3.connect(os.getenv(<span class=\"string\">&#x27;DATABASE_NAME&#x27;</span>, <span class=\"string\">&#x27;database.db&#x27;</span>))</span><br><span class=\"line\">        con.row_factory = sqlite3.Row</span><br><span class=\"line\"></span><br><span class=\"line\">        cur = con.cursor()</span><br><span class=\"line\">        cur.execute(<span class=\"string\">&quot;SELECT * FROM articles&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        records = cur.fetchall()</span><br><span class=\"line\">        articles = [cls(**record) <span class=\"keyword\">for</span> record <span class=\"keyword\">in</span> records]</span><br><span class=\"line\">        con.close()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> articles</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save</span>(<span class=\"params\">self</span>) -&gt; <span class=\"string\">&#x27;Article&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">with</span> sqlite3.connect(os.getenv(<span class=\"string\">&#x27;DATABASE_NAME&#x27;</span>, <span class=\"string\">&#x27;database.db&#x27;</span>)) <span class=\"keyword\">as</span> con:</span><br><span class=\"line\">            cur = con.cursor()</span><br><span class=\"line\">            cur.execute(</span><br><span class=\"line\">                <span class=\"string\">&quot;INSERT INTO articles (id,author,title,content) VALUES(?, ?, ?, ?)&quot;</span>,</span><br><span class=\"line\">                (self.<span class=\"built_in\">id</span>, self.author, self.title, self.content)</span><br><span class=\"line\">            )</span><br><span class=\"line\">            con.commit()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">create_table</span>(<span class=\"params\">cls, database_name=<span class=\"string\">&#x27;database.db&#x27;</span></span>):</span><br><span class=\"line\">        conn = sqlite3.connect(database_name)</span><br><span class=\"line\"></span><br><span class=\"line\">        conn.execute(</span><br><span class=\"line\">            <span class=\"string\">&#x27;CREATE TABLE IF NOT EXISTS articles (id TEXT, author TEXT, title TEXT, content TEXT)&#x27;</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>commands.py如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pydantic <span class=\"keyword\">import</span> BaseModel, EmailStr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.models <span class=\"keyword\">import</span> Article, NotFound</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AlreadyExists</span>(<span class=\"title class_ inherited__\">Exception</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CreateArticleCommand</span>(<span class=\"title class_ inherited__\">BaseModel</span>):</span><br><span class=\"line\">    author: EmailStr</span><br><span class=\"line\">    title: <span class=\"built_in\">str</span></span><br><span class=\"line\">    content: <span class=\"built_in\">str</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">execute</span>(<span class=\"params\">self</span>) -&gt; Article:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            Article.get_by_title(self.title)</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AlreadyExists</span><br><span class=\"line\">        <span class=\"keyword\">except</span> NotFound:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">        article = Article(</span><br><span class=\"line\">            author=self.author,</span><br><span class=\"line\">            title=self.title,</span><br><span class=\"line\">            content=self.title</span><br><span class=\"line\">        ).save()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> article</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>单元测试test_commands.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.commands <span class=\"keyword\">import</span> CreateArticleCommand, AlreadyExists</span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.models <span class=\"keyword\">import</span> Article</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_create_article</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN CreateArticleCommand with a valid properties author, title and content</span></span><br><span class=\"line\"><span class=\"string\">    WHEN the execute method is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN a new Article must exist in the database with the same attributes</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    cmd = CreateArticleCommand(</span><br><span class=\"line\">    author=<span class=\"string\">&#x27;john@doe.com&#x27;</span>,</span><br><span class=\"line\">    title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">    content=<span class=\"string\">&#x27;Super awesome article&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    article = cmd.execute()</span><br><span class=\"line\"></span><br><span class=\"line\">    db_article = Article.get_by_id(article.<span class=\"built_in\">id</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.<span class=\"built_in\">id</span> == article.<span class=\"built_in\">id</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.author == article.author</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.title == article.title</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.content == article.content</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_create_article_with_mock</span>(<span class=\"params\">monkeypatch</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN CreateArticleCommand with valid properties author, title and content</span></span><br><span class=\"line\"><span class=\"string\">    WHEN the execute method is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN a new Article must exist in the database with same attributes</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    article = Article(</span><br><span class=\"line\">    author=<span class=\"string\">&#x27;john@doe.com&#x27;</span>,</span><br><span class=\"line\">    title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">    content=<span class=\"string\">&#x27;Super awesome article&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    monkeypatch.<span class=\"built_in\">setattr</span>(</span><br><span class=\"line\">    Article,</span><br><span class=\"line\">    <span class=\"string\">&#x27;save&#x27;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">lambda</span> self: article</span><br><span class=\"line\">    )</span><br><span class=\"line\">    cmd = CreateArticleCommand(</span><br><span class=\"line\">    author=<span class=\"string\">&#x27;john@doe.com&#x27;</span>,</span><br><span class=\"line\">    title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">    content=<span class=\"string\">&#x27;Super awesome article&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    db_article = cmd.execute()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.<span class=\"built_in\">id</span> == article.<span class=\"built_in\">id</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.author == article.author</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.title == article.title</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> db_article.content == article.content</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_create_article_already_exists</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN CreateArticleCommand with a title of some article in database</span></span><br><span class=\"line\"><span class=\"string\">    WHEN the execute method is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN the AlreadyExists exception must be raised</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Article(</span><br><span class=\"line\">        author=<span class=\"string\">&#x27;jane@doe.com&#x27;</span>,</span><br><span class=\"line\">        title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">        content=<span class=\"string\">&#x27;Super extra awesome article&#x27;</span></span><br><span class=\"line\">    ).save()</span><br><span class=\"line\"></span><br><span class=\"line\">    cmd = CreateArticleCommand(</span><br><span class=\"line\">        author=<span class=\"string\">&#x27;john@doe.com&#x27;</span>,</span><br><span class=\"line\">        title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">        content=<span class=\"string\">&#x27;Super awesome article&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> pytest.raises(AlreadyExists):</span><br><span class=\"line\">        cmd.execute()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>当多次运行时候，需要清理数据库，那么需要使用到用例前置和后置：</p>\n<p>confest.py:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> tempfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.models <span class=\"keyword\">import</span> Article</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">autouse=<span class=\"literal\">True</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">database</span>():</span><br><span class=\"line\">    _, file_name = tempfile.mkstemp()</span><br><span class=\"line\">    os.environ[<span class=\"string\">&#x27;DATABASE_NAME&#x27;</span>] = file_name</span><br><span class=\"line\">    Article.create_table(database_name=file_name)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span></span><br><span class=\"line\">    os.unlink(file_name)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再次运行，执行结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">python3 -m pytest src/tests/blog/test_commands.py</span></span><br><span class=\"line\">=================== test session starts ======================</span><br><span class=\"line\">platform darwin -- Python 3.8.3, pytest-6.2.2, py-1.10.0, pluggy-0.13.1</span><br><span class=\"line\">rootdir: python-ut</span><br><span class=\"line\">plugins: metadata-1.11.0, html-3.1.1, mock-3.5.1</span><br><span class=\"line\">collected 3 items</span><br><span class=\"line\"></span><br><span class=\"line\">src/tests/blog/test_commands.py ...                                                                                                                                                                                                                                                                              [100%]</span><br><span class=\"line\"></span><br><span class=\"line\">===================== 3 passed in 0.02s =======================</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"获取文章列表\"><a href=\"#获取文章列表\" class=\"headerlink\" title=\"获取文章列表\"></a>获取文章列表</h3><p>queries.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> <span class=\"type\">List</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pydantic <span class=\"keyword\">import</span> BaseModel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.models <span class=\"keyword\">import</span> Article</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListArticlesQuery</span>(<span class=\"title class_ inherited__\">BaseModel</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">execute</span>(<span class=\"params\">self</span>) -&gt; <span class=\"type\">List</span>[Article]:</span><br><span class=\"line\">        articles = Article.<span class=\"built_in\">list</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> articles</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>单元测试test_queries.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.models <span class=\"keyword\">import</span> Article</span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.queries <span class=\"keyword\">import</span> ListArticlesQuery, GetArticleByIDQuery</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_list_articles</span>():</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN 2 articles stored in the database</span></span><br><span class=\"line\"><span class=\"string\">    WHEN the execute method is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN it should return 2 articles</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    Article(</span><br><span class=\"line\">    author=<span class=\"string\">&#x27;jane@doe.com&#x27;</span>,</span><br><span class=\"line\">    title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">    content=<span class=\"string\">&#x27;Super extra awesome article&#x27;</span></span><br><span class=\"line\">    ).save()</span><br><span class=\"line\">    Article(</span><br><span class=\"line\">    author=<span class=\"string\">&#x27;jane@doe.com&#x27;</span>,</span><br><span class=\"line\">    title=<span class=\"string\">&#x27;Another Article&#x27;</span>,</span><br><span class=\"line\">    content=<span class=\"string\">&#x27;Super awesome article&#x27;</span></span><br><span class=\"line\">    ).save()</span><br><span class=\"line\"></span><br><span class=\"line\">    query = ListArticlesQuery()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(query.execute()) == <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他功能测试\"><a href=\"#其他功能测试\" class=\"headerlink\" title=\"其他功能测试\"></a>其他功能测试</h2><p>应用入口app.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify, request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.commands <span class=\"keyword\">import</span> CreateArticleCommand</span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.queries <span class=\"keyword\">import</span> GetArticleByIDQuery, ListArticlesQuery</span><br><span class=\"line\"><span class=\"keyword\">from</span> pydantic <span class=\"keyword\">import</span> ValidationError</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/articles/&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create_article</span>():</span><br><span class=\"line\">    cmd = CreateArticleCommand(**request.json)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(cmd.execute().<span class=\"built_in\">dict</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/articles/&lt;article_id&gt;/&#x27;</span>, methods=[<span class=\"string\">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_article</span>(<span class=\"params\">article_id</span>):</span><br><span class=\"line\">    query = GetArticleByIDQuery(</span><br><span class=\"line\">    <span class=\"built_in\">id</span>=article_id</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(query.execute().<span class=\"built_in\">dict</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/articles/&#x27;</span>, methods=[<span class=\"string\">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">list_articles</span>():</span><br><span class=\"line\">    query = ListArticlesQuery()</span><br><span class=\"line\">    records = [record.<span class=\"built_in\">dict</span>() <span class=\"keyword\">for</span> record <span class=\"keyword\">in</span> query.execute()]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(records)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.errorhandler(<span class=\"params\">ValidationError</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">handle_validation_exception</span>(<span class=\"params\">error</span>):</span><br><span class=\"line\">    response = jsonify(error.errors())</span><br><span class=\"line\">    response.status_code = <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n\n<p>暴露json schema，校验响应payload：</p>\n<p>Article.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;$schema&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;http://json-schema.org/draft-07/schema#&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;title&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Article&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;object&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;string&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;author&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;string&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;title&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;string&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;content&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;string&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;required&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"string\">&quot;id&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"string\">&quot;author&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"string\">&quot;title&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"string\">&quot;content&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>ArticleList.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;$schema&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;http://json-schema.org/draft-07/schema#&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;title&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ArticleList&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;array&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;items&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;$ref&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;file:Article.json&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>从应用本身，串起来整个流程的测试，测试test_app.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> pathlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"><span class=\"keyword\">from</span> jsonschema <span class=\"keyword\">import</span> validate, RefResolver</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.app <span class=\"keyword\">import</span> app</span><br><span class=\"line\"><span class=\"keyword\">from</span> src.blog.models <span class=\"keyword\">import</span> Article</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.fixture</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">client</span>():</span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;TESTING&#x27;</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> app.test_client() <span class=\"keyword\">as</span> client:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> client</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">validate_payload</span>(<span class=\"params\">payload, schema_name</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    Validate payload with selected schema</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    schemas_dir = <span class=\"built_in\">str</span>(</span><br><span class=\"line\">        <span class=\"string\">f&#x27;<span class=\"subst\">&#123;pathlib.Path(__file__).parent.absolute()&#125;</span>/schemas&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    schema = json.loads(pathlib.Path(<span class=\"string\">f&#x27;<span class=\"subst\">&#123;schemas_dir&#125;</span>/<span class=\"subst\">&#123;schema_name&#125;</span>&#x27;</span>).read_text())</span><br><span class=\"line\">    validate(</span><br><span class=\"line\">        payload,</span><br><span class=\"line\">        schema,</span><br><span class=\"line\">        resolver=RefResolver(</span><br><span class=\"line\">            <span class=\"string\">&#x27;file://&#x27;</span> + <span class=\"built_in\">str</span>(pathlib.Path(<span class=\"string\">f&#x27;<span class=\"subst\">&#123;schemas_dir&#125;</span>/<span class=\"subst\">&#123;schema_name&#125;</span>&#x27;</span>).absolute()),</span><br><span class=\"line\">            schema  <span class=\"comment\"># it&#x27;s used to resolve file: inside schemas correctly</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_create_article</span>(<span class=\"params\">client</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN request data for new article</span></span><br><span class=\"line\"><span class=\"string\">    WHEN endpoint /articles/ is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN it should return Article in json format matching schema</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    data = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;author&#x27;</span>: <span class=\"string\">&#x27;john@doe.com&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;title&#x27;</span>: <span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;content&#x27;</span>: <span class=\"string\">&#x27;Some extra awesome content&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response = client.post(</span><br><span class=\"line\">        <span class=\"string\">&#x27;/articles/&#x27;</span>,</span><br><span class=\"line\">        data=json.dumps(data),</span><br><span class=\"line\">        content_type=<span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    validate_payload(response.json, <span class=\"string\">&#x27;Article.json&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_get_article</span>(<span class=\"params\">client</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN ID of article stored in the database</span></span><br><span class=\"line\"><span class=\"string\">    WHEN endpoint /articles/&lt;id-of-article&gt;/ is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN it should return Article in json format matching schema</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    article = Article(</span><br><span class=\"line\">        author=<span class=\"string\">&#x27;jane@doe.com&#x27;</span>,</span><br><span class=\"line\">        title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">        content=<span class=\"string\">&#x27;Super extra awesome article&#x27;</span></span><br><span class=\"line\">    ).save()</span><br><span class=\"line\">    response = client.get(</span><br><span class=\"line\">        <span class=\"string\">f&#x27;/articles/<span class=\"subst\">&#123;article.<span class=\"built_in\">id</span>&#125;</span>/&#x27;</span>,</span><br><span class=\"line\">        content_type=<span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    validate_payload(response.json, <span class=\"string\">&#x27;Article.json&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_list_articles</span>(<span class=\"params\">client</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN articles stored in the database</span></span><br><span class=\"line\"><span class=\"string\">    WHEN endpoint /articles/ is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN it should return list of Article in json format matching schema</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    Article(</span><br><span class=\"line\">        author=<span class=\"string\">&#x27;jane@doe.com&#x27;</span>,</span><br><span class=\"line\">        title=<span class=\"string\">&#x27;New Article&#x27;</span>,</span><br><span class=\"line\">        content=<span class=\"string\">&#x27;Super extra awesome article&#x27;</span></span><br><span class=\"line\">    ).save()</span><br><span class=\"line\">    response = client.get(</span><br><span class=\"line\">        <span class=\"string\">&#x27;/articles/&#x27;</span>,</span><br><span class=\"line\">        content_type=<span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    validate_payload(response.json, <span class=\"string\">&#x27;ArticleList.json&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@pytest.mark.parametrize(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\"><span class=\"string\">&#x27;data&#x27;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">[</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;author&#x27;</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;title&#x27;</span>: <span class=\"string\">&#x27;New Article&#x27;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;content&#x27;</span>: <span class=\"string\">&#x27;Some extra awesome content&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    &#125;,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;author&#x27;</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;title&#x27;</span>: <span class=\"string\">&#x27;New Article&#x27;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    &#125;,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;author&#x27;</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;title&#x27;</span>: <span class=\"literal\">None</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">        <span class=\"string\">&#x27;content&#x27;</span>: <span class=\"string\">&#x27;Some extra awesome content&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\">]</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"meta\"></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_create_article_bad_request</span>(<span class=\"params\">client, data</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    GIVEN request data with invalid values or missing attributes</span></span><br><span class=\"line\"><span class=\"string\">    WHEN endpoint /create-article/ is called</span></span><br><span class=\"line\"><span class=\"string\">    THEN it should return status 400 and JSON body</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    response = client.post(</span><br><span class=\"line\">        <span class=\"string\">&#x27;/articles/&#x27;</span>,</span><br><span class=\"line\">        data=json.dumps(data),</span><br><span class=\"line\">        content_type=<span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> response.status_code == <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> response.json <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n\n<p>小结<br>自此，上面的web小应用基本可以完成，包含了基本的服务层单元测试、数据库模拟、mock创建文章以及参数化请求验证。<br>代码示例：Python情景示例代码: <a href=\"https://github.com/vwin/python-ut\">https://github.com/vwin/python-ut</a></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>Python的单元测试框架中，Python库本身提供了unittest，也有第三方框架进行了封装。原生的库插件少，二次开发非常方便。第三方框架融合了不少插件，上手简单。<br>Python属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态地逐行解释运行，虽然其本身的结构灵活多变，但是仍然不妨碍我们用单元测试保证其质量、权衡其设计、设置其有形和无形的约束，为开发保驾护航。</p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><p><a href=\"https://wiki.python.org/moin/PythonTestingToolsTaxonomy\">Python Testing Tools Taxonomy</a><br><a href=\"https://testdriven.io/blog/modern-tdd/#when-should-you-use-mocks\">Modern Test-Driven Development in Python</a></p>\n","slug":"Python-单测","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/03/Python-%E5%8D%95%E6%B5%8B/","excerpt":"单测系列-Python总结在Python中如何做单测，本文介绍了Python常用的单测框架和工具","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"单测","slug":"单测","permalink":"http://vwin.github.io/tags/%E5%8D%95%E6%B5%8B/"},{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"pytest","slug":"pytest","permalink":"http://vwin.github.io/tags/pytest/"},{"name":"unittest","slug":"unittest","permalink":"http://vwin.github.io/tags/unittest/"}]},{"title":"CPP-单测","date":"2022-11-01T06:58:57.000Z","path":"2022/11/01/CPP-单测/","text":"单测系列-C++总结在C++中如何做单测，本文介绍了单测是什么以及C++常用的单测框架和工具 单元测试单元测试是什么单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、超类、抽象类等中的方法。单元测试就是软件开发中对最小单位进行正确性检验的测试工作。不同地方对单元测试有的定义可能会有所不同，但有一些基本共识： 单元测试是比较底层的，关注代码的局部而不是整体。 单元测试是开发人员在写代码时候写的。 单元测试需要比其他测试运行得快。 单元测试的意义 提高代码质量。代码测试都是为了帮助开发人员发现问题从而解决问题，提高代码质量。 尽早发现问题。问题越早发现，解决的难度和成本就越低。 保证重构正确性。随着功能的增加，重构（修改老代码）几乎是无法避免的。很多时候我们不敢重构的原因，就是担心其它模块因为依赖它而不工作。有了单元测试，只要在改完代码后运行一下单测就知道改动对整个系统的影响了，从而可以让我们放心的重构代码。 简化调试过程。单元测试让我们可以轻松地知道是哪一部分代码出了问题。 简化集成过程。由于各个单元已经被测试，在集成过程中进行的后续测试会更加容易。 优化代码设计。编写测试用例会迫使开发人员仔细思考代码的设计和必须完成的工作，有利于开发人员加深对代码功能的理解，从而形成更合理的设计和结构。 单元测试是最好的文档。单元测试覆盖了接口的所有使用方法，是最好的示例代码。而真正的文档包括注释很有可能和代码不同步，并且看不懂。 单元测试用例编写的原则理论原则 快。单元测试是回归测试，可以在开发过程的任何时候运行，因此运行速度必须快 一致性。代码没有改变的情况下，每次运行得结果应该保持确定且一致 原子性。结果只有两种情况：Pass &#x2F; Fail 用例独立。执行顺序不影响；用例间没有状态共享或者依赖关系；用例没有副作用（执行前后环境状态一致） 单一职责。一个用例只负责一个场景 隔离。功能可能依赖于数据库、web访问、环境变量、系统时间等；一个单元可能依赖于另一部分代码，用例应该解除这些依赖 可读性。用例的名称、变量名等应该具有可读性，直接表现出该测试的目标 自动化。单元测试需要全自动执行。测试程序不应该有用户输入；测试结果应该能直接被电脑获取，不应该由人来判断。 规约原则在实际编写代码过程中，不同的团队会有不同团队的风格，只要团队内部保持有一定的规约即可，比如： 单元测试文件名必须以xxx_test.go命名 方法必须是TestXxx开头，建议风格保持一致（驼峰或者下划线） 方法参数必须 t *testing.T 测试文件和被测试文件必须在一个包中 衡量原则单元测试是要写额外的代码的，这对开发同学的也是一个不小的工作负担，在一些项目中，我们合理的评估单元测试的编写，我认为我们不能走极端，当然理论上来说全写肯定时好的，但是从成本，效率上来说我们必须做出权衡，衡量原则如下： 优先编写核心组件和逻辑模块的测试用例 逻辑类似的组件如果存在多个，优先编写其中一种逻辑组件的测试用例 发现Bug时一定先编写测试用例进行Debug 关键util工具类要编写测试用例，这些util工具适用的很频繁，所以这个原则也叫做热点原则，和第1点相呼应。 测试用户应该独立，一个文件对应一个，而且不同的测试用例之间不要互相依赖。 测试用例的保持更新 单元测试用例设计方法规范(规格)导出法规范(规格)导出法将需求”翻译“成测试用例。 例如，一个函数的设计需求如下： 12345函数：一个计算平方根的函数 输入： 实数 输出： 实数 要求： 当输入一个0或者比0大的实数时，返回其正的平方根； 当输入一个小于0的实数时，显示错误信息“平方根非法—输入之小于0”，并返回0； 库函数printf()可以用来输出错误信息。 在这个规范中有3个陈述，可以用两个测试用例来对应: 编号 用例 1 输入4，输出2 2 输入-1，输出0 等价类划分法等价类划分法假定某一特定的等价类中的所有值对于测试目的来说是等价的，所以在每个等价类中找一个之作为测试用例。 按照 [输入条件][有效等价类][无效等价类] 建立等价类表，列出所有划分出的等价类 为每一个等价类规定一个唯一的编号 设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类。重复这一步，直到所有的有效等价类都被覆盖为止 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，直到所有的无效等价类都被覆盖为止 例如，注册邮箱时要求用6~18个字符，可使用字母、数字、下划线，需以字母开头。 有效等价类 无效等价类 6~18个字符（1） 少于6个字符（2）多余18个字符（3）空（4） 包含字母、数字、下划线（5） 除字母、数字、下划线的特殊字符（6）非打印字符（7）中文字符 （8） 以字母开头（9） 以数字或下划线开头（10） 测试用例 编号 输入数据 覆盖等价类 预期结果 1 test_111 （1）、（5）、（9） 合法输入 2 t_11 （2）、（5）、（9） 非法输入 3 testtesttest_12345678 （3）、（5）、（9） 非法输入 4 NULL （4） 非法输入 5 test!@1111 （1）、（6）、（9） 非法输入 6 test 1111 （1）、（7）、（9） 非法输入 7 test测试1111 （1）、（8）、（9） 非法输入 8 _test111 （1）、（5）、（10） 非法输入 边界值分析法边界值分析法使用与等价类测试方法相同的等价类划分，只是边界值分析假定 错误更多地存在于两个划分的边界上。边界值测试在软件变得复杂的时候也会变得不实用。边界值测试对于非向量类型的值(如枚举类型的值)也没有意义。例如，和4.1相同的需求，划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0。由此得到以下测试用例： 输入 {最小负实数} 输入 {绝对值很小的负数} 输入 0 输入 {绝对值很小的正数} 输入 {最大正实数} 基本路径测试法基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。基本路径测试法的基本步骤： 程序的控制流图：描述程序控制流的一种图示方法。 程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。 导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。 准备测试用例：确保基本路径集中的每一条路径的执行。 常用C++单测框架常用的C++单测对比 编号 Google test Catch 2 CppUTest 特点 成熟、兼容性好简洁、有效率常用、学习资源多 框架只有一个catch.hpp、集成轻松有Given-When-Then分区，适合BDD行为驱动开发无自带Mock框架 可以检测内存泄露输出更简洁适合在嵌入式系统项目中使用 Mock框架 Google Mock 无自带Mock框架 CppUMock 推荐指数 ★★★★★ ★★★☆☆ ★★☆☆☆ 一般情况下，我们推荐使用Google Test搭配Google Mock。如果项目有特殊需求或更适合其他框架，也可以考虑。根据实际使用频率，在以下部分，Google Test和Google Mock的介绍更为详细；对于其他框架，这里介绍它们的主要特点， 具体使用方法，可以查阅各自文档。 Google TestGoogle Test是目前比较成熟而且最常用的C++单元测试框架之一。 基本概念 断言（Assertions） 是检查条件是否为真的语句。断言的结果可能是成功或者失败， 而失败又分为非致命失败或致命失败。如果发生致命失败，测试进程将中止当前运行，否则它将继续运行。 测试（Test） 使用断言来验证被测试代码的行为。如果测试崩溃或断言失败，则测试失败；否则测试成功。 测试套件（Test Suite） 包含一个或多个测试（Test）。当测试套件中的多个测试需要共享通用对象和子例程时， 可以将它们放入测试夹具（Test Fixture）。 测试程序（Test Program） 可以包含多个测试套件。 断言 Google Test中，断言（Assertions） 是类似函数调用的宏。断言失败时，googletest会输出断言的源文件和 行号位置以及失败消息；我们还可以提供自定义失败消息，该消息将附加到googletest消息中。 断言成对出现（ASSERT_*和EXPECT_*），它们测试的对象相同，但对当前运行有不同的影响。ASSERT_*版本失败时 会产生致命故障，并中止当前函数（不一定是整个TEST）运行。EXPECT_*版本会产生非致命故障，不会停止当前函数运行。 通常EXPECT_*是首选，因为可以在测试中报告多个故障。但是如果在断言失败时继续执行没有意义，则应使用ASSERT_*。 要提供自定义失败消息，只需使用&lt;&lt; 运算符或此类运算符的序列将其流式传输到宏中即可 。一个例子：12345ASSERT_EQ(x.size(), y.size()) &lt;&lt; &quot;x和y长度不同&quot;;for (int i = 0; i &lt; x.size(); ++i) &#123; EXPECT_EQ(x[i], y[i]) &lt;&lt; &quot;x和y元素存在不同：&quot; &lt;&lt; i;&#125; 以下是一些最常用的断言，如果需要查阅其他断言，可以前往googletest的官方文档。 基本断言condition 是返回true&#x2F;false的变量、布尔表达式、函数调用等，以下断言对其进行验证。 失败时中断执行的断言 失败时不中断执行的断言 断言成功情况 ASSERT_TRUE(condition); EXPECT_TRUE(condition); condition为真 ASSERT_FALSE(condition); EXPECT_FALSE(condition); condition为假 例如：在ASSERT_TRUE(condition)中，当condition为true时，符合断言，不影响执行；当condition为false时，不符合断言，且由于是ASSERT，当前执行中断。 普通比较型断言val1和val2是两个可用==、!=、&gt;、&lt;等运算符进行比较的值，以下断言对其进行比较。 失败时中断执行的断言 失败时不中断执行的断言 断言成功情况 ASSERT_EQ(val1, val2); EXPECT_EQ(val1, val2); val1 &#x3D;&#x3D; val2 ASSERT_NE(val1, val2); EXPECT_NE(val1, val2); val1 !&#x3D; val2 ASSERT_LT(val1, val2); EXPECT_LT(val1, val2); val1 &lt; val2 ASSERT_LE(val1, val2); EXPECT_LE(val1, val2); val1 &lt;&#x3D; val2 ASSERT_GT(val1, val2); EXPECT_GT(val1, val2); val1 &gt; val2 ASSERT_GE(val1, val2); EXPECT_GE(val1, val2); val1 &gt;&#x3D; val2 例如：在ASSERT_GT(val1, val2)中，只有当val1 &gt; val2时，符合断言，不影响执行；当val1 &lt;= val2时，不符合断言，且由于是ASSERT，当前执行中断。 C字符串比较型断言str1和str2是两个C字符串，以下断言对它们的值进行比较；如果要比较两个std::string对象，直接用之前提到的EXPECT_NE，EXPECT_NE等。 失败时中断执行的断言 失败时不中断执行的断言 断言成功情况 ASSERT_STREQ(str1,str2); EXPECT_STREQ(str1,str2); 这两个C字符串具有相同的内容 ASSERT_STRNE(str1,str2); EXPECT_STRNE(str1,str2); 两个C字符串的内容不同 ASSERT_STRCASEEQ(str1,str2); EXPECT_STRCASEEQ(str1,str2); 忽略大小写，两个C字符串的内容相同 ASSERT_STRCASENE(str1,str2); EXPECT_STRCASENE(str1,str2) 忽略大小写，两个C字符串的内容不同 例如：char *str1 = &quot;ABC&quot;;``char *str2 = &quot;ABC&quot;;，EXPECT_STREQ(str1, str2);断言通过，因为它们的内容一样；而EXPECT_EQ(str1, str2);断言失败，因为它们的地址不一样。 注意：一个NULL指针和一个空字符串&quot;&quot;是不同的。 浮点数比较型断言val1和val2是两个浮点数，以下断言对其进行比较。 失败时中断执行的断言 失败时不中断执行的断言 断言成功情况 ASSERT_FLOAT_EQ(val1, val2); EXPECT_FLOAT_EQ(val1, val2); 这两个float值几乎相等 ASSERT_DOUBLE_EQ(val1, val2); EXPECT_DOUBLE_EQ(val1, val2); 这两个double值几乎相等 以下断言可以选择可接受的误差范围： 失败时中断执行的断言 失败时不中断执行的断言 断言成功情况 ASSERT_NEAR(val1, val2, abs_error); EXPECT_NEAR(val1, val2, abs_error); val1和val2的差的绝对值不超过abs_error 明确的成功和失败 明确生成成功： SUCCEED(); 生成一个成功，但这不代表整个测试就成功了。 明确生成失败： FAIL(); 生成致命错误 ADD_FAILURE(); 生成非致命错误。 ADD_FAILURE_AT(&quot;file_path&quot;,line_number); 生成非致命错误，输出文件名和行号。 例如： 12345if(condition) &#123; SUCCEED();&#125; else&#123; FAIL();&#125; 效果上等同于 1ASSERT_TRUE(condition); 只是ASSERT_TRUE失败时可以输出condition的具体值。当但我们需要验证的condition很复杂时，或者需要很多个if..else...分支来验证彼此互斥的情况以保证覆盖到每一种可能性时，SUCCEED()、FAIL()等明确的成功&#x2F;失败可能是更好的选择。 异常断言这些断言验证一段代码（statement）是否抛出（或不抛出）给定类型的异常： 失败时中断执行的断言 失败时不中断执行的断言 断言成功情况 ASSERT_THROW(statement, exception_type); EXPECT_THROW(statement, exception_type); statement抛出给定类型的异常 ASSERT_ANY_THROW(statement); EXPECT_ANY_THROW(statement); statement抛出任何类型的异常 ASSERT_NO_THROW(statement); EXPECT_NO_THROW(statement); statement不抛出任何异常 使用已有布尔函数当predN是一个有N个参数，返回布尔值的函数时，以下断言可以获取更好的错误信息。 失败时中断执行的断言 失败时不中断执行的断言 断言成功情况 ASSERT_PRED1(pred1, val1); EXPECT_PRED1(pred1, val1); pred1(val1)为真 ASSERT_PRED2(pred2, val1, val2); EXPECT_PRED2(pred2, val1, val2); pred2(val1, val2)为真 … … … 例如：isComparable(Object o1, Object o2)是一个返回布尔值的函数。我们可以有以下选择，都能达到验证函数调用结果的目的： ASSERT_TRUE(isComparable(obj1, obj2)); ASSERT_PRED2(isComparable, obj1, obj2); 区别在于：当断言失败时，ASSERT_TRUE只会告知函数最后的返回值是false；而ASSERT_TRUE同时会输出val1、val2的值。 测试创建一个测试的步骤： 使用TEST()宏定义和命名测试功能。 在TEST()宏内，构造出达到测试状态的函数、变量 使用断言指定函数、变量期望的返回值、值。1234TEST(MessageTestSuite, BodyLengthNegative) &#123; ... 构造 ... ... 断言 ...&#125; TEST()第一个参数是Test Suite的名称，第二个参数是Test Suite内的Test名称。这两个名称都必须是有效的C++标识符，并且它们不应包含任何下划线（_）。测试的全名包括Test Suite名和Test名。来自不同Test Suite的测试可以具有相同的Test名。它们都不是变量，也不是字符串。 在上面的例子中，这个测试的名称是BodyLengthNegative，Test Suite的名称是MessageTestSuite。 测试夹具：多个测试有共有的数据配置如果多个测试有共有的数据配置，可以使用测试夹具（Test Fixture）将共用部分提取出来重复利用。 要创建一个测试夹具： 创建一个继承::testing::Test的类。从protected开始这个类，因为我们要从子类访问夹具成员。 在类内部，声明计划使用的任何对象。 如有必要，编写默认的constructor或SetUp()函数为每个测试准备对象。 如有必要，编写一个destructor或TearDown()函数以释放在SetUp()中分配的任何资源。 如有必要，定义一些共享的类函数 当使用测试夹具是，需要使用TEST_F()而不是TEST() 1234567891011121314151617181920212223class TestFixtureName : public ::testing::Test &#123;protected: virtual void SetUp() &#123; ... &#125; virtual void TearDown() &#123; ... &#125; virtual int SomeFunction() &#123; ... &#125; SomeObject object;&#125;;TEST_F(TestFixtureName, TestName1) &#123; ... 构造 ... ... 断言 ...&#125;TEST_F(TestFixtureName, TestName2) &#123; ... 构造 ... ... 断言 ...&#125; 那上面这个例子来说，对于每个TEST_F()测试，googletest将在运行时 创建一个新的测试夹具（Test Fixture）对象 通过SetUp()对其进行初始化 运行该TEST_F()测试 通过调用进行清理TearDown() 然后删除该测试夹具（Test Fixture）对象 所以，虽然多个TEST_F共用同一部分代码，但共同代码会每个TEST_F都独立执行一次。同一测试套件中的不同测试具有不同的测试夹具对象。一个测试对测试夹具所做的任何更改均不会影响其他测试。 Catch 2Catch2 仅有头部文件（header only），所以它的第一个优点是可以轻易地放入任何项目中进行使用。只需要 #include &quot;catch.hpp&quot; 就可以在当前文件使用 Catch REQUIRECatch的基础使用方法也很简单。 12345678910111213#define CATCH_CONFIG_MAIN // This tells Catch to provide a main() - only do this in one cpp file#include &quot;catch.hpp&quot;unsigned int Factorial( unsigned int number ) &#123; return number &lt;= 1 ? number : Factorial(number-1)*number;&#125;TEST_CASE( &quot;Factorials are computed&quot;, &quot;[factorial]&quot; ) &#123; REQUIRE( Factorial(0) == 1 ); REQUIRE( Factorial(1) == 1 ); REQUIRE( Factorial(2) == 2 ); REQUIRE( Factorial(3) == 6 ); REQUIRE( Factorial(10) == 3628800 );&#125; SECTIONSCatch的SECTION相当于GTEST里夹具（fixture）的功能。对每一个SECTION，TEST_CASE 都从头开始执行。 12345678910111213141516171819202122232425TEST_CASE( &quot;vectors can be sized and resized&quot;, &quot;[vector]&quot; ) &#123; std::vector&lt;int&gt; v( 5 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); SECTION( &quot;resizing bigger changes size and capacity&quot; ) v.resize( 10 ); REQUIRE( v.size() == 10 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; SECTION( &quot;resizing smaller changes size not capacity&quot; )&#123; v.resize( 0 ); REQUIRE( v.size() == 0 ); REQUIRE( v.capacity() &gt;= 5 ); &#125; SECTION( &quot;reserving bigger changes capacity not size&quot; ) &#123; v.reserve( 10 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; SECTION( &quot;reserving smaller does not change size&quot; ) &#123; v.reserve( 0 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); &#125;&#125; 标签Catch提供标签特性。 1234TEST_CASE( &quot;A&quot;, &quot;[widget]&quot; ) &#123; /* ... */ &#125;TEST_CASE( &quot;B&quot;, &quot;[widget]&quot; ) &#123; /* ... */ &#125;TEST_CASE( &quot;C&quot;, &quot;[gadget]&quot; ) &#123; /* ... */ &#125;TEST_CASE( &quot;D&quot;, &quot;[widget][gadget]&quot; ) &#123; /* ... */ &#125; &quot;[widget]&quot; 选取 A、B、D. &quot;[gadget]&quot; 选取 C、D. &quot;[widget][gadget]&quot; 只选取 D &quot;[widget],[gadget]&quot; 所有A、B、C、D. 还有一些特殊标签指定特殊行为 特点总结 框架只有一个catch.hpp、集成轻松 有Given-When-Then分区，适合BDD行为驱动开发 无自带Mock框架 CppUTestmain和testmain.cpp: 1234#include &quot;CppUTest/CommandLineTestRunner.h&quot;int main(int ac, char** av)&#123; return CommandLineTestRunner::RunAllTests(ac, av);&#125; test.cpp: 12345678910111213141516#include &quot;CppUTest/TestHarness.h&quot;TEST_GROUP(FirstTestGroup)&#123; void setup()&#123; // Init stuff &#125; void teardown()&#123; // Uninit stuff &#125;&#125;;TEST(FirstTestGroup, FirstTest)&#123; FAIL(&quot;Fail me!&quot;);&#125;TEST(FirstTestGroup, SecondTest)&#123; STRCMP_EQUAL(&quot;hello&quot;, &quot;world&quot;);&#125; 断言 CHECK(boolean condition)检查任何布尔结果。 CHECK_TEXT(boolean condition, text)检查任何布尔结果，并在失败时输出文本。 CHECK_FALSE(condition)检查任何布尔结果 CHECK_EQUAL(expected, actual)使用==检查实体之间的相等性。因此，如果有一个支持operator==()的类，则可以使用此宏比较两个实例。 CHECK_COMPARE(first, relop, second)检查在两个实体之间是否存在关系运算符。失败时，打印两个操作数求和的结果。 CHECK_THROWS(expected_exception, expression)检查表达式是否抛出expected_exception（例如std::exception）。CHECK_THROWS仅在使用标准C ++库（默认）构建CppUTest时可用。 STRCMP_EQUAL(expected, actual)使用strcmp()检查const char *字符串是否相等。 STRNCMP_EQUAL(expected, actual, length)使用strncmp()检查const char *字符串是否相等。 STRCMP_NOCASE_EQUAL(expected, actual)不考虑大小写，检查const char *字符串是否相等。 特点 可以检测内存泄露 输出更简洁 使用在嵌入式系统项目中使用 Google MockGoogle Mock一般来说和Google Test搭配使用，但Google Test也可以和其他Mock框架一起使用。本部分是Google Mock基础常用的用法，如需要特殊用法，请查阅Google Mock官方文档。 Fake、Mock、Stub Fake对象有具体的实现，但采取一些捷径，比如用内存替代真实的数据库读取。 Stub对象没有具体的实现，只是返回提前准备好的数据。 Mock对象和Stub类似，只是在测试中需要调用时，针对某种输入指定期望的行为。Mock和Stub的区别是，Mock除了返回数据还可以指定期望以验证行为。 简单例子：Mock TurtleTurtle类: 1234567891011class Turtle &#123; ... virtual ~Turtle() &#123;&#125;; virtual void PenUp() = 0; virtual void PenDown() = 0; virtual void Forward(int distance) = 0; virtual void Turn(int degrees) = 0; virtual void GoTo(int x, int y) = 0; virtual int GetX() const = 0; virtual int GetY() const = 0;&#125;; MockTurtle类: 12345678910111213#include &quot;gmock/gmock.h&quot;class MockTurtle : public Turtle &#123;public: ... MOCK_METHOD(void, PenUp, (), (override)); MOCK_METHOD(void, PenDown, (), (override)); MOCK_METHOD(void, Forward, (int distance), (override)); MOCK_METHOD(void, Turn, (int degrees), (override)); MOCK_METHOD(void, GoTo, (int x, int y), (override)); MOCK_METHOD(int, GetX, (), (const, override)); MOCK_METHOD(int, GetY, (), (const, override));&#125;; 创建Mock类的步骤： MockTurtle继承Turtle 找到Turtle的一个虚函数 在public:的部分中，写一个MOCK_METHOD(); 将虚函数函数签名复制进MOCK_METHOD();中，加两个逗号：一个在返回类型和函数名之间另一个在函数名和参数列表之间 例如：void PenDown()有三部分：void、PenDown和()，这三部分就是MOCK_METHOD的前三个参数 如果要模拟const方法，添加一个包含(const) 的第4个参数（必须带括号）。 建议添加override关键字。所以对于const方法，第四个参数变为(const, override)，对于非const方法，第四个参数变为(override)。这不是强制性的。 重复步骤直至完成要模拟的所有虚拟函数。 在测试中使用Mock在测试中使用Mock的步骤： 从testing名称空间导入gmock.h的函数名（每个文件只需要执行一次）。 创建一些Mock对象。 指定对它们的期望（方法将被调用多少次？带有什么参数？每次应该做什么（对参数做什么、返回什么值）？等等）。 使用Mock对象；可以使用googletest断言检查结果。如果mock函数的调用超出预期或参数错误，将会立即收到错误消息。 当Mock对象被销毁时，gMock自动检查对模拟的所有期望是否得到满足。 123456789101112131415#include &quot;path/to/mock-turtle.h&quot;#include &quot;gmock/gmock.h&quot;#include &quot;gtest/gtest.h&quot;using ::testing::AtLeast; // #1TEST(PainterTest, CanDrawSomething) &#123; MockTurtle turtle; // #2 EXPECT_CALL(turtle, PenDown()) // #3 .Times(AtLeast(1)); Painter painter(&amp;turtle); // #4 EXPECT_TRUE(painter.DrawCircle(0, 0, 10)); // #5&#125; 在这个例子中，我们期望turtle的PenDown()至少被调用一次。如果在turtle对象被销毁时，PenDown()还没有被调用或者调用两次或以上，测试会失败。 指定期望EXPECT_CALL（指定期望）是使用Google Mock的核心。EXPECT_CALL的作用是两方面的： 告诉这个Mock（假）方法如何模仿原始方法： 我们在EXPECT_CALL中告诉Google Mock，某个对象的某个方法被第一次调用时，会修改某个参数，会返回某个值；第二次调用时，会修改某个参数，会返回某个值……. 验证被调用的情况 我们在EXPECT_CALL中告诉Google Mock，某个对象的某个方法总共会被调用N次（或大于N次、小于N次）。如果最终次数不符合预期，会导致测试失败。 基本语法1234EXPECT_CALL(mock_object, method(matchers)) .Times(cardinality) .WillOnce(action) .WillRepeatedly(action); mock_object 是对象 method(matchers) 用于匹配相应的函数调用 cardinality 指定基数（被调用次数情况） action 指定被调用时的行为 例子： 1234567using ::testing::Return;...EXPECT_CALL(turtle, GetX()) .Times(5) .WillOnce(Return(100)) .WillOnce(Return(150)) .WillRepeatedly(Return(200)); 这个EXPECT_CALL()指定的期望是：在turtle这个Mock对象销毁之前，turtle的getX()函数会被调用五次。第一次返回100，第二次返回150，第三次及以后都返回200。指定期望后，5次对getX的调用会有这些行为。但如果最终调用次数不为5次，则测试失败。 参数匹配：哪次调用123456using ::testing::_;using ::testing::Ge;// 只与Forward(100)匹配EXPECT_CALL(turtle, Forward(100));// 与GoTo(x,y)匹配, 只要x&gt;=50EXPECT_CALL(turtle, GoTo(Ge(50), _)); _相当于“任何”。 100相当于Eq(100)。 Ge(50)指参数大于或等于50。 如果不关心参数，只写函数名就可以。比如EXPECT_CALL(turtle, GoTo);。 基数：被调用几次用Times(m)，Times(AtLeast(n))等来指定期待的调用次数。 Times可以被省略。比如整个EXPECT_CALL只有一个WillOnce(action)相当于也说明了调用次数只能为1。 行为：该做什么常用模式：如果需要指定前几次调用的特殊情况，并且之后的调用情况相同。使用一系列WillOnce()之后有WillRepeatedly() 除了用来指定调用返回值的Return()，Google Mock中常用行为中还有：SetArgPointee&lt;N&gt;(value)，SetArgPointee将第N个指针参数（从0开始）指向的变量赋值为value。 比如void getObject(Object* response)&#123;...&#125;的EXPECT_CALL： 123Object* a = new Object;EXPECT_CALL(object, request) .WillOnce(SetArgPointee&lt;1&gt;(*a)); 就修改了传入的指针response，使其指向了一个我们新创建的对象。 如果有多个行为，应该使用DoAll(a1, a2, ..., an)。DoAll执行所有n个action并返回an的结果。 使用多个预期例子： 123456789using ::testing::_;...EXPECT_CALL(turtle, Forward(_)) // #1 .Times(3); EXPECT_CALL(turtle, Forward(10)) // #2 .Times(2);...mock对象函数被调用... //Forward(10); // 与#2匹配 //Forward(20); // 与#1匹配 正常情况下，Google Mock以倒序搜索预期：如果和多个EXPECT_CALL都可以匹配，只有之前的，距离调用最近的一个EXPECT_CALL()会被匹配。例如： 连续三次调用Forward(10)会生错误因为它和#2匹配。 连续三次调用Forward(20)不会有错误因为它和#1匹配。 一旦匹配，该预期会被一直绑定，即使执行次数达到上限之后，还是是生效的，这就是为什么三次调用Forward(10)超过了2号EXPECT_CALL的上限时，不会去试图绑定1号EXPECT_CALL而是报错的原因。 为了明确地让某一个EXPECT_CALL“退休”，可以加上RetiresOnSaturation()，例子： 1234567891011using ::testing::Return;EXPECT_CALL(turtle, GetX()) // #1 .WillOnce(Return(10)) .RetiresOnSaturation();EXPECT_CALL(turtle, GetX()) // #2 .WillOnce(Return(20)) .RetiresOnSaturation();turtle.GetX() // 与#2匹配，返回20，然后#2“退休”turtle.GetX() // 与#1匹配，返回10 在这个例子中，第一次GetX()调用和#2匹配，返回20，然后这个EXPECT_CALL就“退休”了；第二次GetX()调用和#1匹配，返回10 Sequence可以用sequence来指定期望匹配的顺序。 12345678910111213using ::testing::Return;using ::testing::Sequence;Sequence s1, s2;...EXPECT_CALL(foo, Reset()) .InSequence(s1, s2) .WillOnce(Return(true));EXPECT_CALL(foo, GetSize()) .InSequence(s1) .WillOnce(Return(1));EXPECT_CALL(foo, Describe(A&lt;const char*&gt;())) .InSequence(s2) .WillOnce(Return(&quot;dummy&quot;)); 在上面的例子中，创建了两个Sequence s1和s2，属于s1的有Reset()和GetSize()，所以Reset()必须在GetSize()之前执行。属于s2的有Reset()和Describe(A&lt;const char*&gt;())，所以Reset()必须在Describe(A&lt;const char*&gt;())之前执行。所以，Reset()必须在GetSize()和Describe()之前执行。而GetSize()和Describe()这两者之间没有顺序约束。 如果需要指定很多期望的顺序，有另一种用法： 123456789using ::testing::InSequence;&#123; InSequence seq; EXPECT_CALL(...)...; EXPECT_CALL(...)...; ... EXPECT_CALL(...)...;&#125; 在这种用法中，scope中（大括号中）的期望必须遵守严格的顺序。 更多 Google Mock Cheat Sheet Google Mock Cook Book 情景示例在这部分，我们用一个示例项目来演示，如何在不同情景中使用Google Test和Google Mock写单元测试用例。 项目结构示例项目是一个C++命令行聊天室软件，包含服务器和客户端。 123456789101112131415161718192021222324252627.├── CMakeLists.txt├── README.md├── client_main.cpp├── server_main.cpp├── include│ ├── chat_client.hpp│ ├── chat_message.hpp│ ├── chat_participant.hpp│ ├── chat_room.hpp│ ├── chat_server.hpp│ ├── chat_session.hpp│ ├── http_request.hpp│ ├── http_request_impl.hpp│ ├── message_dao.hpp│ └── message_dao_impl.hpp├── src│ ├── chat_client.cpp│ ├── chat_message.cpp│ ├── chat_room.cpp│ ├── chat_server.cpp│ ├── chat_session.cpp│ ├── http_request_impl.cpp│ └── message_dao_impl.cpp└── tests ├── chat_message_unittest.cpp └── chat_room_unittest.cpp 普通测试如果被测试的函数不包含外部依赖，用Google Test基础的用法就可以完成用例编写。 原函数： 12345void chat_message::body_length(std::size_t new_length) &#123; body_length_ = new_length; if (body_length_ &gt; 512) body_length_ = 512;&#125; 这个函数很简单。就是给body_length_赋值但是有最大值限制。测试用例可以这样写： 1234567891011121314151617181920212223242526272829TEST(ChatMessageTest, BodyLengthNegative) &#123; chat_message c; c.body_length(-50); EXPECT_EQ(512, c.body_length());&#125;TEST(ChatMessageTest, BodyLength0) &#123; chat_message c; c.body_length(0); EXPECT_EQ(0, c.body_length());&#125;TEST(ChatMessageTest, BodyLength100) &#123; chat_message c; c.body_length(100); EXPECT_EQ(100, c.body_length());&#125;TEST(ChatMessageTest, BodyLength512) &#123; chat_message c; c.body_length(512); EXPECT_EQ(512, c.body_length());&#125;TEST(ChatMessageTest, BodyLength513) &#123; chat_message c; c.body_length(513); EXPECT_EQ(512, c.body_length());&#125; 我们可以看到，对于这类函数，用例编写很直接简单，步骤都是构造变量，再用合适的Google Test的宏来验证变量值或者函数调用返回值。 简单 Mock原函数 123void chat_room::leave(chat_participant_ptr participant) &#123; participants_.erase(participant);&#125; participants_ 的类型是 std::set&lt;chat_participant_ptr&gt;。这个函数的目的很明显，将一个participant从set中移除。 真实地创建一个聊天参与者participant对象可以条件比较苛刻或者成本比较高。为了有效率地验证这个函数，我们可以新建一些Mock的chat_participant_ptr而不用严格地去创建真实的participant对象。 chat_participant对象： 12345class chat_participant &#123;public: virtual ~chat_participant() &#123;&#125; virtual void deliver(const chat_message &amp;msg) = 0;&#125;; Mock对象： 1234class mock_chat_participant : public chat_participant &#123;public: MOCK_METHOD(void, deliver, (const chat_message &amp;msg), (override));&#125;; 测试用例： 123456789101112131415161718TEST(ChatRoomTest, leave) &#123; auto p1 = std::make_shared&lt;mock_chat_participant&gt;(); //新建第一个Mock指针 auto p2 = std::make_shared&lt;mock_chat_participant&gt;(); //新建第二个Mock指针 auto p3 = std::make_shared&lt;mock_chat_participant&gt;(); //新建第三个Mock指针 auto p4 = std::make_shared&lt;mock_chat_participant&gt;(); //新建第四个Mock指针 chat_room cr; //新建待测试对象chat_room cr.join(p1); cr.join(p2); cr.join(p3); cr.join(p4); EXPECT_EQ(cr.participants().size(), 4); cr.leave(p4); EXPECT_EQ(cr.participants().size(), 3); cr.leave(p4); EXPECT_EQ(cr.participants().size(), 3); cr.leave(p2); EXPECT_EQ(cr.participants().size(), 2);&#125; Web请求chat_room中有一个log()，依赖网络请求。原函数： 12345std::string chat_room::log() &#123; std::string* response; this-&gt;requester-&gt;execute(&quot;request&quot;,response); // web访问，结果存在response指针中 return *response;&#125; 在单元测试中，我们只关心被测试部分的逻辑。为了测试这个函数，我们不应该创建真实的requester，应该使用mock。 http_request对象： 12345class http_request &#123;public: virtual ~http_request()&#123;&#125; virtual bool execute(std::string request, std::string* response)=0;&#125;; Mock对象： 1234class mock_http_request : public http_request &#123;public: MOCK_METHOD(bool, execute, (std::string request, std::string * response), (override));&#125;; 测试用例： 12345678910111213TEST(ChatRoomTest, log) &#123; testing::NiceMock&lt;mock_message_dao&gt; mock_dao; //在下一部分会提到mock_message_dao mock_http_request mock_requester; //Mock对象 std::string response = &quot;response&quot;; //期待调用函数的第二个参数将指向这个string对象 EXPECT_CALL(mock_requester, execute) .WillRepeatedly( //每次调用都会（WillRepeatedly）执行 testing::DoAll( //每次执行包含多个行为 testing::SetArgPointee&lt;1&gt;(response),//将传入参数指针变量response指向response testing::Return(true))); //返回值为true chat_room cr = chat_room(&amp;mock_dao, &amp;mock_requester); //将mock对象通过chat_room的constructor注入 EXPECT_EQ(cr.log(),&quot;response&quot;); //调用和Google Test断言&#125; 数据库访问chat_room对象会将聊天者发送的消息存储在redis数据库中。当新用户加入时，chat_room对象从数据库获取所有历史消息发送给该新用户。 join()函数： 1234567891011void chat_room::join(chat_participant_ptr participant) &#123; participants_.insert(participant); std::vector&lt;std::string&gt; recent_msg_strs = this-&gt;dao-&gt;get_messages(); //从数据库中获取历史消息 for (std::string recent_msg_str: recent_msg_strs) &#123; //将每一个消息发送给该聊天参与者 auto msg = chat_message(); msg.set_body_string(recent_msg_str); participant-&gt;deliver(msg); &#125;&#125; message_dao对象： 123456class message_dao &#123;public: virtual ~message_dao()&#123;&#125; virtual bool add_message(std::string m)=0; virtual std::vector&lt;std::string&gt; get_messages()=0;&#125;; Mock对象： 12345class mock_message_dao : public message_dao &#123;public: MOCK_METHOD(bool, add_message, (std::string m), (override)); MOCK_METHOD(std::vector&lt;std::string&gt;, get_messages, (), (override));&#125;; 测试用例： 1234567891011121314TEST(ChatRoomTest, join) &#123; mock_message_dao mock_dao; //创建mock对象（需要注入chat_room） http_request_impl requester; //创建web访问对象（也需要注入chat_room） auto mock_p1 = std::make_shared&lt;mock_chat_participant&gt;(); //创建participant的mock指针 EXPECT_CALL(mock_dao, get_messages) .WillOnce(testing::Return(std::vector&lt;std::string&gt;&#123;&quot;test_msg_body_1&quot;, &quot;test_msg_body_2&quot;, &quot;test_msg_body_3&quot;&#125;)); //指定get_messages调用的返回值 EXPECT_CALL(*mock_p1, deliver).Times(3); //指定deliver调用的次数 chat_room cr = chat_room(&amp;mock_dao, &amp;requester); //创建chat_room对象，注入dao和requester cr.join(mock_p1); //调用&#125; 先创建mock对象，再指定函数调用的预期，最后指向被测试函数。我们可以看到，mock_dao指定了get_messages的返回值时一个长度为3的vector，所以有3条消息会被deliver。 FAQ单元测试源文件应该放在项目的什么位置？一般来说，我们会在根目录创建一个tests文件夹，里面放单元测试部分的源代码，从而不会和被测试代码混在一起。 如果需要和其他测试（如接口测试、压力测试）等区分开来，可以 把tests改成unittests、utests等，或者 在tests创建不同子文件夹存放不同类型的测试代码。 Google Mock只能Mock虚函数，如果我想Mock非虚函数怎么办？由于Google Mock（及其他大部分Mock框架）通过继承来动态重载机制的限制，一般来说Google Mock只能Mock虚函数。如果要mock非虚函数，官方文档提供这几种思路： Mock类和原类没有继承关系，在测试对象使用函数模板。在测试中，测试对象接受Mock类。 创建一个接口（抽象类），原类继承自这个接口（抽象类）。在测试中Mock这个接口（抽象类）。 这两种方法，都需要对代码进行一定的修改或重构。如果不想修改被测试代码。可以考虑使用hook技术替换被mock的部分从而mock一般函数。 使用TMock对非虚函数mock的例子： mock函数 12345678910# include &quot;tmock.h&quot;class MockClass&#123;public: //注册mock类 TMOCK_CLASS(MockClass); //声明mock类函数，TMOCK_METHOD&#123;n&#125;第一个参数与attach_func_lib第一个参数相同，其余参考与MOCK_METHOD&#123;n&#125;一致。 TMOCK_METHOD1(&quot;original&quot;, original, uint32_t(const char * str_file_md5) )&#125;; 单测中应用tmock的方法和Google Mock基本一致。但在结束的时候需要使用TMOCK_CLEAR清除exception，detach hook的函数，防止干扰其他单元测试。 Google Test官方文档中说测测试套件名称、测试夹具名称、测试名称中不应该出现下划线_。为什么？TEST(TestSuiteName, TestName)生成名为TestSuiteName_TestName_Test的类。 下划线_是特殊的，因为C ++保留以下内容供编译器和标准库使用。所以开头和结尾有下划线很容易让生成的类的标识符不合法。 另一方面，下划线可能让不同测试生成相同的类。比如TEST（Time，Flies_Like_An_Arrow）&#123;...&#125; 和TEST（Time_Flies，Like_An_Arrow）&#123;...&#125; 都生成名为Time_Flies_Like_An_Arrow_Test的类。 测试输出里有很多Uninteresting mock function call警告怎么办？创建的Mock的对象的某些调用如果没有相应匹配的EXPECT_CALL，Google Mock会生成这个警告。 为了去除这个警告，可以使用NiceMock。比如如果原本使用MockFoo nice_foo;新建mock对象的话，可以改成NiceMock&lt;MockFoo&gt; nice_foo;。NiceMock&lt;MockFoo&gt;是MockFoo的子类。 单测覆盖率使用 Gcov 和 LCOV 度量 C&#x2F;C++ 项目的代码覆盖率 什么是代码覆盖率？代码覆盖率是对整个测试过程中被执行的代码的衡量，它能测量源代码中的哪些语句在测试中被执行，哪些语句尚未被执行。 为什么要测量代码覆盖率？众所周知，测试可以提高软件版本的质量和可预测性。但是，你知道你的单元测试甚至是你的功能测试实际测试代码的效果如何吗？是否还需要更多的测试？ 这些是代码覆盖率可以试图回答的问题。总之，出于以下原因我们需要测量代码覆盖率： 了解我们的测试用例对源代码的测试效果 了解我们是否进行了足够的测试 在软件的整个生命周期内保持测试质量注：代码覆盖率不是灵丹妙药，覆盖率测量不能替代良好的代码审查和优秀的编程实践。 通常，我们应该采用合理的覆盖目标，力求在代码覆盖率在所有模块中实现均匀覆盖，而不是只看最终数字的是否高到令人满意。 举例：假设代码覆盖率只在某一些模块代码覆盖率很高，但在一些关键模块并没有足够的测试用例覆盖，那样虽然代码覆盖率很高，但并不能说明产品质量就很高。 代码覆盖率的指标种类代码覆盖率工具通常使用一个或多个标准来确定你的代码在被自动化测试后是否得到了执行，常见的覆盖率报告中看到的指标包括： 函数覆盖率：定义的函数中有多少被调用 语句覆盖率：程序中的语句有多少被执行 分支覆盖率：有多少控制结构的分支（例如if语句）被执行 条件覆盖率：有多少布尔子表达式被测试为真值和假值 行覆盖率：有多少行的源代码被测试过 代码覆盖率是如何工作的？代码覆盖率测量主要有以下三种方式： Source code instrumentation - 源代码检测将检测语句添加到源代码中，并使用正常的编译工具链编译代码以生成检测的程序集。这是我们常说的插桩，Gcov 是属于这一类的代码覆盖率工具。 Runtime instrumentation - 运行时收集这种方法在代码执行时从运行时环境收集信息以确定覆盖率信息。以我的理解 JaCoCo 和 Coverage 这两个工具的原理属于这一类别。 Intermediate code instrumentation - 中间代码检测 通过添加新的字节码来检测编译后的类文件，并生成一个新的检测类。说实话，我 Google 了很多文章并找到确定的说明哪个工具是属于这一类的。 了解这些工具的基本原理，结合现有的测试用例，有助于正确的选择代码覆盖率工具。比如： 产品的源代码只有 E2E（端到端）测试用例，通常只能选择第一类工具，即通过插桩编译出的可执行文件，然后进行测试和结果收集。 产品的源代码有单元测试用例，通常选择第二类工具，即运行时收集。这类工具的执行效率高，易于做持续集成。 当前主流代码覆盖率工具代码覆盖率的工具有很多，以下是我用过的不同编程语言的代码覆盖率工具。在选择工具时，力求去选择那些开源、流行（活跃）、好用的工具。 编程语言 代码覆盖率工具 C&#x2F;C++ Gcov Java JaCoCo JavaScript Istanbul Python Coverage.py Golang cover 最后，不要高估代码覆盖率指标代码覆盖率不是灵丹妙药，它只是告诉我们有哪些代码没有被测试用例“执行到”而已，高百分比的代码覆盖率不等于高质量的有效测试。 首先，高代码覆盖率不足以衡量有效测试。相反，代码覆盖率更准确地给出了代码未被测试程度的度量。这意味着，如果我们的代码覆盖率指标较低，那么我们可以确定代码的重要部分没有经过测试，然而反过来不一定正确。具有高代码覆盖率并不能充分表明我们的代码已经过充分测试。 其次，100% 的代码覆盖率不应该是我们明确努力的目标之一。这是因为在实现 100% 的代码覆盖率与实际测试重要的代码之间总是需要权衡。虽然可以测试所有代码，但考虑到为了满足覆盖率要求而编写更多无意义测试的趋势，当你接近此限制时，测试的价值也很可能会减少。借 Martin Fowler 在这篇测试覆盖率的文章说的一句话：12代码覆盖率是查找代码库中未测试部分的有用工具,然而它作为一个数字说明你的测试有多好用处不大。 C++覆盖率介绍如何使用 Gcov 和 LCOV 对 C&#x2F;C++ 项目进行代码覆盖率的度量。 对于想使用 Gcov 的人，为了说明它是如何工作的，准备了一段示例程序，运行这个程序之前需要先安装 GCC 和 LCOV。 如果没有环境或不想安装，可以直接查看示例仓库的 GitHub 仓库：Gcov示例 注：主分支 master 下面放的是源码，分支 coverage 下的 out 目录是最终的结果报告。 这是我的测试环境上的 GCC 和 lcov 的版本 12345678sh-4.2$ gcc --versionApple clang version 13.1.6 (clang-1316.0.21.2.5)Target: x86_64-apple-darwin22.1.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/binsh-4.2$ lcov -vlcov: LCOV version 1.16 Gcov 是如何工作的Gcov 工作流程图 主要分三步： 在 GCC 编译的时加入特殊的编译选项，生成可执行文件，和 *.gcno； 运行（测试）生成的可执行文件，生成了 *.gcda 数据文件； 有了 *.gcno 和 *.gcda，通过源码生成 gcov 文件，最后生成代码覆盖率报告。 下面就开始介绍其中每一步具体是怎么做的。 编译第一步编译，这里已经将编译用到的参数和文件都写在了 makefile 里了，只要执行 make 就可以编译了。 1make make 命令的输出 1234sh-4.2$ makegcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror main.cgcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror foo.cgcc -fPIC -fprofile-arcs -ftest-coverage -o main main.o foo.o 通过输出可以看到，这个程序在编译的时候添加了两个编译选项 -fprofile-arcs and -ftest-coverage。在编译成功后，不仅生成了 main and .o 文件，同时还生成了两个 .gcno 文件. .gcno 记录文件是在加入 GCC 编译选项 -ftest-coverage 后生成的，在编译过程中它包含用于重建基本块图和为块分配源行号的信息。 如果使用的是cmake，则在CMakeLists.txt中加入 12set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;)set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;) 运行可执行文件在编译完成后，生成了 main 这个可执行文件，运行（测试）它： 1./main 运行 main 时输出 123456sh-4.2$ ./mainStart calling foo() ...when num is equal to 1...when num is equal to 2... 当运行 main 后，执行结果被记录在了 .gcda 这个数据文件里，查看当前目录下可以看到一共有生成了两个 .gcda 文件，每个源文件都对应一个 .gcda 文件。 1234$ lsfoo.c foo.gcda foo.gcno foo.h foo.o img main main.c main.gcda main.gcno main.o makefile README.md.gcda 记录数据文件的生成是因为程序在编译的时候引入了 -fprofile-arcs 选项。它包含弧过渡计数、值分布计数和一些摘要信息。 生成报告1make report 生成报告的输出 1234567891011121314151617181920212223242526272829303132sh-4.2$ make reportgcov main.c foo.cFile &#x27;main.c&#x27;Lines executed:100.00% of 5Creating &#x27;main.c.gcov&#x27;File &#x27;foo.c&#x27;Lines executed:85.71% of 7Creating &#x27;foo.c.gcov&#x27;Lines executed:91.67% of 12lcov --capture --directory . --output-file coverage.infoCapturing coverage data from .Found gcov version: 4.8.5Scanning . for .gcda files ...Found 2 data files in .Processing foo.gcdageninfo: WARNING: cannot find an entry for main.c.gcov in .gcno file, skipping file!Processing main.gcdaFinished .info-file creationgenhtml coverage.info --output-directory outReading data file coverage.infoFound 2 entries.Found common filename prefix &quot;/workspace/coco&quot;Writing .css and .png files.Generating output.Processing file gcov-example/main.cProcessing file gcov-example/foo.cWriting directory view page.Overall coverage rate:lines......: 91.7% (11 of 12 lines)functions..: 100.0% (2 of 2 functions) 执行 make report 来生成 HTML 报告，这条命令的背后实际上主要执行了以下两个步骤： 在有了编译和运行时候生成的 .gcno 和 .gcda 文件后，执行命令 gcov main.c foo.c 即可生成 .gcov 代码覆盖率文件。 有了代码覆盖率 .gcov 文件，通过 LCOV 生成可视化代码覆盖率报告。生成 HTML 结果报告的步骤如下：12345678910# 1. 生成 coverage.info 数据文件lcov --capture --directory . --output-file coverage.info# 2. 根据这个数据文件生成报告genhtml coverage.info --output-directory out常用的lcov命令:1. lcov --extract xx.info &#x27;*/xx&#x27; &#x27;*/yy&#x27; -o res.info // 只保留xx.info中的xx和yy目录并输出到res.info2. lcov --remove xx.info &#x27;*/xx&#x27; &#x27;*/yy&#x27; -o res.info //删除xx.info中的xx和yy目录并输出到res.info3. lcov -a xx.info -a yy.info -o res.info //合并xx.info和yy.info并输出到res.info 收尾上传过程中所有生成的文件可通过执行 make clean 命令来彻底删除掉。 make clean 命令的输出 1234sh-4.2$ make cleanrm -rf main *.o *.so *.gcno *.gcda *.gcov coverage.info out 旁注： 还有另外一个生成 HTML 报告的工具叫 gcovr，使用 Python 开发的，它的报告在显示方式上与 LCOV 略有不同。比如 LCOV 以目录结构显示， gcovr 以文件路径来显示，前者与代码结构一直因此我更倾向于使用前者。 结语实践小结和GoLang单元测试框架有些区别的是，GoLang自生就提供了自带的测试框架，也有第三方框架进行选择。而C&#x2F;C++&#x2F;php等语言的单元测试框架则需要第三方提供和安装。 框架的使用，无非是一些语法糖的差异和使用的难易程度。不管使用什么语言，什么框架，最关键的是利用单元测试的思路，写出解耦的、可测试的、易于维护的代码，保证代码的质量。 单元测试是一种手段，能够一定程度的改善生产力。凡事有度过犹不及，如果一味的盲目的追求测试覆盖率，忽视了测试代码本身的质量，那么各种无效的单元测试反而带来了沉重的维护负担。因此单测的代码，本身也是代码，也是和项目本身的代码一样，需要重构、维护的（好好写代码）。","raw":"---\ntitle: CPP-单测\ntoc: true\ndate: 2022-11-01 14:58:57\ntags: [C++,单测]\ncategories: [技术]\ndescription: \n---\n单测系列-C++\n总结在C++中如何做单测，本文介绍了单测是什么以及C++常用的单测框架和工具\n<!-- more -->\n# 单元测试\n## 单元测试是什么\n单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、超类、抽象类等中的方法。单元测试就是软件开发中对最小单位进行正确性检验的测试工作。\n不同地方对单元测试有的定义可能会有所不同，但有一些基本共识：\n\n1. 单元测试是比较底层的，关注代码的局部而不是整体。 \n2. 单元测试是开发人员在写代码时候写的。 \n3. 单元测试需要比其他测试运行得快。\n\n## 单元测试的意义\n- 提高代码质量。代码测试都是为了帮助开发人员发现问题从而解决问题，提高代码质量。 \n- 尽早发现问题。问题越早发现，解决的难度和成本就越低。 \n- 保证重构正确性。随着功能的增加，重构（修改老代码）几乎是无法避免的。很多时候我们不敢重构的原因，就是担心其它模块因为依赖它而不工作。有了单元测试，只要在改完代码后运行一下单测就知道改动对整个系统的影响了，从而可以让我们放心的重构代码。 \n- 简化调试过程。单元测试让我们可以轻松地知道是哪一部分代码出了问题。 \n- 简化集成过程。由于各个单元已经被测试，在集成过程中进行的后续测试会更加容易。 \n- 优化代码设计。编写测试用例会迫使开发人员仔细思考代码的设计和必须完成的工作，有利于开发人员加深对代码功能的理解，从而形成更合理的设计和结构。 \n- 单元测试是最好的文档。单元测试覆盖了接口的所有使用方法，是最好的示例代码。而真正的文档包括注释很有可能和代码不同步，并且看不懂。\n\n## 单元测试用例编写的原则\n### 理论原则\n- 快。单元测试是回归测试，可以在开发过程的任何时候运行，因此运行速度必须快 \n- 一致性。代码没有改变的情况下，每次运行得结果应该保持确定且一致 \n- 原子性。结果只有两种情况：Pass / Fail \n- 用例独立。执行顺序不影响；用例间没有状态共享或者依赖关系；用例没有副作用（执行前后环境状态一致） \n- 单一职责。一个用例只负责一个场景 \n- 隔离。功能可能依赖于数据库、web访问、环境变量、系统时间等；一个单元可能依赖于另一部分代码，用例应该解除这些依赖 \n- 可读性。用例的名称、变量名等应该具有可读性，直接表现出该测试的目标 \n- 自动化。单元测试需要全自动执行。测试程序不应该有用户输入；测试结果应该能直接被电脑获取，不应该由人来判断。\n\n### 规约原则\n在实际编写代码过程中，不同的团队会有不同团队的风格，只要团队内部保持有一定的规约即可，比如：\n\n- 单元测试文件名必须以xxx_test.go命名 \n- 方法必须是TestXxx开头，建议风格保持一致（驼峰或者下划线） \n- 方法参数必须 t *testing.T \n- 测试文件和被测试文件必须在一个包中\n\n\n### 衡量原则\n单元测试是要写额外的代码的，这对开发同学的也是一个不小的工作负担，在一些项目中，我们合理的评估单元测试的编写，我认为我们不能走极端，当然理论上来说全写肯定时好的，但是从成本，效率上来说我们必须做出权衡，衡量原则如下：\n\n- 优先编写核心组件和逻辑模块的测试用例 \n- 逻辑类似的组件如果存在多个，优先编写其中一种逻辑组件的测试用例 \n- 发现Bug时一定先编写测试用例进行Debug \n- 关键util工具类要编写测试用例，这些util工具适用的很频繁，所以这个原则也叫做热点原则，和第1点相呼应。 \n- 测试用户应该独立，一个文件对应一个，而且不同的测试用例之间不要互相依赖。 \n- 测试用例的保持更新\n\n## 单元测试用例设计方法\n### 规范(规格)导出法\n规范(规格)导出法将需求”翻译“成测试用例。\n\n例如，一个函数的设计需求如下：\n\n```text\n函数：一个计算平方根的函数 \n输入： 实数 \n输出： 实数 \n要求： 当输入一个0或者比0大的实数时，返回其正的平方根； 当输入一个小于0的实数时，显示错误信息“平方根非法—输入之小于0”，并返回0； \n库函数printf()可以用来输出错误信息。\n```\n\n在这个规范中有3个陈述，可以用两个测试用例来对应:\n\n| 编号 | 用例          |\n| ---- | ------------- |\n| 1    | 输入4，输出2  |\n| 2    | 输入-1，输出0 |\n\n\n### 等价类划分法\n等价类划分法假定某一特定的等价类中的所有值对于测试目的来说是等价的，所以在每个等价类中找一个之作为测试用例。\n\n按照 [输入条件][有效等价类][无效等价类] 建立等价类表，列出所有划分出的等价类\n- 为每一个等价类规定一个唯一的编号 \n- 设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类。重复这一步，直到所有的有效等价类都被覆盖为止 \n- 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，直到所有的无效等价类都被覆盖为止\n\n例如，注册邮箱时要求用6~18个字符，可使用字母、数字、下划线，需以字母开头。\n\n| 有效等价类                  | 无效等价类                                                               |\n| --------------------------- | ------------------------------------------------------------------------ |\n| 6~18个字符（1）             | 少于6个字符（2）<br>多余18个字符（3）<br>空（4）                         |\n| 包含字母、数字、下划线（5） | 除字母、数字、下划线的特殊字符（6）<br>非打印字符（7）<br>中文字符 （8） |\n| 以字母开头（9）             | 以数字或下划线开头（10）                                                 |\n\n测试用例\n\n| 编号 | 输入数据              | 覆盖等价类           | 预期结果 |\n| ---- | --------------------- | -------------------- | -------- |\n| 1    | test_111              | （1）、（5）、（9）  | 合法输入 |\n| 2    | t_11                  | （2）、（5）、（9）  | 非法输入 |\n| 3    | testtesttest_12345678 | （3）、（5）、（9）  | 非法输入 |\n| 4    | NULL                  | （4）                | 非法输入 |\n| 5    | test!@1111            | （1）、（6）、（9）  | 非法输入 |\n| 6    | test 1111             | （1）、（7）、（9）  | 非法输入 |\n| 7    | test测试1111          | （1）、（8）、（9）  | 非法输入 |\n| 8    | _test111              | （1）、（5）、（10） | 非法输入 |\n\n### 边界值分析法　　\n边界值分析法使用与等价类测试方法相同的等价类划分，只是边界值分析假定 错误更多地存在于两个划分的边界上。\n边界值测试在软件变得复杂的时候也会变得不实用。边界值测试对于非向量类型的值(如枚举类型的值)也没有意义。\n例如，和4.1相同的需求，划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0。由此得到以下测试用例：\n\n- 输入 {最小负实数} \n- 输入 {绝对值很小的负数} \n- 输入 0 \n- 输入 {绝对值很小的正数} \n- 输入 {最大正实数}\n\n\n### 基本路径测试法\n基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。\n基本路径测试法的基本步骤：\n\n- 程序的控制流图：描述程序控制流的一种图示方法。 \n- 程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。 \n- 导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。 \n- 准备测试用例：确保基本路径集中的每一条路径的执行。\n\n# 常用C++单测框架\n\n## 常用的C++单测对比\n\n| 编号     | Google test                                        | Catch 2                                                                                         | CppUTest                                                     |\n| -------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |\n| 特点     | 成熟、兼容性好<br>简洁、有效率<br>常用、学习资源多 | 框架只有一个catch.hpp、集成轻松<br>有Given-When-Then分区，适合BDD行为驱动开发<br>无自带Mock框架 | 可以检测内存泄露<br>输出更简洁<br>适合在嵌入式系统项目中使用 |\n| Mock框架 | Google Mock                                        | 无自带Mock框架                                                                                  | CppUMock                                                     |\n| 推荐指数 | ★★★★★                                         | ★★★☆☆                                                                                      | ★★☆☆☆                                                   |\n\n\n一般情况下，我们推荐使用Google Test搭配Google Mock。如果项目有特殊需求或更适合其他框架，也可以考虑。\n根据实际使用频率，在以下部分，Google Test和Google Mock的介绍更为详细；对于其他框架，这里介绍它们的主要特点， 具体使用方法，可以查阅各自文档。\n\n# Google Test\nGoogle Test是目前比较成熟而且最常用的C++单元测试框架之一。\n\n## 基本概念\n- 断言（Assertions） 是检查条件是否为真的语句。断言的结果可能是成功或者失败， 而失败又分为非致命失败或致命失败。如果发生致命失败，测试进程将中止当前运行，否则它将继续运行。 \n- 测试（Test） 使用断言来验证被测试代码的行为。如果测试崩溃或断言失败，则测试失败；否则测试成功。 \n- 测试套件（Test Suite） 包含一个或多个测试（Test）。当测试套件中的多个测试需要共享通用对象和子例程时， 可以将它们放入测试夹具（Test Fixture）。 \n- 测试程序（Test Program） 可以包含多个测试套件。\n\n## 断言\n- Google Test中，断言（Assertions） 是类似函数调用的宏。断言失败时，googletest会输出断言的源文件和 行号位置以及失败消息；我们还可以提供自定义失败消息，该消息将附加到googletest消息中。 \n- 断言成对出现（ASSERT_*和EXPECT_*），它们测试的对象相同，但对当前运行有不同的影响。ASSERT_*版本失败时 会产生致命故障，并中止当前函数（不一定是整个TEST）运行。EXPECT_*版本会产生非致命故障，不会停止当前函数运行。 通常EXPECT_*是首选，因为可以在测试中报告多个故障。但是如果在断言失败时继续执行没有意义，则应使用ASSERT_*。 \n- 要提供自定义失败消息，只需使用<< 运算符或此类运算符的序列将其流式传输到宏中即可 。一个例子：\n```c++\nASSERT_EQ(x.size(), y.size()) << \"x和y长度不同\";\n\nfor (int i = 0; i < x.size(); ++i) {\n\tEXPECT_EQ(x[i], y[i]) << \"x和y元素存在不同：\" << i;\n}\n```\n以下是一些最常用的断言，如果需要查阅其他断言，可以前往googletest的官方文档。\n\n### 基本断言\n`condition` 是返回`true`/`false`的变量、布尔表达式、函数调用等，以下断言对其进行验证。\n\n| 失败时中断执行的断言     | 失败时不中断执行的断言   | 断言成功情况  |\n| ------------------------ | ------------------------ | ------------- |\n| ASSERT_TRUE(condition);  | EXPECT_TRUE(condition);  | condition为真 |\n| ASSERT_FALSE(condition); | EXPECT_FALSE(condition); | condition为假 |\n\n例如：在`ASSERT_TRUE(condition)`中，当`condition`为`true`时，符合断言，不影响执行；当`condition`\n为`false`时，不符合断言，且由于是`ASSERT`，当前执行中断。\n\n### 普通比较型断言\n`val1`和`val2`是两个可用`==`、`!=`、`>`、`<`等运算符进行比较的值，以下断言对其进行比较。\n\n| 失败时中断执行的断言   | 失败时不中断执行的断言 | 断言成功情况 |\n| ---------------------- | ---------------------- | ------------ |\n| ASSERT_EQ(val1, val2); | EXPECT_EQ(val1, val2); | val1 == val2 |\n| ASSERT_NE(val1, val2); | EXPECT_NE(val1, val2); | val1 != val2 |\n| ASSERT_LT(val1, val2); | EXPECT_LT(val1, val2); | val1 < val2  |\n| ASSERT_LE(val1, val2); | EXPECT_LE(val1, val2); | val1 <= val2 |\n| ASSERT_GT(val1, val2); | EXPECT_GT(val1, val2); | val1 > val2  |\n| ASSERT_GE(val1, val2); | EXPECT_GE(val1, val2); | val1 >= val2 |\n\n例如：在`ASSERT_GT(val1, val2)`中，只有当`val1 > val2`时，符合断言，不影响执行；当`val1 <= val2`时，\n不符合断言，且由于是`ASSERT`，当前执行中断。\n\n### C字符串比较型断言\n`str1`和`str2`是两个C字符串，以下断言对它们的值进行比较；如果要比较两个`std::string`对象，直接用之前\n提到的`EXPECT_NE`，`EXPECT_NE`等。\n\n| 失败时中断执行的断言         | 失败时不中断执行的断言       | 断言成功情况                      |\n| ---------------------------- | ---------------------------- | --------------------------------- |\n| ASSERT_STREQ(str1,str2);     | EXPECT_STREQ(str1,str2);     | 这两个C字符串具有相同的内容       |\n| ASSERT_STRNE(str1,str2);     | EXPECT_STRNE(str1,str2);     | 两个C字符串的内容不同             |\n| ASSERT_STRCASEEQ(str1,str2); | EXPECT_STRCASEEQ(str1,str2); | 忽略大小写，两个C字符串的内容相同 |\n| ASSERT_STRCASENE(str1,str2); | EXPECT_STRCASENE(str1,str2)  | 忽略大小写，两个C字符串的内容不同 |\n\n例如：`char *str1 = \"ABC\";``char *str2 = \"ABC\";`，`EXPECT_STREQ(str1, str2);`断言通过，\n因为它们的内容一样；而`EXPECT_EQ(str1, str2);`断言失败，因为它们的地址不一样。\n\n注意：一个`NULL`指针和一个空字符串`\"\"`是不同的。\n\n### 浮点数比较型断言\n`val1`和`val2`是两个浮点数，以下断言对其进行比较。\n\n| 失败时中断执行的断言          | 失败时不中断执行的断言        | 断言成功情况           |\n| ----------------------------- | ----------------------------- | ---------------------- |\n| ASSERT_FLOAT_EQ(val1, val2);  | EXPECT_FLOAT_EQ(val1, val2);  | 这两个float值几乎相等  |\n| ASSERT_DOUBLE_EQ(val1, val2); | EXPECT_DOUBLE_EQ(val1, val2); | 这两个double值几乎相等 |\n\n以下断言可以选择可接受的误差范围：\n\n| 失败时中断执行的断言                | 失败时不中断执行的断言              | 断言成功情况                          |\n| ----------------------------------- | ----------------------------------- | ------------------------------------- |\n| ASSERT_NEAR(val1, val2, abs_error); | EXPECT_NEAR(val1, val2, abs_error); | val1和val2的差的绝对值不超过abs_error |\n\n### 明确的成功和失败\n\n- 明确生成成功：\n - `SUCCEED();` 生成一个成功，但这不代表整个测试就成功了。\n- 明确生成失败：\n - `FAIL();` 生成致命错误\n - `ADD_FAILURE();` 生成非致命错误。\n - `ADD_FAILURE_AT(\"file_path\",line_number);` 生成非致命错误，输出文件名和行号。\n\n例如：\n```c++\nif(condition) {\n\tSUCCEED();\n} else{\n\tFAIL();\n}\n```\n效果上等同于\n\n```c++\nASSERT_TRUE(condition);\n```\n只是`ASSERT_TRUE`失败时可以输出`condition`的具体值。当但我们需要验证的`condition`很复杂时，\n或者需要很多个`if..else...`分支来验证彼此互斥的情况以保证覆盖到每一种可能性时，`SUCCEED()`、`FAIL()`等\n明确的成功/失败可能是更好的选择。\n\n### 异常断言\n这些断言验证一段代码（`statement`）是否抛出（或不抛出）给定类型的异常：\n\n| 失败时中断执行的断言                     | 失败时不中断执行的断言                   | 断言成功情况                |\n| ---------------------------------------- | ---------------------------------------- | --------------------------- |\n| ASSERT_THROW(statement, exception_type); | EXPECT_THROW(statement, exception_type); | statement抛出给定类型的异常 |\n| ASSERT_ANY_THROW(statement);             | EXPECT_ANY_THROW(statement);             | statement抛出任何类型的异常 |\n| ASSERT_NO_THROW(statement);              | EXPECT_NO_THROW(statement);              | statement不抛出任何异常     |\n\n### 使用已有布尔函数\n当`predN`是一个有`N`个参数，返回布尔值的函数时，以下断言可以获取更好的错误信息。\n\n| 失败时中断执行的断言             | 失败时不中断执行的断言           | 断言成功情况          |\n| -------------------------------- | -------------------------------- | --------------------- |\n| ASSERT_PRED1(pred1, val1);       | EXPECT_PRED1(pred1, val1);       | pred1(val1)为真       |\n| ASSERT_PRED2(pred2, val1, val2); | EXPECT_PRED2(pred2, val1, val2); | pred2(val1, val2)为真 |\n| ...                              | ...                              | ...                   |\n\n例如：`isComparable(Object o1, Object o2)`是一个返回布尔值的函数。我们可以有以下选择，\n都能达到验证函数调用结果的目的：\n1. `ASSERT_TRUE(isComparable(obj1, obj2));`\n2. `ASSERT_PRED2(isComparable, obj1, obj2);`\n　　区别在于：当断言失败时，`ASSERT_TRUE`只会告知函数最后的返回值是`false`；而`ASSERT_TRUE`同时\n   会输出`val1`、`val2`的值。\n\n## 测试\n\n创建一个测试的步骤：\n1. 使用`TEST()`宏定义和命名测试功能。\n2. 在`TEST()`宏内，构造出达到测试状态的函数、变量\n3. 使用断言指定函数、变量期望的返回值、值。\n```c++\nTEST(MessageTestSuite, BodyLengthNegative) {\n\t... 构造 ...\n\t... 断言 ...\n}\n```\n\n`TEST()`第一个参数是Test Suite的名称，第二个参数是Test Suite内的Test名称。这两个名称都必须是有效的\nC++标识符，并且它们不应包含任何下划线（`_`）。测试的全名包括Test Suite名和Test名。来自不同Test Suite的\n测试可以具有相同的Test名。它们都不是变量，也不是字符串。\n\n在上面的例子中，这个测试的名称是`BodyLengthNegative`，Test Suite的名称是`MessageTestSuite`。\n\n## 测试夹具：多个测试有共有的数据配置\n\n如果多个测试有共有的数据配置，可以使用**测试夹具（Test Fixture）**将共用部分提取出来重复利用。\n\n要创建一个测试夹具：\n1. 创建一个继承`::testing::Test`的类。从`protected`开始这个类，因为我们要从子类访问夹具成员。\n2. 在类内部，声明计划使用的任何对象。\n3. 如有必要，编写默认的`constructor`或`SetUp()`函数为每个测试准备对象。\n4. 如有必要，编写一个`destructor`或`TearDown()`函数以释放在`SetUp()`中分配的任何资源。\n5. 如有必要，定义一些共享的类函数\n\n当使用测试夹具是，需要使用`TEST_F()`而不是`TEST()`\n\n```c++\nclass TestFixtureName : public ::testing::Test {\nprotected:\n\tvirtual void SetUp() {\n\t\t...\n\t}\n\tvirtual void TearDown() {\n\t\t...\n\t}\n\tvirtual int SomeFunction() {\n\t\t...\n\t}\n\tSomeObject object;\n};\n\nTEST_F(TestFixtureName, TestName1) {\n\t... 构造 ...\n\t... 断言 ...\n}\n\nTEST_F(TestFixtureName, TestName2) {\n\t... 构造 ...\n\t... 断言 ...\n}\n```\n\n那上面这个例子来说，对于每个`TEST_F()`测试，googletest将在运行时\n1. 创建一个新的**测试夹具（Test Fixture）**对象\n2. 通过`SetUp()`对其进行初始化\n3. 运行该`TEST_F()`测试\n4. 通过调用进行清理`TearDown()`\n5. 然后删除该**测试夹具（Test Fixture）**对象\n\n所以，虽然多个`TEST_F`共用同一部分代码，但共同代码会每个`TEST_F`都独立执行一次。同一测试套件中的不同测试具有不同的测试夹具对象。一个测试对**测试夹具**所做的任何更改均不会影响其他测试。\n\n# Catch 2\n\nCatch2 仅有头部文件（header only），所以它的第一个优点是可以轻易地放入任何项目中进行使用。只需要 `#include \"catch.hpp\"` 就可以在当前文件使用 Catch\n\n## REQUIRE\n\nCatch的基础使用方法也很简单。\n\n```c++\n#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file\n#include \"catch.hpp\"\nunsigned int Factorial( unsigned int number ) {\n\treturn number <= 1 ? number : Factorial(number-1)*number;\n}\n\nTEST_CASE( \"Factorials are computed\", \"[factorial]\" ) {   \n\tREQUIRE( Factorial(0) == 1 );    \n\tREQUIRE( Factorial(1) == 1 );    \n\tREQUIRE( Factorial(2) == 2 );    \n\tREQUIRE( Factorial(3) == 6 );    \n\tREQUIRE( Factorial(10) == 3628800 );\n}\n```\n\n## SECTIONS\n\nCatch的SECTION相当于GTEST里夹具（fixture）的功能。对每一个SECTION，TEST_CASE 都从头开始执行。\n\n```c++\nTEST_CASE( \"vectors can be sized and resized\", \"[vector]\" ) {\n    std::vector<int> v( 5 );    \n    REQUIRE( v.size() == 5 );    \n    REQUIRE( v.capacity() >= 5 );    \n    SECTION( \"resizing bigger changes size and capacity\" ) \n        v.resize( 10 );        \n        REQUIRE( v.size() == 10 );        \n        REQUIRE( v.capacity() >= 10 );    \n    }    \n    SECTION( \"resizing smaller changes size not capacity\" ){\n        v.resize( 0 );        \n        REQUIRE( v.size() == 0 );        \n        REQUIRE( v.capacity() >= 5 );    \n    }    \n    SECTION( \"reserving bigger changes capacity not size\" ) { \n        v.reserve( 10 );        \n        REQUIRE( v.size() == 5 );        \n        REQUIRE( v.capacity() >= 10 );    \n    }    \n    SECTION( \"reserving smaller does not change size\" ) {\n        v.reserve( 0 );        \n        REQUIRE( v.size() == 5 );        \n        REQUIRE( v.capacity() >= 5 );    \n    }\n}\n```\n\n## 标签\n\nCatch提供标签特性。\n\n```c++\nTEST_CASE( \"A\", \"[widget]\" ) { /* ... */ }\nTEST_CASE( \"B\", \"[widget]\" ) { /* ... */ }\nTEST_CASE( \"C\", \"[gadget]\" ) { /* ... */ }\nTEST_CASE( \"D\", \"[widget][gadget]\" ) { /* ... */ }\n```\n\n* `\"[widget]\"` 选取 A、B、D.\n* `\"[gadget]\"` 选取 C、D.\n* `\"[widget][gadget]\"` 只选取 D\n* `\"[widget],[gadget]\"` 所有A、B、C、D.\n* 还有一些特殊标签指定特殊行为\n\n## 特点总结\n\n- 框架只有一个<code>catch.hpp</code>、集成轻松\n- 有Given-When-Then分区，适合BDD行为驱动开发\n- 无自带Mock框架\n\n# CppUTest\n\n## main和test\n\nmain.cpp:\n\n```c++\n#include \"CppUTest/CommandLineTestRunner.h\"\nint main(int ac, char** av){    \n\treturn CommandLineTestRunner::RunAllTests(ac, av);\n}\n```\n\ntest.cpp:\n\n```c++\n#include \"CppUTest/TestHarness.h\"\nTEST_GROUP(FirstTestGroup){\n    void setup(){      \n        // Init stuff   \n    } \n    void teardown(){      \n        // Uninit stuff   \n    }\n};\n\nTEST(FirstTestGroup, FirstTest){\n    FAIL(\"Fail me!\");\n}\nTEST(FirstTestGroup, SecondTest){\n    STRCMP_EQUAL(\"hello\", \"world\");\n}\n```\n\n## 断言\n\n- `CHECK(boolean condition)`检查任何布尔结果。\n- `CHECK_TEXT(boolean condition, text)`检查任何布尔结果，并在失败时输出文本。\n- `CHECK_FALSE(condition)`检查任何布尔结果\n- `CHECK_EQUAL(expected, actual)`使用`==`检查实体之间的相等性。因此，如果有一个支持`operator==()`的类，则可以使用此宏比较两个实例。\n- `CHECK_COMPARE(first, relop, second)`检查在两个实体之间是否存在关系运算符。失败时，打印两个操作数求和的结果。\n- `CHECK_THROWS(expected_exception, expression)`检查表达式是否抛出`expected_exception`（例如`std::exception`）。`CHECK_THROWS`仅在使用标准C ++库（默认）构建CppUTest时可用。\n- `STRCMP_EQUAL(expected, actual)`使用`strcmp()`检查`const char *`字符串是否相等。\n- `STRNCMP_EQUAL(expected, actual, length)`使用`strncmp()`检查`const char *`字符串是否相等。\n- `STRCMP_NOCASE_EQUAL(expected, actual)`不考虑大小写，检查`const char *`字符串是否相等。\n\n## 特点\n- 可以检测内存泄露\n- 输出更简洁\n- 使用在嵌入式系统项目中使用\n\n# Google Mock\n\nGoogle Mock一般来说和Google Test搭配使用，但Google Test也可以和其他Mock框架一起使用。\n本部分是Google Mock基础常用的用法，如需要特殊用法，请查阅Google Mock官方文档。\n\n## Fake、Mock、Stub\n\n- Fake对象**有**具体的实现，但采取一些捷径，比如用内存替代真实的数据库读取。\n- Stub对象**没有**具体的实现，只是返回提前准备好的数据。\n- Mock对象和Stub类似，只是在测试中需要调用时，针对某种输入指定期望的行为。Mock和Stub的区别是，\n  Mock除了返回数据还可以指定期望以验证行为。\n\n## 简单例子：Mock Turtle\n\nTurtle类:\n\n```c++\nclass Turtle {\n\t...\n\tvirtual ~Turtle() {};\n\tvirtual void PenUp() = 0;\n\tvirtual void PenDown() = 0;\n\tvirtual void Forward(int distance) = 0;\n\tvirtual void Turn(int degrees) = 0;\n\tvirtual void GoTo(int x, int y) = 0;\n\tvirtual int GetX() const = 0;\n\tvirtual int GetY() const = 0;\n};\n```\nMockTurtle类:\n\n```c++\n#include \"gmock/gmock.h\"\n\nclass MockTurtle : public Turtle {\npublic:\n\t...\n\tMOCK_METHOD(void, PenUp, (), (override));\n\tMOCK_METHOD(void, PenDown, (), (override));\n\tMOCK_METHOD(void, Forward, (int distance), (override));\n\tMOCK_METHOD(void, Turn, (int degrees), (override));\n\tMOCK_METHOD(void, GoTo, (int x, int y), (override));\n\tMOCK_METHOD(int, GetX, (), (const, override));\n\tMOCK_METHOD(int, GetY, (), (const, override));\n};\n```\n\n创建Mock类的步骤：\n\n1. `MockTurtle`继承`Turtle`\n2. 找到`Turtle`的一个虚函数\n3. 在`public:`的部分中，写一个`MOCK_METHOD();`\n4. 将虚函数函数签名复制进`MOCK_METHOD();`中，加两个逗号：一个在返回类型和函数名之间另一个在函数名和参数列表之间\n\n   例如：`void PenDown()`有三部分：`void`、`PenDown`和`()`，这三部分就是`MOCK_METHOD`的前三个参数\n\n5. 如果要模拟`const`方法，添加一个包含`(const) `的第4个参数（必须带括号）。\n6. 建议添加`override`关键字。所以对于`const`方法，第四个参数变为`(const, override)`，对于非`const`方法，第四个参数变为`(override)`。这不是强制性的。\n7. 重复步骤直至完成要模拟的所有虚拟函数。\n\n## 在测试中使用Mock\n\n在测试中使用Mock的步骤：\n\n1. 从`testing`名称空间导入`gmock.h`的函数名（每个文件只需要执行一次）。\n2. 创建一些Mock对象。\n3. 指定对它们的期望（方法将被调用多少次？带有什么参数？每次应该做什么（对参数做什么、返回什么值）？等等）。\n4. 使用Mock对象；可以使用googletest断言检查结果。如果mock函数的调用超出预期或参数错误，将会立即收到错误消息。\n5. 当Mock对象被销毁时，gMock自动检查对模拟的所有期望是否得到满足。\n\n```c++\n#include \"path/to/mock-turtle.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing ::testing::AtLeast;                         \t// #1\n\nTEST(PainterTest, CanDrawSomething) {\n\tMockTurtle turtle;                              // #2\n\tEXPECT_CALL(turtle, PenDown())                  // #3\n\t\t.Times(AtLeast(1));\n\n\tPainter painter(&turtle);                       // #4\n\n\tEXPECT_TRUE(painter.DrawCircle(0, 0, 10));      // #5\n}\n```\n\n在这个例子中，我们期望`turtle`的`PenDown()`至少被调用一次。如果在`turtle`对象被销毁时，`PenDown()`还没有被调用或者调用两次或以上，测试会失败。\n\n## 指定期望\n\n`EXPECT_CALL`（指定期望）是使用Google Mock的核心。`EXPECT_CALL`的作用是两方面的：\n\n1. 告诉这个Mock（假）方法如何模仿原始方法：\n\n   我们在`EXPECT_CALL`中告诉Google Mock，某个对象的某个方法被第一次调用时，会修改某个参数，会返回某个值；第二次调用时，会修改某个参数，会返回某个值.......\n\n2. 验证被调用的情况\n\n   我们在`EXPECT_CALL`中告诉Google Mock，某个对象的某个方法总共会被调用N次（或大于N次、小于N次）。如果最终次数不符合预期，会导致测试失败。\n\n### 基本语法\n\n```c++\nEXPECT_CALL(mock_object, method(matchers))\n\t.Times(cardinality)\n\t.WillOnce(action)\n\t.WillRepeatedly(action);\n```\n\n* `mock_object` 是对象\n* `method(matchers)` 用于匹配相应的函数调用\n* `cardinality` 指定基数（被调用次数情况）\n* `action` 指定被调用时的行为\n\n例子：\n\n```c++\nusing ::testing::Return;\n...\nEXPECT_CALL(turtle, GetX())\n\t.Times(5)\n\t.WillOnce(Return(100))\n\t.WillOnce(Return(150))\n\t.WillRepeatedly(Return(200));\n```\n\n这个`EXPECT_CALL()`指定的期望是：在`turtle`这个Mock对象销毁之前，`turtle`的`getX()`函数会被调用五次。第一次返回`100`，第二次返回`150`，第三次及以后都返回`200`。指定期望后，5次对`getX`的调用会有这些行为。但如果最终调用次数不为5次，则测试失败。\n\n### 参数匹配：哪次调用\n\n```c++\nusing ::testing::_;\nusing ::testing::Ge;\n// 只与Forward(100)匹配\nEXPECT_CALL(turtle, Forward(100));\n// 与GoTo(x,y)匹配, 只要x>=50\nEXPECT_CALL(turtle, GoTo(Ge(50), _));\n```\n\n* `_`相当于“任何”。\n* `100`相当于`Eq(100)`。\n* `Ge(50)`指参数大于或等于50。\n* 如果不关心参数，只写函数名就可以。比如`EXPECT_CALL(turtle, GoTo);`。\n\n### 基数：被调用几次\n用`Times(m)`，`Times(AtLeast(n))`等来指定期待的调用次数。\n\n`Times`可以被省略。比如整个`EXPECT_CALL`只有一个`WillOnce(action)`相当于也说明了调用次数只能为1。\n\n### 行为：该做什么\n常用模式：如果需要指定前几次调用的特殊情况，并且之后的调用情况相同。使用一系列`WillOnce()`之后有`WillRepeatedly()`\n\n除了用来指定调用返回值的`Return()`，Google Mock中常用行为中还有：`SetArgPointee<N>(value)`，\n`SetArgPointee`将第`N`个指针参数（从0开始）指向的变量赋值为`value`。\n\n比如`void getObject(Object* response){...}`的`EXPECT_CALL`：\n\n```\nObject* a = new Object;\nEXPECT_CALL(object, request)\n\t.WillOnce(SetArgPointee<1>(*a));\n```\n就修改了传入的指针`response`，使其指向了一个我们新创建的对象。\n\n如果有多个行为，应该使用`DoAll(a1, a2, ..., an)`。`DoAll`执行所有`n`个action并返回`an`的结果。\n\n### 使用多个预期\n\n例子：\n\n```c++\nusing ::testing::_;\n...\nEXPECT_CALL(turtle, Forward(_))\t\t// #1\n\t.Times(3);  \t\nEXPECT_CALL(turtle, Forward(10))  \t// #2\n\t.Times(2);\n...mock对象函数被调用...\n\t//Forward(10);\t\t\t\t\t\t// 与#2匹配\n\t//Forward(20);\t\t\t\t\t\t// 与#1匹配\n```\n\n正常情况下，Google Mock以倒序搜索预期：如果和多个`EXPECT_CALL`都可以匹配，只有之前的，\n距离调用最近的一个`EXPECT_CALL()`会被匹配。例如：\n\n* 连续三次调用`Forward(10)`会生错误因为它和#2匹配。\n* 连续三次调用`Forward(20)`不会有错误因为它和#1匹配。\n\n一旦匹配，该预期会被一直绑定，即使执行次数达到上限之后，还是是生效的，这就是为什么三次调用\n`Forward(10)`超过了2号`EXPECT_CALL`的上限时，不会去试图绑定1号`EXPECT_CALL`而是报错的原因。\n\n为了明确地让某一个`EXPECT_CALL`“退休”，可以加上`RetiresOnSaturation()`，例子：\n\n```c++\nusing ::testing::Return;\n\nEXPECT_CALL(turtle, GetX())\t\t// #1\n\t.WillOnce(Return(10))\n\t.RetiresOnSaturation();\nEXPECT_CALL(turtle, GetX())\t\t// #2\n\t.WillOnce(Return(20))\n\t.RetiresOnSaturation();\n\nturtle.GetX()\t\t\t\t\t// 与#2匹配，返回20，然后#2“退休”\nturtle.GetX()\t\t\t\t\t// 与#1匹配，返回10\n```\n\n在这个例子中，第一次`GetX()`调用和#2匹配，返回`20`，然后这个`EXPECT_CALL`就“退休”了；\n第二次`GetX()`调用和#1匹配，返回`10`\n\n### Sequence\n可以用sequence来指定期望匹配的顺序。\n\n```c++\nusing ::testing::Return;\nusing ::testing::Sequence;\nSequence s1, s2;\n...\nEXPECT_CALL(foo, Reset())\n    .InSequence(s1, s2)\n    .WillOnce(Return(true));\nEXPECT_CALL(foo, GetSize())\n    .InSequence(s1)\n    .WillOnce(Return(1));\nEXPECT_CALL(foo, Describe(A<const char*>()))\n    .InSequence(s2)\n    .WillOnce(Return(\"dummy\"));\n```\n![sequence](http://cdn.yuleweici.com/CPP-%E5%8D%95%E6%B5%8B/img.png)\n\n在上面的例子中，创建了两个Sequence `s1`和`s2`，属于`s1`的有`Reset()`和`GetSize()`，\n所以`Reset()`必须在`GetSize()`之前执行。属于`s2`的有`Reset()`和`Describe(A<const char*>())`，\n所以`Reset()`必须在`Describe(A<const char*>())`之前执行。所以，`Reset()`必须在`GetSize()`\n和`Describe()`之前执行。而`GetSize()`和`Describe()`这两者之间没有顺序约束。\n\n如果需要指定很多期望的顺序，有另一种用法：\n\n```c++\nusing ::testing::InSequence;\n{\n  InSequence seq;\n\n  EXPECT_CALL(...)...;\n  EXPECT_CALL(...)...;\n  ...\n  EXPECT_CALL(...)...;\n}\n```\n在这种用法中，scope中（大括号中）的期望必须遵守严格的顺序。\n\n\n## 更多\n\n* [Google Mock Cheat Sheet](https://github.com/google/googletest/blob/master/googlemock/docs/cheat_sheet.md)\n* [Google Mock Cook Book](https://github.com/google/googletest/blob/master/googlemock/docs/cook_book.md)\n\n# 情景示例\n\n在这部分，我们用一个示例项目来演示，如何在不同情景中使用\nGoogle Test和Google Mock写单元测试用例。\n\n## 项目结构\n\n示例项目是一个C++命令行聊天室软件，包含服务器和客户端。\n\n```text\n.\n├── CMakeLists.txt\n├── README.md\n├── client_main.cpp\n├── server_main.cpp\n├── include\n│   ├── chat_client.hpp\n│   ├── chat_message.hpp\n│   ├── chat_participant.hpp\n│   ├── chat_room.hpp\n│   ├── chat_server.hpp\n│   ├── chat_session.hpp\n│   ├── http_request.hpp\n│   ├── http_request_impl.hpp\n│   ├── message_dao.hpp\n│   └── message_dao_impl.hpp\n├── src\n│   ├── chat_client.cpp\n│   ├── chat_message.cpp\n│   ├── chat_room.cpp\n│   ├── chat_server.cpp\n│   ├── chat_session.cpp\n│   ├── http_request_impl.cpp\n│   └── message_dao_impl.cpp\n└── tests\n    ├── chat_message_unittest.cpp\n    └── chat_room_unittest.cpp\n```\n\n## 普通测试\n\n如果被测试的函数不包含外部依赖，用Google Test基础的用法就可以完成用例编写。\n\n原函数：\n\n```c++\nvoid chat_message::body_length(std::size_t new_length) {\n    body_length_ = new_length;\n    if (body_length_ > 512)\n        body_length_ = 512;\n}\n```\n\n这个函数很简单。就是给`body_length_`赋值但是有最大值限制。测试用例可以这样写：\n\n```c++\nTEST(ChatMessageTest, BodyLengthNegative) {\n    chat_message c;\n    c.body_length(-50);\n    EXPECT_EQ(512, c.body_length());\n}\n\nTEST(ChatMessageTest, BodyLength0) {\n    chat_message c;\n    c.body_length(0);\n    EXPECT_EQ(0, c.body_length());\n}\n\nTEST(ChatMessageTest, BodyLength100) {\n    chat_message c;\n    c.body_length(100);\n    EXPECT_EQ(100, c.body_length());\n}\n\nTEST(ChatMessageTest, BodyLength512) {\n    chat_message c;\n    c.body_length(512);\n    EXPECT_EQ(512, c.body_length());\n}\n\nTEST(ChatMessageTest, BodyLength513) {\n    chat_message c;\n    c.body_length(513);\n    EXPECT_EQ(512, c.body_length());\n}\n```\n\n我们可以看到，对于这类函数，用例编写很直接简单，步骤都是构造变量，再用合适的Google Test的\n宏来验证变量值或者函数调用返回值。\n\n## 简单 Mock\n\n原函数\n\n```\nvoid chat_room::leave(chat_participant_ptr participant) {\n    participants_.erase(participant);\n}\n```\n`participants_ ` 的类型是 `std::set<chat_participant_ptr>`。这个函数的目的很明显，将一个`participant`从`set`中移除。\n\n真实地创建一个聊天参与者`participant`对象可以条件比较苛刻或者成本比较高。为了有效率地验证这个函数，我们可以新建一些Mock的`chat_participant_ptr`而不用严格地去创建真实的`participant`对象。\n\n`chat_participant`对象：\n\n```\nclass chat_participant {\npublic:\n    virtual ~chat_participant() {}\n    virtual void deliver(const chat_message &msg) = 0;\n};\n```\n\nMock对象：\n\n```\nclass mock_chat_participant : public chat_participant {\npublic:\n    MOCK_METHOD(void, deliver, (const chat_message &msg), (override));\n};\n```\n\n测试用例：\n\n```\nTEST(ChatRoomTest, leave) {\n    auto p1 = std::make_shared<mock_chat_participant>();\t//新建第一个Mock指针\n    auto p2 = std::make_shared<mock_chat_participant>();\t//新建第二个Mock指针\n    auto p3 = std::make_shared<mock_chat_participant>();\t//新建第三个Mock指针\n    auto p4 = std::make_shared<mock_chat_participant>();\t//新建第四个Mock指针\n    chat_room cr;\t\t\t\t\t\t\t\t\t\t\t//新建待测试对象chat_room\n    cr.join(p1);\n    cr.join(p2);\n    cr.join(p3);\n    cr.join(p4);\n    EXPECT_EQ(cr.participants().size(), 4);\n    cr.leave(p4);\n    EXPECT_EQ(cr.participants().size(), 3);\n    cr.leave(p4);\n    EXPECT_EQ(cr.participants().size(), 3);\n    cr.leave(p2);\n    EXPECT_EQ(cr.participants().size(), 2);\n}\n```\n\n## Web请求\n\n`chat_room`中有一个`log()`，依赖网络请求。原函数：\n\n```c++\nstd::string chat_room::log() {\n    std::string* response;\n    this->requester->execute(\"request\",response);\t\t// web访问，结果存在response指针中\n    return *response;\n}\n```\n\n在单元测试中，我们只关心被测试部分的逻辑。为了测试这个函数，我们不应该创建真实的`requester`，应该使用mock。\n\n`http_request`对象：\n\n```c++\nclass http_request {\npublic:\n    virtual ~http_request(){}\n    virtual bool execute(std::string request, std::string* response)=0;\n};\n```\n\nMock对象：\n\n```c++\nclass mock_http_request : public http_request {\npublic:\n    MOCK_METHOD(bool, execute, (std::string request, std::string * response), (override));\n};\n```\n\n测试用例：\n\n```c++\nTEST(ChatRoomTest, log) {\n    testing::NiceMock<mock_message_dao> mock_dao;\t//在下一部分会提到mock_message_dao\n    mock_http_request mock_requester;\t\t\t\t//Mock对象\n    std::string response = \"response\";\t\t\t\t//期待调用函数的第二个参数将指向这个string对象\n    EXPECT_CALL(mock_requester, execute)\n    \t.WillRepeatedly(\t\t\t\t\t\t\t//每次调用都会（WillRepeatedly）执行\n    \t\ttesting::DoAll(\t\t\t\t\t\t\t//每次执行包含多个行为\n    \t\t\ttesting::SetArgPointee<1>(response),//将传入参数指针变量response指向response\n    \t\t\ttesting::Return(true)));\t\t\t//返回值为true\n    chat_room cr \n    \t= chat_room(&mock_dao, &mock_requester);\t//将mock对象通过chat_room的constructor注入\n    EXPECT_EQ(cr.log(),\"response\");\t\t\t\t\t//调用和Google Test断言\n}\n```\n\n## 数据库访问\n\n`chat_room`对象会将聊天者发送的消息存储在redis数据库中。当新用户加入时，`chat_room`对象从数据库\n获取所有历史消息发送给该新用户。\n\n`join()`函数：\n\n```c++\nvoid chat_room::join(chat_participant_ptr participant) {\n    participants_.insert(participant);\n    std::vector<std::string> recent_msg_strs = \n    \tthis->dao->get_messages(); \t\t\t//从数据库中获取历史消息\n    for (std::string recent_msg_str: recent_msg_strs) {\n\t\t\t\t\t\t\t\t\t\t    //将每一个消息发送给该聊天参与者\t\n        auto msg = chat_message();\n        msg.set_body_string(recent_msg_str);\n        participant->deliver(msg);\n    }\n}\n```\n\n`message_dao`对象：\n\n```c++\nclass message_dao {\npublic:\n    virtual ~message_dao(){}\n    virtual bool add_message(std::string m)=0;\n    virtual std::vector<std::string> get_messages()=0;\n};\n```\n\nMock对象：\n\n```c++\nclass mock_message_dao : public message_dao {\npublic:\n    MOCK_METHOD(bool, add_message, (std::string m), (override));\n    MOCK_METHOD(std::vector<std::string>, get_messages, (), (override));\n};\n```\n\n测试用例：\n\n```c++\nTEST(ChatRoomTest, join) {\n    mock_message_dao mock_dao;\t\t\t\t//创建mock对象（需要注入chat_room）\n    http_request_impl requester;\t\t\t//创建web访问对象（也需要注入chat_room）\n    auto mock_p1 = std::make_shared<mock_chat_participant>();\n    \t\t\t\t\t\t\t\t\t\t//创建participant的mock指针\n    EXPECT_CALL(mock_dao, get_messages)\n    \t.WillOnce(testing::Return(std::vector<std::string>{\"test_msg_body_1\", \"test_msg_body_2\", \"test_msg_body_3\"}));\n    \t\t\t\t\t\t\t\t\t\t//指定get_messages调用的返回值\n    EXPECT_CALL(*mock_p1, deliver).Times(3);\n    \t\t\t\t\t\t\t\t\t\t//指定deliver调用的次数\n    chat_room cr = chat_room(&mock_dao, &requester);\n    \t\t\t\t\t\t\t\t\t\t//创建chat_room对象，注入dao和requester\n    cr.join(mock_p1);\t\t\t\t\t\t//调用\n}\n```\n\n先创建mock对象，再指定函数调用的预期，最后指向被测试函数。我们可以看到，`mock_dao`指定了`get_messages`的\n返回值时一个长度为3的vector，所以有3条消息会被deliver。\n\n# FAQ\n\n## 单元测试源文件应该放在项目的什么位置？\n\n一般来说，我们会在根目录创建一个`tests`文件夹，里面放单元测试部分的源代码，从而不会和被测试代码混在一起。\n\n如果需要和其他测试（如接口测试、压力测试）等区分开来，可以\n\n1. 把`tests`改成`unittests`、`utests`等，或者\n2. 在`tests`创建不同子文件夹存放不同类型的测试代码。\n\n## Google Mock只能Mock虚函数，如果我想Mock非虚函数怎么办？\n\n由于Google Mock（及其他大部分Mock框架）通过继承来动态重载机制的限制，一般来说Google Mock只能Mock虚函数。如果要mock非虚函数，官方文档提供这几种思路：\n\n1. Mock类和原类没有继承关系，在测试对象使用函数模板。在测试中，测试对象接受Mock类。\n2. 创建一个接口（抽象类），原类继承自这个接口（抽象类）。在测试中Mock这个接口（抽象类）。\n\n这两种方法，都需要对代码进行一定的修改或重构。如果不想修改被测试代码。可以考虑使用hook技术替换被mock的部分从而mock一般函数。\n\n使用`TMock`对非虚函数mock的例子：\n\nmock函数\n\n```c++\n# include \"tmock.h\"\n\nclass MockClass\n{\npublic:\n    //注册mock类\n    TMOCK_CLASS(MockClass);\n    //声明mock类函数，TMOCK_METHOD{n}第一个参数与attach_func_lib第一个参数相同，其余参考与MOCK_METHOD{n}一致。\n    TMOCK_METHOD1(\"original\", original, uint32_t(const char * str_file_md5) )\n};\n```\n单测中应用`tmock`的方法和Google Mock基本一致。但在结束的时候需要使用`TMOCK_CLEAR`清除exception，\ndetach hook的函数，防止干扰其他单元测试。\n\n\n## Google Test官方文档中说测测试套件名称、测试夹具名称、测试名称中不应该出现下划线`_`。为什么？\n\n`TEST(TestSuiteName, TestName)`生成名为`TestSuiteName_TestName_Test`的类。\n\n下划线`_`是特殊的，因为C ++保留以下内容供编译器和标准库使用。所以开头和结尾有下划线很容易让生成的类的标识符不合法。\n\n另一方面，下划线可能让不同测试生成相同的类。比如`TEST（Time，Flies_Like_An_Arrow）{...} `和`TEST（Time_Flies，Like_An_Arrow）{...} `都生成名为`Time_Flies_Like_An_Arrow_Test`的类。\n\n## 测试输出里有很多`Uninteresting mock function call`警告怎么办？\n\n创建的Mock的对象的某些调用如果没有相应匹配的`EXPECT_CALL`，Google Mock会生成这个警告。\n\n为了去除这个警告，可以使用`NiceMock`。比如如果原本使用`MockFoo nice_foo;`新建mock对象的话，可以改成`NiceMock<MockFoo> nice_foo;`。`NiceMock<MockFoo>`是`MockFoo`的子类。\n\n\n# 单测覆盖率\n使用 Gcov 和 LCOV 度量 C/C++ 项目的代码覆盖率\n## 什么是代码覆盖率？\n代码覆盖率是对整个测试过程中被执行的代码的衡量，它能测量源代码中的哪些语句在测试中被执行，哪些语句尚未被执行。\n\n## 为什么要测量代码覆盖率？\n众所周知，测试可以提高软件版本的质量和可预测性。但是，你知道你的单元测试甚至是你的功能测试实际测试代码的效果如何吗？是否还需要更多的测试？\n\n这些是代码覆盖率可以试图回答的问题。总之，出于以下原因我们需要测量代码覆盖率：\n\n- 了解我们的测试用例对源代码的测试效果 \n- 了解我们是否进行了足够的测试 \n- 在软件的整个生命周期内保持测试质量\n注：代码覆盖率不是灵丹妙药，覆盖率测量不能替代良好的代码审查和优秀的编程实践。\n\n通常，我们应该采用合理的覆盖目标，力求在代码覆盖率在所有模块中实现均匀覆盖，而不是只看最终数字的是否高到令人满意。\n\n举例：假设代码覆盖率只在某一些模块代码覆盖率很高，但在一些关键模块并没有足够的测试用例覆盖，那样虽然代码覆盖率很高，但并不能说明产品质量就很高。\n\n## 代码覆盖率的指标种类\n代码覆盖率工具通常使用一个或多个标准来确定你的代码在被自动化测试后是否得到了执行，常见的覆盖率报告中看到的指标包括：\n\n- 函数覆盖率：定义的函数中有多少被调用 \n- 语句覆盖率：程序中的语句有多少被执行 \n- 分支覆盖率：有多少控制结构的分支（例如if语句）被执行 \n- 条件覆盖率：有多少布尔子表达式被测试为真值和假值 \n- 行覆盖率：有多少行的源代码被测试过\n\n## 代码覆盖率是如何工作的？\n代码覆盖率测量主要有以下三种方式：\n\n1. Source code instrumentation - 源代码检测\n将检测语句添加到源代码中，并使用正常的编译工具链编译代码以生成检测的程序集。这是我们常说的插桩，Gcov 是属于这一类的代码覆盖率工具。\n\n2. Runtime instrumentation - 运行时收集\n这种方法在代码执行时从运行时环境收集信息以确定覆盖率信息。以我的理解 JaCoCo 和 Coverage 这两个工具的原理属于这一类别。\n\n3. Intermediate code instrumentation - 中间代码检测\n\n通过添加新的字节码来检测编译后的类文件，并生成一个新的检测类。说实话，我 Google 了很多文章并找到确定的说明哪个工具是属于这一类的。\n\n了解这些工具的基本原理，结合现有的测试用例，有助于正确的选择代码覆盖率工具。比如：\n\n- 产品的源代码只有 E2E（端到端）测试用例，通常只能选择第一类工具，即通过插桩编译出的可执行文件，然后进行测试和结果收集。\n- 产品的源代码有单元测试用例，通常选择第二类工具，即运行时收集。这类工具的执行效率高，易于做持续集成。\n\n## 当前主流代码覆盖率工具\n代码覆盖率的工具有很多，以下是我用过的不同编程语言的代码覆盖率工具。在选择工具时，力求去选择那些开源、流行（活跃）、好用的工具。\n\n| 编程语言   | 代码覆盖率工具 |\n| ---------- | -------------- |\n| C/C++      | Gcov           |\n| Java       | JaCoCo         |\n| JavaScript | Istanbul       |\n| Python     | Coverage.py    |\n| Golang     | cover          |\n\n\n## 最后，不要高估代码覆盖率指标\n代码覆盖率不是灵丹妙药，它只是告诉我们有哪些代码没有被测试用例“执行到”而已，高百分比的代码覆盖率不等于高质量的有效测试。\n\n- 首先，高代码覆盖率不足以衡量有效测试。相反，代码覆盖率更准确地给出了代码未被测试程度的度量。这意味着，如果我们的代码覆盖率指标较低，那么我们可以确定代码的重要部分没有经过测试，然而反过来不一定正确。具有高代码覆盖率并不能充分表明我们的代码已经过充分测试。 \n- 其次，100% 的代码覆盖率不应该是我们明确努力的目标之一。这是因为在实现 100% 的代码覆盖率与实际测试重要的代码之间总是需要权衡。虽然可以测试所有代码，但考虑到为了满足覆盖率要求而编写更多无意义测试的趋势，当你接近此限制时，测试的价值也很可能会减少。\n借 Martin Fowler 在这篇测试覆盖率的文章说的一句话：\n```shell\n代码覆盖率是查找代码库中未测试部分的有用工具,然而它作为一个数字说明你的测试有多好用处不大。\n\n```\n\n## C++覆盖率\n介绍如何使用 Gcov 和 LCOV 对 C/C++ 项目进行代码覆盖率的度量。\n\n对于想使用 Gcov 的人，为了说明它是如何工作的，准备了一段示例程序，运行这个程序之前需要先安装 GCC 和 LCOV。\n\n如果没有环境或不想安装，可以直接查看示例仓库的 GitHub 仓库：[Gcov示例](https://github.com/vwin/gcov-example)\n\n注：主分支 master 下面放的是源码，分支 coverage 下的 out 目录是最终的结果报告。\n\n这是我的测试环境上的 GCC 和 lcov 的版本\n```shell\nsh-4.2$ gcc --version\nApple clang version 13.1.6 (clang-1316.0.21.2.5)\nTarget: x86_64-apple-darwin22.1.0\nThread model: posix\nInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin\n\nsh-4.2$ lcov -v\nlcov: LCOV version 1.16\n```\n### Gcov 是如何工作的\nGcov 工作流程图\n![gcov流程](http://cdn.yuleweici.com/CPP-%E5%8D%95%E6%B5%8B/img_2.png)\n\n主要分三步：\n1. 在 GCC 编译的时加入特殊的编译选项，生成可执行文件，和 *.gcno； \n2. 运行（测试）生成的可执行文件，生成了 *.gcda 数据文件； \n3. 有了 *.gcno 和 *.gcda，通过源码生成 gcov 文件，最后生成代码覆盖率报告。\n\n下面就开始介绍其中每一步具体是怎么做的。\n#### 编译\n第一步编译，这里已经将编译用到的参数和文件都写在了 makefile 里了，只要执行 make 就可以编译了。\n```shell\nmake\n```\n\nmake 命令的输出\n\n```shell\nsh-4.2$ make\ngcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror main.c\ngcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror foo.c\ngcc -fPIC -fprofile-arcs -ftest-coverage -o main main.o foo.o\n```\n通过输出可以看到，这个程序在编译的时候添加了两个编译选项 -fprofile-arcs and -ftest-coverage。在编译成功后，不仅生成了 main and .o 文件，同时还生成了两个 .gcno 文件.\n\n.gcno 记录文件是在加入 GCC 编译选项 -ftest-coverage 后生成的，在编译过程中它包含用于重建基本块图和为块分配源行号的信息。\n\n如果使用的是cmake，则在CMakeLists.txt中加入\n```shell\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fprofile-arcs -ftest-coverage\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fprofile-arcs -ftest-coverage\")\n```\n\n#### 运行可执行文件\n在编译完成后，生成了 main 这个可执行文件，运行（测试）它：\n```shell\n./main\n```\n运行 main 时输出\n```shell\n\nsh-4.2$ ./main\nStart calling foo() ...\nwhen num is equal to 1...\nwhen num is equal to 2...\n\n```\n\n当运行 main 后，执行结果被记录在了 .gcda 这个数据文件里，查看当前目录下可以看到一共有生成了两个 .gcda 文件，每个源文件都对应一个 .gcda 文件。\n```shell\n\n$ ls\nfoo.c  foo.gcda  foo.gcno  foo.h  foo.o  img  main  main.c  main.gcda  main.gcno  main.o  makefile  README.md\n.gcda 记录数据文件的生成是因为程序在编译的时候引入了 -fprofile-arcs 选项。它包含弧过渡计数、值分布计数和一些摘要信息。\n```\n\n#### 生成报告\n\n```shell\nmake report\n```\n\n生成报告的输出\n```shell\nsh-4.2$ make report\ngcov main.c foo.c\nFile 'main.c'\nLines executed:100.00% of 5\nCreating 'main.c.gcov'\n\nFile 'foo.c'\nLines executed:85.71% of 7\nCreating 'foo.c.gcov'\n\nLines executed:91.67% of 12\nlcov --capture --directory . --output-file coverage.info\nCapturing coverage data from .\nFound gcov version: 4.8.5\nScanning . for .gcda files ...\nFound 2 data files in .\nProcessing foo.gcda\ngeninfo: WARNING: cannot find an entry for main.c.gcov in .gcno file, skipping file!\nProcessing main.gcda\nFinished .info-file creation\ngenhtml coverage.info --output-directory out\nReading data file coverage.info\nFound 2 entries.\nFound common filename prefix \"/workspace/coco\"\nWriting .css and .png files.\nGenerating output.\nProcessing file gcov-example/main.c\nProcessing file gcov-example/foo.c\nWriting directory view page.\nOverall coverage rate:\nlines......: 91.7% (11 of 12 lines)\nfunctions..: 100.0% (2 of 2 functions)\n```\n\n执行 make report 来生成 HTML 报告，这条命令的背后实际上主要执行了以下两个步骤：\n\n1. 在有了编译和运行时候生成的 .gcno 和 .gcda 文件后，执行命令 gcov main.c foo.c 即可生成 .gcov 代码覆盖率文件。\n2. 有了代码覆盖率 .gcov 文件，通过 LCOV 生成可视化代码覆盖率报告。\n生成 HTML 结果报告的步骤如下：\n```shell\n\n# 1. 生成 coverage.info 数据文件\nlcov --capture --directory . --output-file coverage.info\n# 2. 根据这个数据文件生成报告\ngenhtml coverage.info --output-directory out\n\n常用的lcov命令:\n1. lcov --extract xx.info '*/xx' '*/yy' -o res.info  // 只保留xx.info中的xx和yy目录并输出到res.info\n2. lcov --remove xx.info '*/xx' '*/yy' -o res.info //删除xx.info中的xx和yy目录并输出到res.info\n3. lcov -a xx.info -a yy.info -o res.info //合并xx.info和yy.info并输出到res.info\n```\n\n#### 收尾\n上传过程中所有生成的文件可通过执行 make clean 命令来彻底删除掉。\n\nmake clean 命令的输出\n```shell\n\nsh-4.2$ make clean\nrm -rf main *.o *.so *.gcno *.gcda *.gcov coverage.info out\n\n```\n\n> 旁注： 还有另外一个生成 HTML 报告的工具叫 gcovr，使用 Python 开发的，它的报告在显示方式上与 LCOV 略有不同。比如 LCOV 以目录结构显示， gcovr 以文件路径来显示，前者与代码结构一直因此我更倾向于使用前者。\n\n# 结语\n\n## 实践小结\n和GoLang单元测试框架有些区别的是，GoLang自生就提供了自带的测试框架，也有第三方框架进行选择。\n而C/C++/php等语言的单元测试框架则需要第三方提供和安装。\n\n框架的使用，无非是一些语法糖的差异和使用的难易程度。不管使用什么语言，什么框架，最关键的是利用单元测试的思路，\n写出解耦的、可测试的、易于维护的代码，保证代码的质量。\n\n单元测试是一种手段，能够一定程度的改善生产力。凡事有度过犹不及，如果一味的盲目的追求测试覆盖率，\n忽视了测试代码本身的质量，那么各种无效的单元测试反而带来了沉重的维护负担。因此单测的代码，本身也是代码，\n也是和项目本身的代码一样，需要重构、维护的（好好写代码）。\n","content":"<p>单测系列-C++<br>总结在C++中如何做单测，本文介绍了单测是什么以及C++常用的单测框架和工具</p>\n<span id=\"more\"></span>\n<h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><h2 id=\"单元测试是什么\"><a href=\"#单元测试是什么\" class=\"headerlink\" title=\"单元测试是什么\"></a>单元测试是什么</h2><p>单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、超类、抽象类等中的方法。单元测试就是软件开发中对最小单位进行正确性检验的测试工作。<br>不同地方对单元测试有的定义可能会有所不同，但有一些基本共识：</p>\n<ol>\n<li>单元测试是比较底层的，关注代码的局部而不是整体。 </li>\n<li>单元测试是开发人员在写代码时候写的。 </li>\n<li>单元测试需要比其他测试运行得快。</li>\n</ol>\n<h2 id=\"单元测试的意义\"><a href=\"#单元测试的意义\" class=\"headerlink\" title=\"单元测试的意义\"></a>单元测试的意义</h2><ul>\n<li>提高代码质量。代码测试都是为了帮助开发人员发现问题从而解决问题，提高代码质量。 </li>\n<li>尽早发现问题。问题越早发现，解决的难度和成本就越低。 </li>\n<li>保证重构正确性。随着功能的增加，重构（修改老代码）几乎是无法避免的。很多时候我们不敢重构的原因，就是担心其它模块因为依赖它而不工作。有了单元测试，只要在改完代码后运行一下单测就知道改动对整个系统的影响了，从而可以让我们放心的重构代码。 </li>\n<li>简化调试过程。单元测试让我们可以轻松地知道是哪一部分代码出了问题。 </li>\n<li>简化集成过程。由于各个单元已经被测试，在集成过程中进行的后续测试会更加容易。 </li>\n<li>优化代码设计。编写测试用例会迫使开发人员仔细思考代码的设计和必须完成的工作，有利于开发人员加深对代码功能的理解，从而形成更合理的设计和结构。 </li>\n<li>单元测试是最好的文档。单元测试覆盖了接口的所有使用方法，是最好的示例代码。而真正的文档包括注释很有可能和代码不同步，并且看不懂。</li>\n</ul>\n<h2 id=\"单元测试用例编写的原则\"><a href=\"#单元测试用例编写的原则\" class=\"headerlink\" title=\"单元测试用例编写的原则\"></a>单元测试用例编写的原则</h2><h3 id=\"理论原则\"><a href=\"#理论原则\" class=\"headerlink\" title=\"理论原则\"></a>理论原则</h3><ul>\n<li>快。单元测试是回归测试，可以在开发过程的任何时候运行，因此运行速度必须快 </li>\n<li>一致性。代码没有改变的情况下，每次运行得结果应该保持确定且一致 </li>\n<li>原子性。结果只有两种情况：Pass &#x2F; Fail </li>\n<li>用例独立。执行顺序不影响；用例间没有状态共享或者依赖关系；用例没有副作用（执行前后环境状态一致） </li>\n<li>单一职责。一个用例只负责一个场景 </li>\n<li>隔离。功能可能依赖于数据库、web访问、环境变量、系统时间等；一个单元可能依赖于另一部分代码，用例应该解除这些依赖 </li>\n<li>可读性。用例的名称、变量名等应该具有可读性，直接表现出该测试的目标 </li>\n<li>自动化。单元测试需要全自动执行。测试程序不应该有用户输入；测试结果应该能直接被电脑获取，不应该由人来判断。</li>\n</ul>\n<h3 id=\"规约原则\"><a href=\"#规约原则\" class=\"headerlink\" title=\"规约原则\"></a>规约原则</h3><p>在实际编写代码过程中，不同的团队会有不同团队的风格，只要团队内部保持有一定的规约即可，比如：</p>\n<ul>\n<li>单元测试文件名必须以xxx_test.go命名 </li>\n<li>方法必须是TestXxx开头，建议风格保持一致（驼峰或者下划线） </li>\n<li>方法参数必须 t *testing.T </li>\n<li>测试文件和被测试文件必须在一个包中</li>\n</ul>\n<h3 id=\"衡量原则\"><a href=\"#衡量原则\" class=\"headerlink\" title=\"衡量原则\"></a>衡量原则</h3><p>单元测试是要写额外的代码的，这对开发同学的也是一个不小的工作负担，在一些项目中，我们合理的评估单元测试的编写，我认为我们不能走极端，当然理论上来说全写肯定时好的，但是从成本，效率上来说我们必须做出权衡，衡量原则如下：</p>\n<ul>\n<li>优先编写核心组件和逻辑模块的测试用例 </li>\n<li>逻辑类似的组件如果存在多个，优先编写其中一种逻辑组件的测试用例 </li>\n<li>发现Bug时一定先编写测试用例进行Debug </li>\n<li>关键util工具类要编写测试用例，这些util工具适用的很频繁，所以这个原则也叫做热点原则，和第1点相呼应。 </li>\n<li>测试用户应该独立，一个文件对应一个，而且不同的测试用例之间不要互相依赖。 </li>\n<li>测试用例的保持更新</li>\n</ul>\n<h2 id=\"单元测试用例设计方法\"><a href=\"#单元测试用例设计方法\" class=\"headerlink\" title=\"单元测试用例设计方法\"></a>单元测试用例设计方法</h2><h3 id=\"规范-规格-导出法\"><a href=\"#规范-规格-导出法\" class=\"headerlink\" title=\"规范(规格)导出法\"></a>规范(规格)导出法</h3><p>规范(规格)导出法将需求”翻译“成测试用例。</p>\n<p>例如，一个函数的设计需求如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数：一个计算平方根的函数 </span><br><span class=\"line\">输入： 实数 </span><br><span class=\"line\">输出： 实数 </span><br><span class=\"line\">要求： 当输入一个0或者比0大的实数时，返回其正的平方根； 当输入一个小于0的实数时，显示错误信息“平方根非法—输入之小于0”，并返回0； </span><br><span class=\"line\">库函数printf()可以用来输出错误信息。</span><br></pre></td></tr></table></figure>\n\n<p>在这个规范中有3个陈述，可以用两个测试用例来对应:</p>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>用例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>输入4，输出2</td>\n</tr>\n<tr>\n<td>2</td>\n<td>输入-1，输出0</td>\n</tr>\n</tbody></table>\n<h3 id=\"等价类划分法\"><a href=\"#等价类划分法\" class=\"headerlink\" title=\"等价类划分法\"></a>等价类划分法</h3><p>等价类划分法假定某一特定的等价类中的所有值对于测试目的来说是等价的，所以在每个等价类中找一个之作为测试用例。</p>\n<p>按照 [输入条件][有效等价类][无效等价类] 建立等价类表，列出所有划分出的等价类</p>\n<ul>\n<li>为每一个等价类规定一个唯一的编号 </li>\n<li>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类。重复这一步，直到所有的有效等价类都被覆盖为止 </li>\n<li>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类。重复这一步，直到所有的无效等价类都被覆盖为止</li>\n</ul>\n<p>例如，注册邮箱时要求用6~18个字符，可使用字母、数字、下划线，需以字母开头。</p>\n<table>\n<thead>\n<tr>\n<th>有效等价类</th>\n<th>无效等价类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>6~18个字符（1）</td>\n<td>少于6个字符（2）<br>多余18个字符（3）<br>空（4）</td>\n</tr>\n<tr>\n<td>包含字母、数字、下划线（5）</td>\n<td>除字母、数字、下划线的特殊字符（6）<br>非打印字符（7）<br>中文字符 （8）</td>\n</tr>\n<tr>\n<td>以字母开头（9）</td>\n<td>以数字或下划线开头（10）</td>\n</tr>\n</tbody></table>\n<p>测试用例</p>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>输入数据</th>\n<th>覆盖等价类</th>\n<th>预期结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>test_111</td>\n<td>（1）、（5）、（9）</td>\n<td>合法输入</td>\n</tr>\n<tr>\n<td>2</td>\n<td>t_11</td>\n<td>（2）、（5）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>3</td>\n<td>testtesttest_12345678</td>\n<td>（3）、（5）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>4</td>\n<td>NULL</td>\n<td>（4）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>5</td>\n<td>test!@1111</td>\n<td>（1）、（6）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>6</td>\n<td>test 1111</td>\n<td>（1）、（7）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>7</td>\n<td>test测试1111</td>\n<td>（1）、（8）、（9）</td>\n<td>非法输入</td>\n</tr>\n<tr>\n<td>8</td>\n<td>_test111</td>\n<td>（1）、（5）、（10）</td>\n<td>非法输入</td>\n</tr>\n</tbody></table>\n<h3 id=\"边界值分析法\"><a href=\"#边界值分析法\" class=\"headerlink\" title=\"边界值分析法\"></a>边界值分析法</h3><p>边界值分析法使用与等价类测试方法相同的等价类划分，只是边界值分析假定 错误更多地存在于两个划分的边界上。<br>边界值测试在软件变得复杂的时候也会变得不实用。边界值测试对于非向量类型的值(如枚举类型的值)也没有意义。<br>例如，和4.1相同的需求，划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0。由此得到以下测试用例：</p>\n<ul>\n<li>输入 {最小负实数} </li>\n<li>输入 {绝对值很小的负数} </li>\n<li>输入 0 </li>\n<li>输入 {绝对值很小的正数} </li>\n<li>输入 {最大正实数}</li>\n</ul>\n<h3 id=\"基本路径测试法\"><a href=\"#基本路径测试法\" class=\"headerlink\" title=\"基本路径测试法\"></a>基本路径测试法</h3><p>基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。<br>基本路径测试法的基本步骤：</p>\n<ul>\n<li>程序的控制流图：描述程序控制流的一种图示方法。 </li>\n<li>程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。 </li>\n<li>导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。 </li>\n<li>准备测试用例：确保基本路径集中的每一条路径的执行。</li>\n</ul>\n<h1 id=\"常用C-单测框架\"><a href=\"#常用C-单测框架\" class=\"headerlink\" title=\"常用C++单测框架\"></a>常用C++单测框架</h1><h2 id=\"常用的C-单测对比\"><a href=\"#常用的C-单测对比\" class=\"headerlink\" title=\"常用的C++单测对比\"></a>常用的C++单测对比</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>Google test</th>\n<th>Catch 2</th>\n<th>CppUTest</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>特点</td>\n<td>成熟、兼容性好<br>简洁、有效率<br>常用、学习资源多</td>\n<td>框架只有一个catch.hpp、集成轻松<br>有Given-When-Then分区，适合BDD行为驱动开发<br>无自带Mock框架</td>\n<td>可以检测内存泄露<br>输出更简洁<br>适合在嵌入式系统项目中使用</td>\n</tr>\n<tr>\n<td>Mock框架</td>\n<td>Google Mock</td>\n<td>无自带Mock框架</td>\n<td>CppUMock</td>\n</tr>\n<tr>\n<td>推荐指数</td>\n<td>★★★★★</td>\n<td>★★★☆☆</td>\n<td>★★☆☆☆</td>\n</tr>\n</tbody></table>\n<p>一般情况下，我们推荐使用Google Test搭配Google Mock。如果项目有特殊需求或更适合其他框架，也可以考虑。<br>根据实际使用频率，在以下部分，Google Test和Google Mock的介绍更为详细；对于其他框架，这里介绍它们的主要特点， 具体使用方法，可以查阅各自文档。</p>\n<h1 id=\"Google-Test\"><a href=\"#Google-Test\" class=\"headerlink\" title=\"Google Test\"></a>Google Test</h1><p>Google Test是目前比较成熟而且最常用的C++单元测试框架之一。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>断言（Assertions） 是检查条件是否为真的语句。断言的结果可能是成功或者失败， 而失败又分为非致命失败或致命失败。如果发生致命失败，测试进程将中止当前运行，否则它将继续运行。 </li>\n<li>测试（Test） 使用断言来验证被测试代码的行为。如果测试崩溃或断言失败，则测试失败；否则测试成功。 </li>\n<li>测试套件（Test Suite） 包含一个或多个测试（Test）。当测试套件中的多个测试需要共享通用对象和子例程时， 可以将它们放入测试夹具（Test Fixture）。 </li>\n<li>测试程序（Test Program） 可以包含多个测试套件。</li>\n</ul>\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><ul>\n<li>Google Test中，断言（Assertions） 是类似函数调用的宏。断言失败时，googletest会输出断言的源文件和 行号位置以及失败消息；我们还可以提供自定义失败消息，该消息将附加到googletest消息中。 </li>\n<li>断言成对出现（ASSERT_*和EXPECT_*），它们测试的对象相同，但对当前运行有不同的影响。ASSERT_*版本失败时 会产生致命故障，并中止当前函数（不一定是整个TEST）运行。EXPECT_*版本会产生非致命故障，不会停止当前函数运行。 通常EXPECT_*是首选，因为可以在测试中报告多个故障。但是如果在断言失败时继续执行没有意义，则应使用ASSERT_*。 </li>\n<li>要提供自定义失败消息，只需使用&lt;&lt; 运算符或此类运算符的序列将其流式传输到宏中即可 。一个例子：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ASSERT_EQ</span>(x.<span class=\"built_in\">size</span>(), y.<span class=\"built_in\">size</span>()) &lt;&lt; <span class=\"string\">&quot;x和y长度不同&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; x.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_EQ</span>(x[i], y[i]) &lt;&lt; <span class=\"string\">&quot;x和y元素存在不同：&quot;</span> &lt;&lt; i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n以下是一些最常用的断言，如果需要查阅其他断言，可以前往googletest的官方文档。</li>\n</ul>\n<h3 id=\"基本断言\"><a href=\"#基本断言\" class=\"headerlink\" title=\"基本断言\"></a>基本断言</h3><p><code>condition</code> 是返回<code>true</code>&#x2F;<code>false</code>的变量、布尔表达式、函数调用等，以下断言对其进行验证。</p>\n<table>\n<thead>\n<tr>\n<th>失败时中断执行的断言</th>\n<th>失败时不中断执行的断言</th>\n<th>断言成功情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSERT_TRUE(condition);</td>\n<td>EXPECT_TRUE(condition);</td>\n<td>condition为真</td>\n</tr>\n<tr>\n<td>ASSERT_FALSE(condition);</td>\n<td>EXPECT_FALSE(condition);</td>\n<td>condition为假</td>\n</tr>\n</tbody></table>\n<p>例如：在<code>ASSERT_TRUE(condition)</code>中，当<code>condition</code>为<code>true</code>时，符合断言，不影响执行；当<code>condition</code><br>为<code>false</code>时，不符合断言，且由于是<code>ASSERT</code>，当前执行中断。</p>\n<h3 id=\"普通比较型断言\"><a href=\"#普通比较型断言\" class=\"headerlink\" title=\"普通比较型断言\"></a>普通比较型断言</h3><p><code>val1</code>和<code>val2</code>是两个可用<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>等运算符进行比较的值，以下断言对其进行比较。</p>\n<table>\n<thead>\n<tr>\n<th>失败时中断执行的断言</th>\n<th>失败时不中断执行的断言</th>\n<th>断言成功情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSERT_EQ(val1, val2);</td>\n<td>EXPECT_EQ(val1, val2);</td>\n<td>val1 &#x3D;&#x3D; val2</td>\n</tr>\n<tr>\n<td>ASSERT_NE(val1, val2);</td>\n<td>EXPECT_NE(val1, val2);</td>\n<td>val1 !&#x3D; val2</td>\n</tr>\n<tr>\n<td>ASSERT_LT(val1, val2);</td>\n<td>EXPECT_LT(val1, val2);</td>\n<td>val1 &lt; val2</td>\n</tr>\n<tr>\n<td>ASSERT_LE(val1, val2);</td>\n<td>EXPECT_LE(val1, val2);</td>\n<td>val1 &lt;&#x3D; val2</td>\n</tr>\n<tr>\n<td>ASSERT_GT(val1, val2);</td>\n<td>EXPECT_GT(val1, val2);</td>\n<td>val1 &gt; val2</td>\n</tr>\n<tr>\n<td>ASSERT_GE(val1, val2);</td>\n<td>EXPECT_GE(val1, val2);</td>\n<td>val1 &gt;&#x3D; val2</td>\n</tr>\n</tbody></table>\n<p>例如：在<code>ASSERT_GT(val1, val2)</code>中，只有当<code>val1 &gt; val2</code>时，符合断言，不影响执行；当<code>val1 &lt;= val2</code>时，<br>不符合断言，且由于是<code>ASSERT</code>，当前执行中断。</p>\n<h3 id=\"C字符串比较型断言\"><a href=\"#C字符串比较型断言\" class=\"headerlink\" title=\"C字符串比较型断言\"></a>C字符串比较型断言</h3><p><code>str1</code>和<code>str2</code>是两个C字符串，以下断言对它们的值进行比较；如果要比较两个<code>std::string</code>对象，直接用之前<br>提到的<code>EXPECT_NE</code>，<code>EXPECT_NE</code>等。</p>\n<table>\n<thead>\n<tr>\n<th>失败时中断执行的断言</th>\n<th>失败时不中断执行的断言</th>\n<th>断言成功情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSERT_STREQ(str1,str2);</td>\n<td>EXPECT_STREQ(str1,str2);</td>\n<td>这两个C字符串具有相同的内容</td>\n</tr>\n<tr>\n<td>ASSERT_STRNE(str1,str2);</td>\n<td>EXPECT_STRNE(str1,str2);</td>\n<td>两个C字符串的内容不同</td>\n</tr>\n<tr>\n<td>ASSERT_STRCASEEQ(str1,str2);</td>\n<td>EXPECT_STRCASEEQ(str1,str2);</td>\n<td>忽略大小写，两个C字符串的内容相同</td>\n</tr>\n<tr>\n<td>ASSERT_STRCASENE(str1,str2);</td>\n<td>EXPECT_STRCASENE(str1,str2)</td>\n<td>忽略大小写，两个C字符串的内容不同</td>\n</tr>\n</tbody></table>\n<p>例如：<code>char *str1 = &quot;ABC&quot;;``char *str2 = &quot;ABC&quot;;</code>，<code>EXPECT_STREQ(str1, str2);</code>断言通过，<br>因为它们的内容一样；而<code>EXPECT_EQ(str1, str2);</code>断言失败，因为它们的地址不一样。</p>\n<p>注意：一个<code>NULL</code>指针和一个空字符串<code>&quot;&quot;</code>是不同的。</p>\n<h3 id=\"浮点数比较型断言\"><a href=\"#浮点数比较型断言\" class=\"headerlink\" title=\"浮点数比较型断言\"></a>浮点数比较型断言</h3><p><code>val1</code>和<code>val2</code>是两个浮点数，以下断言对其进行比较。</p>\n<table>\n<thead>\n<tr>\n<th>失败时中断执行的断言</th>\n<th>失败时不中断执行的断言</th>\n<th>断言成功情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSERT_FLOAT_EQ(val1, val2);</td>\n<td>EXPECT_FLOAT_EQ(val1, val2);</td>\n<td>这两个float值几乎相等</td>\n</tr>\n<tr>\n<td>ASSERT_DOUBLE_EQ(val1, val2);</td>\n<td>EXPECT_DOUBLE_EQ(val1, val2);</td>\n<td>这两个double值几乎相等</td>\n</tr>\n</tbody></table>\n<p>以下断言可以选择可接受的误差范围：</p>\n<table>\n<thead>\n<tr>\n<th>失败时中断执行的断言</th>\n<th>失败时不中断执行的断言</th>\n<th>断言成功情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSERT_NEAR(val1, val2, abs_error);</td>\n<td>EXPECT_NEAR(val1, val2, abs_error);</td>\n<td>val1和val2的差的绝对值不超过abs_error</td>\n</tr>\n</tbody></table>\n<h3 id=\"明确的成功和失败\"><a href=\"#明确的成功和失败\" class=\"headerlink\" title=\"明确的成功和失败\"></a>明确的成功和失败</h3><ul>\n<li>明确生成成功：</li>\n<li><code>SUCCEED();</code> 生成一个成功，但这不代表整个测试就成功了。</li>\n<li>明确生成失败：</li>\n<li><code>FAIL();</code> 生成致命错误</li>\n<li><code>ADD_FAILURE();</code> 生成非致命错误。</li>\n<li><code>ADD_FAILURE_AT(&quot;file_path&quot;,line_number);</code> 生成非致命错误，输出文件名和行号。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(condition) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">SUCCEED</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">FAIL</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果上等同于</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ASSERT_TRUE</span>(condition);</span><br></pre></td></tr></table></figure>\n<p>只是<code>ASSERT_TRUE</code>失败时可以输出<code>condition</code>的具体值。当但我们需要验证的<code>condition</code>很复杂时，<br>或者需要很多个<code>if..else...</code>分支来验证彼此互斥的情况以保证覆盖到每一种可能性时，<code>SUCCEED()</code>、<code>FAIL()</code>等<br>明确的成功&#x2F;失败可能是更好的选择。</p>\n<h3 id=\"异常断言\"><a href=\"#异常断言\" class=\"headerlink\" title=\"异常断言\"></a>异常断言</h3><p>这些断言验证一段代码（<code>statement</code>）是否抛出（或不抛出）给定类型的异常：</p>\n<table>\n<thead>\n<tr>\n<th>失败时中断执行的断言</th>\n<th>失败时不中断执行的断言</th>\n<th>断言成功情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSERT_THROW(statement, exception_type);</td>\n<td>EXPECT_THROW(statement, exception_type);</td>\n<td>statement抛出给定类型的异常</td>\n</tr>\n<tr>\n<td>ASSERT_ANY_THROW(statement);</td>\n<td>EXPECT_ANY_THROW(statement);</td>\n<td>statement抛出任何类型的异常</td>\n</tr>\n<tr>\n<td>ASSERT_NO_THROW(statement);</td>\n<td>EXPECT_NO_THROW(statement);</td>\n<td>statement不抛出任何异常</td>\n</tr>\n</tbody></table>\n<h3 id=\"使用已有布尔函数\"><a href=\"#使用已有布尔函数\" class=\"headerlink\" title=\"使用已有布尔函数\"></a>使用已有布尔函数</h3><p>当<code>predN</code>是一个有<code>N</code>个参数，返回布尔值的函数时，以下断言可以获取更好的错误信息。</p>\n<table>\n<thead>\n<tr>\n<th>失败时中断执行的断言</th>\n<th>失败时不中断执行的断言</th>\n<th>断言成功情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSERT_PRED1(pred1, val1);</td>\n<td>EXPECT_PRED1(pred1, val1);</td>\n<td>pred1(val1)为真</td>\n</tr>\n<tr>\n<td>ASSERT_PRED2(pred2, val1, val2);</td>\n<td>EXPECT_PRED2(pred2, val1, val2);</td>\n<td>pred2(val1, val2)为真</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody></table>\n<p>例如：<code>isComparable(Object o1, Object o2)</code>是一个返回布尔值的函数。我们可以有以下选择，<br>都能达到验证函数调用结果的目的：</p>\n<ol>\n<li><code>ASSERT_TRUE(isComparable(obj1, obj2));</code></li>\n<li><code>ASSERT_PRED2(isComparable, obj1, obj2);</code><br>　　区别在于：当断言失败时，<code>ASSERT_TRUE</code>只会告知函数最后的返回值是<code>false</code>；而<code>ASSERT_TRUE</code>同时<br>会输出<code>val1</code>、<code>val2</code>的值。</li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>创建一个测试的步骤：</p>\n<ol>\n<li>使用<code>TEST()</code>宏定义和命名测试功能。</li>\n<li>在<code>TEST()</code>宏内，构造出达到测试状态的函数、变量</li>\n<li>使用断言指定函数、变量期望的返回值、值。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST</span>(MessageTestSuite, BodyLengthNegative) &#123;</span><br><span class=\"line\">\t... 构造 ...</span><br><span class=\"line\">\t... 断言 ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><code>TEST()</code>第一个参数是Test Suite的名称，第二个参数是Test Suite内的Test名称。这两个名称都必须是有效的<br>C++标识符，并且它们不应包含任何下划线（<code>_</code>）。测试的全名包括Test Suite名和Test名。来自不同Test Suite的<br>测试可以具有相同的Test名。它们都不是变量，也不是字符串。</p>\n<p>在上面的例子中，这个测试的名称是<code>BodyLengthNegative</code>，Test Suite的名称是<code>MessageTestSuite</code>。</p>\n<h2 id=\"测试夹具：多个测试有共有的数据配置\"><a href=\"#测试夹具：多个测试有共有的数据配置\" class=\"headerlink\" title=\"测试夹具：多个测试有共有的数据配置\"></a>测试夹具：多个测试有共有的数据配置</h2><p>如果多个测试有共有的数据配置，可以使用<strong>测试夹具（Test Fixture）</strong>将共用部分提取出来重复利用。</p>\n<p>要创建一个测试夹具：</p>\n<ol>\n<li>创建一个继承<code>::testing::Test</code>的类。从<code>protected</code>开始这个类，因为我们要从子类访问夹具成员。</li>\n<li>在类内部，声明计划使用的任何对象。</li>\n<li>如有必要，编写默认的<code>constructor</code>或<code>SetUp()</code>函数为每个测试准备对象。</li>\n<li>如有必要，编写一个<code>destructor</code>或<code>TearDown()</code>函数以释放在<code>SetUp()</code>中分配的任何资源。</li>\n<li>如有必要，定义一些共享的类函数</li>\n</ol>\n<p>当使用测试夹具是，需要使用<code>TEST_F()</code>而不是<code>TEST()</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestFixtureName</span> : <span class=\"keyword\">public</span> ::testing::Test &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">SetUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">TearDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">SomeFunction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSomeObject object;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST_F</span>(TestFixtureName, TestName1) &#123;</span><br><span class=\"line\">\t... 构造 ...</span><br><span class=\"line\">\t... 断言 ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST_F</span>(TestFixtureName, TestName2) &#123;</span><br><span class=\"line\">\t... 构造 ...</span><br><span class=\"line\">\t... 断言 ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那上面这个例子来说，对于每个<code>TEST_F()</code>测试，googletest将在运行时</p>\n<ol>\n<li>创建一个新的<strong>测试夹具（Test Fixture）</strong>对象</li>\n<li>通过<code>SetUp()</code>对其进行初始化</li>\n<li>运行该<code>TEST_F()</code>测试</li>\n<li>通过调用进行清理<code>TearDown()</code></li>\n<li>然后删除该<strong>测试夹具（Test Fixture）</strong>对象</li>\n</ol>\n<p>所以，虽然多个<code>TEST_F</code>共用同一部分代码，但共同代码会每个<code>TEST_F</code>都独立执行一次。同一测试套件中的不同测试具有不同的测试夹具对象。一个测试对<strong>测试夹具</strong>所做的任何更改均不会影响其他测试。</p>\n<h1 id=\"Catch-2\"><a href=\"#Catch-2\" class=\"headerlink\" title=\"Catch 2\"></a>Catch 2</h1><p>Catch2 仅有头部文件（header only），所以它的第一个优点是可以轻易地放入任何项目中进行使用。只需要 <code>#include &quot;catch.hpp&quot;</code> 就可以在当前文件使用 Catch</p>\n<h2 id=\"REQUIRE\"><a href=\"#REQUIRE\" class=\"headerlink\" title=\"REQUIRE\"></a>REQUIRE</h2><p>Catch的基础使用方法也很简单。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CATCH_CONFIG_MAIN  <span class=\"comment\">// This tells Catch to provide a main() - only do this in one cpp file</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;catch.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">Factorial</span><span class=\"params\">( <span class=\"type\">unsigned</span> <span class=\"type\">int</span> number )</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> number &lt;= <span class=\"number\">1</span> ? number : <span class=\"built_in\">Factorial</span>(number<span class=\"number\">-1</span>)*number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST_CASE</span>( <span class=\"string\">&quot;Factorials are computed&quot;</span>, <span class=\"string\">&quot;[factorial]&quot;</span> ) &#123;   </span><br><span class=\"line\">\t<span class=\"built_in\">REQUIRE</span>( <span class=\"built_in\">Factorial</span>(<span class=\"number\">0</span>) == <span class=\"number\">1</span> );    </span><br><span class=\"line\">\t<span class=\"built_in\">REQUIRE</span>( <span class=\"built_in\">Factorial</span>(<span class=\"number\">1</span>) == <span class=\"number\">1</span> );    </span><br><span class=\"line\">\t<span class=\"built_in\">REQUIRE</span>( <span class=\"built_in\">Factorial</span>(<span class=\"number\">2</span>) == <span class=\"number\">2</span> );    </span><br><span class=\"line\">\t<span class=\"built_in\">REQUIRE</span>( <span class=\"built_in\">Factorial</span>(<span class=\"number\">3</span>) == <span class=\"number\">6</span> );    </span><br><span class=\"line\">\t<span class=\"built_in\">REQUIRE</span>( <span class=\"built_in\">Factorial</span>(<span class=\"number\">10</span>) == <span class=\"number\">3628800</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SECTIONS\"><a href=\"#SECTIONS\" class=\"headerlink\" title=\"SECTIONS\"></a>SECTIONS</h2><p>Catch的SECTION相当于GTEST里夹具（fixture）的功能。对每一个SECTION，TEST_CASE 都从头开始执行。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST_CASE</span>( <span class=\"string\">&quot;vectors can be sized and resized&quot;</span>, <span class=\"string\">&quot;[vector]&quot;</span> ) &#123;</span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">( <span class=\"number\">5</span> )</span></span>;    </span><br><span class=\"line\">    <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">size</span>() == <span class=\"number\">5</span> );    </span><br><span class=\"line\">    <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">capacity</span>() &gt;= <span class=\"number\">5</span> );    </span><br><span class=\"line\">    <span class=\"built_in\">SECTION</span>( <span class=\"string\">&quot;resizing bigger changes size and capacity&quot;</span> ) </span><br><span class=\"line\">        v.<span class=\"built_in\">resize</span>( <span class=\"number\">10</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">size</span>() == <span class=\"number\">10</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">capacity</span>() &gt;= <span class=\"number\">10</span> );    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"built_in\">SECTION</span>( <span class=\"string\">&quot;resizing smaller changes size not capacity&quot;</span> )&#123;</span><br><span class=\"line\">        v.<span class=\"built_in\">resize</span>( <span class=\"number\">0</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">capacity</span>() &gt;= <span class=\"number\">5</span> );    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"built_in\">SECTION</span>( <span class=\"string\">&quot;reserving bigger changes capacity not size&quot;</span> ) &#123; </span><br><span class=\"line\">        v.<span class=\"built_in\">reserve</span>( <span class=\"number\">10</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">size</span>() == <span class=\"number\">5</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">capacity</span>() &gt;= <span class=\"number\">10</span> );    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"built_in\">SECTION</span>( <span class=\"string\">&quot;reserving smaller does not change size&quot;</span> ) &#123;</span><br><span class=\"line\">        v.<span class=\"built_in\">reserve</span>( <span class=\"number\">0</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">size</span>() == <span class=\"number\">5</span> );        </span><br><span class=\"line\">        <span class=\"built_in\">REQUIRE</span>( v.<span class=\"built_in\">capacity</span>() &gt;= <span class=\"number\">5</span> );    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>Catch提供标签特性。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST_CASE</span>( <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;[widget]&quot;</span> ) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">TEST_CASE</span>( <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;[widget]&quot;</span> ) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">TEST_CASE</span>( <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;[gadget]&quot;</span> ) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">TEST_CASE</span>( <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;[widget][gadget]&quot;</span> ) &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>&quot;[widget]&quot;</code> 选取 A、B、D.</li>\n<li><code>&quot;[gadget]&quot;</code> 选取 C、D.</li>\n<li><code>&quot;[widget][gadget]&quot;</code> 只选取 D</li>\n<li><code>&quot;[widget],[gadget]&quot;</code> 所有A、B、C、D.</li>\n<li>还有一些特殊标签指定特殊行为</li>\n</ul>\n<h2 id=\"特点总结\"><a href=\"#特点总结\" class=\"headerlink\" title=\"特点总结\"></a>特点总结</h2><ul>\n<li>框架只有一个<code>catch.hpp</code>、集成轻松</li>\n<li>有Given-When-Then分区，适合BDD行为驱动开发</li>\n<li>无自带Mock框架</li>\n</ul>\n<h1 id=\"CppUTest\"><a href=\"#CppUTest\" class=\"headerlink\" title=\"CppUTest\"></a>CppUTest</h1><h2 id=\"main和test\"><a href=\"#main和test\" class=\"headerlink\" title=\"main和test\"></a>main和test</h2><p>main.cpp:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;CppUTest/CommandLineTestRunner.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> ac, <span class=\"type\">char</span>** av)</span></span>&#123;    </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> CommandLineTestRunner::<span class=\"built_in\">RunAllTests</span>(ac, av);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>test.cpp:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;CppUTest/TestHarness.h&quot;</span></span></span><br><span class=\"line\"><span class=\"built_in\">TEST_GROUP</span>(FirstTestGroup)&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span>&#123;      </span><br><span class=\"line\">        <span class=\"comment\">// Init stuff   </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">teardown</span><span class=\"params\">()</span></span>&#123;      </span><br><span class=\"line\">        <span class=\"comment\">// Uninit stuff   </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(FirstTestGroup, FirstTest)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">FAIL</span>(<span class=\"string\">&quot;Fail me!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(FirstTestGroup, SecondTest)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">STRCMP_EQUAL</span>(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"断言-1\"><a href=\"#断言-1\" class=\"headerlink\" title=\"断言\"></a>断言</h2><ul>\n<li><code>CHECK(boolean condition)</code>检查任何布尔结果。</li>\n<li><code>CHECK_TEXT(boolean condition, text)</code>检查任何布尔结果，并在失败时输出文本。</li>\n<li><code>CHECK_FALSE(condition)</code>检查任何布尔结果</li>\n<li><code>CHECK_EQUAL(expected, actual)</code>使用<code>==</code>检查实体之间的相等性。因此，如果有一个支持<code>operator==()</code>的类，则可以使用此宏比较两个实例。</li>\n<li><code>CHECK_COMPARE(first, relop, second)</code>检查在两个实体之间是否存在关系运算符。失败时，打印两个操作数求和的结果。</li>\n<li><code>CHECK_THROWS(expected_exception, expression)</code>检查表达式是否抛出<code>expected_exception</code>（例如<code>std::exception</code>）。<code>CHECK_THROWS</code>仅在使用标准C ++库（默认）构建CppUTest时可用。</li>\n<li><code>STRCMP_EQUAL(expected, actual)</code>使用<code>strcmp()</code>检查<code>const char *</code>字符串是否相等。</li>\n<li><code>STRNCMP_EQUAL(expected, actual, length)</code>使用<code>strncmp()</code>检查<code>const char *</code>字符串是否相等。</li>\n<li><code>STRCMP_NOCASE_EQUAL(expected, actual)</code>不考虑大小写，检查<code>const char *</code>字符串是否相等。</li>\n</ul>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>可以检测内存泄露</li>\n<li>输出更简洁</li>\n<li>使用在嵌入式系统项目中使用</li>\n</ul>\n<h1 id=\"Google-Mock\"><a href=\"#Google-Mock\" class=\"headerlink\" title=\"Google Mock\"></a>Google Mock</h1><p>Google Mock一般来说和Google Test搭配使用，但Google Test也可以和其他Mock框架一起使用。<br>本部分是Google Mock基础常用的用法，如需要特殊用法，请查阅Google Mock官方文档。</p>\n<h2 id=\"Fake、Mock、Stub\"><a href=\"#Fake、Mock、Stub\" class=\"headerlink\" title=\"Fake、Mock、Stub\"></a>Fake、Mock、Stub</h2><ul>\n<li>Fake对象<strong>有</strong>具体的实现，但采取一些捷径，比如用内存替代真实的数据库读取。</li>\n<li>Stub对象<strong>没有</strong>具体的实现，只是返回提前准备好的数据。</li>\n<li>Mock对象和Stub类似，只是在测试中需要调用时，针对某种输入指定期望的行为。Mock和Stub的区别是，<br>Mock除了返回数据还可以指定期望以验证行为。</li>\n</ul>\n<h2 id=\"简单例子：Mock-Turtle\"><a href=\"#简单例子：Mock-Turtle\" class=\"headerlink\" title=\"简单例子：Mock Turtle\"></a>简单例子：Mock Turtle</h2><p>Turtle类:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Turtle</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Turtle</span>() &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">PenUp</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">PenDown</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Forward</span><span class=\"params\">(<span class=\"type\">int</span> distance)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Turn</span><span class=\"params\">(<span class=\"type\">int</span> degrees)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">GoTo</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">GetX</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">GetY</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>MockTurtle类:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;gmock/gmock.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MockTurtle</span> : <span class=\"keyword\">public</span> Turtle &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">void</span>, PenUp, (), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">void</span>, PenDown, (), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">void</span>, Forward, (<span class=\"type\">int</span> distance), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">void</span>, Turn, (<span class=\"type\">int</span> degrees), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">void</span>, GoTo, (<span class=\"type\">int</span> x, <span class=\"type\">int</span> y), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">int</span>, GetX, (), (<span class=\"type\">const</span>, <span class=\"keyword\">override</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">int</span>, GetY, (), (<span class=\"type\">const</span>, <span class=\"keyword\">override</span>));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>创建Mock类的步骤：</p>\n<ol>\n<li><p><code>MockTurtle</code>继承<code>Turtle</code></p>\n</li>\n<li><p>找到<code>Turtle</code>的一个虚函数</p>\n</li>\n<li><p>在<code>public:</code>的部分中，写一个<code>MOCK_METHOD();</code></p>\n</li>\n<li><p>将虚函数函数签名复制进<code>MOCK_METHOD();</code>中，加两个逗号：一个在返回类型和函数名之间另一个在函数名和参数列表之间</p>\n<p>例如：<code>void PenDown()</code>有三部分：<code>void</code>、<code>PenDown</code>和<code>()</code>，这三部分就是<code>MOCK_METHOD</code>的前三个参数</p>\n</li>\n<li><p>如果要模拟<code>const</code>方法，添加一个包含<code>(const) </code>的第4个参数（必须带括号）。</p>\n</li>\n<li><p>建议添加<code>override</code>关键字。所以对于<code>const</code>方法，第四个参数变为<code>(const, override)</code>，对于非<code>const</code>方法，第四个参数变为<code>(override)</code>。这不是强制性的。</p>\n</li>\n<li><p>重复步骤直至完成要模拟的所有虚拟函数。</p>\n</li>\n</ol>\n<h2 id=\"在测试中使用Mock\"><a href=\"#在测试中使用Mock\" class=\"headerlink\" title=\"在测试中使用Mock\"></a>在测试中使用Mock</h2><p>在测试中使用Mock的步骤：</p>\n<ol>\n<li>从<code>testing</code>名称空间导入<code>gmock.h</code>的函数名（每个文件只需要执行一次）。</li>\n<li>创建一些Mock对象。</li>\n<li>指定对它们的期望（方法将被调用多少次？带有什么参数？每次应该做什么（对参数做什么、返回什么值）？等等）。</li>\n<li>使用Mock对象；可以使用googletest断言检查结果。如果mock函数的调用超出预期或参数错误，将会立即收到错误消息。</li>\n<li>当Mock对象被销毁时，gMock自动检查对模拟的所有期望是否得到满足。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;path/to/mock-turtle.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;gmock/gmock.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;gtest/gtest.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> ::testing::AtLeast;                         \t<span class=\"comment\">// #1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(PainterTest, CanDrawSomething) &#123;</span><br><span class=\"line\">\tMockTurtle turtle;                              <span class=\"comment\">// #2</span></span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">PenDown</span>())                  <span class=\"comment\">// #3</span></span><br><span class=\"line\">\t\t.<span class=\"built_in\">Times</span>(<span class=\"built_in\">AtLeast</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Painter <span class=\"title\">painter</span><span class=\"params\">(&amp;turtle)</span></span>;                       <span class=\"comment\">// #4</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_TRUE</span>(painter.<span class=\"built_in\">DrawCircle</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>));      <span class=\"comment\">// #5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们期望<code>turtle</code>的<code>PenDown()</code>至少被调用一次。如果在<code>turtle</code>对象被销毁时，<code>PenDown()</code>还没有被调用或者调用两次或以上，测试会失败。</p>\n<h2 id=\"指定期望\"><a href=\"#指定期望\" class=\"headerlink\" title=\"指定期望\"></a>指定期望</h2><p><code>EXPECT_CALL</code>（指定期望）是使用Google Mock的核心。<code>EXPECT_CALL</code>的作用是两方面的：</p>\n<ol>\n<li><p>告诉这个Mock（假）方法如何模仿原始方法：</p>\n<p>我们在<code>EXPECT_CALL</code>中告诉Google Mock，某个对象的某个方法被第一次调用时，会修改某个参数，会返回某个值；第二次调用时，会修改某个参数，会返回某个值…….</p>\n</li>\n<li><p>验证被调用的情况</p>\n<p>我们在<code>EXPECT_CALL</code>中告诉Google Mock，某个对象的某个方法总共会被调用N次（或大于N次、小于N次）。如果最终次数不符合预期，会导致测试失败。</p>\n</li>\n</ol>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(mock_object, <span class=\"built_in\">method</span>(matchers))</span><br><span class=\"line\">\t.<span class=\"built_in\">Times</span>(cardinality)</span><br><span class=\"line\">\t.<span class=\"built_in\">WillOnce</span>(action)</span><br><span class=\"line\">\t.<span class=\"built_in\">WillRepeatedly</span>(action);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>mock_object</code> 是对象</li>\n<li><code>method(matchers)</code> 用于匹配相应的函数调用</li>\n<li><code>cardinality</code> 指定基数（被调用次数情况）</li>\n<li><code>action</code> 指定被调用时的行为</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> ::testing::Return;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">GetX</span>())</span><br><span class=\"line\">\t.<span class=\"built_in\">Times</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\">\t.<span class=\"built_in\">WillOnce</span>(<span class=\"built_in\">Return</span>(<span class=\"number\">100</span>))</span><br><span class=\"line\">\t.<span class=\"built_in\">WillOnce</span>(<span class=\"built_in\">Return</span>(<span class=\"number\">150</span>))</span><br><span class=\"line\">\t.<span class=\"built_in\">WillRepeatedly</span>(<span class=\"built_in\">Return</span>(<span class=\"number\">200</span>));</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>EXPECT_CALL()</code>指定的期望是：在<code>turtle</code>这个Mock对象销毁之前，<code>turtle</code>的<code>getX()</code>函数会被调用五次。第一次返回<code>100</code>，第二次返回<code>150</code>，第三次及以后都返回<code>200</code>。指定期望后，5次对<code>getX</code>的调用会有这些行为。但如果最终调用次数不为5次，则测试失败。</p>\n<h3 id=\"参数匹配：哪次调用\"><a href=\"#参数匹配：哪次调用\" class=\"headerlink\" title=\"参数匹配：哪次调用\"></a>参数匹配：哪次调用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> ::testing::_;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ::testing::Ge;</span><br><span class=\"line\"><span class=\"comment\">// 只与Forward(100)匹配</span></span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">Forward</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\"><span class=\"comment\">// 与GoTo(x,y)匹配, 只要x&gt;=50</span></span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">GoTo</span>(<span class=\"built_in\">Ge</span>(<span class=\"number\">50</span>), _));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>_</code>相当于“任何”。</li>\n<li><code>100</code>相当于<code>Eq(100)</code>。</li>\n<li><code>Ge(50)</code>指参数大于或等于50。</li>\n<li>如果不关心参数，只写函数名就可以。比如<code>EXPECT_CALL(turtle, GoTo);</code>。</li>\n</ul>\n<h3 id=\"基数：被调用几次\"><a href=\"#基数：被调用几次\" class=\"headerlink\" title=\"基数：被调用几次\"></a>基数：被调用几次</h3><p>用<code>Times(m)</code>，<code>Times(AtLeast(n))</code>等来指定期待的调用次数。</p>\n<p><code>Times</code>可以被省略。比如整个<code>EXPECT_CALL</code>只有一个<code>WillOnce(action)</code>相当于也说明了调用次数只能为1。</p>\n<h3 id=\"行为：该做什么\"><a href=\"#行为：该做什么\" class=\"headerlink\" title=\"行为：该做什么\"></a>行为：该做什么</h3><p>常用模式：如果需要指定前几次调用的特殊情况，并且之后的调用情况相同。使用一系列<code>WillOnce()</code>之后有<code>WillRepeatedly()</code></p>\n<p>除了用来指定调用返回值的<code>Return()</code>，Google Mock中常用行为中还有：<code>SetArgPointee&lt;N&gt;(value)</code>，<br><code>SetArgPointee</code>将第<code>N</code>个指针参数（从0开始）指向的变量赋值为<code>value</code>。</p>\n<p>比如<code>void getObject(Object* response)&#123;...&#125;</code>的<code>EXPECT_CALL</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object* a = new Object;</span><br><span class=\"line\">EXPECT_CALL(object, request)</span><br><span class=\"line\">\t.WillOnce(SetArgPointee&lt;1&gt;(*a));</span><br></pre></td></tr></table></figure>\n<p>就修改了传入的指针<code>response</code>，使其指向了一个我们新创建的对象。</p>\n<p>如果有多个行为，应该使用<code>DoAll(a1, a2, ..., an)</code>。<code>DoAll</code>执行所有<code>n</code>个action并返回<code>an</code>的结果。</p>\n<h3 id=\"使用多个预期\"><a href=\"#使用多个预期\" class=\"headerlink\" title=\"使用多个预期\"></a>使用多个预期</h3><p>例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> ::testing::_;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">Forward</span>(_))\t\t<span class=\"comment\">// #1</span></span><br><span class=\"line\">\t.<span class=\"built_in\">Times</span>(<span class=\"number\">3</span>);  \t</span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">Forward</span>(<span class=\"number\">10</span>))  \t<span class=\"comment\">// #2</span></span><br><span class=\"line\">\t.<span class=\"built_in\">Times</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">...mock对象函数被调用...</span><br><span class=\"line\">\t<span class=\"comment\">//Forward(10);\t\t\t\t\t\t// 与#2匹配</span></span><br><span class=\"line\">\t<span class=\"comment\">//Forward(20);\t\t\t\t\t\t// 与#1匹配</span></span><br></pre></td></tr></table></figure>\n\n<p>正常情况下，Google Mock以倒序搜索预期：如果和多个<code>EXPECT_CALL</code>都可以匹配，只有之前的，<br>距离调用最近的一个<code>EXPECT_CALL()</code>会被匹配。例如：</p>\n<ul>\n<li>连续三次调用<code>Forward(10)</code>会生错误因为它和#2匹配。</li>\n<li>连续三次调用<code>Forward(20)</code>不会有错误因为它和#1匹配。</li>\n</ul>\n<p>一旦匹配，该预期会被一直绑定，即使执行次数达到上限之后，还是是生效的，这就是为什么三次调用<br><code>Forward(10)</code>超过了2号<code>EXPECT_CALL</code>的上限时，不会去试图绑定1号<code>EXPECT_CALL</code>而是报错的原因。</p>\n<p>为了明确地让某一个<code>EXPECT_CALL</code>“退休”，可以加上<code>RetiresOnSaturation()</code>，例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> ::testing::Return;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">GetX</span>())\t\t<span class=\"comment\">// #1</span></span><br><span class=\"line\">\t.<span class=\"built_in\">WillOnce</span>(<span class=\"built_in\">Return</span>(<span class=\"number\">10</span>))</span><br><span class=\"line\">\t.<span class=\"built_in\">RetiresOnSaturation</span>();</span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(turtle, <span class=\"built_in\">GetX</span>())\t\t<span class=\"comment\">// #2</span></span><br><span class=\"line\">\t.<span class=\"built_in\">WillOnce</span>(<span class=\"built_in\">Return</span>(<span class=\"number\">20</span>))</span><br><span class=\"line\">\t.<span class=\"built_in\">RetiresOnSaturation</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">turtle.<span class=\"built_in\">GetX</span>()\t\t\t\t\t<span class=\"comment\">// 与#2匹配，返回20，然后#2“退休”</span></span><br><span class=\"line\">turtle.<span class=\"built_in\">GetX</span>()\t\t\t\t\t<span class=\"comment\">// 与#1匹配，返回10</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，第一次<code>GetX()</code>调用和#2匹配，返回<code>20</code>，然后这个<code>EXPECT_CALL</code>就“退休”了；<br>第二次<code>GetX()</code>调用和#1匹配，返回<code>10</code></p>\n<h3 id=\"Sequence\"><a href=\"#Sequence\" class=\"headerlink\" title=\"Sequence\"></a>Sequence</h3><p>可以用sequence来指定期望匹配的顺序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> ::testing::Return;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ::testing::Sequence;</span><br><span class=\"line\">Sequence s1, s2;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(foo, <span class=\"built_in\">Reset</span>())</span><br><span class=\"line\">    .<span class=\"built_in\">InSequence</span>(s1, s2)</span><br><span class=\"line\">    .<span class=\"built_in\">WillOnce</span>(<span class=\"built_in\">Return</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(foo, <span class=\"built_in\">GetSize</span>())</span><br><span class=\"line\">    .<span class=\"built_in\">InSequence</span>(s1)</span><br><span class=\"line\">    .<span class=\"built_in\">WillOnce</span>(<span class=\"built_in\">Return</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"built_in\">EXPECT_CALL</span>(foo, <span class=\"built_in\">Describe</span>(<span class=\"built_in\">A</span>&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;()))</span><br><span class=\"line\">    .<span class=\"built_in\">InSequence</span>(s2)</span><br><span class=\"line\">    .<span class=\"built_in\">WillOnce</span>(<span class=\"built_in\">Return</span>(<span class=\"string\">&quot;dummy&quot;</span>));</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.yuleweici.com/CPP-%E5%8D%95%E6%B5%8B/img.png\" alt=\"sequence\"></p>\n<p>在上面的例子中，创建了两个Sequence <code>s1</code>和<code>s2</code>，属于<code>s1</code>的有<code>Reset()</code>和<code>GetSize()</code>，<br>所以<code>Reset()</code>必须在<code>GetSize()</code>之前执行。属于<code>s2</code>的有<code>Reset()</code>和<code>Describe(A&lt;const char*&gt;())</code>，<br>所以<code>Reset()</code>必须在<code>Describe(A&lt;const char*&gt;())</code>之前执行。所以，<code>Reset()</code>必须在<code>GetSize()</code><br>和<code>Describe()</code>之前执行。而<code>GetSize()</code>和<code>Describe()</code>这两者之间没有顺序约束。</p>\n<p>如果需要指定很多期望的顺序，有另一种用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> ::testing::InSequence;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  InSequence seq;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">EXPECT_CALL</span>(...)...;</span><br><span class=\"line\">  <span class=\"built_in\">EXPECT_CALL</span>(...)...;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"built_in\">EXPECT_CALL</span>(...)...;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这种用法中，scope中（大括号中）的期望必须遵守严格的顺序。</p>\n<h2 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h2><ul>\n<li><a href=\"https://github.com/google/googletest/blob/master/googlemock/docs/cheat_sheet.md\">Google Mock Cheat Sheet</a></li>\n<li><a href=\"https://github.com/google/googletest/blob/master/googlemock/docs/cook_book.md\">Google Mock Cook Book</a></li>\n</ul>\n<h1 id=\"情景示例\"><a href=\"#情景示例\" class=\"headerlink\" title=\"情景示例\"></a>情景示例</h1><p>在这部分，我们用一个示例项目来演示，如何在不同情景中使用<br>Google Test和Google Mock写单元测试用例。</p>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>示例项目是一个C++命令行聊天室软件，包含服务器和客户端。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── client_main.cpp</span><br><span class=\"line\">├── server_main.cpp</span><br><span class=\"line\">├── include</span><br><span class=\"line\">│   ├── chat_client.hpp</span><br><span class=\"line\">│   ├── chat_message.hpp</span><br><span class=\"line\">│   ├── chat_participant.hpp</span><br><span class=\"line\">│   ├── chat_room.hpp</span><br><span class=\"line\">│   ├── chat_server.hpp</span><br><span class=\"line\">│   ├── chat_session.hpp</span><br><span class=\"line\">│   ├── http_request.hpp</span><br><span class=\"line\">│   ├── http_request_impl.hpp</span><br><span class=\"line\">│   ├── message_dao.hpp</span><br><span class=\"line\">│   └── message_dao_impl.hpp</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── chat_client.cpp</span><br><span class=\"line\">│   ├── chat_message.cpp</span><br><span class=\"line\">│   ├── chat_room.cpp</span><br><span class=\"line\">│   ├── chat_server.cpp</span><br><span class=\"line\">│   ├── chat_session.cpp</span><br><span class=\"line\">│   ├── http_request_impl.cpp</span><br><span class=\"line\">│   └── message_dao_impl.cpp</span><br><span class=\"line\">└── tests</span><br><span class=\"line\">    ├── chat_message_unittest.cpp</span><br><span class=\"line\">    └── chat_room_unittest.cpp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"普通测试\"><a href=\"#普通测试\" class=\"headerlink\" title=\"普通测试\"></a>普通测试</h2><p>如果被测试的函数不包含外部依赖，用Google Test基础的用法就可以完成用例编写。</p>\n<p>原函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">chat_message::body_length</span><span class=\"params\">(std::<span class=\"type\">size_t</span> new_length)</span> </span>&#123;</span><br><span class=\"line\">    body_length_ = new_length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (body_length_ &gt; <span class=\"number\">512</span>)</span><br><span class=\"line\">        body_length_ = <span class=\"number\">512</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数很简单。就是给<code>body_length_</code>赋值但是有最大值限制。测试用例可以这样写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST</span>(ChatMessageTest, BodyLengthNegative) &#123;</span><br><span class=\"line\">    chat_message c;</span><br><span class=\"line\">    c.<span class=\"built_in\">body_length</span>(<span class=\"number\">-50</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(<span class=\"number\">512</span>, c.<span class=\"built_in\">body_length</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(ChatMessageTest, BodyLength0) &#123;</span><br><span class=\"line\">    chat_message c;</span><br><span class=\"line\">    c.<span class=\"built_in\">body_length</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(<span class=\"number\">0</span>, c.<span class=\"built_in\">body_length</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(ChatMessageTest, BodyLength100) &#123;</span><br><span class=\"line\">    chat_message c;</span><br><span class=\"line\">    c.<span class=\"built_in\">body_length</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(<span class=\"number\">100</span>, c.<span class=\"built_in\">body_length</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(ChatMessageTest, BodyLength512) &#123;</span><br><span class=\"line\">    chat_message c;</span><br><span class=\"line\">    c.<span class=\"built_in\">body_length</span>(<span class=\"number\">512</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(<span class=\"number\">512</span>, c.<span class=\"built_in\">body_length</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(ChatMessageTest, BodyLength513) &#123;</span><br><span class=\"line\">    chat_message c;</span><br><span class=\"line\">    c.<span class=\"built_in\">body_length</span>(<span class=\"number\">513</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(<span class=\"number\">512</span>, c.<span class=\"built_in\">body_length</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，对于这类函数，用例编写很直接简单，步骤都是构造变量，再用合适的Google Test的<br>宏来验证变量值或者函数调用返回值。</p>\n<h2 id=\"简单-Mock\"><a href=\"#简单-Mock\" class=\"headerlink\" title=\"简单 Mock\"></a>简单 Mock</h2><p>原函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void chat_room::leave(chat_participant_ptr participant) &#123;</span><br><span class=\"line\">    participants_.erase(participant);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>participants_ </code> 的类型是 <code>std::set&lt;chat_participant_ptr&gt;</code>。这个函数的目的很明显，将一个<code>participant</code>从<code>set</code>中移除。</p>\n<p>真实地创建一个聊天参与者<code>participant</code>对象可以条件比较苛刻或者成本比较高。为了有效率地验证这个函数，我们可以新建一些Mock的<code>chat_participant_ptr</code>而不用严格地去创建真实的<code>participant</code>对象。</p>\n<p><code>chat_participant</code>对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class chat_participant &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual ~chat_participant() &#123;&#125;</span><br><span class=\"line\">    virtual void deliver(const chat_message &amp;msg) = 0;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Mock对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class mock_chat_participant : public chat_participant &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    MOCK_METHOD(void, deliver, (const chat_message &amp;msg), (override));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试用例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEST(ChatRoomTest, leave) &#123;</span><br><span class=\"line\">    auto p1 = std::make_shared&lt;mock_chat_participant&gt;();\t//新建第一个Mock指针</span><br><span class=\"line\">    auto p2 = std::make_shared&lt;mock_chat_participant&gt;();\t//新建第二个Mock指针</span><br><span class=\"line\">    auto p3 = std::make_shared&lt;mock_chat_participant&gt;();\t//新建第三个Mock指针</span><br><span class=\"line\">    auto p4 = std::make_shared&lt;mock_chat_participant&gt;();\t//新建第四个Mock指针</span><br><span class=\"line\">    chat_room cr;\t\t\t\t\t\t\t\t\t\t\t//新建待测试对象chat_room</span><br><span class=\"line\">    cr.join(p1);</span><br><span class=\"line\">    cr.join(p2);</span><br><span class=\"line\">    cr.join(p3);</span><br><span class=\"line\">    cr.join(p4);</span><br><span class=\"line\">    EXPECT_EQ(cr.participants().size(), 4);</span><br><span class=\"line\">    cr.leave(p4);</span><br><span class=\"line\">    EXPECT_EQ(cr.participants().size(), 3);</span><br><span class=\"line\">    cr.leave(p4);</span><br><span class=\"line\">    EXPECT_EQ(cr.participants().size(), 3);</span><br><span class=\"line\">    cr.leave(p2);</span><br><span class=\"line\">    EXPECT_EQ(cr.participants().size(), 2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Web请求\"><a href=\"#Web请求\" class=\"headerlink\" title=\"Web请求\"></a>Web请求</h2><p><code>chat_room</code>中有一个<code>log()</code>，依赖网络请求。原函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">chat_room::log</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::string* response;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;requester-&gt;<span class=\"built_in\">execute</span>(<span class=\"string\">&quot;request&quot;</span>,response);\t\t<span class=\"comment\">// web访问，结果存在response指针中</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在单元测试中，我们只关心被测试部分的逻辑。为了测试这个函数，我们不应该创建真实的<code>requester</code>，应该使用mock。</p>\n<p><code>http_request</code>对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">http_request</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">http_request</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">execute</span><span class=\"params\">(std::string request, std::string* response)</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Mock对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">mock_http_request</span> : <span class=\"keyword\">public</span> http_request &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">bool</span>, execute, (std::string request, std::string * response), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试用例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST</span>(ChatRoomTest, log) &#123;</span><br><span class=\"line\">    testing::NiceMock&lt;mock_message_dao&gt; mock_dao;\t<span class=\"comment\">//在下一部分会提到mock_message_dao</span></span><br><span class=\"line\">    mock_http_request mock_requester;\t\t\t\t<span class=\"comment\">//Mock对象</span></span><br><span class=\"line\">    std::string response = <span class=\"string\">&quot;response&quot;</span>;\t\t\t\t<span class=\"comment\">//期待调用函数的第二个参数将指向这个string对象</span></span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_CALL</span>(mock_requester, execute)</span><br><span class=\"line\">    \t.<span class=\"built_in\">WillRepeatedly</span>(\t\t\t\t\t\t\t<span class=\"comment\">//每次调用都会（WillRepeatedly）执行</span></span><br><span class=\"line\">    \t\ttesting::<span class=\"built_in\">DoAll</span>(\t\t\t\t\t\t\t<span class=\"comment\">//每次执行包含多个行为</span></span><br><span class=\"line\">    \t\t\ttesting::<span class=\"built_in\">SetArgPointee</span>&lt;<span class=\"number\">1</span>&gt;(response),<span class=\"comment\">//将传入参数指针变量response指向response</span></span><br><span class=\"line\">    \t\t\ttesting::<span class=\"built_in\">Return</span>(<span class=\"literal\">true</span>)));\t\t\t<span class=\"comment\">//返回值为true</span></span><br><span class=\"line\">    chat_room cr </span><br><span class=\"line\">    \t= <span class=\"built_in\">chat_room</span>(&amp;mock_dao, &amp;mock_requester);\t<span class=\"comment\">//将mock对象通过chat_room的constructor注入</span></span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(cr.<span class=\"built_in\">log</span>(),<span class=\"string\">&quot;response&quot;</span>);\t\t\t\t\t<span class=\"comment\">//调用和Google Test断言</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库访问\"><a href=\"#数据库访问\" class=\"headerlink\" title=\"数据库访问\"></a>数据库访问</h2><p><code>chat_room</code>对象会将聊天者发送的消息存储在redis数据库中。当新用户加入时，<code>chat_room</code>对象从数据库<br>获取所有历史消息发送给该新用户。</p>\n<p><code>join()</code>函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">chat_room::join</span><span class=\"params\">(chat_participant_ptr participant)</span> </span>&#123;</span><br><span class=\"line\">    participants_.<span class=\"built_in\">insert</span>(participant);</span><br><span class=\"line\">    std::vector&lt;std::string&gt; recent_msg_strs = </span><br><span class=\"line\">    \t<span class=\"keyword\">this</span>-&gt;dao-&gt;<span class=\"built_in\">get_messages</span>(); \t\t\t<span class=\"comment\">//从数据库中获取历史消息</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (std::string recent_msg_str: recent_msg_strs) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t    <span class=\"comment\">//将每一个消息发送给该聊天参与者\t</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> msg = <span class=\"built_in\">chat_message</span>();</span><br><span class=\"line\">        msg.<span class=\"built_in\">set_body_string</span>(recent_msg_str);</span><br><span class=\"line\">        participant-&gt;<span class=\"built_in\">deliver</span>(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>message_dao</code>对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">message_dao</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">message_dao</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">add_message</span><span class=\"params\">(std::string m)</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> std::vector&lt;std::string&gt; <span class=\"title\">get_messages</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Mock对象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">mock_message_dao</span> : <span class=\"keyword\">public</span> message_dao &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MOCK_METHOD</span>(<span class=\"type\">bool</span>, add_message, (std::string m), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">    <span class=\"built_in\">MOCK_METHOD</span>(std::vector&lt;std::string&gt;, get_messages, (), (<span class=\"keyword\">override</span>));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试用例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST</span>(ChatRoomTest, join) &#123;</span><br><span class=\"line\">    mock_message_dao mock_dao;\t\t\t\t<span class=\"comment\">//创建mock对象（需要注入chat_room）</span></span><br><span class=\"line\">    http_request_impl requester;\t\t\t<span class=\"comment\">//创建web访问对象（也需要注入chat_room）</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mock_p1 = std::<span class=\"built_in\">make_shared</span>&lt;mock_chat_participant&gt;();</span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//创建participant的mock指针</span></span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_CALL</span>(mock_dao, get_messages)</span><br><span class=\"line\">    \t.<span class=\"built_in\">WillOnce</span>(testing::<span class=\"built_in\">Return</span>(std::vector&lt;std::string&gt;&#123;<span class=\"string\">&quot;test_msg_body_1&quot;</span>, <span class=\"string\">&quot;test_msg_body_2&quot;</span>, <span class=\"string\">&quot;test_msg_body_3&quot;</span>&#125;));</span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//指定get_messages调用的返回值</span></span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_CALL</span>(*mock_p1, deliver).<span class=\"built_in\">Times</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//指定deliver调用的次数</span></span><br><span class=\"line\">    chat_room cr = <span class=\"built_in\">chat_room</span>(&amp;mock_dao, &amp;requester);</span><br><span class=\"line\">    \t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//创建chat_room对象，注入dao和requester</span></span><br><span class=\"line\">    cr.<span class=\"built_in\">join</span>(mock_p1);\t\t\t\t\t\t<span class=\"comment\">//调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先创建mock对象，再指定函数调用的预期，最后指向被测试函数。我们可以看到，<code>mock_dao</code>指定了<code>get_messages</code>的<br>返回值时一个长度为3的vector，所以有3条消息会被deliver。</p>\n<h1 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h1><h2 id=\"单元测试源文件应该放在项目的什么位置？\"><a href=\"#单元测试源文件应该放在项目的什么位置？\" class=\"headerlink\" title=\"单元测试源文件应该放在项目的什么位置？\"></a>单元测试源文件应该放在项目的什么位置？</h2><p>一般来说，我们会在根目录创建一个<code>tests</code>文件夹，里面放单元测试部分的源代码，从而不会和被测试代码混在一起。</p>\n<p>如果需要和其他测试（如接口测试、压力测试）等区分开来，可以</p>\n<ol>\n<li>把<code>tests</code>改成<code>unittests</code>、<code>utests</code>等，或者</li>\n<li>在<code>tests</code>创建不同子文件夹存放不同类型的测试代码。</li>\n</ol>\n<h2 id=\"Google-Mock只能Mock虚函数，如果我想Mock非虚函数怎么办？\"><a href=\"#Google-Mock只能Mock虚函数，如果我想Mock非虚函数怎么办？\" class=\"headerlink\" title=\"Google Mock只能Mock虚函数，如果我想Mock非虚函数怎么办？\"></a>Google Mock只能Mock虚函数，如果我想Mock非虚函数怎么办？</h2><p>由于Google Mock（及其他大部分Mock框架）通过继承来动态重载机制的限制，一般来说Google Mock只能Mock虚函数。如果要mock非虚函数，官方文档提供这几种思路：</p>\n<ol>\n<li>Mock类和原类没有继承关系，在测试对象使用函数模板。在测试中，测试对象接受Mock类。</li>\n<li>创建一个接口（抽象类），原类继承自这个接口（抽象类）。在测试中Mock这个接口（抽象类）。</li>\n</ol>\n<p>这两种方法，都需要对代码进行一定的修改或重构。如果不想修改被测试代码。可以考虑使用hook技术替换被mock的部分从而mock一般函数。</p>\n<p>使用<code>TMock</code>对非虚函数mock的例子：</p>\n<p>mock函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&quot;tmock.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MockClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//注册mock类</span></span><br><span class=\"line\">    <span class=\"built_in\">TMOCK_CLASS</span>(MockClass);</span><br><span class=\"line\">    <span class=\"comment\">//声明mock类函数，TMOCK_METHOD&#123;n&#125;第一个参数与attach_func_lib第一个参数相同，其余参考与MOCK_METHOD&#123;n&#125;一致。</span></span><br><span class=\"line\">    <span class=\"built_in\">TMOCK_METHOD1</span>(<span class=\"string\">&quot;original&quot;</span>, original, <span class=\"built_in\">uint32_t</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> * str_file_md5) )</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>单测中应用<code>tmock</code>的方法和Google Mock基本一致。但在结束的时候需要使用<code>TMOCK_CLEAR</code>清除exception，<br>detach hook的函数，防止干扰其他单元测试。</p>\n<h2 id=\"Google-Test官方文档中说测测试套件名称、测试夹具名称、测试名称中不应该出现下划线-。为什么？\"><a href=\"#Google-Test官方文档中说测测试套件名称、测试夹具名称、测试名称中不应该出现下划线-。为什么？\" class=\"headerlink\" title=\"Google Test官方文档中说测测试套件名称、测试夹具名称、测试名称中不应该出现下划线_。为什么？\"></a>Google Test官方文档中说测测试套件名称、测试夹具名称、测试名称中不应该出现下划线<code>_</code>。为什么？</h2><p><code>TEST(TestSuiteName, TestName)</code>生成名为<code>TestSuiteName_TestName_Test</code>的类。</p>\n<p>下划线<code>_</code>是特殊的，因为C ++保留以下内容供编译器和标准库使用。所以开头和结尾有下划线很容易让生成的类的标识符不合法。</p>\n<p>另一方面，下划线可能让不同测试生成相同的类。比如<code>TEST（Time，Flies_Like_An_Arrow）&#123;...&#125; </code>和<code>TEST（Time_Flies，Like_An_Arrow）&#123;...&#125; </code>都生成名为<code>Time_Flies_Like_An_Arrow_Test</code>的类。</p>\n<h2 id=\"测试输出里有很多Uninteresting-mock-function-call警告怎么办？\"><a href=\"#测试输出里有很多Uninteresting-mock-function-call警告怎么办？\" class=\"headerlink\" title=\"测试输出里有很多Uninteresting mock function call警告怎么办？\"></a>测试输出里有很多<code>Uninteresting mock function call</code>警告怎么办？</h2><p>创建的Mock的对象的某些调用如果没有相应匹配的<code>EXPECT_CALL</code>，Google Mock会生成这个警告。</p>\n<p>为了去除这个警告，可以使用<code>NiceMock</code>。比如如果原本使用<code>MockFoo nice_foo;</code>新建mock对象的话，可以改成<code>NiceMock&lt;MockFoo&gt; nice_foo;</code>。<code>NiceMock&lt;MockFoo&gt;</code>是<code>MockFoo</code>的子类。</p>\n<h1 id=\"单测覆盖率\"><a href=\"#单测覆盖率\" class=\"headerlink\" title=\"单测覆盖率\"></a>单测覆盖率</h1><p>使用 Gcov 和 LCOV 度量 C&#x2F;C++ 项目的代码覆盖率</p>\n<h2 id=\"什么是代码覆盖率？\"><a href=\"#什么是代码覆盖率？\" class=\"headerlink\" title=\"什么是代码覆盖率？\"></a>什么是代码覆盖率？</h2><p>代码覆盖率是对整个测试过程中被执行的代码的衡量，它能测量源代码中的哪些语句在测试中被执行，哪些语句尚未被执行。</p>\n<h2 id=\"为什么要测量代码覆盖率？\"><a href=\"#为什么要测量代码覆盖率？\" class=\"headerlink\" title=\"为什么要测量代码覆盖率？\"></a>为什么要测量代码覆盖率？</h2><p>众所周知，测试可以提高软件版本的质量和可预测性。但是，你知道你的单元测试甚至是你的功能测试实际测试代码的效果如何吗？是否还需要更多的测试？</p>\n<p>这些是代码覆盖率可以试图回答的问题。总之，出于以下原因我们需要测量代码覆盖率：</p>\n<ul>\n<li>了解我们的测试用例对源代码的测试效果 </li>\n<li>了解我们是否进行了足够的测试 </li>\n<li>在软件的整个生命周期内保持测试质量<br>注：代码覆盖率不是灵丹妙药，覆盖率测量不能替代良好的代码审查和优秀的编程实践。</li>\n</ul>\n<p>通常，我们应该采用合理的覆盖目标，力求在代码覆盖率在所有模块中实现均匀覆盖，而不是只看最终数字的是否高到令人满意。</p>\n<p>举例：假设代码覆盖率只在某一些模块代码覆盖率很高，但在一些关键模块并没有足够的测试用例覆盖，那样虽然代码覆盖率很高，但并不能说明产品质量就很高。</p>\n<h2 id=\"代码覆盖率的指标种类\"><a href=\"#代码覆盖率的指标种类\" class=\"headerlink\" title=\"代码覆盖率的指标种类\"></a>代码覆盖率的指标种类</h2><p>代码覆盖率工具通常使用一个或多个标准来确定你的代码在被自动化测试后是否得到了执行，常见的覆盖率报告中看到的指标包括：</p>\n<ul>\n<li>函数覆盖率：定义的函数中有多少被调用 </li>\n<li>语句覆盖率：程序中的语句有多少被执行 </li>\n<li>分支覆盖率：有多少控制结构的分支（例如if语句）被执行 </li>\n<li>条件覆盖率：有多少布尔子表达式被测试为真值和假值 </li>\n<li>行覆盖率：有多少行的源代码被测试过</li>\n</ul>\n<h2 id=\"代码覆盖率是如何工作的？\"><a href=\"#代码覆盖率是如何工作的？\" class=\"headerlink\" title=\"代码覆盖率是如何工作的？\"></a>代码覆盖率是如何工作的？</h2><p>代码覆盖率测量主要有以下三种方式：</p>\n<ol>\n<li><p>Source code instrumentation - 源代码检测<br>将检测语句添加到源代码中，并使用正常的编译工具链编译代码以生成检测的程序集。这是我们常说的插桩，Gcov 是属于这一类的代码覆盖率工具。</p>\n</li>\n<li><p>Runtime instrumentation - 运行时收集<br>这种方法在代码执行时从运行时环境收集信息以确定覆盖率信息。以我的理解 JaCoCo 和 Coverage 这两个工具的原理属于这一类别。</p>\n</li>\n<li><p>Intermediate code instrumentation - 中间代码检测</p>\n</li>\n</ol>\n<p>通过添加新的字节码来检测编译后的类文件，并生成一个新的检测类。说实话，我 Google 了很多文章并找到确定的说明哪个工具是属于这一类的。</p>\n<p>了解这些工具的基本原理，结合现有的测试用例，有助于正确的选择代码覆盖率工具。比如：</p>\n<ul>\n<li>产品的源代码只有 E2E（端到端）测试用例，通常只能选择第一类工具，即通过插桩编译出的可执行文件，然后进行测试和结果收集。</li>\n<li>产品的源代码有单元测试用例，通常选择第二类工具，即运行时收集。这类工具的执行效率高，易于做持续集成。</li>\n</ul>\n<h2 id=\"当前主流代码覆盖率工具\"><a href=\"#当前主流代码覆盖率工具\" class=\"headerlink\" title=\"当前主流代码覆盖率工具\"></a>当前主流代码覆盖率工具</h2><p>代码覆盖率的工具有很多，以下是我用过的不同编程语言的代码覆盖率工具。在选择工具时，力求去选择那些开源、流行（活跃）、好用的工具。</p>\n<table>\n<thead>\n<tr>\n<th>编程语言</th>\n<th>代码覆盖率工具</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C&#x2F;C++</td>\n<td>Gcov</td>\n</tr>\n<tr>\n<td>Java</td>\n<td>JaCoCo</td>\n</tr>\n<tr>\n<td>JavaScript</td>\n<td>Istanbul</td>\n</tr>\n<tr>\n<td>Python</td>\n<td>Coverage.py</td>\n</tr>\n<tr>\n<td>Golang</td>\n<td>cover</td>\n</tr>\n</tbody></table>\n<h2 id=\"最后，不要高估代码覆盖率指标\"><a href=\"#最后，不要高估代码覆盖率指标\" class=\"headerlink\" title=\"最后，不要高估代码覆盖率指标\"></a>最后，不要高估代码覆盖率指标</h2><p>代码覆盖率不是灵丹妙药，它只是告诉我们有哪些代码没有被测试用例“执行到”而已，高百分比的代码覆盖率不等于高质量的有效测试。</p>\n<ul>\n<li>首先，高代码覆盖率不足以衡量有效测试。相反，代码覆盖率更准确地给出了代码未被测试程度的度量。这意味着，如果我们的代码覆盖率指标较低，那么我们可以确定代码的重要部分没有经过测试，然而反过来不一定正确。具有高代码覆盖率并不能充分表明我们的代码已经过充分测试。 </li>\n<li>其次，100% 的代码覆盖率不应该是我们明确努力的目标之一。这是因为在实现 100% 的代码覆盖率与实际测试重要的代码之间总是需要权衡。虽然可以测试所有代码，但考虑到为了满足覆盖率要求而编写更多无意义测试的趋势，当你接近此限制时，测试的价值也很可能会减少。<br>借 Martin Fowler 在这篇测试覆盖率的文章说的一句话：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码覆盖率是查找代码库中未测试部分的有用工具,然而它作为一个数字说明你的测试有多好用处不大。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"C-覆盖率\"><a href=\"#C-覆盖率\" class=\"headerlink\" title=\"C++覆盖率\"></a>C++覆盖率</h2><p>介绍如何使用 Gcov 和 LCOV 对 C&#x2F;C++ 项目进行代码覆盖率的度量。</p>\n<p>对于想使用 Gcov 的人，为了说明它是如何工作的，准备了一段示例程序，运行这个程序之前需要先安装 GCC 和 LCOV。</p>\n<p>如果没有环境或不想安装，可以直接查看示例仓库的 GitHub 仓库：<a href=\"https://github.com/vwin/gcov-example\">Gcov示例</a></p>\n<p>注：主分支 master 下面放的是源码，分支 coverage 下的 out 目录是最终的结果报告。</p>\n<p>这是我的测试环境上的 GCC 和 lcov 的版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh-4.2$ gcc --version</span><br><span class=\"line\">Apple clang version 13.1.6 (clang-1316.0.21.2.5)</span><br><span class=\"line\">Target: x86_64-apple-darwin22.1.0</span><br><span class=\"line\">Thread model: posix</span><br><span class=\"line\">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</span><br><span class=\"line\"></span><br><span class=\"line\">sh-4.2$ lcov -v</span><br><span class=\"line\">lcov: LCOV version 1.16</span><br></pre></td></tr></table></figure>\n<h3 id=\"Gcov-是如何工作的\"><a href=\"#Gcov-是如何工作的\" class=\"headerlink\" title=\"Gcov 是如何工作的\"></a>Gcov 是如何工作的</h3><p>Gcov 工作流程图<br><img src=\"http://cdn.yuleweici.com/CPP-%E5%8D%95%E6%B5%8B/img_2.png\" alt=\"gcov流程\"></p>\n<p>主要分三步：</p>\n<ol>\n<li>在 GCC 编译的时加入特殊的编译选项，生成可执行文件，和 *.gcno； </li>\n<li>运行（测试）生成的可执行文件，生成了 *.gcda 数据文件； </li>\n<li>有了 *.gcno 和 *.gcda，通过源码生成 gcov 文件，最后生成代码覆盖率报告。</li>\n</ol>\n<p>下面就开始介绍其中每一步具体是怎么做的。</p>\n<h4 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h4><p>第一步编译，这里已经将编译用到的参数和文件都写在了 makefile 里了，只要执行 make 就可以编译了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<p>make 命令的输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror main.c</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror foo.c</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -o main main.o foo.o</span><br></pre></td></tr></table></figure>\n<p>通过输出可以看到，这个程序在编译的时候添加了两个编译选项 -fprofile-arcs and -ftest-coverage。在编译成功后，不仅生成了 main and .o 文件，同时还生成了两个 .gcno 文件.</p>\n<p>.gcno 记录文件是在加入 GCC 编译选项 -ftest-coverage 后生成的，在编译过程中它包含用于重建基本块图和为块分配源行号的信息。</p>\n<p>如果使用的是cmake，则在CMakeLists.txt中加入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;)</span><br><span class=\"line\">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行可执行文件\"><a href=\"#运行可执行文件\" class=\"headerlink\" title=\"运行可执行文件\"></a>运行可执行文件</h4><p>在编译完成后，生成了 main 这个可执行文件，运行（测试）它：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./main</span><br></pre></td></tr></table></figure>\n<p>运行 main 时输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sh-4.2$ ./main</span><br><span class=\"line\">Start calling foo() ...</span><br><span class=\"line\">when num is equal to 1...</span><br><span class=\"line\">when num is equal to 2...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当运行 main 后，执行结果被记录在了 .gcda 这个数据文件里，查看当前目录下可以看到一共有生成了两个 .gcda 文件，每个源文件都对应一个 .gcda 文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span></span></span><br><span class=\"line\">foo.c  foo.gcda  foo.gcno  foo.h  foo.o  img  main  main.c  main.gcda  main.gcno  main.o  makefile  README.md</span><br><span class=\"line\">.gcda 记录数据文件的生成是因为程序在编译的时候引入了 -fprofile-arcs 选项。它包含弧过渡计数、值分布计数和一些摘要信息。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成报告\"><a href=\"#生成报告\" class=\"headerlink\" title=\"生成报告\"></a>生成报告</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make report</span><br></pre></td></tr></table></figure>\n\n<p>生成报告的输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make report</span><br><span class=\"line\">gcov main.c foo.c</span><br><span class=\"line\">File &#x27;main.c&#x27;</span><br><span class=\"line\">Lines executed:100.00% of 5</span><br><span class=\"line\">Creating &#x27;main.c.gcov&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">File &#x27;foo.c&#x27;</span><br><span class=\"line\">Lines executed:85.71% of 7</span><br><span class=\"line\">Creating &#x27;foo.c.gcov&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">Lines executed:91.67% of 12</span><br><span class=\"line\">lcov --capture --directory . --output-file coverage.info</span><br><span class=\"line\">Capturing coverage data from .</span><br><span class=\"line\">Found gcov version: 4.8.5</span><br><span class=\"line\">Scanning . for .gcda files ...</span><br><span class=\"line\">Found 2 data files in .</span><br><span class=\"line\">Processing foo.gcda</span><br><span class=\"line\">geninfo: WARNING: cannot find an entry for main.c.gcov in .gcno file, skipping file!</span><br><span class=\"line\">Processing main.gcda</span><br><span class=\"line\">Finished .info-file creation</span><br><span class=\"line\">genhtml coverage.info --output-directory out</span><br><span class=\"line\">Reading data file coverage.info</span><br><span class=\"line\">Found 2 entries.</span><br><span class=\"line\">Found common filename prefix &quot;/workspace/coco&quot;</span><br><span class=\"line\">Writing .css and .png files.</span><br><span class=\"line\">Generating output.</span><br><span class=\"line\">Processing file gcov-example/main.c</span><br><span class=\"line\">Processing file gcov-example/foo.c</span><br><span class=\"line\">Writing directory view page.</span><br><span class=\"line\">Overall coverage rate:</span><br><span class=\"line\">lines......: 91.7% (11 of 12 lines)</span><br><span class=\"line\">functions..: 100.0% (2 of 2 functions)</span><br></pre></td></tr></table></figure>\n\n<p>执行 make report 来生成 HTML 报告，这条命令的背后实际上主要执行了以下两个步骤：</p>\n<ol>\n<li>在有了编译和运行时候生成的 .gcno 和 .gcda 文件后，执行命令 gcov main.c foo.c 即可生成 .gcov 代码覆盖率文件。</li>\n<li>有了代码覆盖率 .gcov 文件，通过 LCOV 生成可视化代码覆盖率报告。<br>生成 HTML 结果报告的步骤如下：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1. 生成 coverage.info 数据文件</span></span><br><span class=\"line\">lcov --capture --directory . --output-file coverage.info</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">2. 根据这个数据文件生成报告</span></span><br><span class=\"line\">genhtml coverage.info --output-directory out</span><br><span class=\"line\"></span><br><span class=\"line\">常用的lcov命令:</span><br><span class=\"line\">1. lcov --extract xx.info &#x27;*/xx&#x27; &#x27;*/yy&#x27; -o res.info  // 只保留xx.info中的xx和yy目录并输出到res.info</span><br><span class=\"line\">2. lcov --remove xx.info &#x27;*/xx&#x27; &#x27;*/yy&#x27; -o res.info //删除xx.info中的xx和yy目录并输出到res.info</span><br><span class=\"line\">3. lcov -a xx.info -a yy.info -o res.info //合并xx.info和yy.info并输出到res.info</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"收尾\"><a href=\"#收尾\" class=\"headerlink\" title=\"收尾\"></a>收尾</h4><p>上传过程中所有生成的文件可通过执行 make clean 命令来彻底删除掉。</p>\n<p>make clean 命令的输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sh-4.2$ make clean</span><br><span class=\"line\">rm -rf main *.o *.so *.gcno *.gcda *.gcov coverage.info out</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>旁注： 还有另外一个生成 HTML 报告的工具叫 gcovr，使用 Python 开发的，它的报告在显示方式上与 LCOV 略有不同。比如 LCOV 以目录结构显示， gcovr 以文件路径来显示，前者与代码结构一直因此我更倾向于使用前者。</p>\n</blockquote>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><h2 id=\"实践小结\"><a href=\"#实践小结\" class=\"headerlink\" title=\"实践小结\"></a>实践小结</h2><p>和GoLang单元测试框架有些区别的是，GoLang自生就提供了自带的测试框架，也有第三方框架进行选择。<br>而C&#x2F;C++&#x2F;php等语言的单元测试框架则需要第三方提供和安装。</p>\n<p>框架的使用，无非是一些语法糖的差异和使用的难易程度。不管使用什么语言，什么框架，最关键的是利用单元测试的思路，<br>写出解耦的、可测试的、易于维护的代码，保证代码的质量。</p>\n<p>单元测试是一种手段，能够一定程度的改善生产力。凡事有度过犹不及，如果一味的盲目的追求测试覆盖率，<br>忽视了测试代码本身的质量，那么各种无效的单元测试反而带来了沉重的维护负担。因此单测的代码，本身也是代码，<br>也是和项目本身的代码一样，需要重构、维护的（好好写代码）。</p>\n","slug":"CPP-单测","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/11/01/CPP-%E5%8D%95%E6%B5%8B/","excerpt":"单测系列-C++总结在C++中如何做单测，本文介绍了单测是什么以及C++常用的单测框架和工具","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://vwin.github.io/tags/C/"},{"name":"单测","slug":"单测","permalink":"http://vwin.github.io/tags/%E5%8D%95%E6%B5%8B/"}]},{"title":"云IaaS测试系列一存储性能及性能测试","date":"2022-10-28T07:41:04.000Z","path":"2022/10/28/云IaaS测试系列一存储性能及性能测试/","text":"简介在过去的几十年，随着计算，网络和存储领域的技术创新以及业务类型的多样化，数据中心经历了从大型主机，到X86服务器，从虚拟化技术到一切皆服务的云计算的漫长演进历程。 存储技术为满足层出不穷应用的海量数据存储需求，从物理介质到技术架构也同样发生了天翻地覆的变革。无论技术如何更新换代，其目的都是为了更好的提供高性能，高容量，高可用的数据服务。而高性能尤其是IT决策过程中一个重要因素，一套好的解决方案可以既节约钱又可以节省时间。本文会对存储系统的性能，以及如何测试存储系统的性能做详细介绍。 术语什么是存储性能？简单的说，就是指单个或一套存储系统表现有多好有多快。0-100公里加速时间，最高速度，最大功率，最大扭矩等等指标通常被用来衡量一辆车的性能好坏：扭矩越大加速越快，功率越大速度越高。存储系统也有类似的度量性能的指标和方法，下面先来理解几个概念： I&#x2F;O一个I&#x2F;O就是单个读&#x2F;写请求。I&#x2F;O的目标可以是一块硬盘或SSD，也可以是SAN存储系统，也可以是文件系统中的某个文件。从应用到操作系统，从网络到存储系统，从内存到物理硬盘，I&#x2F;O在不同的上下文有着不同的解读。 I&#x2F;O大小I&#x2F;O请求的大小 利用率（utilization）通常用百分比表示一个设备用来服务请求的时间占比。 服务时间（service time）指真正处理一个请求所需要花费的时间。 等待时间（queue time）指一个请求排队等候处理所花费的时间。设备利用率较低排队请求少则等待时间短，反之则等待时间长。 延时（latency）延时指从发起I&#x2F;O请求到收到响应需要花费的时间，包含服务时间和等待时间。多数情况下延时是反应存储系统性能最关键的单一指标。 IOPSIOPS（I&#x2F;O Operations Per Second）代表每秒的I&#x2F;O请求，它是存储世界里最典型的一个性能指标，用来表示单位时间内有多少I&#x2F;O请求可以被处理。IOPS通常需要和延时作为一个整体来看：相同延时情况下IOPS越高则存储系统处理能力越强，如果单纯达到高IOPS但时延也高，则并不能说明存储系统的性能更好。 吞吐（throughput）IOPS乘以I&#x2F;O大小就可以算出吞吐，用来表示每秒发起请求的数据量。比如I&#x2F;O大小为4KB，IOPS为100K，得出的吞吐是400MB&#x2F;s。 了解了这几个概念后，我们知道可以通过延时衡量一个存储系统响应快慢与否，通过IOPS和吞吐了解每秒处理能力强弱。 业务模型不同的业务模型（workload）对存储系统的性能影响巨大，是非常重要的性能考量因素。 大I&#x2F;O vs 小I&#x2F;O请求的I&#x2F;O大小对吞吐有直接的影响。总体来说，大I&#x2F;O会给带来更高的吞吐，也会导致需要更多的时间传输和处理，但同时也减少了额外开销（overhead）；小I&#x2F;O会产生更高的IOPS，时延更低。大多数真实的应用的I&#x2F;O大小是混合的： 典型文件系统或Oracle：8KB 备份软件：64KB 流媒体：256K 读写比例现实中大多数的应用访问模型都是读写混合的，真正的纯读或纯写很少。通常读消耗更少的系统资源，性能表现更好： 顺序读在cache读命中可以轻易达到最高的吞吐 随机读未命中cache则需要从下层获取数据，I&#x2F;O路径更长，响应时间更长，吞吐更少 写入时为了保证数据一致性，会消耗更多的系统资源来保护，缓存这部分数据，通常性能不如读 顺序 vs 随机 顺序存取（sequential access）取指大量顺序的I&#x2F;O请求连续相邻的数据块，现代存储会通过模型识别进行预读来提升读性能。典型的业务有备份恢复，日志，视频点播等。 随机存取（random access）指I&#x2F;O请求随机的分布在存储介质的各个区域，比如高并发读写大量小文件，会导致IOPS和吞吐的性能下降。典型的业务有OLTP，Home directories，MS Exchange等。 单线程 vs 多线程就单个线程而言，顺序I&#x2F;O比随机I&#x2F;O更快。增加并发的顺序I&#x2F;O的线程数量会导致存储系统需要同时从不同的位置查找，读写，尽管每个线程都是顺序I&#x2F;O，但整个存储系统看起来在做随机I&#x2F;O。适度的线程数量可以实现并发达到较优的延时，而过度并发会消耗更多的系统资源，造成排队和繁忙。 Direct I&#x2F;O vs Buffered I&#x2F;O通过直接 I&#x2F;O 方式进行数据传输，数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输，中间少了页缓存的支持。 而Buffer I&#x2F;O为了提高读写效率和保护磁盘，使用了页缓存机制，不过由于页缓存处于内核空间，不能被应用程序（用户进程）直接寻址，所以还需要将页缓存数据再拷贝到内存对应的用户空间中。这样，需要两次数据拷贝才能完成用户进程对数据的读取操作。写操作也是一样，将页缓存的数据写入磁盘的时候，必须先拷贝到内核空间对应的主存，然后在写入磁盘中。 下面例举几个典型应用的I&#x2F;O模型： OLTP指联机事务处理（Online transaction processing），主要是执行基本日常的事务处理，例如数据库的增删改查，其中每个事务涉及的数据量通常很小，对延时要求高。 OLAP指联机分析处理（Online Analytical Processing），是数据仓库系统主要应用，支持复杂的分析操作，一般很少有数据修改，以复杂的查询语句为主，侧重决策支持并提供直观易懂的查询结果。 VDI指桌面虚拟化（Virtual Desktop Infrastructure），是基于虚拟化服务器诞生出的一种技术。它将所有桌面PC所需的系统软件，应用及用户数据存放到后台服务器中并通过专门的管理系统赋予给特定用户，用户通过专用的网络传输协议连接到后端服务器分配的桌面资源，连接后，用户可在连接本地终端上直接使用后台运行的桌面系统，使用体验基本与物理PC一致。有几种启动风暴、登录风暴和平稳状态几种典型场景，其中启动风暴是读密集型，登陆风暴是写密集型，而平稳状态以顺序写少量读为主。 Media Streaming指流媒体，将一连串的多媒体资料压缩后，经过互联网分段发送资料，在互联网上即时传输影音以供观赏的一种技术与过程，此技术使得资料数据包得以像流水一样发送，如果不使用此技术，就必须在使用前下载整个媒体文件。其以大块的顺序读为主，缓存命中高，吞吐高。 影响性能的因素 存储介质 机械硬盘（hard disk）因为物理结构的局限磁头寻道，磁盘有转速以及延时，导致顺序存取比随机存取性能更好。 在顺序读写时不需要频繁的移动磁头，从而减少了寻道开销可以把时间花在读写实际数据上；随机读写则把本该用来读写实际数据的时间浪费在不停的寻道，等待上。所以使用机械硬盘的传统存储系统通过复杂算法，缓存技术进行优化尽量减少随机存取带来的性能损耗。 固态硬盘（SSD）物理上基于闪存颗粒没有了磁盘和磁头，从而避免了旋转和移动带来的时间浪费，可以更快的响应I&#x2F;O请求，提供更低的延时。但SSD只能写入被擦除的页，写入命令会在写入闪存之前调用闪存擦除周期，导致写比读慢。而写入&#x2F;擦除循环会导致单元磨损，从而带来有限的写入寿命。固态硬盘会通过损耗均衡算法确保损耗均匀延长使用寿命，而后台的垃圾回收会消耗系统资源对前台操作造成负面影响。因此，全闪存存储系统设计时会扬长避短：既能发挥介质革新带来的性能提升，又能减少它带来的劣势。 存储系统I&#x2F;O从应用程序发起，经由操作系统，网卡，网络&#x2F;交换路由设备，到达存储系统，再由存储系统的I&#x2F;O调用栈处理后最终到达磁盘。这套复杂系统的性能取决于整个环节中最慢的组件，只有平衡各组件的性能才能优化并挖掘整套系统性能的全部潜力。存储厂商通常会通过以下几方面升级优化提升性能，因此在考量存储系统性能时需要充分考虑业务模型的差异，存储介质的差异以及影响性能的各种因素，才能在贴近真实的场景下用正确的方法测试存储系统的性能： 硬件升级，比如使用更快CPU更大的内存，使用RDMA网络 软件优化：优化I&#x2F;O路径，比如使用缓存，冷热数据分层；使用用户态协议栈，SPDK等技术减少中断和实现水平扩展与此同时，存储系统为了降低成本，提升空间利用率，安全等会使用诸如压缩，去重，EC，垃圾回收，加密等技术，而这些特性一定程度上都会影响性能。 存储性能测试企业级存储价格昂贵，实现复杂，通常没有现成的性能对比数据辅助IT决策。怎么办？最有效的方法是定制化实施适合自己的性能测试。在了解了不同业务模型对性能的差异、存储系统的度量指标以及影响存储系统性能的相关因素之后，进行存储系统的性能测试其实并不难。 目标制定首先我们需要明确测试目标，需要得到哪个维度的存储性能：IOPS，吞吐，延时还是混合指标？不同的测试目标需要权衡使用不同的业务模型来达成： 小数据块配合深队列可以输出大量的OIO（outstanding IO），多用于测试峰值IOPS性能。但由于数据块偏小不能充分占用带宽因此不能反应峰值吞吐性能； 同理深队列由于会输出大量OIO也不能反应单个IO的极限延时性能； 小数据块单队列可以得到最好的延时数据，但因为OIO量小导致IOPS和吞吐都不够高。所以，我们测试吞吐需要使用大数据块，配合深队列顺序读写；测试延时需要使用小数据块但队列。不同的测试目标下权衡不同的参数，才能搜集正确的性能指标。 此外，虽然IOPS，吞吐，延时这三个指标最有代表性，但现实世界里的业务模型通常是混合的，而且存储设备的网络拓扑和背景负载也不一样，因此进行性能测试需要考虑充分并尽量做到apple-to-apple类比：服务器的规格配置，网络拓扑及延时，闪存的类型，操作系统的类型及版本，I&#x2F;O工具的类型及版本等等。 工具选择 测试块设备测试磁盘的工具往往就是调用块设备驱动的接口进行读写测试。可以用来评估块设备性能的I&#x2F;O工具很多，例如fio, vdbench, IOMeter, dd等等，它们各有特色。这里拿fio为例，通过配置参数–iodepth， –bs， –rw即可调整队列深度，I&#x2F;O大小，读写类型，通过指定–write_bw_log，–write_iops_log，–write_lat_log参数并配合-log_avg_msec使用可以按指定时间间隔采集时间点的吞吐，iops和延时数据并输出到指定文件，后期方便观察分析IO稳定性。 测试文件系统块设备之上是文件系统，测试需要针对文件系统层提供的功能进行测试，包括文件的打开关闭速度以及顺序读写随机位置读写的速度，以及进程并发数目等各个方面进行详细的测试等等。常用的测试工具有fio，vdbench，IOZone，sysbench等等。以IOZone为例，它能够产生并测量各种的操作性能，包括read, write, re-read, re-write, read backwards, read strided, fread, fwrite, random read, pread ,mmap, aio_read, aio_write等操作。Iozone目前已经被移植到各种体系结构计算机和操作系统上，广泛用于文件系统性能测试、分析与评估的标准工具。使用IOZone 可以在多线程，多CPU，并指定CPU Cache 空间大小以及同步或者异步IO读写模式的情况下进行文件操作的性能测试。 测试数据库文件系统之上是应用，测试典型的OLTP数据库场景也可以使用不同的工具进行：ORION使用和 Oracle 相同的 I&#x2F;O 软件集生成一个合成的 I&#x2F;O 负载，可以在不需要创建和运行Oracle数据的情况下模拟OLTP和数据仓库负载。pgbench是面向PostgreSQL的一个基准测试工具。默认情况下（工具默认提供），pgbench 测试基于TPC-B场景，每个事务包括5个SELECT、UPDATE 和INSERT命令。可以通过编写自己的事务脚本文件按需进行定制化测试；sysbench是一个模块化、跨平台、多线程的性能基准测试工具，支持MySSL，PostgreSQL，Oracle。除此之外它还可以测试CPU，内存，文件系统等等。 redis-benchmark是Redis官方自带的Redis性能测试工具。 测试阶段开箱即测得出的结果往往因为资源消耗不多，内部数据未老化导致数据偏好，因此测试之前需要进行初始化：例如预埋足够多的数据，触发SSD预留空间的写分配，触发垃圾回收；使用不可重删压缩的数据顺序写块设备以覆盖SSD更多的物理空间；格式化文件系统&#x2F;预置足够多的数据库记录等等。 另外，测试时间要足够长，排除噪音并搜集长稳测试的性能数据，反应真实的性能的同时观察IO波动。 测试工具通常会输出格式化的报告，包含I&#x2F;O相关的性能指标。除此之外，可以视情况收集系统的资源使用情况作为辅助数据进行性能分析： 报告阶段测试结束后，测试工程师搜集测试结果进行汇总并初步分析。尝试分析出现噪音，毛刺的原因并排错；分析数值偏高或偏低的可能原因；与相关产品、开发人员对齐初步结论，必要时重新测试。几轮之后得到可靠的性能数据后，接下来需要提炼测试结论，针对不同的观众输出相应的报告，这里有一些小技巧： 一目了然，尽量可视化，通过对比差异呈现优劣。 调理清晰，主次分明：headlines first！详细数据分析往后放。 覆盖关键指标，并开宗明义用简单直白的文字提炼结论 针对产品经理的报告，尽量站在客户的角度写；针对开发和测试人员，则需要充分考虑并注明背后技术架构、工作环境的差异。到这里我们已经流程化了一套存储性能测试方法，搜集到一组特定场景下的性能数据作为基线，它不一定具备普适性但却具有良好的参考价值。 接下来，可以通过微调测试环境进行更多场景的性能测试并与基线做对比；也可以通过性能分析工具进一步分析系统中的瓶颈或潜在的问题。 结论看到这里，相信各位已经掌握了影响存储系统性能的因素以及存储性能测试的基本思路和常用工具，在面对天花乱坠的性能宣传时可以结合实际情况订制合适的性能测试方法亲自验证一番。","raw":"---\ntitle: 云IaaS测试系列一存储性能及性能测试\ntoc: true\ndate: 2022-10-28 15:41:04\ntags: [IaaS,存储]\ncategories: [技术]\ndescription:\n---\n\n# 简介\n\n在过去的几十年，随着计算，网络和存储领域的技术创新以及业务类型的多样化，数据中心经历了从大型主机，到X86服务器，从虚拟化技术到一切皆服务的云计算的漫长演进历程。\n\n存储技术为满足层出不穷应用的海量数据存储需求，从物理介质到技术架构也同样发生了天翻地覆的变革。无论技术如何更新换代，其目的都是为了更好的提供高性能，高容量，高可用的数据服务。而高性能尤其是IT决策过程中一个重要因素，一套好的解决方案可以既节约钱又可以节省时间。本文会对存储系统的性能，以及如何测试存储系统的性能做详细介绍。\n\n# 术语\n\n什么是存储性能？简单的说，就是指单个或一套存储系统表现有多好有多快。0-100公里加速时间，最高速度，最大功率，最大扭矩等等指标通常被用来衡量一辆车的性能好坏：扭矩越大加速越快，功率越大速度越高。存储系统也有类似的度量性能的指标和方法，下面先来理解几个概念：\n1. I/O\n一个I/O就是单个读/写请求。I/O的目标可以是一块硬盘或SSD，也可以是SAN存储系统，也可以是文件系统中的某个文件。从应用到操作系统，从网络到存储系统，从内存到物理硬盘，I/O在不同的上下文有着不同的解读。\n\n2. I/O大小\nI/O请求的大小\n\n3. 利用率（utilization）\n通常用百分比表示一个设备用来服务请求的时间占比。\n\n4. 服务时间（service time）\n指真正处理一个请求所需要花费的时间。\n\n5. 等待时间（queue time）\n指一个请求排队等候处理所花费的时间。设备利用率较低排队请求少则等待时间短，反之则等待时间长。\n\n6. 延时（latency）\n延时指从发起I/O请求到收到响应需要花费的时间，包含服务时间和等待时间。多数情况下延时是反应存储系统性能最关键的单一指标。\n\n7. IOPS\nIOPS（I/O Operations Per Second）代表每秒的I/O请求，它是存储世界里最典型的一个性能指标，用来表示单位时间内有多少I/O请求可以被处理。IOPS通常需要和延时作为一个整体来看：相同延时情况下IOPS越高则存储系统处理能力越强，如果单纯达到高IOPS但时延也高，则并不能说明存储系统的性能更好。\n\n8. 吞吐（throughput）\nIOPS乘以I/O大小就可以算出吞吐，用来表示每秒发起请求的数据量。比如I/O大小为4KB，IOPS为100K，得出的吞吐是400MB/s。\n\n了解了这几个概念后，我们知道可以通过延时衡量一个存储系统响应快慢与否，通过IOPS和吞吐了解每秒处理能力强弱。\n\n\n# 业务模型\n\n不同的业务模型（workload）对存储系统的性能影响巨大，是非常重要的性能考量因素。\n\n1. 大I/O vs 小I/O\n请求的I/O大小对吞吐有直接的影响。总体来说，大I/O会给带来更高的吞吐，也会导致需要更多的时间传输和处理，但同时也减少了额外开销（overhead）；小I/O会产生更高的IOPS，时延更低。大多数真实的应用的I/O大小是混合的：\n   - 典型文件系统或Oracle：8KB \n   - 备份软件：64KB \n   - 流媒体：256K\n2. 读写比例\n现实中大多数的应用访问模型都是读写混合的，真正的纯读或纯写很少。通常读消耗更少的系统资源，性能表现更好：\n   - 顺序读在cache读命中可以轻易达到最高的吞吐\n   - 随机读未命中cache则需要从下层获取数据，I/O路径更长，响应时间更长，吞吐更少\n   - 写入时为了保证数据一致性，会消耗更多的系统资源来保护，缓存这部分数据，通常性能不如读\n3. 顺序 vs 随机\n   - 顺序存取（sequential access）取指大量顺序的I/O请求连续相邻的数据块，现代存储会通过模型识别进行预读来提升读性能。典型的业务有备份恢复，日志，视频点播等。 \n   - 随机存取（random access）指I/O请求随机的分布在存储介质的各个区域，比如高并发读写大量小文件，会导致IOPS和吞吐的性能下降。典型的业务有OLTP，Home directories，MS Exchange等。\n\n4. 单线程 vs 多线程 \n   就单个线程而言，顺序I/O比随机I/O更快。增加并发的顺序I/O的线程数量会导致存储系统需要同时从不同的位置查找，读写，尽管每个线程都是顺序I/O，但整个存储系统看起来在做随机I/O。适度的线程数量可以实现并发达到较优的延时，而过度并发会消耗更多的系统资源，造成排队和繁忙。\n\n5. Direct I/O vs Buffered I/O \n   通过直接 I/O 方式进行数据传输，数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输，中间少了页缓存的支持。\n\n而Buffer I/O为了提高读写效率和保护磁盘，使用了页缓存机制，不过由于页缓存处于内核空间，不能被应用程序（用户进程）直接寻址，所以还需要将页缓存数据再拷贝到内存对应的用户空间中。这样，需要两次数据拷贝才能完成用户进程对数据的读取操作。写操作也是一样，将页缓存的数据写入磁盘的时候，必须先拷贝到内核空间对应的主存，然后在写入磁盘中。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img.png)\n\n下面例举几个典型应用的I/O模型：\n\n1. OLTP指联机事务处理（Online transaction processing），主要是执行基本日常的事务处理，例如数据库的增删改查，其中每个事务涉及的数据量通常很小，对延时要求高。\n2. OLAP指联机分析处理（Online Analytical Processing），是数据仓库系统主要应用，支持复杂的分析操作，一般很少有数据修改，以复杂的查询语句为主，侧重决策支持并提供直观易懂的查询结果。\n3. VDI指桌面虚拟化（Virtual Desktop Infrastructure），是基于虚拟化服务器诞生出的一种技术。它将所有桌面PC所需的系统软件，应用及用户数据存放到后台服务器中并通过专门的管理系统赋予给特定用户，用户通过专用的网络传输协议连接到后端服务器分配的桌面资源，连接后，用户可在连接本地终端上直接使用后台运行的桌面系统，使用体验基本与物理PC一致。有几种启动风暴、登录风暴和平稳状态几种典型场景，其中启动风暴是读密集型，登陆风暴是写密集型，而平稳状态以顺序写少量读为主。\n4. Media Streaming指流媒体，将一连串的多媒体资料压缩后，经过互联网分段发送资料，在互联网上即时传输影音以供观赏的一种技术与过程，此技术使得资料数据包得以像流水一样发送，如果不使用此技术，就必须在使用前下载整个媒体文件。其以大块的顺序读为主，缓存命中高，吞吐高。\n\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_1.png)\n\n# 影响性能的因素\n\n1. 存储介质\n   - 机械硬盘（hard disk）因为物理结构的局限磁头寻道，磁盘有转速以及延时，导致顺序存取比随机存取性能更好。 \n   - 在顺序读写时不需要频繁的移动磁头，从而减少了寻道开销可以把时间花在读写实际数据上；随机读写则把本该用来读写实际数据的时间浪费在不停的寻道，等待上。所以使用机械硬盘的传统存储系统通过复杂算法，缓存技术进行优化尽量减少随机存取带来的性能损耗。\n   - 固态硬盘（SSD）物理上基于闪存颗粒没有了磁盘和磁头，从而避免了旋转和移动带来的时间浪费，可以更快的响应I/O请求，提供更低的延时。但SSD只能写入被擦除的页，写入命令会在写入闪存之前调用闪存擦除周期，导致写比读慢。而写入/擦除循环会导致单元磨损，从而带来有限的写入寿命。固态硬盘会通过损耗均衡算法确保损耗均匀延长使用寿命，而后台的垃圾回收会消耗系统资源对前台操作造成负面影响。因此，全闪存存储系统设计时会扬长避短：既能发挥介质革新带来的性能提升，又能减少它带来的劣势。\n\n2. 存储系统 \n   I/O从应用程序发起，经由操作系统，网卡，网络/交换路由设备，到达存储系统，再由存储系统的I/O调用栈处理后最终到达磁盘。这套复杂系统的性能取决于整个环节中最慢的组件，只有平衡各组件的性能才能优化并挖掘整套系统性能的全部潜力。\n   存储厂商通常会通过以下几方面升级优化提升性能，因此在考量存储系统性能时需要充分考虑业务模型的差异，存储介质的差异以及影响性能的各种因素，才能在贴近真实的场景下用正确的方法测试存储系统的性能：\n   - 硬件升级，比如使用更快CPU更大的内存，使用RDMA网络\n   - 软件优化：\n     优化I/O路径，比如使用缓存，冷热数据分层；使用用户态协议栈，SPDK等技术减少中断和实现水平扩展\n     与此同时，存储系统为了降低成本，提升空间利用率，安全等会使用诸如压缩，去重，EC，垃圾回收，加密等技术，而这些特性一定程度上都会影响性能。\n\n# 存储性能测试\n\n企业级存储价格昂贵，实现复杂，通常没有现成的性能对比数据辅助IT决策。怎么办？最有效的方法是定制化实施适合自己的性能测试。在了解了不同业务模型对性能的差异、存储系统的度量指标以及影响存储系统性能的相关因素之后，进行存储系统的性能测试其实并不难。\n\n1. 目标制定 \n首先我们需要明确测试目标，需要得到哪个维度的存储性能：IOPS，吞吐，延时还是混合指标？不同的测试目标需要权衡使用不同的业务模型来达成：\n\n- 小数据块配合深队列可以输出大量的OIO（outstanding IO），多用于测试峰值IOPS性能。但由于数据块偏小不能充分占用带宽因此不能反应峰值吞吐性能；\n- 同理深队列由于会输出大量OIO也不能反应单个IO的极限延时性能；\n- 小数据块单队列可以得到最好的延时数据，但因为OIO量小导致IOPS和吞吐都不够高。\n所以，我们测试吞吐需要使用大数据块，配合深队列顺序读写；测试延时需要使用小数据块但队列。不同的测试目标下权衡不同的参数，才能搜集正确的性能指标。\n\n此外，虽然IOPS，吞吐，延时这三个指标最有代表性，但现实世界里的业务模型通常是混合的，而且存储设备的网络拓扑和背景负载也不一样，因此进行性能测试需要考虑充分并尽量做到apple-to-apple类比：服务器的规格配置，网络拓扑及延时，闪存的类型，操作系统的类型及版本，I/O工具的类型及版本等等。\n\n2. 工具选择\n   - 测试块设备 \n   测试磁盘的工具往往就是调用块设备驱动的接口进行读写测试。可以用来评估块设备性能的I/O工具很多，例如fio, vdbench, IOMeter, dd等等，它们各有特色。这里拿fio为例，通过配置参数--iodepth， --bs， --rw即可调整队列深度，I/O大小，读写类型，通过指定--write_bw_log，--write_iops_log，--write_lat_log参数并配合-log_avg_msec使用可以按指定时间间隔采集时间点的吞吐，iops和延时数据并输出到指定文件，后期方便观察分析IO稳定性。\n   - 测试文件系统\n     块设备之上是文件系统，测试需要针对文件系统层提供的功能进行测试，包括文件的打开关闭速度以及顺序读写随机位置读写的速度，以及进程并发数目等各个方面进行详细的测试等等。常用的测试工具有fio，vdbench，IOZone，sysbench等等。以IOZone为例，它能够产生并测量各种的操作性能，包括read, write, re-read, re-write, read backwards, read strided, fread, fwrite, random read, pread ,mmap, aio_read, aio_write等操作。Iozone目前已经被移植到各种体系结构计算机和操作系统上，广泛用于文件系统性能测试、分析与评估的标准工具。使用IOZone 可以在多线程，多CPU，并指定CPU Cache 空间大小以及同步或者异步IO读写模式的情况下进行文件操作的性能测试。\n   - 测试数据库\n     文件系统之上是应用，测试典型的OLTP数据库场景也可以使用不同的工具进行：ORION使用和 Oracle 相同的 I/O 软件集生成一个合成的 I/O 负载，可以在不需要创建和运行Oracle数据的情况下模拟OLTP和数据仓库负载。pgbench是面向PostgreSQL的一个基准测试工具。默认情况下（工具默认提供），pgbench 测试基于TPC-B场景，每个事务包括5个SELECT、UPDATE 和INSERT命令。可以通过编写自己的事务脚本文件按需进行定制化测试；sysbench是一个模块化、跨平台、多线程的性能基准测试工具，支持MySSL，PostgreSQL，Oracle。除此之外它还可以测试CPU，内存，文件系统等等。 redis-benchmark是Redis官方自带的Redis性能测试工具。\n   ![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_2.png)\n     ![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_3.png)\n\n3. 测试阶段\n开箱即测得出的结果往往因为资源消耗不多，内部数据未老化导致数据偏好，因此测试之前需要进行初始化：例如预埋足够多的数据，触发SSD预留空间的写分配，触发垃圾回收；使用不可重删压缩的数据顺序写块设备以覆盖SSD更多的物理空间；格式化文件系统/预置足够多的数据库记录等等。\n\n另外，测试时间要足够长，排除噪音并搜集长稳测试的性能数据，反应真实的性能的同时观察IO波动。\n\n测试工具通常会输出格式化的报告，包含I/O相关的性能指标。除此之外，可以视情况收集系统的资源使用情况作为辅助数据进行性能分析：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_4.png)\n\n4. 报告阶段\n   测试结束后，测试工程师搜集测试结果进行汇总并初步分析。尝试分析出现噪音，毛刺的原因并排错；分析数值偏高或偏低的可能原因；与相关产品、开发人员对齐初步结论，必要时重新测试。几轮之后得到可靠的性能数据后，接下来需要提炼测试结论，针对不同的观众输出相应的报告，这里有一些小技巧： \n   - 一目了然，尽量可视化，通过对比差异呈现优劣。\n   - 调理清晰，主次分明：headlines first！详细数据分析往后放。\n   - 覆盖关键指标，并开宗明义用简单直白的文字提炼结论\n   - 针对产品经理的报告，尽量站在客户的角度写；针对开发和测试人员，则需要充分考虑并注明背后技术架构、工作环境的差异。\n   到这里我们已经流程化了一套存储性能测试方法，搜集到一组特定场景下的性能数据作为基线，它不一定具备普适性但却具有良好的参考价值。\n\n接下来，可以通过微调测试环境进行更多场景的性能测试并与基线做对比；也可以通过性能分析工具进一步分析系统中的瓶颈或潜在的问题。\n\n# 结论\n\n看到这里，相信各位已经掌握了影响存储系统性能的因素以及存储性能测试的基本思路和常用工具，在面对天花乱坠的性能宣传时可以结合实际情况订制合适的性能测试方法亲自验证一番。\n\n\n\n\n\n\n\n\n","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>在过去的几十年，随着计算，网络和存储领域的技术创新以及业务类型的多样化，数据中心经历了从大型主机，到X86服务器，从虚拟化技术到一切皆服务的云计算的漫长演进历程。</p>\n<p>存储技术为满足层出不穷应用的海量数据存储需求，从物理介质到技术架构也同样发生了天翻地覆的变革。无论技术如何更新换代，其目的都是为了更好的提供高性能，高容量，高可用的数据服务。而高性能尤其是IT决策过程中一个重要因素，一套好的解决方案可以既节约钱又可以节省时间。本文会对存储系统的性能，以及如何测试存储系统的性能做详细介绍。</p>\n<h1 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h1><p>什么是存储性能？简单的说，就是指单个或一套存储系统表现有多好有多快。0-100公里加速时间，最高速度，最大功率，最大扭矩等等指标通常被用来衡量一辆车的性能好坏：扭矩越大加速越快，功率越大速度越高。存储系统也有类似的度量性能的指标和方法，下面先来理解几个概念：</p>\n<ol>\n<li><p>I&#x2F;O<br>一个I&#x2F;O就是单个读&#x2F;写请求。I&#x2F;O的目标可以是一块硬盘或SSD，也可以是SAN存储系统，也可以是文件系统中的某个文件。从应用到操作系统，从网络到存储系统，从内存到物理硬盘，I&#x2F;O在不同的上下文有着不同的解读。</p>\n</li>\n<li><p>I&#x2F;O大小<br>I&#x2F;O请求的大小</p>\n</li>\n<li><p>利用率（utilization）<br>通常用百分比表示一个设备用来服务请求的时间占比。</p>\n</li>\n<li><p>服务时间（service time）<br>指真正处理一个请求所需要花费的时间。</p>\n</li>\n<li><p>等待时间（queue time）<br>指一个请求排队等候处理所花费的时间。设备利用率较低排队请求少则等待时间短，反之则等待时间长。</p>\n</li>\n<li><p>延时（latency）<br>延时指从发起I&#x2F;O请求到收到响应需要花费的时间，包含服务时间和等待时间。多数情况下延时是反应存储系统性能最关键的单一指标。</p>\n</li>\n<li><p>IOPS<br>IOPS（I&#x2F;O Operations Per Second）代表每秒的I&#x2F;O请求，它是存储世界里最典型的一个性能指标，用来表示单位时间内有多少I&#x2F;O请求可以被处理。IOPS通常需要和延时作为一个整体来看：相同延时情况下IOPS越高则存储系统处理能力越强，如果单纯达到高IOPS但时延也高，则并不能说明存储系统的性能更好。</p>\n</li>\n<li><p>吞吐（throughput）<br>IOPS乘以I&#x2F;O大小就可以算出吞吐，用来表示每秒发起请求的数据量。比如I&#x2F;O大小为4KB，IOPS为100K，得出的吞吐是400MB&#x2F;s。</p>\n</li>\n</ol>\n<p>了解了这几个概念后，我们知道可以通过延时衡量一个存储系统响应快慢与否，通过IOPS和吞吐了解每秒处理能力强弱。</p>\n<h1 id=\"业务模型\"><a href=\"#业务模型\" class=\"headerlink\" title=\"业务模型\"></a>业务模型</h1><p>不同的业务模型（workload）对存储系统的性能影响巨大，是非常重要的性能考量因素。</p>\n<ol>\n<li><p>大I&#x2F;O vs 小I&#x2F;O<br>请求的I&#x2F;O大小对吞吐有直接的影响。总体来说，大I&#x2F;O会给带来更高的吞吐，也会导致需要更多的时间传输和处理，但同时也减少了额外开销（overhead）；小I&#x2F;O会产生更高的IOPS，时延更低。大多数真实的应用的I&#x2F;O大小是混合的：</p>\n<ul>\n<li>典型文件系统或Oracle：8KB </li>\n<li>备份软件：64KB </li>\n<li>流媒体：256K</li>\n</ul>\n</li>\n<li><p>读写比例<br>现实中大多数的应用访问模型都是读写混合的，真正的纯读或纯写很少。通常读消耗更少的系统资源，性能表现更好：</p>\n<ul>\n<li>顺序读在cache读命中可以轻易达到最高的吞吐</li>\n<li>随机读未命中cache则需要从下层获取数据，I&#x2F;O路径更长，响应时间更长，吞吐更少</li>\n<li>写入时为了保证数据一致性，会消耗更多的系统资源来保护，缓存这部分数据，通常性能不如读</li>\n</ul>\n</li>\n<li><p>顺序 vs 随机</p>\n<ul>\n<li>顺序存取（sequential access）取指大量顺序的I&#x2F;O请求连续相邻的数据块，现代存储会通过模型识别进行预读来提升读性能。典型的业务有备份恢复，日志，视频点播等。 </li>\n<li>随机存取（random access）指I&#x2F;O请求随机的分布在存储介质的各个区域，比如高并发读写大量小文件，会导致IOPS和吞吐的性能下降。典型的业务有OLTP，Home directories，MS Exchange等。</li>\n</ul>\n</li>\n<li><p>单线程 vs 多线程<br>就单个线程而言，顺序I&#x2F;O比随机I&#x2F;O更快。增加并发的顺序I&#x2F;O的线程数量会导致存储系统需要同时从不同的位置查找，读写，尽管每个线程都是顺序I&#x2F;O，但整个存储系统看起来在做随机I&#x2F;O。适度的线程数量可以实现并发达到较优的延时，而过度并发会消耗更多的系统资源，造成排队和繁忙。</p>\n</li>\n<li><p>Direct I&#x2F;O vs Buffered I&#x2F;O<br>通过直接 I&#x2F;O 方式进行数据传输，数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输，中间少了页缓存的支持。</p>\n</li>\n</ol>\n<p>而Buffer I&#x2F;O为了提高读写效率和保护磁盘，使用了页缓存机制，不过由于页缓存处于内核空间，不能被应用程序（用户进程）直接寻址，所以还需要将页缓存数据再拷贝到内存对应的用户空间中。这样，需要两次数据拷贝才能完成用户进程对数据的读取操作。写操作也是一样，将页缓存的数据写入磁盘的时候，必须先拷贝到内核空间对应的主存，然后在写入磁盘中。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img.png\"></p>\n<p>下面例举几个典型应用的I&#x2F;O模型：</p>\n<ol>\n<li>OLTP指联机事务处理（Online transaction processing），主要是执行基本日常的事务处理，例如数据库的增删改查，其中每个事务涉及的数据量通常很小，对延时要求高。</li>\n<li>OLAP指联机分析处理（Online Analytical Processing），是数据仓库系统主要应用，支持复杂的分析操作，一般很少有数据修改，以复杂的查询语句为主，侧重决策支持并提供直观易懂的查询结果。</li>\n<li>VDI指桌面虚拟化（Virtual Desktop Infrastructure），是基于虚拟化服务器诞生出的一种技术。它将所有桌面PC所需的系统软件，应用及用户数据存放到后台服务器中并通过专门的管理系统赋予给特定用户，用户通过专用的网络传输协议连接到后端服务器分配的桌面资源，连接后，用户可在连接本地终端上直接使用后台运行的桌面系统，使用体验基本与物理PC一致。有几种启动风暴、登录风暴和平稳状态几种典型场景，其中启动风暴是读密集型，登陆风暴是写密集型，而平稳状态以顺序写少量读为主。</li>\n<li>Media Streaming指流媒体，将一连串的多媒体资料压缩后，经过互联网分段发送资料，在互联网上即时传输影音以供观赏的一种技术与过程，此技术使得资料数据包得以像流水一样发送，如果不使用此技术，就必须在使用前下载整个媒体文件。其以大块的顺序读为主，缓存命中高，吞吐高。</li>\n</ol>\n<p><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_1.png\"></p>\n<h1 id=\"影响性能的因素\"><a href=\"#影响性能的因素\" class=\"headerlink\" title=\"影响性能的因素\"></a>影响性能的因素</h1><ol>\n<li><p>存储介质</p>\n<ul>\n<li>机械硬盘（hard disk）因为物理结构的局限磁头寻道，磁盘有转速以及延时，导致顺序存取比随机存取性能更好。 </li>\n<li>在顺序读写时不需要频繁的移动磁头，从而减少了寻道开销可以把时间花在读写实际数据上；随机读写则把本该用来读写实际数据的时间浪费在不停的寻道，等待上。所以使用机械硬盘的传统存储系统通过复杂算法，缓存技术进行优化尽量减少随机存取带来的性能损耗。</li>\n<li>固态硬盘（SSD）物理上基于闪存颗粒没有了磁盘和磁头，从而避免了旋转和移动带来的时间浪费，可以更快的响应I&#x2F;O请求，提供更低的延时。但SSD只能写入被擦除的页，写入命令会在写入闪存之前调用闪存擦除周期，导致写比读慢。而写入&#x2F;擦除循环会导致单元磨损，从而带来有限的写入寿命。固态硬盘会通过损耗均衡算法确保损耗均匀延长使用寿命，而后台的垃圾回收会消耗系统资源对前台操作造成负面影响。因此，全闪存存储系统设计时会扬长避短：既能发挥介质革新带来的性能提升，又能减少它带来的劣势。</li>\n</ul>\n</li>\n<li><p>存储系统<br>I&#x2F;O从应用程序发起，经由操作系统，网卡，网络&#x2F;交换路由设备，到达存储系统，再由存储系统的I&#x2F;O调用栈处理后最终到达磁盘。这套复杂系统的性能取决于整个环节中最慢的组件，只有平衡各组件的性能才能优化并挖掘整套系统性能的全部潜力。<br>存储厂商通常会通过以下几方面升级优化提升性能，因此在考量存储系统性能时需要充分考虑业务模型的差异，存储介质的差异以及影响性能的各种因素，才能在贴近真实的场景下用正确的方法测试存储系统的性能：</p>\n<ul>\n<li>硬件升级，比如使用更快CPU更大的内存，使用RDMA网络</li>\n<li>软件优化：<br>优化I&#x2F;O路径，比如使用缓存，冷热数据分层；使用用户态协议栈，SPDK等技术减少中断和实现水平扩展<br>与此同时，存储系统为了降低成本，提升空间利用率，安全等会使用诸如压缩，去重，EC，垃圾回收，加密等技术，而这些特性一定程度上都会影响性能。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"存储性能测试\"><a href=\"#存储性能测试\" class=\"headerlink\" title=\"存储性能测试\"></a>存储性能测试</h1><p>企业级存储价格昂贵，实现复杂，通常没有现成的性能对比数据辅助IT决策。怎么办？最有效的方法是定制化实施适合自己的性能测试。在了解了不同业务模型对性能的差异、存储系统的度量指标以及影响存储系统性能的相关因素之后，进行存储系统的性能测试其实并不难。</p>\n<ol>\n<li>目标制定<br>首先我们需要明确测试目标，需要得到哪个维度的存储性能：IOPS，吞吐，延时还是混合指标？不同的测试目标需要权衡使用不同的业务模型来达成：</li>\n</ol>\n<ul>\n<li>小数据块配合深队列可以输出大量的OIO（outstanding IO），多用于测试峰值IOPS性能。但由于数据块偏小不能充分占用带宽因此不能反应峰值吞吐性能；</li>\n<li>同理深队列由于会输出大量OIO也不能反应单个IO的极限延时性能；</li>\n<li>小数据块单队列可以得到最好的延时数据，但因为OIO量小导致IOPS和吞吐都不够高。<br>所以，我们测试吞吐需要使用大数据块，配合深队列顺序读写；测试延时需要使用小数据块但队列。不同的测试目标下权衡不同的参数，才能搜集正确的性能指标。</li>\n</ul>\n<p>此外，虽然IOPS，吞吐，延时这三个指标最有代表性，但现实世界里的业务模型通常是混合的，而且存储设备的网络拓扑和背景负载也不一样，因此进行性能测试需要考虑充分并尽量做到apple-to-apple类比：服务器的规格配置，网络拓扑及延时，闪存的类型，操作系统的类型及版本，I&#x2F;O工具的类型及版本等等。</p>\n<ol start=\"2\">\n<li><p>工具选择</p>\n<ul>\n<li>测试块设备<br>测试磁盘的工具往往就是调用块设备驱动的接口进行读写测试。可以用来评估块设备性能的I&#x2F;O工具很多，例如fio, vdbench, IOMeter, dd等等，它们各有特色。这里拿fio为例，通过配置参数–iodepth， –bs， –rw即可调整队列深度，I&#x2F;O大小，读写类型，通过指定–write_bw_log，–write_iops_log，–write_lat_log参数并配合-log_avg_msec使用可以按指定时间间隔采集时间点的吞吐，iops和延时数据并输出到指定文件，后期方便观察分析IO稳定性。</li>\n<li>测试文件系统<br>块设备之上是文件系统，测试需要针对文件系统层提供的功能进行测试，包括文件的打开关闭速度以及顺序读写随机位置读写的速度，以及进程并发数目等各个方面进行详细的测试等等。常用的测试工具有fio，vdbench，IOZone，sysbench等等。以IOZone为例，它能够产生并测量各种的操作性能，包括read, write, re-read, re-write, read backwards, read strided, fread, fwrite, random read, pread ,mmap, aio_read, aio_write等操作。Iozone目前已经被移植到各种体系结构计算机和操作系统上，广泛用于文件系统性能测试、分析与评估的标准工具。使用IOZone 可以在多线程，多CPU，并指定CPU Cache 空间大小以及同步或者异步IO读写模式的情况下进行文件操作的性能测试。</li>\n<li>测试数据库<br>文件系统之上是应用，测试典型的OLTP数据库场景也可以使用不同的工具进行：ORION使用和 Oracle 相同的 I&#x2F;O 软件集生成一个合成的 I&#x2F;O 负载，可以在不需要创建和运行Oracle数据的情况下模拟OLTP和数据仓库负载。pgbench是面向PostgreSQL的一个基准测试工具。默认情况下（工具默认提供），pgbench 测试基于TPC-B场景，每个事务包括5个SELECT、UPDATE 和INSERT命令。可以通过编写自己的事务脚本文件按需进行定制化测试；sysbench是一个模块化、跨平台、多线程的性能基准测试工具，支持MySSL，PostgreSQL，Oracle。除此之外它还可以测试CPU，内存，文件系统等等。 redis-benchmark是Redis官方自带的Redis性能测试工具。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_2.png\"><br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_3.png\"></li>\n</ul>\n</li>\n<li><p>测试阶段<br>开箱即测得出的结果往往因为资源消耗不多，内部数据未老化导致数据偏好，因此测试之前需要进行初始化：例如预埋足够多的数据，触发SSD预留空间的写分配，触发垃圾回收；使用不可重删压缩的数据顺序写块设备以覆盖SSD更多的物理空间；格式化文件系统&#x2F;预置足够多的数据库记录等等。</p>\n</li>\n</ol>\n<p>另外，测试时间要足够长，排除噪音并搜集长稳测试的性能数据，反应真实的性能的同时观察IO波动。</p>\n<p>测试工具通常会输出格式化的报告，包含I&#x2F;O相关的性能指标。除此之外，可以视情况收集系统的资源使用情况作为辅助数据进行性能分析：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/img_4.png\"></p>\n<ol start=\"4\">\n<li>报告阶段<br>测试结束后，测试工程师搜集测试结果进行汇总并初步分析。尝试分析出现噪音，毛刺的原因并排错；分析数值偏高或偏低的可能原因；与相关产品、开发人员对齐初步结论，必要时重新测试。几轮之后得到可靠的性能数据后，接下来需要提炼测试结论，针对不同的观众输出相应的报告，这里有一些小技巧： <ul>\n<li>一目了然，尽量可视化，通过对比差异呈现优劣。</li>\n<li>调理清晰，主次分明：headlines first！详细数据分析往后放。</li>\n<li>覆盖关键指标，并开宗明义用简单直白的文字提炼结论</li>\n<li>针对产品经理的报告，尽量站在客户的角度写；针对开发和测试人员，则需要充分考虑并注明背后技术架构、工作环境的差异。<br>到这里我们已经流程化了一套存储性能测试方法，搜集到一组特定场景下的性能数据作为基线，它不一定具备普适性但却具有良好的参考价值。</li>\n</ul>\n</li>\n</ol>\n<p>接下来，可以通过微调测试环境进行更多场景的性能测试并与基线做对比；也可以通过性能分析工具进一步分析系统中的瓶颈或潜在的问题。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>看到这里，相信各位已经掌握了影响存储系统性能的因素以及存储性能测试的基本思路和常用工具，在面对天花乱坠的性能宣传时可以结合实际情况订制合适的性能测试方法亲自验证一番。</p>\n","slug":"云IaaS测试系列一存储性能及性能测试","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/10/28/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IaaS","slug":"IaaS","permalink":"http://vwin.github.io/tags/IaaS/"},{"name":"存储","slug":"存储","permalink":"http://vwin.github.io/tags/%E5%AD%98%E5%82%A8/"}]},{"title":"云IaaS测试系列一分布式存储测试实践3-自动化测试","date":"2022-10-25T07:26:01.000Z","path":"2022/10/25/云IaaS测试系列一分布式存储测试实践3-自动化测试/","text":"自动化测试是指通过一些自动化测试工具或者框架把之前以人为驱动的测试行为转换为以机器执行的测试过程。自动化测试作为测试领域的先进生产力很大程度上提升了测试执行效率，自动化通常与持续集成和持续交付（CICD）一起使用，没有自动化的CICD就像没有灵魂的躯壳，它的好处毋庸置疑。自动化测试是贯穿于研发流程的每个阶段，而不只是在系统测试阶段，比如单元测试、接口测试、功能测试以及集成测试等都适用于自动化测试。 概述自动化测试是指通过一些自动化测试工具或者框架把之前以人为驱动的测试行为转换为以机器执行的测试过程。自动化测试作为测试领域的先进生产力很大程度上提升了测试执行效率，自动化通常与持续集成和持续交付（CICD）一起使用，没有自动化的CICD就像没有灵魂的躯壳，它的好处毋庸置疑。自动化测试是贯穿于研发流程的每个阶段，而不只是在系统测试阶段，比如单元测试、接口测试、功能测试以及集成测试等都适用于自动化测试。 正确认识自动化在开展自动化测试之前首先需要对自动化测试有一个正确的认知： 自动化测试主要是为了提升测试效率自动化测试是整个研发流程中的其中一环，它是以提升测试效率为目的；软件系统的质量防护需要通过构建完整的测试体系以及规范研发流程，在每个环节来保证。 自动化测试是随着产品的功能变化而变化，并不是一劳永逸的当产品功能发生变化后，也要对相应的自动化测试脚本进行修改适配，以适应新的功能；因此对于产品功能特性变化比较大且变化比较频繁的产品或者特性，并不适合做自动化测试，否则自动化测试脚本的维护成本会变高，反而影响测试效率 不是所有的功能测试都可以自动化产品变化大且频繁的的功能、带主观判断的测试（如UI用户体验、需要依靠经验判断的测试）、必须人工参与的功能、产品表现不明确的功能以及需要操作硬件的功能不适合做自动化。 自动化测试对产品的可测试性和可观测性有很大的要求自动化测试对产品的可测试性和可观察性有很大的要求，手工测试可以通过查询日志、gdb打桩等方式实现测试和观察系统表现，但是自动化不能，因为这种方式极不稳定（比如日志的随意修改会导致自动化失败），对自动化测试很不友好，需要产品能够提供相关接口或者工具来做自动化测试。 自动化测试也是需要成本的自动化测试需要长期维护、持续建设以及需要研发开发可测试和可观察性需求，因此开展自动化测试之前，需要考虑ROI（投入回报率）。比如某些功能只是临时性的需求，需要投入精力去建设自动化用例，但是实际的利用率并不高，因此该类功能的自动化测试需要综合评估。 自动化测试也需要设计自动化框架的选取和架构需要设计，自动化是一个长期持续的建设过程，越到后期越需要兼容更多的产品特性和需求，所以需要不断重构和优化自动化的架构设计。 自动化测试需要长期持续利用自动化测试应该结合CICD流程长期利用，用的越多，自动化测试的价值越大 自动化测试自动化建设的首要任务是明确定义业务的用例集，比如建设产品基线用例库，然后根据用例集选择一个符合业务实际需求的自动化框架进行建设，基线用例库中需要明确包含哪些类型的测试，筛选出适合自动化以及自动化价值比较大的用例集，对于不适合做自动化的用例需要根据实际情况来定制化处理（如提可观测性需求给研发、手工测试）；以CBS产品为例，CBS产品基线用例库主要有以下几种类型的测试用例： 接口测试用例 功能测试用例 故障注入等可靠性测试用例 压力&#x2F;性能测试用例 升降级等可服务性测试用例 极端故障下的灾难测试用例 规格测试用例 探索性测试 自动化测试框架不能盲目的选择已有的自动化测试框架，框架选取更多的考虑是否适合当前业务，这依赖于对自动化用例的技术和需求把控，比如框架是否能够支持用例和配置解耦、是否支持在用例中进行并发和随机操作、是否支持测试集以及是否支持数据驱动等。选定自动化框架以后，需要对业务的自动化架构利用一些设计方法进行设计，比如设计公共库和公共方法、根据面向对象的设计方法设计用例结构和lib库等。下面是一个CBS自动化的简化版的架构设计： 公共Lib库提供了一些测试用例中必须的公共操作，如盘&#x2F;快照等相关操作、配置解析、故障注入类等，供测试用例中调用；测试环境以配置的方式由测试配置中指定并通过配置解析库解析后传入到测试用例使用，测试用例中分为前置、运行和后置步骤。 接口测试自动化接口类测试自动化成本较低，所以比较适合做自动化测试，其主要是对接口的参数、功能以及返回值做覆盖。接口测试一般需要如下 数据准备：准备被测接口需要的依赖数据 入口覆盖：对接口的参数进行完整性覆盖，包括正常和异常参数 数据完整性校验：校验接口的返回&#x2F;错误码以及一些DB中的数据相同接口的测试用例比较雷同，其本身的逻辑也相对简单，差别在于参数以及返回值的覆盖，比较适合用数据驱动的方式进行开发。如： 功能测试自动化功能测试和接口测试有部分重叠，其带有一定的业务场景和业务逻辑关系，功能测试自动化主要分为两种情况： 如果产品的接口设计的较好，则大部分功能测试可以通过接口的组合调用来覆盖，那么该类功能的自动化成本也较低，比较适合进行自动化建设； 如果产品的接口设计的不完善，则接口的组合调用只能覆盖部分功能，更多的功能需要一些其他手段：比如通过ssh登录到服务器进行shell命令操作，查看日志或者通过gdb打桩进行测试，那么这类功能的自动化建设相对较复杂，且稳定率容易受到网络&#x2F;机器等多方面的影响。 实际在IaaS层很多产品的功能测试都是第2种情况，不是简单的调用接口来覆盖，更多的是通过ssh登录到被测设备或者通过客户端给被测设备发送命令，然后通过特定的一些手段进行观测。一般来讲P0级别的用例（核心流程）基本可以通过调用接口来覆盖，但是非P0的用例测试手段和自动化手段都需要一些特别的方式来完成，其自动化成本也是因产品而异。以CBS为例，一个云盘迁移的功能用例如下： 该用例需要在迁移在pending状态时进行其他操作，实际在做自动化测试时，该pending状态很难捕捉到，需要使用打桩的方式进行，因此该类功能自动化成本较高。 故障注入测试自动化故障注入类的测试也可以做自动化，自动化成本因故障注入的难度而不同，一般情况会只针对L0级别的故障用例进行自动化，且自动化运行时只能串行运行（避免影响其他用例），所以故障测试用例的自动化率相对较低。故障注入测试用例一般并不是A-B-C这种流程式的执行方式，更多的是并行执行方式，比如A流程执行过程中并行注入B故障。另外故障注入测试用例的观察手段更多的是依赖监控手段来进行，传统的流程式自动化开发方式很难实现，因此该类测试比较适合使用CFT或者混沌测试的方式进行自动化测试，适用于在测试阶段进行持续测试和长稳测试。 压力性能测试自动化压力测试和性能测试会存在根据系统表现动态调整压力，并对系统的性能瓶颈进行分析和报表，测试过程中需要有一定的人工参与，一般都是半自动化状态，由手工测试和自动化测试结合进行。对于系统基准性能的测试，可以完全自动化。 可服务性测试自动化可服务性测试主要是指类似升级&#x2F;回退、卡件或者机器更换等方面的测试，在IaaS层的可服务性测试会有很多操作硬件设备的步骤，因此其自动化成本会非常高。一般这类测试的自动化主要聚焦于软件升级&#x2F;回退的自动化建设，软件升级&#x2F;回退的自动化对产品的升级回退能力有很大的诉求，比如升级回退流程固化的组件，其自动化成本较低，自动化率也相对较高；但是对于流程不固化的组件或者产品，其自动化维护成本将非常高，一般都不建议进行自动化测试。 兼容性测试自动化兼容性测试主要是指对被测系统的周边依赖（如数据库、操作系统、服务器及其他依赖组件等）进行兼容性验证，验证其相关的功能无兼容性问题，其测试内容以及兼容性测试点与业务强相关，非常适合用自动化来提升兼容性测试的效率（因为分布式系统的兼容性组合非常多），测试的前提是需要依赖产研侧有一个明确的兼容性列表。常见的流程如下图： 兼容性验证需要强依赖于研发和产品团队提供的兼容性列表（兼容性需求），因此在开展兼容性测试之前，需要产研明确出产品的兼容性需求 硬件兼容性对于CBS来讲，硬件兼容性主要是指机型（不同服务器搭配不同型号、数量、类型的硬盘以及CPU和内存的配置）的兼容性 数据库兼容性对于CBS来讲，数据库都是用云CDB，因此此处的数据库兼容性主要是验证数据库版本的兼容性。 软件兼容性变更兼容性测试CBS作为分布式存储，集群节点数较多，升级变更并不是一次性变更所有节点，而是按照节点和地域分批灰度变更，因此升级过程中的版本兼容性是影响升级过程中服务稳定性的一个重大风险，变更测试跟具体的变更策略有关，以CBS存储系统为例，需要以不中断用户IO为目标进行变更，变更过程中以一定的业务压力（如40%-50%压力）为背景，依次变更三副本中的某一边，每次变更单边后进行业务恢复和P0自动化验证，观察变更对用户io的影响，如下图 操作系统兼容性主要是指对被测系统所部署的操作系统进行兼容性验证 第三方组件兼容性如前文所知，分布式系统由很多组件组成，因此需要验证被测组件与直接交互的其他组件的版本兼容性，已确保服务没有兼容性问题。 示例组件A需要支持从版本A1~An共n个版本的升级，并有如下依赖： 组件B：需要兼容b个版本 组件C：需要兼容c个版本 数据库D：需要兼容d个版本 机型M：需要兼容m个机型 操作系统O：需要兼容o个机型因此，需要验证的兼容性组合最多有nbcdm*o个组合，组合非常多，实际测试过程中要覆盖所有的组合并不现实，因此，我们需要尽可能收敛每个影响兼容性的因子，最好的情况是每个依赖都只有1个版本，那只需要测一次兼容性即可。 规格测试自动化规格测试主要是指对产品的外部和内部规格指标进行测试，比如一个母机上支持挂载云盘的最大规格数，该类测试比较适合做自动化测试。但是，规格测试对环境诉求极高，需要投入一定对资源设备成本，一般在测试环境很难开展全面的规格测试。在我们当前的产品测试中，对于有明确规格的并对资源要求相对可控的测试一般会进行规格测试，并且进行自动化建设，比如： 单仓库最大允许创建的云盘数量 单CVM最大允许挂载的云盘数量等 CFT测试自动化CFT测试可以作为探索性测试的一个分支，比较适合利用自动化测试来开展，它并不是一个个非A即B的测试用例，而是由很多单一的原子用例并发或者随机调度组成的一套综合性的测试集合。CFT测试对自动化框架有很大的要求，需要框架能支持用例的并发性、随机性、调度的灵活性以及用例之间的数据交换等特性。 测试单元集包含每个最小粒度的测试行为，可以是单个测试用例，也可以是单个测试步骤，如正常的盘操作用例&#x2F;运维变更步骤或者故障步骤，测试套中包含多个按多种调度维度分类的测试单元，如顺序调度分组的测试单元按照A-B-C这种顺序执行，随机调度分组的测试单元按照随机的方式选择测试单元执行，测试套内的多个分组并行执行，中间产生的数据或者比测依赖的数据通过缓存交换数据。通过这种方式可以尽可能的模拟多客户的真实操作，多个特性和故障及相关操作随机并发运行。 自动化测试的应用自动化测试必须依托于DevOps研发流程来使用，否则自动化测试的价值就极其有限。前面讲了自动化按照测试维度分为接口&#x2F;功能以及各种系统级自动化测试，每种类型的自动化应该在不同的研发阶段发挥不同的价值，以下是CBS自动化测试在研发流程的使用方式： 开发阶段：在开发阶段主要通过CI流水线的方式（无论是代码提交触发的开发流水线还是定时出发的日构建流水线）承载流水线的方式，能够持续通过自动化来反馈开发阶段的代码质量。一般建议日构建流水线可以跑全量的自动化测试。 提测阶段：在提测流程中，使用接口&#x2F;功能以及P0级别的系统测试自动化作为提测的门禁，保障测试介入前提测产品的质量，避免因质量不合格导致的测试阻塞等影响测试效率的情况。 测试阶段：自动化测试在测试阶段的应用不止于回归测试，其应该贯穿于整个测试阶段进行持续测试 发布阶段：自动化测试在发布阶段主要作用是验证发布阶段的质量，需要能够快速反馈，一旦发布测试出错，需要及时回退。所以对发布测试用例的选取不仅要考虑功能的覆盖度，也要考虑自动化测试的执行时间。 现网运营阶段：这一阶段的自动化测试主要分为两类：拨测自动化和日常现网运营自动化，拨测自动化需要长期持续运行，一般跟发布阶段的自动化测试一致，主要是保证系统的核心能力不出问题，一但出错能够快速反馈；日常现网运营自动化一般是按需定时运行，内容主要覆盖功能和接口的P0用例。 自动化测试的挑战自动化测试主要的挑战在于自动化用例的健壮性和自动化框架的扩展性，自动化用例运行难免会失败或出错，造成自动化测试失败的原因有很多，大概可以分为以下几类： 被测系统Bug：这部分失败是我们希望看到的，说明自动化测试拦截了bug，这才是自动化测试的价值 工具或被测环境的问题：这部分主要是指自动化工具和被测环境出了问题，如执行机负载过高、被测环境异常或者遗留脏数据等问题，我们应该尽量收敛该类问题，一旦出现该类问题，说明我们这次的自动化测试是无效的。 测试用例的问题：测试用例因为被测系统的行为出现了变化没有同步适配，或者自动化用例本身有bug导致，我们也应该尽量收敛该类问题。 第三方不可抗拒因素：比如机器下线、网络问题等问题，这部分我们基本无能为力，只能在实际运营过程中持续去优化自动化用例，来减少部分不可抗因素对自动化用例的影响。 自动化测试是一个长期持续的过程，需要持续的维稳并长期利用才能发挥其价值，罗马不是一天建起来的，自动化测试也不是一天能够稳定的，需要包容部分失败，只有长期使用，自动化才会越来越稳，越来越发挥其价值，这也是对研发和测试团队最大的挑战。 结语自动化测试只是作为一种提升测试效率的测试工具，它并不是万能的，不能指望自动化测试能发现和拦截所有问题，它只是尽最大可能发现更多问题，更不能指望自动化测试替代人工测试，尤其是复杂的系统。我们要正确的认识自动化测试，合理的利用自动化测试。","raw":"---\ntitle: 云IaaS测试系列一分布式存储测试实践3-自动化测试\ntoc: true\ndate: 2022-10-25 15:26:01\ntags: [Iaas,分布式]\ncategories: [技术]\ndescription:\n---\n\n自动化测试是指通过一些自动化测试工具或者框架把之前以人为驱动的测试行为转换为以机器执行的测试过程。自动化测试作为测试领域的先进生产力很大程度上提升了测试执行效率，自动化通常与持续集成和持续交付（CICD）一起使用，没有自动化的CICD就像没有灵魂的躯壳，它的好处毋庸置疑。自动化测试是贯穿于研发流程的每个阶段，而不只是在系统测试阶段，比如单元测试、接口测试、功能测试以及集成测试等都适用于自动化测试。\n\n<!-- more -->\n\n# 概述\n自动化测试是指通过一些自动化测试工具或者框架把之前以人为驱动的测试行为转换为以机器执行的测试过程。自动化测试作为测试领域的先进生产力很大程度上提升了测试执行效率，自动化通常与持续集成和持续交付（CICD）一起使用，没有自动化的CICD就像没有灵魂的躯壳，它的好处毋庸置疑。自动化测试是贯穿于研发流程的每个阶段，而不只是在系统测试阶段，比如单元测试、接口测试、功能测试以及集成测试等都适用于自动化测试。\n\n# 正确认识自动化\n在开展自动化测试之前首先需要对自动化测试有一个正确的认知：\n\n1. 自动化测试主要是为了提升测试效率\n自动化测试是整个研发流程中的其中一环，它是以提升测试效率为目的；软件系统的质量防护需要通过构建完整的测试体系以及规范研发流程，在每个环节来保证。\n\n2. 自动化测试是随着产品的功能变化而变化，并不是一劳永逸的\n当产品功能发生变化后，也要对相应的自动化测试脚本进行修改适配，以适应新的功能；因此对于产品功能特性变化比较大且变化比较频繁的产品或者特性，并不适合做自动化测试，否则自动化测试脚本的维护成本会变高，反而影响测试效率\n\n3. 不是所有的功能测试都可以自动化\n产品变化大且频繁的的功能、带主观判断的测试（如UI用户体验、需要依靠经验判断的测试）、必须人工参与的功能、产品表现不明确的功能以及需要操作硬件的功能不适合做自动化。\n\n4. 自动化测试对产品的可测试性和可观测性有很大的要求\n自动化测试对产品的可测试性和可观察性有很大的要求，手工测试可以通过查询日志、gdb打桩等方式实现测试和观察系统表现，但是自动化不能，因为这种方式极不稳定（比如日志的随意修改会导致自动化失败），对自动化测试很不友好，需要产品能够提供相关接口或者工具来做自动化测试。\n\n5. 自动化测试也是需要成本的\n自动化测试需要长期维护、持续建设以及需要研发开发可测试和可观察性需求，因此开展自动化测试之前，需要考虑ROI（投入回报率）。比如某些功能只是临时性的需求，需要投入精力去建设自动化用例，但是实际的利用率并不高，因此该类功能的自动化测试需要综合评估。\n\n6. 自动化测试也需要设计\n自动化框架的选取和架构需要设计，自动化是一个长期持续的建设过程，越到后期越需要兼容更多的产品特性和需求，所以需要不断重构和优化自动化的架构设计。\n\n7. 自动化测试需要长期持续利用\n自动化测试应该结合CICD流程长期利用，用的越多，自动化测试的价值越大\n\n# 自动化测试\n自动化建设的首要任务是明确定义业务的用例集，比如建设产品基线用例库，然后根据用例集选择一个符合业务实际需求的自动化框架进行建设，基线用例库中需要明确包含哪些类型的测试，筛选出适合自动化以及自动化价值比较大的用例集，对于不适合做自动化的用例需要根据实际情况来定制化处理（如提可观测性需求给研发、手工测试）；以CBS产品为例，CBS产品基线用例库主要有以下几种类型的测试用例：\n- 接口测试用例 \n- 功能测试用例 \n- 故障注入等可靠性测试用例 \n- 压力/性能测试用例 \n- 升降级等可服务性测试用例 \n- 极端故障下的灾难测试用例 \n- 规格测试用例 \n- 探索性测试\n\n## 自动化测试框架\n不能盲目的选择已有的自动化测试框架，框架选取更多的考虑是否适合当前业务，这依赖于对自动化用例的技术和需求把控，比如框架是否能够支持用例和配置解耦、是否支持在用例中进行并发和随机操作、是否支持测试集以及是否支持数据驱动等。选定自动化框架以后，需要对业务的自动化架构利用一些设计方法进行设计，比如设计公共库和公共方法、根据面向对象的设计方法设计用例结构和lib库等。下面是一个CBS自动化的简化版的架构设计：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img.png)\n\n公共Lib库提供了一些测试用例中必须的公共操作，如盘/快照等相关操作、配置解析、故障注入类等，供测试用例中调用；测试环境以配置的方式由测试配置中指定并通过配置解析库解析后传入到测试用例使用，测试用例中分为前置、运行和后置步骤。\n\n## 接口测试自动化\n接口类测试自动化成本较低，所以比较适合做自动化测试，其主要是对接口的参数、功能以及返回值做覆盖。接口测试一般需要如下\n\n1. 数据准备：准备被测接口需要的依赖数据\n2. 入口覆盖：对接口的参数进行完整性覆盖，包括正常和异常参数\n3. 数据完整性校验：校验接口的返回/错误码以及一些DB中的数据\n相同接口的测试用例比较雷同，其本身的逻辑也相对简单，差别在于参数以及返回值的覆盖，比较适合用数据驱动的方式进行开发。如：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_1.png)\n\n## 功能测试自动化\n功能测试和接口测试有部分重叠，其带有一定的业务场景和业务逻辑关系，功能测试自动化主要分为两种情况：\n\n1. 如果产品的接口设计的较好，则大部分功能测试可以通过接口的组合调用来覆盖，那么该类功能的自动化成本也较低，比较适合进行自动化建设；\n2. 如果产品的接口设计的不完善，则接口的组合调用只能覆盖部分功能，更多的功能需要一些其他手段：比如通过ssh登录到服务器进行shell命令操作，查看日志或者通过gdb打桩进行测试，那么这类功能的自动化建设相对较复杂，且稳定率容易受到网络/机器等多方面的影响。\n\n实际在IaaS层很多产品的功能测试都是第2种情况，不是简单的调用接口来覆盖，更多的是通过ssh登录到被测设备或者通过客户端给被测设备发送命令，然后通过特定的一些手段进行观测。一般来讲P0级别的用例（核心流程）基本可以通过调用接口来覆盖，但是非P0的用例测试手段和自动化手段都需要一些特别的方式来完成，其自动化成本也是因产品而异。以CBS为例，一个云盘迁移的功能用例如下：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_2.png)\n\n该用例需要在迁移在pending状态时进行其他操作，实际在做自动化测试时，该pending状态很难捕捉到，需要使用打桩的方式进行，因此该类功能自动化成本较高。\n\n## 故障注入测试自动化\n故障注入类的测试也可以做自动化，自动化成本因故障注入的难度而不同，一般情况会只针对L0级别的故障用例进行自动化，且自动化运行时只能串行运行（避免影响其他用例），所以故障测试用例的自动化率相对较低。故障注入测试用例一般并不是A-B-C这种流程式的执行方式，更多的是并行执行方式，比如A流程执行过程中并行注入B故障。另外故障注入测试用例的观察手段更多的是依赖监控手段来进行，传统的流程式自动化开发方式很难实现，因此该类测试比较适合使用CFT或者混沌测试的方式进行自动化测试，适用于在测试阶段进行持续测试和长稳测试。\n\n## 压力性能测试自动化\n压力测试和性能测试会存在根据系统表现动态调整压力，并对系统的性能瓶颈进行分析和报表，测试过程中需要有一定的人工参与，一般都是半自动化状态，由手工测试和自动化测试结合进行。对于系统基准性能的测试，可以完全自动化。\n\n## 可服务性测试自动化\n可服务性测试主要是指类似升级/回退、卡件或者机器更换等方面的测试，在IaaS层的可服务性测试会有很多操作硬件设备的步骤，因此其自动化成本会非常高。一般这类测试的自动化主要聚焦于软件升级/回退的自动化建设，软件升级/回退的自动化对产品的升级回退能力有很大的诉求，比如升级回退流程固化的组件，其自动化成本较低，自动化率也相对较高；但是对于流程不固化的组件或者产品，其自动化维护成本将非常高，一般都不建议进行自动化测试。\n\n## 兼容性测试自动化\n兼容性测试主要是指对被测系统的周边依赖（如数据库、操作系统、服务器及其他依赖组件等）进行兼容性验证，验证其相关的功能无兼容性问题，其测试内容以及兼容性测试点与业务强相关，非常适合用自动化来提升兼容性测试的效率（因为分布式系统的兼容性组合非常多），测试的前提是需要依赖产研侧有一个明确的兼容性列表。常见的流程如下图：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_3.png)\n\n> 兼容性验证需要强依赖于研发和产品团队提供的兼容性列表（兼容性需求），因此在开展兼容性测试之前，需要产研明确出产品的兼容性需求\n\n### 硬件兼容性\n对于CBS来讲，硬件兼容性主要是指机型（不同服务器搭配不同型号、数量、类型的硬盘以及CPU和内存的配置）的兼容性\n\n### 数据库兼容性\n对于CBS来讲，数据库都是用云CDB，因此此处的数据库兼容性主要是验证数据库版本的兼容性。\n\n### 软件兼容性\n#### 变更兼容性测试\n\nCBS作为分布式存储，集群节点数较多，升级变更并不是一次性变更所有节点，而是按照节点和地域分批灰度变更，因此升级过程中的版本兼容性是影响升级过程中服务稳定性的一个重大风险，变更测试跟具体的变更策略有关，以CBS存储系统为例，需要以不中断用户IO为目标进行变更，变更过程中以一定的业务压力（如40%-50%压力）为背景，依次变更三副本中的某一边，每次变更单边后进行业务恢复和P0自动化验证，观察变更对用户io的影响，如下图\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_4.png)\n\n#### 操作系统兼容性\n\n主要是指对被测系统所部署的操作系统进行兼容性验证\n\n#### 第三方组件兼容性\n\n如前文所知，分布式系统由很多组件组成，因此需要验证被测组件与直接交互的其他组件的版本兼容性，已确保服务没有兼容性问题。\n\n### 示例\n组件A需要支持从版本A1~An共n个版本的升级，并有如下依赖：\n\n1. 组件B：需要兼容b个版本\n2. 组件C：需要兼容c个版本\n3. 数据库D：需要兼容d个版本\n4. 机型M：需要兼容m个机型\n5. 操作系统O：需要兼容o个机型\n因此，需要验证的兼容性组合最多有n*b*c*d*m*o个组合，组合非常多，实际测试过程中要覆盖所有的组合并不现实，因此，我们需要尽可能收敛每个影响兼容性的因子，最好的情况是每个依赖都只有1个版本，那只需要测一次兼容性即可。\n\n## 规格测试自动化\n规格测试主要是指对产品的外部和内部规格指标进行测试，比如一个母机上支持挂载云盘的最大规格数，该类测试比较适合做自动化测试。但是，规格测试对环境诉求极高，需要投入一定对资源设备成本，一般在测试环境很难开展全面的规格测试。在我们当前的产品测试中，对于有明确规格的并对资源要求相对可控的测试一般会进行规格测试，并且进行自动化建设，比如：\n1. 单仓库最大允许创建的云盘数量 \n2. 单CVM最大允许挂载的云盘数量等\n\n## CFT测试自动化\nCFT测试可以作为探索性测试的一个分支，比较适合利用自动化测试来开展，它并不是一个个非A即B的测试用例，而是由很多单一的原子用例并发或者随机调度组成的一套综合性的测试集合。CFT测试对自动化框架有很大的要求，需要框架能支持用例的并发性、随机性、调度的灵活性以及用例之间的数据交换等特性。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_5.png)\n\n测试单元集包含每个最小粒度的测试行为，可以是单个测试用例，也可以是单个测试步骤，如正常的盘操作用例/运维变更步骤或者故障步骤，测试套中包含多个按多种调度维度分类的测试单元，如顺序调度分组的测试单元按照A-B-C这种顺序执行，随机调度分组的测试单元按照随机的方式选择测试单元执行，测试套内的多个分组并行执行，中间产生的数据或者比测依赖的数据通过缓存交换数据。通过这种方式可以尽可能的模拟多客户的真实操作，多个特性和故障及相关操作随机并发运行。\n\n# 自动化测试的应用\n自动化测试必须依托于DevOps研发流程来使用，否则自动化测试的价值就极其有限。前面讲了自动化按照测试维度分为接口/功能以及各种系统级自动化测试，每种类型的自动化应该在不同的研发阶段发挥不同的价值，以下是CBS自动化测试在研发流程的使用方式：\n\n1. 开发阶段：在开发阶段主要通过CI流水线的方式（无论是代码提交触发的开发流水线还是定时出发的日构建流水线）承载流水线的方式，能够持续通过自动化来反馈开发阶段的代码质量。一般建议日构建流水线可以跑全量的自动化测试。\n2. 提测阶段：在提测流程中，使用接口/功能以及P0级别的系统测试自动化作为提测的门禁，保障测试介入前提测产品的质量，避免因质量不合格导致的测试阻塞等影响测试效率的情况。\n3. 测试阶段：自动化测试在测试阶段的应用不止于回归测试，其应该贯穿于整个测试阶段进行持续测试\n   ![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_6.png)\n4. 发布阶段：自动化测试在发布阶段主要作用是验证发布阶段的质量，需要能够快速反馈，一旦发布测试出错，需要及时回退。所以对发布测试用例的选取不仅要考虑功能的覆盖度，也要考虑自动化测试的执行时间。\n5. 现网运营阶段：这一阶段的自动化测试主要分为两类：拨测自动化和日常现网运营自动化，拨测自动化需要长期持续运行，一般跟发布阶段的自动化测试一致，主要是保证系统的核心能力不出问题，一但出错能够快速反馈；日常现网运营自动化一般是按需定时运行，内容主要覆盖功能和接口的P0用例。\n\n# 自动化测试的挑战\n自动化测试主要的挑战在于自动化用例的健壮性和自动化框架的扩展性，自动化用例运行难免会失败或出错，造成自动化测试失败的原因有很多，大概可以分为以下几类：\n\n1. 被测系统Bug：这部分失败是我们希望看到的，说明自动化测试拦截了bug，这才是自动化测试的价值\n2. 工具或被测环境的问题：这部分主要是指自动化工具和被测环境出了问题，如执行机负载过高、被测环境异常或者遗留脏数据等问题，我们应该尽量收敛该类问题，一旦出现该类问题，说明我们这次的自动化测试是无效的。\n3. 测试用例的问题：测试用例因为被测系统的行为出现了变化没有同步适配，或者自动化用例本身有bug导致，我们也应该尽量收敛该类问题。\n4. 第三方不可抗拒因素：比如机器下线、网络问题等问题，这部分我们基本无能为力，只能在实际运营过程中持续去优化自动化用例，来减少部分不可抗因素对自动化用例的影响。\n\n自动化测试是一个长期持续的过程，需要持续的维稳并长期利用才能发挥其价值，罗马不是一天建起来的，自动化测试也不是一天能够稳定的，需要包容部分失败，只有长期使用，自动化才会越来越稳，越来越发挥其价值，这也是对研发和测试团队最大的挑战。\n\n# 结语\n自动化测试只是作为一种提升测试效率的测试工具，它并不是万能的，不能指望自动化测试能发现和拦截所有问题，它只是尽最大可能发现更多问题，更不能指望自动化测试替代人工测试，尤其是复杂的系统。我们要正确的认识自动化测试，合理的利用自动化测试。\n\n\n\n\n\n\n\n\n\n\n","content":"<p>自动化测试是指通过一些自动化测试工具或者框架把之前以人为驱动的测试行为转换为以机器执行的测试过程。自动化测试作为测试领域的先进生产力很大程度上提升了测试执行效率，自动化通常与持续集成和持续交付（CICD）一起使用，没有自动化的CICD就像没有灵魂的躯壳，它的好处毋庸置疑。自动化测试是贯穿于研发流程的每个阶段，而不只是在系统测试阶段，比如单元测试、接口测试、功能测试以及集成测试等都适用于自动化测试。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>自动化测试是指通过一些自动化测试工具或者框架把之前以人为驱动的测试行为转换为以机器执行的测试过程。自动化测试作为测试领域的先进生产力很大程度上提升了测试执行效率，自动化通常与持续集成和持续交付（CICD）一起使用，没有自动化的CICD就像没有灵魂的躯壳，它的好处毋庸置疑。自动化测试是贯穿于研发流程的每个阶段，而不只是在系统测试阶段，比如单元测试、接口测试、功能测试以及集成测试等都适用于自动化测试。</p>\n<h1 id=\"正确认识自动化\"><a href=\"#正确认识自动化\" class=\"headerlink\" title=\"正确认识自动化\"></a>正确认识自动化</h1><p>在开展自动化测试之前首先需要对自动化测试有一个正确的认知：</p>\n<ol>\n<li><p>自动化测试主要是为了提升测试效率<br>自动化测试是整个研发流程中的其中一环，它是以提升测试效率为目的；软件系统的质量防护需要通过构建完整的测试体系以及规范研发流程，在每个环节来保证。</p>\n</li>\n<li><p>自动化测试是随着产品的功能变化而变化，并不是一劳永逸的<br>当产品功能发生变化后，也要对相应的自动化测试脚本进行修改适配，以适应新的功能；因此对于产品功能特性变化比较大且变化比较频繁的产品或者特性，并不适合做自动化测试，否则自动化测试脚本的维护成本会变高，反而影响测试效率</p>\n</li>\n<li><p>不是所有的功能测试都可以自动化<br>产品变化大且频繁的的功能、带主观判断的测试（如UI用户体验、需要依靠经验判断的测试）、必须人工参与的功能、产品表现不明确的功能以及需要操作硬件的功能不适合做自动化。</p>\n</li>\n<li><p>自动化测试对产品的可测试性和可观测性有很大的要求<br>自动化测试对产品的可测试性和可观察性有很大的要求，手工测试可以通过查询日志、gdb打桩等方式实现测试和观察系统表现，但是自动化不能，因为这种方式极不稳定（比如日志的随意修改会导致自动化失败），对自动化测试很不友好，需要产品能够提供相关接口或者工具来做自动化测试。</p>\n</li>\n<li><p>自动化测试也是需要成本的<br>自动化测试需要长期维护、持续建设以及需要研发开发可测试和可观察性需求，因此开展自动化测试之前，需要考虑ROI（投入回报率）。比如某些功能只是临时性的需求，需要投入精力去建设自动化用例，但是实际的利用率并不高，因此该类功能的自动化测试需要综合评估。</p>\n</li>\n<li><p>自动化测试也需要设计<br>自动化框架的选取和架构需要设计，自动化是一个长期持续的建设过程，越到后期越需要兼容更多的产品特性和需求，所以需要不断重构和优化自动化的架构设计。</p>\n</li>\n<li><p>自动化测试需要长期持续利用<br>自动化测试应该结合CICD流程长期利用，用的越多，自动化测试的价值越大</p>\n</li>\n</ol>\n<h1 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h1><p>自动化建设的首要任务是明确定义业务的用例集，比如建设产品基线用例库，然后根据用例集选择一个符合业务实际需求的自动化框架进行建设，基线用例库中需要明确包含哪些类型的测试，筛选出适合自动化以及自动化价值比较大的用例集，对于不适合做自动化的用例需要根据实际情况来定制化处理（如提可观测性需求给研发、手工测试）；以CBS产品为例，CBS产品基线用例库主要有以下几种类型的测试用例：</p>\n<ul>\n<li>接口测试用例 </li>\n<li>功能测试用例 </li>\n<li>故障注入等可靠性测试用例 </li>\n<li>压力&#x2F;性能测试用例 </li>\n<li>升降级等可服务性测试用例 </li>\n<li>极端故障下的灾难测试用例 </li>\n<li>规格测试用例 </li>\n<li>探索性测试</li>\n</ul>\n<h2 id=\"自动化测试框架\"><a href=\"#自动化测试框架\" class=\"headerlink\" title=\"自动化测试框架\"></a>自动化测试框架</h2><p>不能盲目的选择已有的自动化测试框架，框架选取更多的考虑是否适合当前业务，这依赖于对自动化用例的技术和需求把控，比如框架是否能够支持用例和配置解耦、是否支持在用例中进行并发和随机操作、是否支持测试集以及是否支持数据驱动等。选定自动化框架以后，需要对业务的自动化架构利用一些设计方法进行设计，比如设计公共库和公共方法、根据面向对象的设计方法设计用例结构和lib库等。下面是一个CBS自动化的简化版的架构设计：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img.png\"></p>\n<p>公共Lib库提供了一些测试用例中必须的公共操作，如盘&#x2F;快照等相关操作、配置解析、故障注入类等，供测试用例中调用；测试环境以配置的方式由测试配置中指定并通过配置解析库解析后传入到测试用例使用，测试用例中分为前置、运行和后置步骤。</p>\n<h2 id=\"接口测试自动化\"><a href=\"#接口测试自动化\" class=\"headerlink\" title=\"接口测试自动化\"></a>接口测试自动化</h2><p>接口类测试自动化成本较低，所以比较适合做自动化测试，其主要是对接口的参数、功能以及返回值做覆盖。接口测试一般需要如下</p>\n<ol>\n<li>数据准备：准备被测接口需要的依赖数据</li>\n<li>入口覆盖：对接口的参数进行完整性覆盖，包括正常和异常参数</li>\n<li>数据完整性校验：校验接口的返回&#x2F;错误码以及一些DB中的数据<br>相同接口的测试用例比较雷同，其本身的逻辑也相对简单，差别在于参数以及返回值的覆盖，比较适合用数据驱动的方式进行开发。如：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_1.png\"></li>\n</ol>\n<h2 id=\"功能测试自动化\"><a href=\"#功能测试自动化\" class=\"headerlink\" title=\"功能测试自动化\"></a>功能测试自动化</h2><p>功能测试和接口测试有部分重叠，其带有一定的业务场景和业务逻辑关系，功能测试自动化主要分为两种情况：</p>\n<ol>\n<li>如果产品的接口设计的较好，则大部分功能测试可以通过接口的组合调用来覆盖，那么该类功能的自动化成本也较低，比较适合进行自动化建设；</li>\n<li>如果产品的接口设计的不完善，则接口的组合调用只能覆盖部分功能，更多的功能需要一些其他手段：比如通过ssh登录到服务器进行shell命令操作，查看日志或者通过gdb打桩进行测试，那么这类功能的自动化建设相对较复杂，且稳定率容易受到网络&#x2F;机器等多方面的影响。</li>\n</ol>\n<p>实际在IaaS层很多产品的功能测试都是第2种情况，不是简单的调用接口来覆盖，更多的是通过ssh登录到被测设备或者通过客户端给被测设备发送命令，然后通过特定的一些手段进行观测。一般来讲P0级别的用例（核心流程）基本可以通过调用接口来覆盖，但是非P0的用例测试手段和自动化手段都需要一些特别的方式来完成，其自动化成本也是因产品而异。以CBS为例，一个云盘迁移的功能用例如下：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_2.png\"></p>\n<p>该用例需要在迁移在pending状态时进行其他操作，实际在做自动化测试时，该pending状态很难捕捉到，需要使用打桩的方式进行，因此该类功能自动化成本较高。</p>\n<h2 id=\"故障注入测试自动化\"><a href=\"#故障注入测试自动化\" class=\"headerlink\" title=\"故障注入测试自动化\"></a>故障注入测试自动化</h2><p>故障注入类的测试也可以做自动化，自动化成本因故障注入的难度而不同，一般情况会只针对L0级别的故障用例进行自动化，且自动化运行时只能串行运行（避免影响其他用例），所以故障测试用例的自动化率相对较低。故障注入测试用例一般并不是A-B-C这种流程式的执行方式，更多的是并行执行方式，比如A流程执行过程中并行注入B故障。另外故障注入测试用例的观察手段更多的是依赖监控手段来进行，传统的流程式自动化开发方式很难实现，因此该类测试比较适合使用CFT或者混沌测试的方式进行自动化测试，适用于在测试阶段进行持续测试和长稳测试。</p>\n<h2 id=\"压力性能测试自动化\"><a href=\"#压力性能测试自动化\" class=\"headerlink\" title=\"压力性能测试自动化\"></a>压力性能测试自动化</h2><p>压力测试和性能测试会存在根据系统表现动态调整压力，并对系统的性能瓶颈进行分析和报表，测试过程中需要有一定的人工参与，一般都是半自动化状态，由手工测试和自动化测试结合进行。对于系统基准性能的测试，可以完全自动化。</p>\n<h2 id=\"可服务性测试自动化\"><a href=\"#可服务性测试自动化\" class=\"headerlink\" title=\"可服务性测试自动化\"></a>可服务性测试自动化</h2><p>可服务性测试主要是指类似升级&#x2F;回退、卡件或者机器更换等方面的测试，在IaaS层的可服务性测试会有很多操作硬件设备的步骤，因此其自动化成本会非常高。一般这类测试的自动化主要聚焦于软件升级&#x2F;回退的自动化建设，软件升级&#x2F;回退的自动化对产品的升级回退能力有很大的诉求，比如升级回退流程固化的组件，其自动化成本较低，自动化率也相对较高；但是对于流程不固化的组件或者产品，其自动化维护成本将非常高，一般都不建议进行自动化测试。</p>\n<h2 id=\"兼容性测试自动化\"><a href=\"#兼容性测试自动化\" class=\"headerlink\" title=\"兼容性测试自动化\"></a>兼容性测试自动化</h2><p>兼容性测试主要是指对被测系统的周边依赖（如数据库、操作系统、服务器及其他依赖组件等）进行兼容性验证，验证其相关的功能无兼容性问题，其测试内容以及兼容性测试点与业务强相关，非常适合用自动化来提升兼容性测试的效率（因为分布式系统的兼容性组合非常多），测试的前提是需要依赖产研侧有一个明确的兼容性列表。常见的流程如下图：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_3.png\"></p>\n<blockquote>\n<p>兼容性验证需要强依赖于研发和产品团队提供的兼容性列表（兼容性需求），因此在开展兼容性测试之前，需要产研明确出产品的兼容性需求</p>\n</blockquote>\n<h3 id=\"硬件兼容性\"><a href=\"#硬件兼容性\" class=\"headerlink\" title=\"硬件兼容性\"></a>硬件兼容性</h3><p>对于CBS来讲，硬件兼容性主要是指机型（不同服务器搭配不同型号、数量、类型的硬盘以及CPU和内存的配置）的兼容性</p>\n<h3 id=\"数据库兼容性\"><a href=\"#数据库兼容性\" class=\"headerlink\" title=\"数据库兼容性\"></a>数据库兼容性</h3><p>对于CBS来讲，数据库都是用云CDB，因此此处的数据库兼容性主要是验证数据库版本的兼容性。</p>\n<h3 id=\"软件兼容性\"><a href=\"#软件兼容性\" class=\"headerlink\" title=\"软件兼容性\"></a>软件兼容性</h3><h4 id=\"变更兼容性测试\"><a href=\"#变更兼容性测试\" class=\"headerlink\" title=\"变更兼容性测试\"></a>变更兼容性测试</h4><p>CBS作为分布式存储，集群节点数较多，升级变更并不是一次性变更所有节点，而是按照节点和地域分批灰度变更，因此升级过程中的版本兼容性是影响升级过程中服务稳定性的一个重大风险，变更测试跟具体的变更策略有关，以CBS存储系统为例，需要以不中断用户IO为目标进行变更，变更过程中以一定的业务压力（如40%-50%压力）为背景，依次变更三副本中的某一边，每次变更单边后进行业务恢复和P0自动化验证，观察变更对用户io的影响，如下图<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_4.png\"></p>\n<h4 id=\"操作系统兼容性\"><a href=\"#操作系统兼容性\" class=\"headerlink\" title=\"操作系统兼容性\"></a>操作系统兼容性</h4><p>主要是指对被测系统所部署的操作系统进行兼容性验证</p>\n<h4 id=\"第三方组件兼容性\"><a href=\"#第三方组件兼容性\" class=\"headerlink\" title=\"第三方组件兼容性\"></a>第三方组件兼容性</h4><p>如前文所知，分布式系统由很多组件组成，因此需要验证被测组件与直接交互的其他组件的版本兼容性，已确保服务没有兼容性问题。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>组件A需要支持从版本A1~An共n个版本的升级，并有如下依赖：</p>\n<ol>\n<li>组件B：需要兼容b个版本</li>\n<li>组件C：需要兼容c个版本</li>\n<li>数据库D：需要兼容d个版本</li>\n<li>机型M：需要兼容m个机型</li>\n<li>操作系统O：需要兼容o个机型<br>因此，需要验证的兼容性组合最多有n<em>b</em>c<em>d</em>m*o个组合，组合非常多，实际测试过程中要覆盖所有的组合并不现实，因此，我们需要尽可能收敛每个影响兼容性的因子，最好的情况是每个依赖都只有1个版本，那只需要测一次兼容性即可。</li>\n</ol>\n<h2 id=\"规格测试自动化\"><a href=\"#规格测试自动化\" class=\"headerlink\" title=\"规格测试自动化\"></a>规格测试自动化</h2><p>规格测试主要是指对产品的外部和内部规格指标进行测试，比如一个母机上支持挂载云盘的最大规格数，该类测试比较适合做自动化测试。但是，规格测试对环境诉求极高，需要投入一定对资源设备成本，一般在测试环境很难开展全面的规格测试。在我们当前的产品测试中，对于有明确规格的并对资源要求相对可控的测试一般会进行规格测试，并且进行自动化建设，比如：</p>\n<ol>\n<li>单仓库最大允许创建的云盘数量 </li>\n<li>单CVM最大允许挂载的云盘数量等</li>\n</ol>\n<h2 id=\"CFT测试自动化\"><a href=\"#CFT测试自动化\" class=\"headerlink\" title=\"CFT测试自动化\"></a>CFT测试自动化</h2><p>CFT测试可以作为探索性测试的一个分支，比较适合利用自动化测试来开展，它并不是一个个非A即B的测试用例，而是由很多单一的原子用例并发或者随机调度组成的一套综合性的测试集合。CFT测试对自动化框架有很大的要求，需要框架能支持用例的并发性、随机性、调度的灵活性以及用例之间的数据交换等特性。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_5.png\"></p>\n<p>测试单元集包含每个最小粒度的测试行为，可以是单个测试用例，也可以是单个测试步骤，如正常的盘操作用例&#x2F;运维变更步骤或者故障步骤，测试套中包含多个按多种调度维度分类的测试单元，如顺序调度分组的测试单元按照A-B-C这种顺序执行，随机调度分组的测试单元按照随机的方式选择测试单元执行，测试套内的多个分组并行执行，中间产生的数据或者比测依赖的数据通过缓存交换数据。通过这种方式可以尽可能的模拟多客户的真实操作，多个特性和故障及相关操作随机并发运行。</p>\n<h1 id=\"自动化测试的应用\"><a href=\"#自动化测试的应用\" class=\"headerlink\" title=\"自动化测试的应用\"></a>自动化测试的应用</h1><p>自动化测试必须依托于DevOps研发流程来使用，否则自动化测试的价值就极其有限。前面讲了自动化按照测试维度分为接口&#x2F;功能以及各种系统级自动化测试，每种类型的自动化应该在不同的研发阶段发挥不同的价值，以下是CBS自动化测试在研发流程的使用方式：</p>\n<ol>\n<li>开发阶段：在开发阶段主要通过CI流水线的方式（无论是代码提交触发的开发流水线还是定时出发的日构建流水线）承载流水线的方式，能够持续通过自动化来反馈开发阶段的代码质量。一般建议日构建流水线可以跑全量的自动化测试。</li>\n<li>提测阶段：在提测流程中，使用接口&#x2F;功能以及P0级别的系统测试自动化作为提测的门禁，保障测试介入前提测产品的质量，避免因质量不合格导致的测试阻塞等影响测试效率的情况。</li>\n<li>测试阶段：自动化测试在测试阶段的应用不止于回归测试，其应该贯穿于整个测试阶段进行持续测试<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/img_6.png\"></li>\n<li>发布阶段：自动化测试在发布阶段主要作用是验证发布阶段的质量，需要能够快速反馈，一旦发布测试出错，需要及时回退。所以对发布测试用例的选取不仅要考虑功能的覆盖度，也要考虑自动化测试的执行时间。</li>\n<li>现网运营阶段：这一阶段的自动化测试主要分为两类：拨测自动化和日常现网运营自动化，拨测自动化需要长期持续运行，一般跟发布阶段的自动化测试一致，主要是保证系统的核心能力不出问题，一但出错能够快速反馈；日常现网运营自动化一般是按需定时运行，内容主要覆盖功能和接口的P0用例。</li>\n</ol>\n<h1 id=\"自动化测试的挑战\"><a href=\"#自动化测试的挑战\" class=\"headerlink\" title=\"自动化测试的挑战\"></a>自动化测试的挑战</h1><p>自动化测试主要的挑战在于自动化用例的健壮性和自动化框架的扩展性，自动化用例运行难免会失败或出错，造成自动化测试失败的原因有很多，大概可以分为以下几类：</p>\n<ol>\n<li>被测系统Bug：这部分失败是我们希望看到的，说明自动化测试拦截了bug，这才是自动化测试的价值</li>\n<li>工具或被测环境的问题：这部分主要是指自动化工具和被测环境出了问题，如执行机负载过高、被测环境异常或者遗留脏数据等问题，我们应该尽量收敛该类问题，一旦出现该类问题，说明我们这次的自动化测试是无效的。</li>\n<li>测试用例的问题：测试用例因为被测系统的行为出现了变化没有同步适配，或者自动化用例本身有bug导致，我们也应该尽量收敛该类问题。</li>\n<li>第三方不可抗拒因素：比如机器下线、网络问题等问题，这部分我们基本无能为力，只能在实际运营过程中持续去优化自动化用例，来减少部分不可抗因素对自动化用例的影响。</li>\n</ol>\n<p>自动化测试是一个长期持续的过程，需要持续的维稳并长期利用才能发挥其价值，罗马不是一天建起来的，自动化测试也不是一天能够稳定的，需要包容部分失败，只有长期使用，自动化才会越来越稳，越来越发挥其价值，这也是对研发和测试团队最大的挑战。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>自动化测试只是作为一种提升测试效率的测试工具，它并不是万能的，不能指望自动化测试能发现和拦截所有问题，它只是尽最大可能发现更多问题，更不能指望自动化测试替代人工测试，尤其是复杂的系统。我们要正确的认识自动化测试，合理的利用自动化测试。</p>\n","slug":"云IaaS测试系列一分布式存储测试实践3-自动化测试","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/10/25/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B53-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","excerpt":"自动化测试是指通过一些自动化测试工具或者框架把之前以人为驱动的测试行为转换为以机器执行的测试过程。自动化测试作为测试领域的先进生产力很大程度上提升了测试执行效率，自动化通常与持续集成和持续交付（CICD）一起使用，没有自动化的CICD就像没有灵魂的躯壳，它的好处毋庸置疑。自动化测试是贯穿于研发流程的每个阶段，而不只是在系统测试阶段，比如单元测试、接口测试、功能测试以及集成测试等都适用于自动化测试。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://vwin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"Iaas","slug":"Iaas","permalink":"http://vwin.github.io/tags/Iaas/"}]},{"title":"云IaaS测试系列一分布式存储测试实践2-可靠性高可用测试","date":"2022-10-17T07:15:36.000Z","path":"2022/10/17/云IaaS测试系列一分布式存储测试实践2-可靠性高可用测试/","text":"高可用和可靠性是从软件架构设计层面就需要考虑的因素，本文主要从测试角度去思考如何通过测试手段来保障软件系统的高可用和可靠性。 概述系统可用性和可靠性是软件架构设计中经常要考虑的一个重要因素，它是用来衡量软件系统质量情况的一个关键指标。可用性通常是指系统能够提供服务的时间比例（可服务时间&#x2F;总时间），可用性越高，服务时间越长；可靠性是指系统无故障运行的时间，可靠性越高，无故障运行时间也越久，系统也越稳定。可靠性和可用性既有联系又有区别，可用性需要关注故障后的恢复时间。要保证系统的高可用，一方面要保证系统的可靠性，另一方面要保证系统的故障恢复时长；所以一般高可用和可靠性测试是紧密不分的。 从概率学的角度来讲，所有事物都不是100%可靠的，都是有失败或者错误概率的，只要运行或者变化次数足够多，失败或者错误的频次就会增大。那么高可用和可靠性本质上就是为了针对这种不可靠的事物，或者面对风险进行设计的。比如：软件系统依赖的第三方软件可能会失效，硬件和网络可能会损坏，一旦这些外部依赖出现不可预期的错误，会不会导致软件系统自身出现故障或者不可用，以及出现故障后能不能快速恢复，这是考量软件系统对错误的容忍度，也是高可用和可靠性设计需要解决和考虑的问题。 高可用和可靠性是从软件架构设计层面就需要考虑的因素，本文主要从测试角度去思考如何通过测试手段来保障软件系统的高可用和可靠性。 高可用和可靠性测试如前文所讲，高可用和可靠性主要是面对各种不可靠风险进行设计和测试，而不可靠的原因有很多： 系统本身的软硬件出现异常 依赖的第三方软硬件出现异常 来自客户端非预期的IO模型和流量 来自客户端超并发的请求 长时间运行软硬件系统可能出现的老化现象 运维人员进行变更可能会犯错导致，也可能出现异常 对于不可靠因素出现的故障，是否能够快速恢复（如秒级恢复）是高可用设计和测试需要考虑的因素。高可用和可靠性测试主要包含了故障注入类测试和业务场景构造类测试。 故障注入测试故障注入测试主要是指在系统运行时，采用特定的方法向系统本身或者系统依赖的第三方服务注入一个或多个异常，通过观察系统的表现来评估软件系统的可靠性和可用性，一个典型的故障注入测试流程如下图： 开展故障注入测试首先要面临的几个灵魂问题： 注入什么样的故障？ 如何注入故障？ 故障需要在什么时间注入，什么时间恢复？ 如何衡量故障注入或恢复后的系统表现是否符合预期？ 故障模式库首先解答第一个问题：要注入什么样的故障？ 故障模式库定义了软件系统测试过程中涉及的所有故障类型，也是开展故障注入测试所依赖的基本内容，故障类型与软件架构及网络拓扑强相关，根据其在现网出现的频率以及故障的复杂度分为L0、L1、L2等级别，下面以CBS产品为例，列举下CBS产品的故障模式库。 CBS由多个分布式集群子系统组成，包含若干组件，组件之间通过交换机网络连接，部署在物理和虚拟机等服务器上，组件之间通过特定协议协同工作，并与网络&#x2F;数据库&#x2F;对象存储等第三方业务交互，因此根据业务架构和组网设计设计以下几种故障类型： 网络级故障：CBS系统内部通过网络连接，网络分为TCP和RDMA网络，涉及的网络级故障主要是指对网络拓扑内的网络链路注入故障、亚健康等故障，常见的有网络时延、丢包、错包、限流、网卡重启、端口故障等。 组件级故障：主要是指组件出现异常crash、重启或者假死，包含软件系统内部组件以及系统依赖的第三方组件。 硬件级故障：CBS是基于物理硬件构建的存储系统，对硬件如网卡、硬盘、HBA卡有较强的依赖，此处的硬件级故障主要是指承载软件系统或者依赖的第三方硬件故障，如常见的硬盘异常、HBA 卡异常、网卡异常、交换机端口异常等。 系统类故障：CBS软件系统是部署在Linux系统的物理和虚拟机服务器之上，这里的系统类故障主要指服务器级别的故障，如常见的重启、掉电、内核crash、系统时间错乱等。 资源类故障：CBS软件系统运行需要依赖多种资源，基本的系统资源：如基本的CPU、内存、句柄、进程端口等，以及软件系统的一些内部资源：如Cache。这里的故障主要指承载软件系统的服务器资源以及软件系统内部的业务资源出现异常，如常见的资源耗尽、高负载、目录空间耗尽等 集群类故障：CBS是一个分布式集群，所以必须考虑集群粒度的故障影响，这里的故障主要指集群掉电、断网、主备切换等与业务架构强相关的故障。 运维类操作：主要指跟运维操作相关的场景，如常见的组件变更、系统的可服务性操作等 故障注入方法解答第2个问题：故障如何注入？ 故障注入方式取决于故障类型，常见的方式主要有故障模拟和物理故障，两种方式各有优劣，故障模拟效率更高更灵活，但是故障本身与实际的故障会有部分差异；物理故障是真实的故障，场景更加真实，但是效率低，成本高。 举两个例子说明： 对于网络丢包类和硬盘类故障，构造物理故障成本比较高，因此我们常用一些开源工具或者业务自行开发工具来模拟 对于交换机网络异常类故障，没有比较好的方法来模拟，就需要借助实际的硬件操作来注入，如重启交换机、关闭交换机端口等 无论是故障模拟还是真实的物理故障，都是在成本和效率两方面进行权衡和评估，对于物理故障需要依赖专用的测试设备和环境拓扑，对于故障模拟，一方面借助业界比较常用的一些工具，但是对于一些故障注入方法缺失的场景，需要业务团队专门开发故障工具来模拟，常见的如磁盘坏道、慢盘、RDMA网络异常等，故障工具开发是故障注入测试过程中必须面临的问题，因为不是所有故障工具都可以用拿来主义。比如：磁盘类故障注入方法，利用SystemTap模拟磁盘故障。当然还有更加其他比较牛逼的工具用于辅助故障注入测试。 故障场景设计解答第3、4个问题：故障注入及恢复时间，以及系统的表现是否符合预期？ 故障场景设计主要是指将一个或多个故障与业务流程的不同阶段进行叠加，解决故障在什么时间注入以及注入和恢复后系统预期的表现。主要分为基于灰白盒的面向预期结果的故障测试和基于黑盒的面向未知预期的随机故障测试。 灰白盒故障场景测试设计是建立在对业务场景和系统流程比较熟悉的基础上，需要测试人员和开发人员等相关角色共同配合完成，需要对故障场景和系统流程进行深入分析，并以一定的策略来叠加。 故障场景分析故障场景分析是指将故障模式库中的相关故障与组件和组网拓扑进行组合，生成每一条故障场景，故障场景分析框架如下： 将组件列表和故障模式库进行正交，删除无效故障场景，并根据故障类型进行L0&#x2F;L1等级别划分，最终实现故障场景集合。 下面以CBS的某条存储IO流程和网络类故障为示例： 上述架构中描述的几条核心网络链路： 客户端通过网络访问存储集群副本进行io的读写 存储集群副本之间通过网络进行数据同步 客户端通过网络与管控节点交互进行管理数据以及元数据的访问 管控节点通过网络与zookeeper集群进行元数据的存取以及HA切换 管控节点与存储集群之间通过网络进行心跳及管理数据的同步 网络异常故障需要与存储副本&#x2F;管控节点&#x2F;客户端&#x2F;zookeeper组件进行正交，得到以下故障场景： 客户端与存储集群之间网络异常 客户端与管控节点间网络异常 存储副本之间网络异常 存储集群与客户端之间网络丢包 存储副本与管控节点之间网络丢包 管控节点与客户端之间网络丢包 管控节点与存储副本之间网络丢包 管控节点与zk集群的网络丢包 其中2&#x2F;6，1&#x2F;4，5&#x2F;7为等价类故障，因此去除等价类后剩余5种故障场景，丢包率设置多少以及时延多高等故障程度主要依据历史测试经验，并参考现网运营过程中的故障数据以及系统在故障后的资源消耗等情况进行综合设计，比如丢包率5%~8%等。如： L0：客户端与cell网络出现8%丢包率，持续xx min后恢复 L0：存储副本单节点&#x2F;多节点与管控节点网络出现100ms时延，持续xx min后恢复 系统流程分析系统流程分析是故障注入测试中很重要的一环，其主要目的是决定在什么阶段注入什么样的故障，以及故障持续时间和频次。不同阶段注入故障以及故障的方式（如持续故障还是间歇性故障）才能够多方位检测出系统的BUG，实际产品测试经验表明故障注入的精细度越高，拦截产品质量问题越有效。系统流程分析与故障场景叠加示意图如下：如上图所示：流程1共有5个子流程：A-B-C-D 每个子流程中分别考虑：可能发生的异常，异常后会产生什么问题，需要异常多久？ 然后使用等价类划分法，合并场景并去除无效的场景，作为该流程下的异常场景集，过于复杂的子流程会进行二次拆分。 同样以CBS产品为例： 这是常见的CBS的一些基本流程及操作，需要对每个流程进行分析，在系统流程里如何处理，涉及哪些组件以及哪些资源，此处不一一赘述，仅以io简要流程为例来讲： IO从客户端发送到存储集群，存储侧使用io消息队列来控制流量，当io处理完成返回客户端后，流程结束并释放对应队列中的节点，客户端接收请求超时后会重试，存储端发送超时后也会重试。所以在故障场景设计时，需要考虑资源大小、申请释放机制、资源不足的影响以及超时处理流程等；以一个网络故障导致资源不足的BUG例子为例：当存储端处理完成后向客户端返回rsp时，因网络单向异常（存储–&gt;客户端）导致客户端没有收到包，客户端反复重试导致存储侧消息队列资源不足又无法释放，导致存储上其他客户端的io hang。经过分析（分析过程不赘述），该故障场景用例如下： 不同的故障和系统流程组合直接影响了故障注入及恢复后的系统表现是什么样的，系统表现完全与业务处理流程强相关，需要深入了解系统的处理流程才能精细化指定故障观察点，比如：副本与客户端之间的网络异常和副本与管控节点之间的网络异常对系统的影响是不一样的，前者对io影响比较大，后者对io影响比较小。 故障注入测试需要与系统流程分析结合来做，整个系统分析流程投入会比较大，对测试和研发同学的要求比较高，成本也比较高。因此，在前期的故障测试时，更多的采取一些粗粒度的随机故障测试，主要通过时间和次数来发现概率问题，成本相对较低，但是收益也比预期较小。灰白盒故障测试适合有一定故障注入测试经验的团队，因前期使用粗粒度的随机故障注入测试已经发现了很多高概率或者必现的问题，对于低概率问题，需要使用灰白盒分析方法来精细化故障注入测试。 随机故障测试如前文所讲，随机故障测试相比灰白盒故障测试，粒度较粗，开展成本较低。主要包含两个方面的随机： 故障类型的随机 故障注入频次&#x2F;阶段&#x2F;时长的随机 简单来讲，就是不知道什么时候注入故障，那就使用随机的方式长时间频繁跑故障测试，以此来发现系统问题。随机故障测试对于系统的表现预期相对于灰白盒故障测试来说，观察点也相对较粗，主要是类似io抖动、进程crash等观察点。随机观察注入测试对业务监控系统依赖度比较高，适合通过自动化的方式来开展。 业务场景构造测试业务场景类测试主要是指系统接收到一些对于系统有风险的场景后能否保证其可用性和稳定性。比如CBS作为存储对外提供存储服务，会接收来自客户端各种各样的数据流量，这里的测试主要指业务场景出现异常的情况，如场景的突发流量、长期持续高负载流量（也就是压力测试）以及一些特殊的异常流量报文等。一般包括以下几种类型： 压力测试：通过构造业务模型和配置，对系统进行持续大压力、高并发测试，观察系统的表现。 长稳测试：在一定业务压力模型下（高于正常压力或者完全高于系统负载）持续长时间运行的测试方法，也可以结合一些基本的故障注入来开展。 异常业务场景：如异常操作、异常配置、异常流量报文等 CFT及混沌测试前面讲了基于灰白盒和黑盒的故障注入测试，但是分布式系统的复杂性通过上述测试还是远远不够的，不同的数据量、不同的压力，甚至不均衡的压力在系统内部可能都是对应不同的分支，不同的集群节点也会对应不同的处理逻辑，我们无法群居罗列所有的组合，覆盖所有的分支，因此需要引入一些探索性测试。 CFT（Cross Feature Test）测试是一种基于灰盒的多特性交叉随机的测试，是我们目前正在尝试的一种探索性测试，它的基本逻辑如下图所示： 测试单元最小粒度的测试行为，可以是单个测试用例，也可以是单个测试步骤，比如正常的盘操作用例&#x2F;运维变更步骤或者故障步骤，通过自动化调度引擎将多个测试单元按照顺序&#x2F;随机&#x2F;循环以及按照权重等方式组合成测试套进行并发随机运行，你无法知道在某个时刻具体是哪个操作&#x2F;或者哪个故障在运行，这种测试在一定程度上按照未知的时序进行并发随机运行，极大的模拟了一种探索性测试，该类测试必须通过自动化的手段进行测试，无法人工执行；CFT测试需要依赖很强的系统监控能力，这样在测试执行时，一旦出现问题，监控系统能第一时间知晓。 混沌测试是另外一种工程实践方法，它是一种实验手段，混沌测试的第一步是定义系统的稳态（如iops、时延等指标），然后通过多样化的测试手段（如压力、故障注入等）对系统进行实验，最后对比实验结果，如果系统一直处于稳态，那么认为系统对于该故障是具有容错能力的，否则，就找到了一个系统的bug，去修复它来提高系统的可靠性。 混沌测试开展的前提是需要软件系统有一定的故障容错能力，它对系统架构的韧性有很高的要求，如果软件系统架构存在单点设计的情况，那么不适合开展混沌测试，一旦出现单点故障，整个系统也就奔溃了，没法验证混沌测试的效果。如果系统当前还没有容错能力，那么应该首先使用故障注入测试方法暴露出更多的系统容错能力，最后再去考虑使用混沌测试。混沌测试也是我们后续需要尝试和探索的一种测试方法。 元数据高可用测试元数据在存储系统中的地位是非常重要的，它记录了数据在存储系统中的真实位置，因此对元数据的管理是至关重要的。腾讯云存储的元数据管理包括分布式拓扑结构、节点的HA数据以及存储数据的索引数据等，它是基于开源的分布式zookeeper集群进行管理的，Zookeeper分布式集群主要通过ZAB协议（Paxos算法的变种）来保证数据的分布式一致性。 分布式系统主要面临的一致性问题有以下几种： 数据同步问题：分布式系统中，数据一般都是存在多个节点上，数据需要在节点间进行同步，但是由于现实的网络通道并不是绝对可靠的，经常出现丢包、延迟、错报等问题，导致节点间的数据不能同步，容易出现数据错乱或者不一致的情况。 节点故障问题：分布式系统中某个或者某些节点故障后无法恢复，如何保证部分节点故障后不会导致整个分布式系统的数据不可用。 节点宕机恢复：某个或某些节点在A时刻宕机，并在B时刻恢复，宕机期间或者宕机恢复后的数据一致性问题如何解决。 孤岛节点问题：网络链接异常，将分布式集群分成多个相互隔离的信息孤岛，如何保证孤岛场景下的数据一致性问题。 因此为了保证元数据的高可用，需要结合系统流程对Zookeeper集群进行故障注入来测试，ZAB协议典型的读写流程如下图： ZAB协议中ZK Leader给Follower发送同步复制请求后，只需要一半以上的follower进行了正确反馈（即返回ACK）后，Leader才会再次向所有follower发送事务提交，完成数据同步。因此在测试过程中，需要根据系统流程结合ZAB协议中的选主、事务提交等流程进行故障注入测试来验证元数据的高可用。 结语可靠性和高可用测试是发现系统问题、保障产品质量的非常有效的手段，尤其在复杂度偏高的IaaS产品测试中更为有效。对于CBS测试来讲，我们在高可用和可靠性测试方面投入了很多精力，也发现了非常多的问题，其中不乏数据一致性问题，在实际产品测试过程中，70%的bug都是通过它发现的，但是现网仍然有很多低概率偶发问题。所以可靠性和高可用测试只是起点，永远没有终点。","raw":"---\ntitle: 云IaaS测试系列一分布式存储测试实践2-可靠性高可用测试\ntoc: true\ndate: 2022-10-17 15:15:36\ntags: [IaaS,分布式]\ncategories: [技术]\ndescription:\n---\n\n高可用和可靠性是从软件架构设计层面就需要考虑的因素，本文主要从测试角度去思考如何通过测试手段来保障软件系统的高可用和可靠性。\n\n<!-- more -->\n\n# 概述\n系统可用性和可靠性是软件架构设计中经常要考虑的一个重要因素，它是用来衡量软件系统质量情况的一个关键指标。可用性通常是指系统能够提供服务的时间比例（可服务时间/总时间），可用性越高，服务时间越长；可靠性是指系统无故障运行的时间，可靠性越高，无故障运行时间也越久，系统也越稳定。可靠性和可用性既有联系又有区别，可用性需要关注故障后的恢复时间。要保证系统的高可用，一方面要保证系统的可靠性，另一方面要保证系统的故障恢复时长；所以一般高可用和可靠性测试是紧密不分的。\n\n从概率学的角度来讲，所有事物都不是100%可靠的，都是有失败或者错误概率的，只要运行或者变化次数足够多，失败或者错误的频次就会增大。那么高可用和可靠性本质上就是为了针对这种不可靠的事物，或者面对风险进行设计的。比如：软件系统依赖的第三方软件可能会失效，硬件和网络可能会损坏，一旦这些外部依赖出现不可预期的错误，会不会导致软件系统自身出现故障或者不可用，以及出现故障后能不能快速恢复，这是考量软件系统对错误的容忍度，也是高可用和可靠性设计需要解决和考虑的问题。\n\n高可用和可靠性是从软件架构设计层面就需要考虑的因素，本文主要从测试角度去思考如何通过测试手段来保障软件系统的高可用和可靠性。\n\n# 高可用和可靠性测试\n如前文所讲，高可用和可靠性主要是面对各种不可靠风险进行设计和测试，而不可靠的原因有很多：\n\n- 系统本身的软硬件出现异常 \n- 依赖的第三方软硬件出现异常 \n- 来自客户端非预期的IO模型和流量 \n- 来自客户端超并发的请求 \n- 长时间运行软硬件系统可能出现的老化现象 \n- 运维人员进行变更可能会犯错导致，也可能出现异常\n\n对于不可靠因素出现的故障，是否能够快速恢复（如秒级恢复）是高可用设计和测试需要考虑的因素。高可用和可靠性测试主要包含了故障注入类测试和业务场景构造类测试。\n\n## 故障注入测试\n故障注入测试主要是指在系统运行时，采用特定的方法向系统本身或者系统依赖的第三方服务注入一个或多个异常，通过观察系统的表现来评估软件系统的可靠性和可用性，一个典型的故障注入测试流程如下图：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img.png)\n\n开展故障注入测试首先要面临的几个灵魂问题：\n\n1. 注入什么样的故障？ \n2. 如何注入故障？ \n3. 故障需要在什么时间注入，什么时间恢复？ \n4. 如何衡量故障注入或恢复后的系统表现是否符合预期？\n\n### 故障模式库\n首先解答第一个问题：要注入什么样的故障？\n\n故障模式库定义了软件系统测试过程中涉及的所有故障类型，也是开展故障注入测试所依赖的基本内容，故障类型与软件架构及网络拓扑强相关，根据其在现网出现的频率以及故障的复杂度分为L0、L1、L2等级别，下面以CBS产品为例，列举下CBS产品的故障模式库。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_1.png)\n\nCBS由多个分布式集群子系统组成，包含若干组件，组件之间通过交换机网络连接，部署在物理和虚拟机等服务器上，组件之间通过特定协议协同工作，并与网络/数据库/对象存储等第三方业务交互，因此根据业务架构和组网设计设计以下几种故障类型：\n\n- 网络级故障：CBS系统内部通过网络连接，网络分为TCP和RDMA网络，涉及的网络级故障主要是指对网络拓扑内的网络链路注入故障、亚健康等故障，常见的有网络时延、丢包、错包、限流、网卡重启、端口故障等。\n- 组件级故障：主要是指组件出现异常crash、重启或者假死，包含软件系统内部组件以及系统依赖的第三方组件。\n- 硬件级故障：CBS是基于物理硬件构建的存储系统，对硬件如网卡、硬盘、HBA卡有较强的依赖，此处的硬件级故障主要是指承载软件系统或者依赖的第三方硬件故障，如常见的硬盘异常、HBA 卡异常、网卡异常、交换机端口异常等。\n- 系统类故障：CBS软件系统是部署在Linux系统的物理和虚拟机服务器之上，这里的系统类故障主要指服务器级别的故障，如常见的重启、掉电、内核crash、系统时间错乱等。\n- 资源类故障：CBS软件系统运行需要依赖多种资源，基本的系统资源：如基本的CPU、内存、句柄、进程端口等，以及软件系统的一些内部资源：如Cache。这里的故障主要指承载软件系统的服务器资源以及软件系统内部的业务资源出现异常，如常见的资源耗尽、高负载、目录空间耗尽等\n- 集群类故障：CBS是一个分布式集群，所以必须考虑集群粒度的故障影响，这里的故障主要指集群掉电、断网、主备切换等与业务架构强相关的故障。\n- 运维类操作：主要指跟运维操作相关的场景，如常见的组件变更、系统的可服务性操作等\n\n### 故障注入方法\n解答第2个问题：故障如何注入？\n\n故障注入方式取决于故障类型，常见的方式主要有故障模拟和物理故障，两种方式各有优劣，故障模拟效率更高更灵活，但是故障本身与实际的故障会有部分差异；物理故障是真实的故障，场景更加真实，但是效率低，成本高。\n\n举两个例子说明：\n\n1. 对于网络丢包类和硬盘类故障，构造物理故障成本比较高，因此我们常用一些开源工具或者业务自行开发工具来模拟 \n2. 对于交换机网络异常类故障，没有比较好的方法来模拟，就需要借助实际的硬件操作来注入，如重启交换机、关闭交换机端口等\n\n无论是故障模拟还是真实的物理故障，都是在成本和效率两方面进行权衡和评估，对于物理故障需要依赖专用的测试设备和环境拓扑，对于故障模拟，一方面借助业界比较常用的一些工具，但是对于一些故障注入方法缺失的场景，需要业务团队专门开发故障工具来模拟，常见的如磁盘坏道、慢盘、RDMA网络异常等，故障工具开发是故障注入测试过程中必须面临的问题，因为不是所有故障工具都可以用拿来主义。比如：磁盘类故障注入方法，利用SystemTap模拟磁盘故障。当然还有更加其他比较牛逼的工具用于辅助故障注入测试。\n\n### 故障场景设计\n解答第3、4个问题：故障注入及恢复时间，以及系统的表现是否符合预期？\n\n故障场景设计主要是指将一个或多个故障与业务流程的不同阶段进行叠加，解决故障在什么时间注入以及注入和恢复后系统预期的表现。主要分为基于灰白盒的面向预期结果的故障测试和基于黑盒的面向未知预期的随机故障测试。\n\n灰白盒故障场景测试设计是建立在对业务场景和系统流程比较熟悉的基础上，需要测试人员和开发人员等相关角色共同配合完成，需要对故障场景和系统流程进行深入分析，并以一定的策略来叠加。\n\n### 故障场景分析\n故障场景分析是指将故障模式库中的相关故障与组件和组网拓扑进行组合，生成每一条故障场景，故障场景分析框架如下：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_2.png)\n\n将组件列表和故障模式库进行正交，删除无效故障场景，并根据故障类型进行L0/L1等级别划分，最终实现故障场景集合。\n\n下面以CBS的某条存储IO流程和网络类故障为示例：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_3.png)\n\n上述架构中描述的几条核心网络链路：\n\n- 客户端通过网络访问存储集群副本进行io的读写 \n- 存储集群副本之间通过网络进行数据同步 \n- 客户端通过网络与管控节点交互进行管理数据以及元数据的访问 \n- 管控节点通过网络与zookeeper集群进行元数据的存取以及HA切换 \n- 管控节点与存储集群之间通过网络进行心跳及管理数据的同步\n\n网络异常故障需要与存储副本/管控节点/客户端/zookeeper组件进行正交，得到以下故障场景：\n\n- 客户端与存储集群之间网络异常 \n- 客户端与管控节点间网络异常 \n- 存储副本之间网络异常 \n- 存储集群与客户端之间网络丢包 \n- 存储副本与管控节点之间网络丢包 \n- 管控节点与客户端之间网络丢包 \n- 管控节点与存储副本之间网络丢包 \n- 管控节点与zk集群的网络丢包\n\n其中2/6，1/4，5/7为等价类故障，因此去除等价类后剩余5种故障场景，丢包率设置多少以及时延多高等故障程度主要依据历史测试经验，并参考现网运营过程中的故障数据以及系统在故障后的资源消耗等情况进行综合设计，比如丢包率5%~8%等。如：\n- L0：客户端与cell网络出现8%丢包率，持续xx min后恢复 \n- L0：存储副本单节点/多节点与管控节点网络出现100ms时延，持续xx min后恢复\n\n### 系统流程分析\n系统流程分析是故障注入测试中很重要的一环，其主要目的是决定在什么阶段注入什么样的故障，以及故障持续时间和频次。不同阶段注入故障以及故障的方式（如持续故障还是间歇性故障）才能够多方位检测出系统的BUG，实际产品测试经验表明故障注入的精细度越高，拦截产品质量问题越有效。系统流程分析与故障场景叠加示意图如下：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_4.png)\n如上图所示：流程1共有5个子流程：A-B-C-D\n\n每个子流程中分别考虑：可能发生的异常，异常后会产生什么问题，需要异常多久？\n\n然后使用等价类划分法，合并场景并去除无效的场景，作为该流程下的异常场景集，过于复杂的子流程会进行二次拆分。\n\n同样以CBS产品为例：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_5.png)\n\n这是常见的CBS的一些基本流程及操作，需要对每个流程进行分析，在系统流程里如何处理，涉及哪些组件以及哪些资源，此处不一一赘述，仅以io简要流程为例来讲：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_6.png)\n\nIO从客户端发送到存储集群，存储侧使用io消息队列来控制流量，当io处理完成返回客户端后，流程结束并释放对应队列中的节点，客户端接收请求超时后会重试，存储端发送超时后也会重试。所以在故障场景设计时，需要考虑资源大小、申请释放机制、资源不足的影响以及超时处理流程等；以一个网络故障导致资源不足的BUG例子为例：\n当存储端处理完成后向客户端返回rsp时，因网络单向异常（存储-->客户端）导致客户端没有收到包，客户端反复重试导致存储侧消息队列资源不足又无法释放，导致存储上其他客户端的io hang。经过分析（分析过程不赘述），该故障场景用例如下：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_7.png)\n\n不同的故障和系统流程组合直接影响了故障注入及恢复后的系统表现是什么样的，系统表现完全与业务处理流程强相关，需要深入了解系统的处理流程才能精细化指定故障观察点，比如：副本与客户端之间的网络异常和副本与管控节点之间的网络异常对系统的影响是不一样的，前者对io影响比较大，后者对io影响比较小。\n\n故障注入测试需要与系统流程分析结合来做，整个系统分析流程投入会比较大，对测试和研发同学的要求比较高，成本也比较高。因此，在前期的故障测试时，更多的采取一些粗粒度的随机故障测试，主要通过时间和次数来发现概率问题，成本相对较低，但是收益也比预期较小。灰白盒故障测试适合有一定故障注入测试经验的团队，因前期使用粗粒度的随机故障注入测试已经发现了很多高概率或者必现的问题，对于低概率问题，需要使用灰白盒分析方法来精细化故障注入测试。\n\n### 随机故障测试\n如前文所讲，随机故障测试相比灰白盒故障测试，粒度较粗，开展成本较低。主要包含两个方面的随机：\n\n1. 故障类型的随机\n2. 故障注入频次/阶段/时长的随机\n\n3. 简单来讲，就是不知道什么时候注入故障，那就使用随机的方式长时间频繁跑故障测试，以此来发现系统问题。随机故障测试对于系统的表现预期相对于灰白盒故障测试来说，观察点也相对较粗，主要是类似io抖动、进程crash等观察点。随机观察注入测试对业务监控系统依赖度比较高，适合通过自动化的方式来开展。\n\n## 业务场景构造测试\n业务场景类测试主要是指系统接收到一些对于系统有风险的场景后能否保证其可用性和稳定性。比如CBS作为存储对外提供存储服务，会接收来自客户端各种各样的数据流量，这里的测试主要指业务场景出现异常的情况，如场景的突发流量、长期持续高负载流量（也就是压力测试）以及一些特殊的异常流量报文等。一般包括以下几种类型：\n\n1. 压力测试：通过构造业务模型和配置，对系统进行持续大压力、高并发测试，观察系统的表现。\n2. 长稳测试：在一定业务压力模型下（高于正常压力或者完全高于系统负载）持续长时间运行的测试方法，也可以结合一些基本的故障注入来开展。\n3. 异常业务场景：如异常操作、异常配置、异常流量报文等\n\n# CFT及混沌测试\n前面讲了基于灰白盒和黑盒的故障注入测试，但是分布式系统的复杂性通过上述测试还是远远不够的，不同的数据量、不同的压力，甚至不均衡的压力在系统内部可能都是对应不同的分支，不同的集群节点也会对应不同的处理逻辑，我们无法群居罗列所有的组合，覆盖所有的分支，因此需要引入一些探索性测试。\n\nCFT（Cross Feature Test）测试是一种基于灰盒的多特性交叉随机的测试，是我们目前正在尝试的一种探索性测试，它的基本逻辑如下图所示：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_8.png)\n\n测试单元最小粒度的测试行为，可以是单个测试用例，也可以是单个测试步骤，比如正常的盘操作用例/运维变更步骤或者故障步骤，通过自动化调度引擎将多个测试单元按照顺序/随机/循环以及按照权重等方式组合成测试套进行并发随机运行，你无法知道在某个时刻具体是哪个操作/或者哪个故障在运行，这种测试在一定程度上按照未知的时序进行并发随机运行，极大的模拟了一种探索性测试，该类测试必须通过自动化的手段进行测试，无法人工执行；CFT测试需要依赖很强的系统监控能力，这样在测试执行时，一旦出现问题，监控系统能第一时间知晓。\n\n混沌测试是另外一种工程实践方法，它是一种实验手段，混沌测试的第一步是定义系统的稳态（如iops、时延等指标），然后通过多样化的测试手段（如压力、故障注入等）对系统进行实验，最后对比实验结果，如果系统一直处于稳态，那么认为系统对于该故障是具有容错能力的，否则，就找到了一个系统的bug，去修复它来提高系统的可靠性。\n\n混沌测试开展的前提是需要软件系统有一定的故障容错能力，它对系统架构的韧性有很高的要求，如果软件系统架构存在单点设计的情况，那么不适合开展混沌测试，一旦出现单点故障，整个系统也就奔溃了，没法验证混沌测试的效果。如果系统当前还没有容错能力，那么应该首先使用故障注入测试方法暴露出更多的系统容错能力，最后再去考虑使用混沌测试。混沌测试也是我们后续需要尝试和探索的一种测试方法。\n\n# 元数据高可用测试\n元数据在存储系统中的地位是非常重要的，它记录了数据在存储系统中的真实位置，因此对元数据的管理是至关重要的。腾讯云存储的元数据管理包括分布式拓扑结构、节点的HA数据以及存储数据的索引数据等，它是基于开源的分布式zookeeper集群进行管理的，Zookeeper分布式集群主要通过ZAB协议（Paxos算法的变种）来保证数据的分布式一致性。\n\n分布式系统主要面临的一致性问题有以下几种：\n\n1. 数据同步问题：分布式系统中，数据一般都是存在多个节点上，数据需要在节点间进行同步，但是由于现实的网络通道并不是绝对可靠的，经常出现丢包、延迟、错报等问题，导致节点间的数据不能同步，容易出现数据错乱或者不一致的情况。\n2. 节点故障问题：分布式系统中某个或者某些节点故障后无法恢复，如何保证部分节点故障后不会导致整个分布式系统的数据不可用。\n3. 节点宕机恢复：某个或某些节点在A时刻宕机，并在B时刻恢复，宕机期间或者宕机恢复后的数据一致性问题如何解决。\n4. 孤岛节点问题：网络链接异常，将分布式集群分成多个相互隔离的信息孤岛，如何保证孤岛场景下的数据一致性问题。\n\n因此为了保证元数据的高可用，需要结合系统流程对Zookeeper集群进行故障注入来测试，ZAB协议典型的读写流程如下图：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_9.png)\n\nZAB协议中ZK Leader给Follower发送同步复制请求后，只需要一半以上的follower进行了正确反馈（即返回ACK）后，Leader才会再次向所有follower发送事务提交，完成数据同步。因此在测试过程中，需要根据系统流程结合ZAB协议中的选主、事务提交等流程进行故障注入测试来验证元数据的高可用。\n\n# 结语\n可靠性和高可用测试是发现系统问题、保障产品质量的非常有效的手段，尤其在复杂度偏高的IaaS产品测试中更为有效。对于CBS测试来讲，我们在高可用和可靠性测试方面投入了很多精力，也发现了非常多的问题，其中不乏数据一致性问题，在实际产品测试过程中，70%的bug都是通过它发现的，但是现网仍然有很多低概率偶发问题。所以可靠性和高可用测试只是起点，永远没有终点。\n\n\n\n\n","content":"<p>高可用和可靠性是从软件架构设计层面就需要考虑的因素，本文主要从测试角度去思考如何通过测试手段来保障软件系统的高可用和可靠性。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>系统可用性和可靠性是软件架构设计中经常要考虑的一个重要因素，它是用来衡量软件系统质量情况的一个关键指标。可用性通常是指系统能够提供服务的时间比例（可服务时间&#x2F;总时间），可用性越高，服务时间越长；可靠性是指系统无故障运行的时间，可靠性越高，无故障运行时间也越久，系统也越稳定。可靠性和可用性既有联系又有区别，可用性需要关注故障后的恢复时间。要保证系统的高可用，一方面要保证系统的可靠性，另一方面要保证系统的故障恢复时长；所以一般高可用和可靠性测试是紧密不分的。</p>\n<p>从概率学的角度来讲，所有事物都不是100%可靠的，都是有失败或者错误概率的，只要运行或者变化次数足够多，失败或者错误的频次就会增大。那么高可用和可靠性本质上就是为了针对这种不可靠的事物，或者面对风险进行设计的。比如：软件系统依赖的第三方软件可能会失效，硬件和网络可能会损坏，一旦这些外部依赖出现不可预期的错误，会不会导致软件系统自身出现故障或者不可用，以及出现故障后能不能快速恢复，这是考量软件系统对错误的容忍度，也是高可用和可靠性设计需要解决和考虑的问题。</p>\n<p>高可用和可靠性是从软件架构设计层面就需要考虑的因素，本文主要从测试角度去思考如何通过测试手段来保障软件系统的高可用和可靠性。</p>\n<h1 id=\"高可用和可靠性测试\"><a href=\"#高可用和可靠性测试\" class=\"headerlink\" title=\"高可用和可靠性测试\"></a>高可用和可靠性测试</h1><p>如前文所讲，高可用和可靠性主要是面对各种不可靠风险进行设计和测试，而不可靠的原因有很多：</p>\n<ul>\n<li>系统本身的软硬件出现异常 </li>\n<li>依赖的第三方软硬件出现异常 </li>\n<li>来自客户端非预期的IO模型和流量 </li>\n<li>来自客户端超并发的请求 </li>\n<li>长时间运行软硬件系统可能出现的老化现象 </li>\n<li>运维人员进行变更可能会犯错导致，也可能出现异常</li>\n</ul>\n<p>对于不可靠因素出现的故障，是否能够快速恢复（如秒级恢复）是高可用设计和测试需要考虑的因素。高可用和可靠性测试主要包含了故障注入类测试和业务场景构造类测试。</p>\n<h2 id=\"故障注入测试\"><a href=\"#故障注入测试\" class=\"headerlink\" title=\"故障注入测试\"></a>故障注入测试</h2><p>故障注入测试主要是指在系统运行时，采用特定的方法向系统本身或者系统依赖的第三方服务注入一个或多个异常，通过观察系统的表现来评估软件系统的可靠性和可用性，一个典型的故障注入测试流程如下图：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img.png\"></p>\n<p>开展故障注入测试首先要面临的几个灵魂问题：</p>\n<ol>\n<li>注入什么样的故障？ </li>\n<li>如何注入故障？ </li>\n<li>故障需要在什么时间注入，什么时间恢复？ </li>\n<li>如何衡量故障注入或恢复后的系统表现是否符合预期？</li>\n</ol>\n<h3 id=\"故障模式库\"><a href=\"#故障模式库\" class=\"headerlink\" title=\"故障模式库\"></a>故障模式库</h3><p>首先解答第一个问题：要注入什么样的故障？</p>\n<p>故障模式库定义了软件系统测试过程中涉及的所有故障类型，也是开展故障注入测试所依赖的基本内容，故障类型与软件架构及网络拓扑强相关，根据其在现网出现的频率以及故障的复杂度分为L0、L1、L2等级别，下面以CBS产品为例，列举下CBS产品的故障模式库。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_1.png\"></p>\n<p>CBS由多个分布式集群子系统组成，包含若干组件，组件之间通过交换机网络连接，部署在物理和虚拟机等服务器上，组件之间通过特定协议协同工作，并与网络&#x2F;数据库&#x2F;对象存储等第三方业务交互，因此根据业务架构和组网设计设计以下几种故障类型：</p>\n<ul>\n<li>网络级故障：CBS系统内部通过网络连接，网络分为TCP和RDMA网络，涉及的网络级故障主要是指对网络拓扑内的网络链路注入故障、亚健康等故障，常见的有网络时延、丢包、错包、限流、网卡重启、端口故障等。</li>\n<li>组件级故障：主要是指组件出现异常crash、重启或者假死，包含软件系统内部组件以及系统依赖的第三方组件。</li>\n<li>硬件级故障：CBS是基于物理硬件构建的存储系统，对硬件如网卡、硬盘、HBA卡有较强的依赖，此处的硬件级故障主要是指承载软件系统或者依赖的第三方硬件故障，如常见的硬盘异常、HBA 卡异常、网卡异常、交换机端口异常等。</li>\n<li>系统类故障：CBS软件系统是部署在Linux系统的物理和虚拟机服务器之上，这里的系统类故障主要指服务器级别的故障，如常见的重启、掉电、内核crash、系统时间错乱等。</li>\n<li>资源类故障：CBS软件系统运行需要依赖多种资源，基本的系统资源：如基本的CPU、内存、句柄、进程端口等，以及软件系统的一些内部资源：如Cache。这里的故障主要指承载软件系统的服务器资源以及软件系统内部的业务资源出现异常，如常见的资源耗尽、高负载、目录空间耗尽等</li>\n<li>集群类故障：CBS是一个分布式集群，所以必须考虑集群粒度的故障影响，这里的故障主要指集群掉电、断网、主备切换等与业务架构强相关的故障。</li>\n<li>运维类操作：主要指跟运维操作相关的场景，如常见的组件变更、系统的可服务性操作等</li>\n</ul>\n<h3 id=\"故障注入方法\"><a href=\"#故障注入方法\" class=\"headerlink\" title=\"故障注入方法\"></a>故障注入方法</h3><p>解答第2个问题：故障如何注入？</p>\n<p>故障注入方式取决于故障类型，常见的方式主要有故障模拟和物理故障，两种方式各有优劣，故障模拟效率更高更灵活，但是故障本身与实际的故障会有部分差异；物理故障是真实的故障，场景更加真实，但是效率低，成本高。</p>\n<p>举两个例子说明：</p>\n<ol>\n<li>对于网络丢包类和硬盘类故障，构造物理故障成本比较高，因此我们常用一些开源工具或者业务自行开发工具来模拟 </li>\n<li>对于交换机网络异常类故障，没有比较好的方法来模拟，就需要借助实际的硬件操作来注入，如重启交换机、关闭交换机端口等</li>\n</ol>\n<p>无论是故障模拟还是真实的物理故障，都是在成本和效率两方面进行权衡和评估，对于物理故障需要依赖专用的测试设备和环境拓扑，对于故障模拟，一方面借助业界比较常用的一些工具，但是对于一些故障注入方法缺失的场景，需要业务团队专门开发故障工具来模拟，常见的如磁盘坏道、慢盘、RDMA网络异常等，故障工具开发是故障注入测试过程中必须面临的问题，因为不是所有故障工具都可以用拿来主义。比如：磁盘类故障注入方法，利用SystemTap模拟磁盘故障。当然还有更加其他比较牛逼的工具用于辅助故障注入测试。</p>\n<h3 id=\"故障场景设计\"><a href=\"#故障场景设计\" class=\"headerlink\" title=\"故障场景设计\"></a>故障场景设计</h3><p>解答第3、4个问题：故障注入及恢复时间，以及系统的表现是否符合预期？</p>\n<p>故障场景设计主要是指将一个或多个故障与业务流程的不同阶段进行叠加，解决故障在什么时间注入以及注入和恢复后系统预期的表现。主要分为基于灰白盒的面向预期结果的故障测试和基于黑盒的面向未知预期的随机故障测试。</p>\n<p>灰白盒故障场景测试设计是建立在对业务场景和系统流程比较熟悉的基础上，需要测试人员和开发人员等相关角色共同配合完成，需要对故障场景和系统流程进行深入分析，并以一定的策略来叠加。</p>\n<h3 id=\"故障场景分析\"><a href=\"#故障场景分析\" class=\"headerlink\" title=\"故障场景分析\"></a>故障场景分析</h3><p>故障场景分析是指将故障模式库中的相关故障与组件和组网拓扑进行组合，生成每一条故障场景，故障场景分析框架如下：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_2.png\"></p>\n<p>将组件列表和故障模式库进行正交，删除无效故障场景，并根据故障类型进行L0&#x2F;L1等级别划分，最终实现故障场景集合。</p>\n<p>下面以CBS的某条存储IO流程和网络类故障为示例：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_3.png\"></p>\n<p>上述架构中描述的几条核心网络链路：</p>\n<ul>\n<li>客户端通过网络访问存储集群副本进行io的读写 </li>\n<li>存储集群副本之间通过网络进行数据同步 </li>\n<li>客户端通过网络与管控节点交互进行管理数据以及元数据的访问 </li>\n<li>管控节点通过网络与zookeeper集群进行元数据的存取以及HA切换 </li>\n<li>管控节点与存储集群之间通过网络进行心跳及管理数据的同步</li>\n</ul>\n<p>网络异常故障需要与存储副本&#x2F;管控节点&#x2F;客户端&#x2F;zookeeper组件进行正交，得到以下故障场景：</p>\n<ul>\n<li>客户端与存储集群之间网络异常 </li>\n<li>客户端与管控节点间网络异常 </li>\n<li>存储副本之间网络异常 </li>\n<li>存储集群与客户端之间网络丢包 </li>\n<li>存储副本与管控节点之间网络丢包 </li>\n<li>管控节点与客户端之间网络丢包 </li>\n<li>管控节点与存储副本之间网络丢包 </li>\n<li>管控节点与zk集群的网络丢包</li>\n</ul>\n<p>其中2&#x2F;6，1&#x2F;4，5&#x2F;7为等价类故障，因此去除等价类后剩余5种故障场景，丢包率设置多少以及时延多高等故障程度主要依据历史测试经验，并参考现网运营过程中的故障数据以及系统在故障后的资源消耗等情况进行综合设计，比如丢包率5%~8%等。如：</p>\n<ul>\n<li>L0：客户端与cell网络出现8%丢包率，持续xx min后恢复 </li>\n<li>L0：存储副本单节点&#x2F;多节点与管控节点网络出现100ms时延，持续xx min后恢复</li>\n</ul>\n<h3 id=\"系统流程分析\"><a href=\"#系统流程分析\" class=\"headerlink\" title=\"系统流程分析\"></a>系统流程分析</h3><p>系统流程分析是故障注入测试中很重要的一环，其主要目的是决定在什么阶段注入什么样的故障，以及故障持续时间和频次。不同阶段注入故障以及故障的方式（如持续故障还是间歇性故障）才能够多方位检测出系统的BUG，实际产品测试经验表明故障注入的精细度越高，拦截产品质量问题越有效。系统流程分析与故障场景叠加示意图如下：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_4.png\"><br>如上图所示：流程1共有5个子流程：A-B-C-D</p>\n<p>每个子流程中分别考虑：可能发生的异常，异常后会产生什么问题，需要异常多久？</p>\n<p>然后使用等价类划分法，合并场景并去除无效的场景，作为该流程下的异常场景集，过于复杂的子流程会进行二次拆分。</p>\n<p>同样以CBS产品为例：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_5.png\"></p>\n<p>这是常见的CBS的一些基本流程及操作，需要对每个流程进行分析，在系统流程里如何处理，涉及哪些组件以及哪些资源，此处不一一赘述，仅以io简要流程为例来讲：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_6.png\"></p>\n<p>IO从客户端发送到存储集群，存储侧使用io消息队列来控制流量，当io处理完成返回客户端后，流程结束并释放对应队列中的节点，客户端接收请求超时后会重试，存储端发送超时后也会重试。所以在故障场景设计时，需要考虑资源大小、申请释放机制、资源不足的影响以及超时处理流程等；以一个网络故障导致资源不足的BUG例子为例：<br>当存储端处理完成后向客户端返回rsp时，因网络单向异常（存储–&gt;客户端）导致客户端没有收到包，客户端反复重试导致存储侧消息队列资源不足又无法释放，导致存储上其他客户端的io hang。经过分析（分析过程不赘述），该故障场景用例如下：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_7.png\"></p>\n<p>不同的故障和系统流程组合直接影响了故障注入及恢复后的系统表现是什么样的，系统表现完全与业务处理流程强相关，需要深入了解系统的处理流程才能精细化指定故障观察点，比如：副本与客户端之间的网络异常和副本与管控节点之间的网络异常对系统的影响是不一样的，前者对io影响比较大，后者对io影响比较小。</p>\n<p>故障注入测试需要与系统流程分析结合来做，整个系统分析流程投入会比较大，对测试和研发同学的要求比较高，成本也比较高。因此，在前期的故障测试时，更多的采取一些粗粒度的随机故障测试，主要通过时间和次数来发现概率问题，成本相对较低，但是收益也比预期较小。灰白盒故障测试适合有一定故障注入测试经验的团队，因前期使用粗粒度的随机故障注入测试已经发现了很多高概率或者必现的问题，对于低概率问题，需要使用灰白盒分析方法来精细化故障注入测试。</p>\n<h3 id=\"随机故障测试\"><a href=\"#随机故障测试\" class=\"headerlink\" title=\"随机故障测试\"></a>随机故障测试</h3><p>如前文所讲，随机故障测试相比灰白盒故障测试，粒度较粗，开展成本较低。主要包含两个方面的随机：</p>\n<ol>\n<li><p>故障类型的随机</p>\n</li>\n<li><p>故障注入频次&#x2F;阶段&#x2F;时长的随机</p>\n</li>\n<li><p>简单来讲，就是不知道什么时候注入故障，那就使用随机的方式长时间频繁跑故障测试，以此来发现系统问题。随机故障测试对于系统的表现预期相对于灰白盒故障测试来说，观察点也相对较粗，主要是类似io抖动、进程crash等观察点。随机观察注入测试对业务监控系统依赖度比较高，适合通过自动化的方式来开展。</p>\n</li>\n</ol>\n<h2 id=\"业务场景构造测试\"><a href=\"#业务场景构造测试\" class=\"headerlink\" title=\"业务场景构造测试\"></a>业务场景构造测试</h2><p>业务场景类测试主要是指系统接收到一些对于系统有风险的场景后能否保证其可用性和稳定性。比如CBS作为存储对外提供存储服务，会接收来自客户端各种各样的数据流量，这里的测试主要指业务场景出现异常的情况，如场景的突发流量、长期持续高负载流量（也就是压力测试）以及一些特殊的异常流量报文等。一般包括以下几种类型：</p>\n<ol>\n<li>压力测试：通过构造业务模型和配置，对系统进行持续大压力、高并发测试，观察系统的表现。</li>\n<li>长稳测试：在一定业务压力模型下（高于正常压力或者完全高于系统负载）持续长时间运行的测试方法，也可以结合一些基本的故障注入来开展。</li>\n<li>异常业务场景：如异常操作、异常配置、异常流量报文等</li>\n</ol>\n<h1 id=\"CFT及混沌测试\"><a href=\"#CFT及混沌测试\" class=\"headerlink\" title=\"CFT及混沌测试\"></a>CFT及混沌测试</h1><p>前面讲了基于灰白盒和黑盒的故障注入测试，但是分布式系统的复杂性通过上述测试还是远远不够的，不同的数据量、不同的压力，甚至不均衡的压力在系统内部可能都是对应不同的分支，不同的集群节点也会对应不同的处理逻辑，我们无法群居罗列所有的组合，覆盖所有的分支，因此需要引入一些探索性测试。</p>\n<p>CFT（Cross Feature Test）测试是一种基于灰盒的多特性交叉随机的测试，是我们目前正在尝试的一种探索性测试，它的基本逻辑如下图所示：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_8.png\"></p>\n<p>测试单元最小粒度的测试行为，可以是单个测试用例，也可以是单个测试步骤，比如正常的盘操作用例&#x2F;运维变更步骤或者故障步骤，通过自动化调度引擎将多个测试单元按照顺序&#x2F;随机&#x2F;循环以及按照权重等方式组合成测试套进行并发随机运行，你无法知道在某个时刻具体是哪个操作&#x2F;或者哪个故障在运行，这种测试在一定程度上按照未知的时序进行并发随机运行，极大的模拟了一种探索性测试，该类测试必须通过自动化的手段进行测试，无法人工执行；CFT测试需要依赖很强的系统监控能力，这样在测试执行时，一旦出现问题，监控系统能第一时间知晓。</p>\n<p>混沌测试是另外一种工程实践方法，它是一种实验手段，混沌测试的第一步是定义系统的稳态（如iops、时延等指标），然后通过多样化的测试手段（如压力、故障注入等）对系统进行实验，最后对比实验结果，如果系统一直处于稳态，那么认为系统对于该故障是具有容错能力的，否则，就找到了一个系统的bug，去修复它来提高系统的可靠性。</p>\n<p>混沌测试开展的前提是需要软件系统有一定的故障容错能力，它对系统架构的韧性有很高的要求，如果软件系统架构存在单点设计的情况，那么不适合开展混沌测试，一旦出现单点故障，整个系统也就奔溃了，没法验证混沌测试的效果。如果系统当前还没有容错能力，那么应该首先使用故障注入测试方法暴露出更多的系统容错能力，最后再去考虑使用混沌测试。混沌测试也是我们后续需要尝试和探索的一种测试方法。</p>\n<h1 id=\"元数据高可用测试\"><a href=\"#元数据高可用测试\" class=\"headerlink\" title=\"元数据高可用测试\"></a>元数据高可用测试</h1><p>元数据在存储系统中的地位是非常重要的，它记录了数据在存储系统中的真实位置，因此对元数据的管理是至关重要的。腾讯云存储的元数据管理包括分布式拓扑结构、节点的HA数据以及存储数据的索引数据等，它是基于开源的分布式zookeeper集群进行管理的，Zookeeper分布式集群主要通过ZAB协议（Paxos算法的变种）来保证数据的分布式一致性。</p>\n<p>分布式系统主要面临的一致性问题有以下几种：</p>\n<ol>\n<li>数据同步问题：分布式系统中，数据一般都是存在多个节点上，数据需要在节点间进行同步，但是由于现实的网络通道并不是绝对可靠的，经常出现丢包、延迟、错报等问题，导致节点间的数据不能同步，容易出现数据错乱或者不一致的情况。</li>\n<li>节点故障问题：分布式系统中某个或者某些节点故障后无法恢复，如何保证部分节点故障后不会导致整个分布式系统的数据不可用。</li>\n<li>节点宕机恢复：某个或某些节点在A时刻宕机，并在B时刻恢复，宕机期间或者宕机恢复后的数据一致性问题如何解决。</li>\n<li>孤岛节点问题：网络链接异常，将分布式集群分成多个相互隔离的信息孤岛，如何保证孤岛场景下的数据一致性问题。</li>\n</ol>\n<p>因此为了保证元数据的高可用，需要结合系统流程对Zookeeper集群进行故障注入来测试，ZAB协议典型的读写流程如下图：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/img_9.png\"></p>\n<p>ZAB协议中ZK Leader给Follower发送同步复制请求后，只需要一半以上的follower进行了正确反馈（即返回ACK）后，Leader才会再次向所有follower发送事务提交，完成数据同步。因此在测试过程中，需要根据系统流程结合ZAB协议中的选主、事务提交等流程进行故障注入测试来验证元数据的高可用。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>可靠性和高可用测试是发现系统问题、保障产品质量的非常有效的手段，尤其在复杂度偏高的IaaS产品测试中更为有效。对于CBS测试来讲，我们在高可用和可靠性测试方面投入了很多精力，也发现了非常多的问题，其中不乏数据一致性问题，在实际产品测试过程中，70%的bug都是通过它发现的，但是现网仍然有很多低概率偶发问题。所以可靠性和高可用测试只是起点，永远没有终点。</p>\n","slug":"云IaaS测试系列一分布式存储测试实践2-可靠性高可用测试","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/10/17/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B52-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95/","excerpt":"高可用和可靠性是从软件架构设计层面就需要考虑的因素，本文主要从测试角度去思考如何通过测试手段来保障软件系统的高可用和可靠性。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://vwin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"IaaS","slug":"IaaS","permalink":"http://vwin.github.io/tags/IaaS/"}]},{"title":"云IaaS测试系列一分布式存储测试实践1","date":"2022-10-15T07:07:35.000Z","path":"2022/10/15/云IaaS测试系列一分布式存储测试实践1/","text":"分布式系统广泛应用于公有云、私有云以及大型的后台系统，分布式系统测试本身就是业界的一个难题，也是比较大的话题；本文主要针对云存储系统的测试实践来阐述下我们是如何思考分布式存储测试的 概述分布式系统广泛应用于公有云、私有云以及大型的互联网后台系统，分布式系统测试本身就是业界的一个难题，也是比较大的话题；因此我们推出了IaaS测试系列文章来讲述整个IaaS测试实践，本文作为第一篇，主要针对腾讯云存储系统的测试实践来阐述下我们是如何做分布式存储测试的。 云分布式块存储CBS是腾讯云块存储服务，它作为一种分布式存储系统，为云服务器&#x2F;容器&#x2F;数据库等产品提供持久化、高可靠性的块级存储服务。CBS内部有多个模块相互协作来支撑整个块存储和备份等服务，每个模块都是一个产品级的规模，具有很高的复杂度。CBS产品的简要架构如下图: 测试体系软件测试分为很多阶段：单元测试、接口测试、功能测试、系统集成测试和端到端测试，整个测试活动分布在研发流程的各个阶段，传统的产品测试只需要做接口测试和功能测试，实际上我们在测试初期也是如此；但是随着对分布式系统更多的理解，我们发现分布式存储系统的复杂度很高，内部有若干个模块，并与周边的诸多业务协同工作，每个模块都是一个产品级的复杂度，因此传统的接口测试和功能测试已经不能满足于分布式存储系统的质量保障，典型的比如分布式系统一致性如何保障和测试、分布式系统的可靠性和可用性如何测试等都是分布式测试的难题。所以我们需要系统性的设计一个能支撑如此大规模复杂系统的测试质量保障体系。 首先看看软件测试领域有一个比较行之有效的软件测试模型–来自Martin Fowler的金字塔模型，该模型阐述了软件测试分布在整个研发流程中的各个阶段。 备注：金字塔模型是一种通用模型，本模型的生成结合了业务与传统的金字塔模型 金字塔模型阐述了一个比较理想的测试模型–软件测试早期投入越大，最终的产品质量越好: 越往上，越接近测试、业务&#x2F;最终用户，越往下，越接近开发人员； 越往上，测试执行越慢，效率越低，越往下，测试执行越快； 越往上，测试成本越高（越耗时，失败时的信息越模糊，越难定位跟踪），越往下，测试成本越低 按照测试金字塔模型以及投入&#x2F;产出比，可以得知越向下回报率越高，所以应该使用大量的单元测试和全面的接口测试来覆盖产品提供的基本逻辑和功能，理论上金字塔底部的测试活动越充分，金字塔顶部的测试活动发现的问题越少，产品质量也越好； 理想的测试应该符合金字塔模型的流程，但是在当前的产品研发现状下，由于一些现实条件不允许，比如开发人员为了赶项目进度无暇做开发者测试（如单元测试&#x2F;接口测试和组件测试），从而将产品质量完全依托于上层的系统集成测试（更多的是黑盒测试），即我们当前产品开发中的冰激凌甜筒模型（也叫倒金字塔模型，如下图） 在当前的测试现状下，前期的测试投入很低，整体质量仅依托于以黑盒测试为主的集成测试，测试到一定阶段就达到了瓶颈，有越来越多的问题在测试阶段难以发现，大部分都是小概率问题，有些甚至是代码级别的问题，在集成测试阶段需要用长时间测试来撞，有一定的随概率性，成本很高。对比上文中的冰激凌甜筒模型（当前现状）和金字塔模型（理想模型），我们需要将测试模型逐渐往金字塔模型靠拢，因此我们一方面需要加强前期的测试投入，另一方面需要提升后期的测试效率。 因此，依托于DevOps和自动化测试，我们做了研发流程和测试体系的优化，这得益于研发和测试同学的紧密配合，整体思想是通过提升前期测试的自动化程度（如单元测试、代码静态分析、代码Review、接口、功能测试）从开发阶段就不断夯实产品质量，利用自动化工具提升手工测试和回归测试的效率，并在系统测试和端到端测试阶段引入一些专项测试（比如更多的投入可靠性和可用性测试），如下图： 从上图可以看到，测试活动贯穿于整个研发流程，各阶段的测试活动由不同的角色来完成，下面简要介绍下各个测试活动的内容： 单元测试：单元测试是最小的测试单元，其关注的是代码的实现和逻辑，一般不包含业务逻辑，该类测试由开发人员完成，适合做自动化测试。 接口测试：主要验证模块间的调用返回以及不同系统、服务间的数据交换，有一定的业务逻辑，其关注的是数据，需要构造请求数据，适合做自动化测试。 功能测试：主要是针对产品的功能需求进行验证，包括模块级功能测试以及系统级场景功能测试，自动化率依赖产品提供的能力，一般P0&#x2F;P1用例自动化程度较高。 可靠性测试：主要是做基于灰盒的系统级故障注入测试，用来验证系统在各种异常条件下的表现（服务是否能正常恢复，业务是否受影响等），故障注入测试依托于产品的故障模式库进行，分为L0&#x2F;L1&#x2F;L2等级别的故障以及随机故障注入测试；因故障注入的复杂度，可靠性测试自动化率不高，目前只能做到L0级的故障注入，更多可靠性测试细节请参考系列文章分布式存储之可靠性及高可用测试。 压力测试：主要是对被测系统进行加压测试，用来验证系统在一定负载压力下服务能够持续稳定，一般压力测试会结合故障注入测试一起来进行，用来发现更多的问题。压力测试一般也分为组件级别和E2E压测，组件压测用来验证组件最大的性能指标和瓶颈，E2E压测用来验证整个系统的性能瓶颈。 性能测试：主要是指被测系统在各种workload场景下的性能表现，如常见的OLTP&#x2F;OLAP&#x2F;大数据场景等。性能的好坏主要通过一些性能指标来定义，不同的业务对性能指标的要求和定义不同，对存储系统来讲，性能好坏主要通过以下指标来衡量： 延迟（Latency）：衡量存储系统对请求响应的快慢程度 吞吐量（throughput）：衡量存储系统在单位时间内所能处理的最大数据量 IOPS：衡量存储系统中单位时间内所能处理的io请求数 吞吐量和iops是衡量一个存储系统的处理能力的强弱，更多存储性能测试细节请参考系列文章存储性能及性能测试。 一致性测试：分布式系统的数据一致性测试是一项非常有挑战和难度的测试，主要是指在分布式系统的处理过程中，为了保证多节点之间的数据一致性（如缓存一致性、事务一致性等）进行的测试活动和测试方法，请关注后续系列文章。 长稳测试：主要是指系统在一定压力长时间运行下，可结合故障和多特性交叉功能，验证系统是否会出现服务不可用、内存泄漏、性能稳定性等问题，一般在测试中后期运行，用来发现短期难以发现的问题。 灾难测试：主要是指在极端情况下（如数据中心掉电、网络中断等），系统能够在灾难恢复后正常恢复数据和服务，自动化难度较大。 兼容性测试：主要包含与其他软件系统的兼容性测试以及硬件兼容性测试，主要通过自动化来验证。 UI测试：主要指站在用户角度，在Web UI进行功能验收测试，自动化率低。 测试流程开发者测试开发者测试主要包含：单元测试&#x2F;代码静态检查&#x2F;接口及功能的全量自动化&#x2F;新功能P0手工测试，自动化主要通过CI流水线承载 门禁测试门禁测试是指提测过程中使用自动化测试进行门禁拦截，主要包含基础功能测试和场景类测试，门禁测试失败则提测打回 第一轮测试版本提测后进行的第一轮测试，主要以新特性为主（包含P0、P1级别用例），同时通常伴随存量功能的回归测试、长稳和基础可靠性测试 第N轮测试版本测试的轮数跟版本的测试策略相关，视版本大小而定，可以根据版本大小分为第二轮、第三轮等，主要包含更加复杂全面的系统测试和之前未覆盖的深入测试，如一些可靠性、压力、性能等专项测试，通常包含基于前一轮测试的风险点进行加固测试，以及一些P2、P3的用例 持续测试持续测试主要基于自动化进行持续反复测试，与迭代的轮次一起并行测试。 探索性测试分布式系统测试非常的复杂，不同的数据量、不同的压力，甚至不均衡的压力在系统内部可能都是对应不同的分支，不同的集群节点也会对应不同的处理逻辑，我们无法群居罗列所有的组合，覆盖所有的分支，因此需要引入一些探索性测试（如CFT测试）来做一些高随机性的并发测试。 回归测试版本测试的最后一轮测试，在版本封版后，对主干基线P0用例、新需求P0以及问题单进行回归测试，通常是自动化+手工测试相结合的方式进行 测试质量评估软件系统的质量评估是一个比较难的话题，因为即使通过上述测试流程层层测试，也难免会有漏网之鱼，我们主要通过以下手段来评估产品质量： 代码覆盖率代码覆盖率分为单元测试覆盖率和自动化用例覆盖率，它只是作为质量评估的一个参考，根据代码覆盖程度来评估测试用例覆盖到了哪些代码，但是不能说明覆盖好了这些代码。 基于BUG单的质量分析如前文所讲，我们在测试过程中会根据测试策略分为多轮测试，每一轮测试都有该轮的测试重点，我们根据bug单在整个测试轮次中的分布以及bug对应测试场景的用例覆盖度来评估质量。一个好的产品对应的bug数分布应该符合或者接近正态分布，如下图： 第一轮发现的问题相对较少，在第二轮达到峰值，后面逐渐收敛，最后在回归测试过程中收敛到0。 比质量评估更重要的是对研发流程和测试过程的数据管理，需要对发现bug对应的场景进行分析，按bug数对应的场景聚类，筛选出问题数居多的场景类（即风险最高），分析该场景下的用例覆盖度是否足够，从而得到整体的质量风险。 结语分布式系统的测试非常复杂，我们需要在测试过程中继续探索测试方法，利用自动化工具加大测试频次和频率，更多更真实的模拟复杂的业务场景","raw":"---\ntitle: 云IaaS测试系列一分布式存储测试实践1\ntoc: true\ndate: 2022-10-15 15:07:35\ntags: [云,分布式,Iaas]\ncategories: [技术]\ndescription:\n---\n\n分布式系统广泛应用于公有云、私有云以及大型的后台系统，分布式系统测试本身就是业界的一个难题，也是比较大的话题；本文主要针对云存储系统的测试实践来阐述下我们是如何思考分布式存储测试的\n\n<!-- more -->\n# 概述\n分布式系统广泛应用于公有云、私有云以及大型的互联网后台系统，分布式系统测试本身就是业界的一个难题，也是比较大的话题；因此我们推出了IaaS测试系列文章来讲述整个IaaS测试实践，本文作为第一篇，主要针对腾讯云存储系统的测试实践来阐述下我们是如何做分布式存储测试的。\n\n# 云分布式块存储\nCBS是腾讯云块存储服务，它作为一种分布式存储系统，为云服务器/容器/数据库等产品提供持久化、高可靠性的块级存储服务。CBS内部有多个模块相互协作来支撑整个块存储和备份等服务，每个模块都是一个产品级的规模，具有很高的复杂度。\nCBS产品的简要架构如下图:\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img.png)\n# 测试体系\n软件测试分为很多阶段：单元测试、接口测试、功能测试、系统集成测试和端到端测试，整个测试活动分布在研发流程的各个阶段，传统的产品测试只需要做接口测试和功能测试，实际上我们在测试初期也是如此；但是随着对分布式系统更多的理解，我们发现分布式存储系统的复杂度很高，内部有若干个模块，并与周边的诸多业务协同工作，每个模块都是一个产品级的复杂度，因此传统的接口测试和功能测试已经不能满足于分布式存储系统的质量保障，典型的比如分布式系统一致性如何保障和测试、分布式系统的可靠性和可用性如何测试等都是分布式测试的难题。所以我们需要系统性的设计一个能支撑如此大规模复杂系统的测试质量保障体系。\n\n首先看看软件测试领域有一个比较行之有效的软件测试模型--来自Martin Fowler的[金字塔模型](https://martinfowler.com/bliki/TestPyramid.html)，该模型阐述了软件测试分布在整个研发流程中的各个阶段。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_1.png)\n>备注：金字塔模型是一种通用模型，本模型的生成结合了业务与传统的金字塔模型\n\n金字塔模型阐述了一个比较理想的测试模型--软件测试早期投入越大，最终的产品质量越好:\n- 越往上，越接近测试、业务/最终用户，越往下，越接近开发人员； \n- 越往上，测试执行越慢，效率越低，越往下，测试执行越快； \n- 越往上，测试成本越高（越耗时，失败时的信息越模糊，越难定位跟踪），越往下，测试成本越低\n\n按照测试金字塔模型以及投入/产出比，可以得知越向下回报率越高，所以应该使用大量的单元测试和全面的接口测试来覆盖产品提供的基本逻辑和功能，理论上金字塔底部的测试活动越充分，金字塔顶部的测试活动发现的问题越少，产品质量也越好；\n\n理想的测试应该符合金字塔模型的流程，但是在当前的产品研发现状下，由于一些现实条件不允许，比如开发人员为了赶项目进度无暇做开发者测试（如单元测试/接口测试和组件测试），从而将产品质量完全依托于上层的系统集成测试（更多的是黑盒测试），即我们当前产品开发中的冰激凌甜筒模型（也叫倒金字塔模型，如下图）\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_2.png)\n\n在当前的测试现状下，前期的测试投入很低，整体质量仅依托于以黑盒测试为主的集成测试，测试到一定阶段就达到了瓶颈，有越来越多的问题在测试阶段难以发现，大部分都是小概率问题，有些甚至是代码级别的问题，在集成测试阶段需要用长时间测试来撞，有一定的随概率性，成本很高。对比上文中的冰激凌甜筒模型（当前现状）和金字塔模型（理想模型），我们需要将测试模型逐渐往金字塔模型靠拢，因此我们一方面需要加强前期的测试投入，另一方面需要提升后期的测试效率。\n\n因此，依托于DevOps和自动化测试，我们做了研发流程和测试体系的优化，这得益于研发和测试同学的紧密配合，整体思想是通过提升前期测试的自动化程度（如单元测试、代码静态分析、代码Review、接口、功能测试）从开发阶段就不断夯实产品质量，利用自动化工具提升手工测试和回归测试的效率，并在系统测试和端到端测试阶段引入一些专项测试（比如更多的投入可靠性和可用性测试），如下图：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_3.png)\n\n从上图可以看到，测试活动贯穿于整个研发流程，各阶段的测试活动由不同的角色来完成，下面简要介绍下各个测试活动的内容：\n\n- 单元测试：单元测试是最小的测试单元，其关注的是代码的实现和逻辑，一般不包含业务逻辑，该类测试由开发人员完成，适合做自动化测试。\n- 接口测试：主要验证模块间的调用返回以及不同系统、服务间的数据交换，有一定的业务逻辑，其关注的是数据，需要构造请求数据，适合做自动化测试。\n- 功能测试：主要是针对产品的功能需求进行验证，包括模块级功能测试以及系统级场景功能测试，自动化率依赖产品提供的能力，一般P0/P1用例自动化程度较高。\n- 可靠性测试：主要是做基于灰盒的系统级故障注入测试，用来验证系统在各种异常条件下的表现（服务是否能正常恢复，业务是否受影响等），故障注入测试依托于产品的故障模式库进行，分为L0/L1/L2等级别的故障以及随机故障注入测试；因故障注入的复杂度，可靠性测试自动化率不高，目前只能做到L0级的故障注入，更多可靠性测试细节请参考系列文章分布式存储之可靠性及高可用测试。\n- 压力测试：主要是对被测系统进行加压测试，用来验证系统在一定负载压力下服务能够持续稳定，一般压力测试会结合故障注入测试一起来进行，用来发现更多的问题。压力测试一般也分为组件级别和E2E压测，组件压测用来验证组件最大的性能指标和瓶颈，E2E压测用来验证整个系统的性能瓶颈。\n- 性能测试：主要是指被测系统在各种workload场景下的性能表现，如常见的OLTP/OLAP/大数据场景等。性能的好坏主要通过一些性能指标来定义，不同的业务对性能指标的要求和定义不同，对存储系统来讲，性能好坏主要通过以下指标来衡量：\n  - 延迟（Latency）：衡量存储系统对请求响应的快慢程度 \n  - 吞吐量（throughput）：衡量存储系统在单位时间内所能处理的最大数据量 \n  - IOPS：衡量存储系统中单位时间内所能处理的io请求数 \n  - 吞吐量和iops是衡量一个存储系统的处理能力的强弱，更多存储性能测试细节请参考系列文章存储性能及性能测试。\n\n- 一致性测试：分布式系统的数据一致性测试是一项非常有挑战和难度的测试，主要是指在分布式系统的处理过程中，为了保证多节点之间的数据一致性（如缓存一致性、事务一致性等）进行的测试活动和测试方法，请关注后续系列文章。 \n- 长稳测试：主要是指系统在一定压力长时间运行下，可结合故障和多特性交叉功能，验证系统是否会出现服务不可用、内存泄漏、性能稳定性等问题，一般在测试中后期运行，用来发现短期难以发现的问题。 \n- 灾难测试：主要是指在极端情况下（如数据中心掉电、网络中断等），系统能够在灾难恢复后正常恢复数据和服务，自动化难度较大。 \n- 兼容性测试：主要包含与其他软件系统的兼容性测试以及硬件兼容性测试，主要通过自动化来验证。 \n- UI测试：主要指站在用户角度，在Web UI进行功能验收测试，自动化率低。\n\n# 测试流程\n## 开发者测试\n开发者测试主要包含：单元测试/代码静态检查/接口及功能的全量自动化/新功能P0手工测试，自动化主要通过CI流水线承载\n\n## 门禁测试\n门禁测试是指提测过程中使用自动化测试进行门禁拦截，主要包含基础功能测试和场景类测试，门禁测试失败则提测打回\n\n## 第一轮测试\n版本提测后进行的第一轮测试，主要以新特性为主（包含P0、P1级别用例），同时通常伴随存量功能的回归测试、长稳和基础可靠性测试\n\n## 第N轮测试\n版本测试的轮数跟版本的测试策略相关，视版本大小而定，可以根据版本大小分为第二轮、第三轮等，主要包含更加复杂全面的系统测试和之前未覆盖的深入测试，如一些可靠性、压力、性能等专项测试，通常包含基于前一轮测试的风险点进行加固测试，以及一些P2、P3的用例\n\n## 持续测试\n持续测试主要基于自动化进行持续反复测试，与迭代的轮次一起并行测试。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_4.png)\n\n## 探索性测试\n分布式系统测试非常的复杂，不同的数据量、不同的压力，甚至不均衡的压力在系统内部可能都是对应不同的分支，不同的集群节点也会对应不同的处理逻辑，我们无法群居罗列所有的组合，覆盖所有的分支，因此需要引入一些探索性测试（如CFT测试）来做一些高随机性的并发测试。\n\n## 回归测试\n版本测试的最后一轮测试，在版本封版后，对主干基线P0用例、新需求P0以及问题单进行回归测试，通常是自动化+手工测试相结合的方式进行\n\n# 测试质量评估\n软件系统的质量评估是一个比较难的话题，因为即使通过上述测试流程层层测试，也难免会有漏网之鱼，我们主要通过以下手段来评估产品质量：\n\n## 代码覆盖率\n代码覆盖率分为单元测试覆盖率和自动化用例覆盖率，它只是作为质量评估的一个参考，根据代码覆盖程度来评估测试用例覆盖到了哪些代码，但是不能说明覆盖好了这些代码。\n\n## 基于BUG单的质量分析  \n如前文所讲，我们在测试过程中会根据测试策略分为多轮测试，每一轮测试都有该轮的测试重点，我们根据bug单在整个测试轮次中的分布以及bug对应测试场景的用例覆盖度来评估质量。一个好的产品对应的bug数分布应该符合或者接近正态分布，如下图：\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_5.png)\n\n\n第一轮发现的问题相对较少，在第二轮达到峰值，后面逐渐收敛，最后在回归测试过程中收敛到0。\n\n比质量评估更重要的是对研发流程和测试过程的数据管理，需要对发现bug对应的场景进行分析，按bug数对应的场景聚类，筛选出问题数居多的场景类（即风险最高），分析该场景下的用例覆盖度是否足够，从而得到整体的质量风险。\n\n# 结语\n分布式系统的测试非常复杂，我们需要在测试过程中继续探索测试方法，利用自动化工具加大测试频次和频率，更多更真实的模拟复杂的业务场景\n","content":"<p>分布式系统广泛应用于公有云、私有云以及大型的后台系统，分布式系统测试本身就是业界的一个难题，也是比较大的话题；本文主要针对云存储系统的测试实践来阐述下我们是如何思考分布式存储测试的</p>\n<span id=\"more\"></span>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>分布式系统广泛应用于公有云、私有云以及大型的互联网后台系统，分布式系统测试本身就是业界的一个难题，也是比较大的话题；因此我们推出了IaaS测试系列文章来讲述整个IaaS测试实践，本文作为第一篇，主要针对腾讯云存储系统的测试实践来阐述下我们是如何做分布式存储测试的。</p>\n<h1 id=\"云分布式块存储\"><a href=\"#云分布式块存储\" class=\"headerlink\" title=\"云分布式块存储\"></a>云分布式块存储</h1><p>CBS是腾讯云块存储服务，它作为一种分布式存储系统，为云服务器&#x2F;容器&#x2F;数据库等产品提供持久化、高可靠性的块级存储服务。CBS内部有多个模块相互协作来支撑整个块存储和备份等服务，每个模块都是一个产品级的规模，具有很高的复杂度。<br>CBS产品的简要架构如下图:<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img.png\"></p>\n<h1 id=\"测试体系\"><a href=\"#测试体系\" class=\"headerlink\" title=\"测试体系\"></a>测试体系</h1><p>软件测试分为很多阶段：单元测试、接口测试、功能测试、系统集成测试和端到端测试，整个测试活动分布在研发流程的各个阶段，传统的产品测试只需要做接口测试和功能测试，实际上我们在测试初期也是如此；但是随着对分布式系统更多的理解，我们发现分布式存储系统的复杂度很高，内部有若干个模块，并与周边的诸多业务协同工作，每个模块都是一个产品级的复杂度，因此传统的接口测试和功能测试已经不能满足于分布式存储系统的质量保障，典型的比如分布式系统一致性如何保障和测试、分布式系统的可靠性和可用性如何测试等都是分布式测试的难题。所以我们需要系统性的设计一个能支撑如此大规模复杂系统的测试质量保障体系。</p>\n<p>首先看看软件测试领域有一个比较行之有效的软件测试模型–来自Martin Fowler的<a href=\"https://martinfowler.com/bliki/TestPyramid.html\">金字塔模型</a>，该模型阐述了软件测试分布在整个研发流程中的各个阶段。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_1.png\"></p>\n<blockquote>\n<p>备注：金字塔模型是一种通用模型，本模型的生成结合了业务与传统的金字塔模型</p>\n</blockquote>\n<p>金字塔模型阐述了一个比较理想的测试模型–软件测试早期投入越大，最终的产品质量越好:</p>\n<ul>\n<li>越往上，越接近测试、业务&#x2F;最终用户，越往下，越接近开发人员； </li>\n<li>越往上，测试执行越慢，效率越低，越往下，测试执行越快； </li>\n<li>越往上，测试成本越高（越耗时，失败时的信息越模糊，越难定位跟踪），越往下，测试成本越低</li>\n</ul>\n<p>按照测试金字塔模型以及投入&#x2F;产出比，可以得知越向下回报率越高，所以应该使用大量的单元测试和全面的接口测试来覆盖产品提供的基本逻辑和功能，理论上金字塔底部的测试活动越充分，金字塔顶部的测试活动发现的问题越少，产品质量也越好；</p>\n<p>理想的测试应该符合金字塔模型的流程，但是在当前的产品研发现状下，由于一些现实条件不允许，比如开发人员为了赶项目进度无暇做开发者测试（如单元测试&#x2F;接口测试和组件测试），从而将产品质量完全依托于上层的系统集成测试（更多的是黑盒测试），即我们当前产品开发中的冰激凌甜筒模型（也叫倒金字塔模型，如下图）<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_2.png\"></p>\n<p>在当前的测试现状下，前期的测试投入很低，整体质量仅依托于以黑盒测试为主的集成测试，测试到一定阶段就达到了瓶颈，有越来越多的问题在测试阶段难以发现，大部分都是小概率问题，有些甚至是代码级别的问题，在集成测试阶段需要用长时间测试来撞，有一定的随概率性，成本很高。对比上文中的冰激凌甜筒模型（当前现状）和金字塔模型（理想模型），我们需要将测试模型逐渐往金字塔模型靠拢，因此我们一方面需要加强前期的测试投入，另一方面需要提升后期的测试效率。</p>\n<p>因此，依托于DevOps和自动化测试，我们做了研发流程和测试体系的优化，这得益于研发和测试同学的紧密配合，整体思想是通过提升前期测试的自动化程度（如单元测试、代码静态分析、代码Review、接口、功能测试）从开发阶段就不断夯实产品质量，利用自动化工具提升手工测试和回归测试的效率，并在系统测试和端到端测试阶段引入一些专项测试（比如更多的投入可靠性和可用性测试），如下图：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_3.png\"></p>\n<p>从上图可以看到，测试活动贯穿于整个研发流程，各阶段的测试活动由不同的角色来完成，下面简要介绍下各个测试活动的内容：</p>\n<ul>\n<li><p>单元测试：单元测试是最小的测试单元，其关注的是代码的实现和逻辑，一般不包含业务逻辑，该类测试由开发人员完成，适合做自动化测试。</p>\n</li>\n<li><p>接口测试：主要验证模块间的调用返回以及不同系统、服务间的数据交换，有一定的业务逻辑，其关注的是数据，需要构造请求数据，适合做自动化测试。</p>\n</li>\n<li><p>功能测试：主要是针对产品的功能需求进行验证，包括模块级功能测试以及系统级场景功能测试，自动化率依赖产品提供的能力，一般P0&#x2F;P1用例自动化程度较高。</p>\n</li>\n<li><p>可靠性测试：主要是做基于灰盒的系统级故障注入测试，用来验证系统在各种异常条件下的表现（服务是否能正常恢复，业务是否受影响等），故障注入测试依托于产品的故障模式库进行，分为L0&#x2F;L1&#x2F;L2等级别的故障以及随机故障注入测试；因故障注入的复杂度，可靠性测试自动化率不高，目前只能做到L0级的故障注入，更多可靠性测试细节请参考系列文章分布式存储之可靠性及高可用测试。</p>\n</li>\n<li><p>压力测试：主要是对被测系统进行加压测试，用来验证系统在一定负载压力下服务能够持续稳定，一般压力测试会结合故障注入测试一起来进行，用来发现更多的问题。压力测试一般也分为组件级别和E2E压测，组件压测用来验证组件最大的性能指标和瓶颈，E2E压测用来验证整个系统的性能瓶颈。</p>\n</li>\n<li><p>性能测试：主要是指被测系统在各种workload场景下的性能表现，如常见的OLTP&#x2F;OLAP&#x2F;大数据场景等。性能的好坏主要通过一些性能指标来定义，不同的业务对性能指标的要求和定义不同，对存储系统来讲，性能好坏主要通过以下指标来衡量：</p>\n<ul>\n<li>延迟（Latency）：衡量存储系统对请求响应的快慢程度 </li>\n<li>吞吐量（throughput）：衡量存储系统在单位时间内所能处理的最大数据量 </li>\n<li>IOPS：衡量存储系统中单位时间内所能处理的io请求数 </li>\n<li>吞吐量和iops是衡量一个存储系统的处理能力的强弱，更多存储性能测试细节请参考系列文章存储性能及性能测试。</li>\n</ul>\n</li>\n<li><p>一致性测试：分布式系统的数据一致性测试是一项非常有挑战和难度的测试，主要是指在分布式系统的处理过程中，为了保证多节点之间的数据一致性（如缓存一致性、事务一致性等）进行的测试活动和测试方法，请关注后续系列文章。 </p>\n</li>\n<li><p>长稳测试：主要是指系统在一定压力长时间运行下，可结合故障和多特性交叉功能，验证系统是否会出现服务不可用、内存泄漏、性能稳定性等问题，一般在测试中后期运行，用来发现短期难以发现的问题。 </p>\n</li>\n<li><p>灾难测试：主要是指在极端情况下（如数据中心掉电、网络中断等），系统能够在灾难恢复后正常恢复数据和服务，自动化难度较大。 </p>\n</li>\n<li><p>兼容性测试：主要包含与其他软件系统的兼容性测试以及硬件兼容性测试，主要通过自动化来验证。 </p>\n</li>\n<li><p>UI测试：主要指站在用户角度，在Web UI进行功能验收测试，自动化率低。</p>\n</li>\n</ul>\n<h1 id=\"测试流程\"><a href=\"#测试流程\" class=\"headerlink\" title=\"测试流程\"></a>测试流程</h1><h2 id=\"开发者测试\"><a href=\"#开发者测试\" class=\"headerlink\" title=\"开发者测试\"></a>开发者测试</h2><p>开发者测试主要包含：单元测试&#x2F;代码静态检查&#x2F;接口及功能的全量自动化&#x2F;新功能P0手工测试，自动化主要通过CI流水线承载</p>\n<h2 id=\"门禁测试\"><a href=\"#门禁测试\" class=\"headerlink\" title=\"门禁测试\"></a>门禁测试</h2><p>门禁测试是指提测过程中使用自动化测试进行门禁拦截，主要包含基础功能测试和场景类测试，门禁测试失败则提测打回</p>\n<h2 id=\"第一轮测试\"><a href=\"#第一轮测试\" class=\"headerlink\" title=\"第一轮测试\"></a>第一轮测试</h2><p>版本提测后进行的第一轮测试，主要以新特性为主（包含P0、P1级别用例），同时通常伴随存量功能的回归测试、长稳和基础可靠性测试</p>\n<h2 id=\"第N轮测试\"><a href=\"#第N轮测试\" class=\"headerlink\" title=\"第N轮测试\"></a>第N轮测试</h2><p>版本测试的轮数跟版本的测试策略相关，视版本大小而定，可以根据版本大小分为第二轮、第三轮等，主要包含更加复杂全面的系统测试和之前未覆盖的深入测试，如一些可靠性、压力、性能等专项测试，通常包含基于前一轮测试的风险点进行加固测试，以及一些P2、P3的用例</p>\n<h2 id=\"持续测试\"><a href=\"#持续测试\" class=\"headerlink\" title=\"持续测试\"></a>持续测试</h2><p>持续测试主要基于自动化进行持续反复测试，与迭代的轮次一起并行测试。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_4.png\"></p>\n<h2 id=\"探索性测试\"><a href=\"#探索性测试\" class=\"headerlink\" title=\"探索性测试\"></a>探索性测试</h2><p>分布式系统测试非常的复杂，不同的数据量、不同的压力，甚至不均衡的压力在系统内部可能都是对应不同的分支，不同的集群节点也会对应不同的处理逻辑，我们无法群居罗列所有的组合，覆盖所有的分支，因此需要引入一些探索性测试（如CFT测试）来做一些高随机性的并发测试。</p>\n<h2 id=\"回归测试\"><a href=\"#回归测试\" class=\"headerlink\" title=\"回归测试\"></a>回归测试</h2><p>版本测试的最后一轮测试，在版本封版后，对主干基线P0用例、新需求P0以及问题单进行回归测试，通常是自动化+手工测试相结合的方式进行</p>\n<h1 id=\"测试质量评估\"><a href=\"#测试质量评估\" class=\"headerlink\" title=\"测试质量评估\"></a>测试质量评估</h1><p>软件系统的质量评估是一个比较难的话题，因为即使通过上述测试流程层层测试，也难免会有漏网之鱼，我们主要通过以下手段来评估产品质量：</p>\n<h2 id=\"代码覆盖率\"><a href=\"#代码覆盖率\" class=\"headerlink\" title=\"代码覆盖率\"></a>代码覆盖率</h2><p>代码覆盖率分为单元测试覆盖率和自动化用例覆盖率，它只是作为质量评估的一个参考，根据代码覆盖程度来评估测试用例覆盖到了哪些代码，但是不能说明覆盖好了这些代码。</p>\n<h2 id=\"基于BUG单的质量分析\"><a href=\"#基于BUG单的质量分析\" class=\"headerlink\" title=\"基于BUG单的质量分析\"></a>基于BUG单的质量分析</h2><p>如前文所讲，我们在测试过程中会根据测试策略分为多轮测试，每一轮测试都有该轮的测试重点，我们根据bug单在整个测试轮次中的分布以及bug对应测试场景的用例覆盖度来评估质量。一个好的产品对应的bug数分布应该符合或者接近正态分布，如下图：<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/img_5.png\"></p>\n<p>第一轮发现的问题相对较少，在第二轮达到峰值，后面逐渐收敛，最后在回归测试过程中收敛到0。</p>\n<p>比质量评估更重要的是对研发流程和测试过程的数据管理，需要对发现bug对应的场景进行分析，按bug数对应的场景聚类，筛选出问题数居多的场景类（即风险最高），分析该场景下的用例覆盖度是否足够，从而得到整体的质量风险。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>分布式系统的测试非常复杂，我们需要在测试过程中继续探索测试方法，利用自动化工具加大测试频次和频率，更多更真实的模拟复杂的业务场景</p>\n","slug":"云IaaS测试系列一分布式存储测试实践1","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/10/15/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B51/","excerpt":"分布式系统广泛应用于公有云、私有云以及大型的后台系统，分布式系统测试本身就是业界的一个难题，也是比较大的话题；本文主要针对云存储系统的测试实践来阐述下我们是如何思考分布式存储测试的","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"云","slug":"云","permalink":"http://vwin.github.io/tags/%E4%BA%91/"},{"name":"分布式","slug":"分布式","permalink":"http://vwin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"Iaas","slug":"Iaas","permalink":"http://vwin.github.io/tags/Iaas/"}]},{"title":"CPP-Python解析头文件","date":"2022-09-22T08:30:59.000Z","path":"2022/09/22/CPP-Python解析头文件/","text":"本文主要讲述使用Python解析C++头文件，使用的python库叫robotpy-cppheaderparsergithub地址：https://github.com/robotpy/robotpy-cppheaderparser接口文档：https://cppheaderparser.readthedocs.io/en/stable/index.html 安装使用下面命令进行安装 1pip install robotpy-cppheaderparser 示例.h文件准备一个C++头文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#ifndef _SAMPLE_CLASS_H_#define _SAMPLE_CLASS_H_ #include &lt;vector&gt;#include &lt;string&gt;#include &lt;stdio.h&gt; #define DEF_1 1#define OS_NAME &quot;Linux&quot; const int MyData1=100;const int MyData2=200; using namespace std; typedef enum &#123; AA, BB&#125; myEnum_t; class SampleClass&#123;public: typedef enum &#123; CC, DD &#125; myAnother_t; SampleClass(); /*! * Method 1 */ string meth1(); /// /// Method 2 description /// /// @param v1 Variable 1 /// int meth2(int v1); /** * Method 3 description * * \\param v1 Variable 1 * \\param v2 Variable 2 */ void meth3(const string &amp; v1, vector&lt;string&gt; &amp; v2); /********************************** * Method 4 description * * @return Return value *********************************/ unsigned int meth4();private: void * meth5()&#123;return NULL&#125;; /// prop1 description string prop1; //! prop5 description int prop5;&#125;; namespace Alpha&#123; class AlphaClass &#123; public: AlphaClass(); void alphaMethod(); string alphaString; &#125;; namespace Omega &#123; class OmegaClass &#123; public: OmegaClass(); string omegaString; &#125;; &#125;;&#125; int sampleFreeFunction(int i)&#123; return i + 1;&#125; int anotherFreeFunction(void); #endif 使用robotpy-cppheaderparser123import CppHeaderParsercppHeader = CppHeaderParser.CppHeader(&quot;SampleClass.h&quot;)# 解析后的内容放到变量cppHeader里，下面就来看下如何获取头文件里的各种内容 获取include的头文件名12print(cppHeader.includes) 获取头文件中定义的类名12for classname in cppHeader.classes.keys(): print(classname) 获取类所属的namespace1234print(cppHeader.classes[&#x27;SampleClass&#x27;][&#x27;namespace&#x27;])print(cppHeader.classes[&#x27;AlphaClass&#x27;][&#x27;namespace&#x27;])print(cppHeader.classes[&#x27;OmegaClass&#x27;][&#x27;namespace&#x27;])# 没有namespace就打印为空 获取类里的public方法12345for oneMethod in cppHeader.classes[&#x27;SampleClass&#x27;][&#x27;methods&#x27;][&#x27;public&#x27;]: for kv in oneMethod.items(): print(kv[0], &quot; : &quot;, kv[1]) print(&#x27;---------------------\\n&#x27;) 获取类里的public方法函数参数和返回类型一个方法会有许多相关属性，可以根据实际需要进行选择。 常规来说只需要函数名，函数参数和返回类型就可以了，对应的key分别为“name”，“parameters”，“rtnType” 12345678for oneMethod in cppHeader.classes[&#x27;SampleClass&#x27;][&#x27;methods&#x27;][&#x27;public&#x27;]: print(&#x27;name: &#x27;, oneMethod[&#x27;name&#x27;]) print(&#x27;rtnType: &#x27;, oneMethod[&#x27;rtnType&#x27;]) print(&#x27;parameters: &#x27;, end=&#x27;&#x27;) if len(oneMethod[&#x27;parameters&#x27;]): for oneParam in oneMethod[&#x27;parameters&#x27;]: print(oneParam[&#x27;name&#x27;], oneParam[&#x27;type&#x27;], end=&#x27;; &#x27;) print(&#x27;\\n&#x27;) 获取类里的public变量12345for oneProperty in cppHeader.classes[&#x27;AlphaClass&#x27;][&#x27;properties&#x27;][&#x27;public&#x27;]: print(&#x27;name: &#x27;, oneProperty[&#x27;name&#x27;]) print(&#x27;type: &#x27;, oneProperty[&#x27;type&#x27;]) # for kv in oneProperty.items(): # print(kv[0], &quot; : &quot;, kv[1]) 这里只挑了2个比较重要的属性name和type 获取类里的private方法12345for oneMethod in cppHeader.classes[&#x27;SampleClass&#x27;][&#x27;methods&#x27;][&#x27;private&#x27;]: for kv in oneMethod.items(): print(kv[0], &quot; : &quot;, kv[1]) print(&#x27;---------------------\\n&#x27;) 获取类里的private变量12345for oneProperty in cppHeader.classes[&#x27;SampleClass&#x27;][&#x27;properties&#x27;][&#x27;private&#x27;]: print(&#x27;name: &#x27;, oneProperty[&#x27;name&#x27;]) print(&#x27;type: &#x27;, oneProperty[&#x27;type&#x27;]) # for kv in oneProperty.items(): # print(kv[0], &quot; : &quot;, kv[1]) 获取头文件里定义的函数（类外定义的函数）12345for func in cppHeader.functions: print(&#x27;name: &#123;&#125;&#x27;.format(func[&#x27;name&#x27;])) print(&#x27;rtnType: &#123;&#125;&#x27;.format(func[&#x27;rtnType&#x27;])) print(&#x27;parameters: &#123;&#125;&#x27;.format(func[&#x27;parameters&#x27;])) print(&#x27;\\n&#x27;) 获取头文件里定义的宏定义12for define in cppHeader.defines: print(define) # 类型是str 获取头文件里定义的enum12for oneEnum in cppHeader.enums: print(oneEnum) 获取类里定义的enum123for oneEnum in cppHeader.classes[&#x27;SampleClass&#x27;][&#x27;enums&#x27;][&#x27;public&#x27;]: print(oneEnum)# 注意，这个enum是定义在SampleClass的public区 获取头文件里定义的变量12for oneVar in cppHeader.variables: print(oneVar) 总览使用下面的命令对整个头文件的解析结果进行总览，结果会以json格式打印出来， 12python -m CppHeaderParser.tojson ./SampleClass.h#总览的好处是可以根据需要进行查看，因为很多属性不是很清楚，总览看一下就很方便。","raw":"---\ntitle: CPP-Python解析头文件\ntoc: true\ndate: 2022-09-22 16:30:59\ntags: [c++,头文件]\ncategories: [技术]\ndescription:\n---\n\n本文主要讲述使用Python解析C++头文件，使用的python库叫robotpy-cppheaderparser\ngithub地址：https://github.com/robotpy/robotpy-cppheaderparser\n接口文档：https://cppheaderparser.readthedocs.io/en/stable/index.html\n\n<!-- more-->\n## 安装\n使用下面命令进行安装\n```shell\npip install robotpy-cppheaderparser\n```\n\n## 示例.h文件\n准备一个C++头文件\n```c++\n#ifndef _SAMPLE_CLASS_H_\n#define _SAMPLE_CLASS_H_\n \n#include <vector>\n#include <string>\n#include <stdio.h>\n \n#define DEF_1 1\n#define OS_NAME \"Linux\"\n \nconst int MyData1=100;\nconst int MyData2=200;\n \nusing namespace std;\n \ntypedef enum {\n    AA,\n    BB\n} myEnum_t;\n \n \nclass SampleClass\n{\npublic:\n \n    typedef enum {\n        CC,\n        DD\n    } myAnother_t;\n \n    SampleClass();\n    /*!\n     * Method 1\n     */\n    string meth1();\n \n    ///\n    /// Method 2 description\n    ///\n    /// @param v1 Variable 1\n    ///\n    int meth2(int v1);\n \n    /**\n     * Method 3 description\n     *\n     * \\param v1 Variable 1\n     * \\param v2 Variable 2\n     */\n    void meth3(const string & v1, vector<string> & v2);\n \n    /**********************************\n     * Method 4 description\n     *\n     * @return Return value\n     *********************************/\n    unsigned int meth4();\nprivate:\n    void * meth5(){return NULL};\n \n    /// prop1 description\n    string prop1;\n    //! prop5 description\n    int prop5;\n};\n \n \nnamespace Alpha\n{\n    class AlphaClass\n    {\n    public:\n        AlphaClass();\n \n        void alphaMethod();\n \n        string alphaString;\n    };\n \n    namespace Omega\n    {\n        class OmegaClass\n        {\n        public:\n            OmegaClass();\n \n            string omegaString;\n        };\n    };\n}\n \nint sampleFreeFunction(int i)\n{\n    return i + 1;\n}\n \nint anotherFreeFunction(void);\n \n \n#endif\n```\n\n## 使用robotpy-cppheaderparser\n\n```python\nimport CppHeaderParser\ncppHeader = CppHeaderParser.CppHeader(\"SampleClass.h\")\n# 解析后的内容放到变量cppHeader里，下面就来看下如何获取头文件里的各种内容\n```\n### 获取include的头文件名\n```python\nprint(cppHeader.includes)\n\n```\n### 获取头文件中定义的类名\n```python\nfor classname in cppHeader.classes.keys():\n\tprint(classname)\n```\n\n### 获取类所属的namespace\n```python\nprint(cppHeader.classes['SampleClass']['namespace'])\nprint(cppHeader.classes['AlphaClass']['namespace'])\nprint(cppHeader.classes['OmegaClass']['namespace'])\n# 没有namespace就打印为空\n```\n### 获取类里的public方法\n\n```python\nfor oneMethod in cppHeader.classes['SampleClass']['methods']['public']:\n\tfor kv in oneMethod.items():\n\t\tprint(kv[0], \" : \", kv[1])\n \n\tprint('---------------------\\n')\n```\n\n### 获取类里的public方法函数参数和返回类型\n一个方法会有许多相关属性，可以根据实际需要进行选择。\n\n常规来说只需要函数名，函数参数和返回类型就可以了，对应的key分别为“name”，“parameters”，“rtnType”\n```python\nfor oneMethod in cppHeader.classes['SampleClass']['methods']['public']:\n\tprint('name: ', oneMethod['name'])\n\tprint('rtnType: ', oneMethod['rtnType'])\n\tprint('parameters: ', end='')\n\tif len(oneMethod['parameters']):\n\t\tfor oneParam in oneMethod['parameters']:\n\t\t\tprint(oneParam['name'], oneParam['type'], end='; ')\n\tprint('\\n')\n```\n### 获取类里的public变量\n```python\nfor oneProperty in cppHeader.classes['AlphaClass']['properties']['public']:\n\tprint('name: ', oneProperty['name'])\n\tprint('type: ', oneProperty['type'])\n\t# for kv in oneProperty.items():\n\t# \tprint(kv[0], \" : \", kv[1])\n```\n这里只挑了2个比较重要的属性name和type\n\n### 获取类里的private方法\n```python\nfor oneMethod in cppHeader.classes['SampleClass']['methods']['private']:\n\tfor kv in oneMethod.items():\n\t\tprint(kv[0], \" : \", kv[1])\n \n\tprint('---------------------\\n')\n```\n### 获取类里的private变量\n```python\nfor oneProperty in cppHeader.classes['SampleClass']['properties']['private']:\n    print('name: ', oneProperty['name'])\n    print('type: ', oneProperty['type'])\n    # for kv in oneProperty.items():\n    # \tprint(kv[0], \" : \", kv[1])\n```\n### 获取头文件里定义的函数（类外定义的函数）\n```python\nfor func in cppHeader.functions:\n    print('name: {}'.format(func['name']))\n    print('rtnType: {}'.format(func['rtnType']))\n    print('parameters: {}'.format(func['parameters']))\n    print('\\n')\n```\n### 获取头文件里定义的宏定义\n```python\nfor define in cppHeader.defines:\n    print(define) # 类型是str\n```\n\n### 获取头文件里定义的enum\n```python\nfor oneEnum in cppHeader.enums:\n    print(oneEnum)\n```\n\n### 获取类里定义的enum\n```python\nfor oneEnum in cppHeader.classes['SampleClass']['enums']['public']:\n    print(oneEnum)\n# 注意，这个enum是定义在SampleClass的public区\n```\n\n### 获取头文件里定义的变量\n```python\nfor oneVar in cppHeader.variables:\n    print(oneVar)\n```\n\n### 总览\n使用下面的命令对整个头文件的解析结果进行总览，结果会以json格式打印出来，\n```shell\npython -m CppHeaderParser.tojson ./SampleClass.h\n#总览的好处是可以根据需要进行查看，因为很多属性不是很清楚，总览看一下就很方便。\n```\n","content":"<p>本文主要讲述使用Python解析C++头文件，使用的python库叫robotpy-cppheaderparser<br>github地址：<a href=\"https://github.com/robotpy/robotpy-cppheaderparser\">https://github.com/robotpy/robotpy-cppheaderparser</a><br>接口文档：<a href=\"https://cppheaderparser.readthedocs.io/en/stable/index.html\">https://cppheaderparser.readthedocs.io/en/stable/index.html</a></p>\n<span id=\"more\"></span>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用下面命令进行安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install robotpy-cppheaderparser</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例-h文件\"><a href=\"#示例-h文件\" class=\"headerlink\" title=\"示例.h文件\"></a>示例.h文件</h2><p>准备一个C++头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _SAMPLE_CLASS_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _SAMPLE_CLASS_H_</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DEF_1 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OS_NAME <span class=\"string\">&quot;Linux&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MyData1=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MyData2=<span class=\"number\">200</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    AA,</span><br><span class=\"line\">    BB</span><br><span class=\"line\">&#125; myEnum_t;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SampleClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">        CC,</span><br><span class=\"line\">        DD</span><br><span class=\"line\">    &#125; myAnother_t;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">SampleClass</span>();</span><br><span class=\"line\">    <span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\">     * Method 1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">meth1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// Method 2 description</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// @param v1 Variable 1</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">meth2</span><span class=\"params\">(<span class=\"type\">int</span> v1)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Method 3 description</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * \\param v1 Variable 1</span></span><br><span class=\"line\"><span class=\"comment\">     * \\param v2 Variable 2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">meth3</span><span class=\"params\">(<span class=\"type\">const</span> string &amp; v1, vector&lt;string&gt; &amp; v2)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**********************************</span></span><br><span class=\"line\"><span class=\"comment\">     * Method 4 description</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * @return Return value</span></span><br><span class=\"line\"><span class=\"comment\">     *********************************/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">meth4</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> * <span class=\"title\">meth5</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/// prop1 description</span></span><br><span class=\"line\">    string prop1;</span><br><span class=\"line\">    <span class=\"comment\">//! prop5 description</span></span><br><span class=\"line\">    <span class=\"type\">int</span> prop5;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Alpha</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">AlphaClass</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">AlphaClass</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">alphaMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        string alphaString;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">namespace</span> Omega</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">OmegaClass</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span>:</span><br><span class=\"line\">            <span class=\"built_in\">OmegaClass</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">            string omegaString;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sampleFreeFunction</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">anotherFreeFunction</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用robotpy-cppheaderparser\"><a href=\"#使用robotpy-cppheaderparser\" class=\"headerlink\" title=\"使用robotpy-cppheaderparser\"></a>使用robotpy-cppheaderparser</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> CppHeaderParser</span><br><span class=\"line\">cppHeader = CppHeaderParser.CppHeader(<span class=\"string\">&quot;SampleClass.h&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 解析后的内容放到变量cppHeader里，下面就来看下如何获取头文件里的各种内容</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取include的头文件名\"><a href=\"#获取include的头文件名\" class=\"headerlink\" title=\"获取include的头文件名\"></a>获取include的头文件名</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(cppHeader.includes)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取头文件中定义的类名\"><a href=\"#获取头文件中定义的类名\" class=\"headerlink\" title=\"获取头文件中定义的类名\"></a>获取头文件中定义的类名</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> classname <span class=\"keyword\">in</span> cppHeader.classes.keys():</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(classname)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取类所属的namespace\"><a href=\"#获取类所属的namespace\" class=\"headerlink\" title=\"获取类所属的namespace\"></a>获取类所属的namespace</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(cppHeader.classes[<span class=\"string\">&#x27;SampleClass&#x27;</span>][<span class=\"string\">&#x27;namespace&#x27;</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(cppHeader.classes[<span class=\"string\">&#x27;AlphaClass&#x27;</span>][<span class=\"string\">&#x27;namespace&#x27;</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(cppHeader.classes[<span class=\"string\">&#x27;OmegaClass&#x27;</span>][<span class=\"string\">&#x27;namespace&#x27;</span>])</span><br><span class=\"line\"><span class=\"comment\"># 没有namespace就打印为空</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取类里的public方法\"><a href=\"#获取类里的public方法\" class=\"headerlink\" title=\"获取类里的public方法\"></a>获取类里的public方法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneMethod <span class=\"keyword\">in</span> cppHeader.classes[<span class=\"string\">&#x27;SampleClass&#x27;</span>][<span class=\"string\">&#x27;methods&#x27;</span>][<span class=\"string\">&#x27;public&#x27;</span>]:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> kv <span class=\"keyword\">in</span> oneMethod.items():</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(kv[<span class=\"number\">0</span>], <span class=\"string\">&quot; : &quot;</span>, kv[<span class=\"number\">1</span>])</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;---------------------\\n&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取类里的public方法函数参数和返回类型\"><a href=\"#获取类里的public方法函数参数和返回类型\" class=\"headerlink\" title=\"获取类里的public方法函数参数和返回类型\"></a>获取类里的public方法函数参数和返回类型</h3><p>一个方法会有许多相关属性，可以根据实际需要进行选择。</p>\n<p>常规来说只需要函数名，函数参数和返回类型就可以了，对应的key分别为“name”，“parameters”，“rtnType”</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneMethod <span class=\"keyword\">in</span> cppHeader.classes[<span class=\"string\">&#x27;SampleClass&#x27;</span>][<span class=\"string\">&#x27;methods&#x27;</span>][<span class=\"string\">&#x27;public&#x27;</span>]:</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;name: &#x27;</span>, oneMethod[<span class=\"string\">&#x27;name&#x27;</span>])</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;rtnType: &#x27;</span>, oneMethod[<span class=\"string\">&#x27;rtnType&#x27;</span>])</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;parameters: &#x27;</span>, end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(oneMethod[<span class=\"string\">&#x27;parameters&#x27;</span>]):</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> oneParam <span class=\"keyword\">in</span> oneMethod[<span class=\"string\">&#x27;parameters&#x27;</span>]:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">print</span>(oneParam[<span class=\"string\">&#x27;name&#x27;</span>], oneParam[<span class=\"string\">&#x27;type&#x27;</span>], end=<span class=\"string\">&#x27;; &#x27;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取类里的public变量\"><a href=\"#获取类里的public变量\" class=\"headerlink\" title=\"获取类里的public变量\"></a>获取类里的public变量</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneProperty <span class=\"keyword\">in</span> cppHeader.classes[<span class=\"string\">&#x27;AlphaClass&#x27;</span>][<span class=\"string\">&#x27;properties&#x27;</span>][<span class=\"string\">&#x27;public&#x27;</span>]:</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;name: &#x27;</span>, oneProperty[<span class=\"string\">&#x27;name&#x27;</span>])</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;type: &#x27;</span>, oneProperty[<span class=\"string\">&#x27;type&#x27;</span>])</span><br><span class=\"line\">\t<span class=\"comment\"># for kv in oneProperty.items():</span></span><br><span class=\"line\">\t<span class=\"comment\"># \tprint(kv[0], &quot; : &quot;, kv[1])</span></span><br></pre></td></tr></table></figure>\n<p>这里只挑了2个比较重要的属性name和type</p>\n<h3 id=\"获取类里的private方法\"><a href=\"#获取类里的private方法\" class=\"headerlink\" title=\"获取类里的private方法\"></a>获取类里的private方法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneMethod <span class=\"keyword\">in</span> cppHeader.classes[<span class=\"string\">&#x27;SampleClass&#x27;</span>][<span class=\"string\">&#x27;methods&#x27;</span>][<span class=\"string\">&#x27;private&#x27;</span>]:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> kv <span class=\"keyword\">in</span> oneMethod.items():</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(kv[<span class=\"number\">0</span>], <span class=\"string\">&quot; : &quot;</span>, kv[<span class=\"number\">1</span>])</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;---------------------\\n&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取类里的private变量\"><a href=\"#获取类里的private变量\" class=\"headerlink\" title=\"获取类里的private变量\"></a>获取类里的private变量</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneProperty <span class=\"keyword\">in</span> cppHeader.classes[<span class=\"string\">&#x27;SampleClass&#x27;</span>][<span class=\"string\">&#x27;properties&#x27;</span>][<span class=\"string\">&#x27;private&#x27;</span>]:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;name: &#x27;</span>, oneProperty[<span class=\"string\">&#x27;name&#x27;</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;type: &#x27;</span>, oneProperty[<span class=\"string\">&#x27;type&#x27;</span>])</span><br><span class=\"line\">    <span class=\"comment\"># for kv in oneProperty.items():</span></span><br><span class=\"line\">    <span class=\"comment\"># \tprint(kv[0], &quot; : &quot;, kv[1])</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取头文件里定义的函数（类外定义的函数）\"><a href=\"#获取头文件里定义的函数（类外定义的函数）\" class=\"headerlink\" title=\"获取头文件里定义的函数（类外定义的函数）\"></a>获取头文件里定义的函数（类外定义的函数）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> func <span class=\"keyword\">in</span> cppHeader.functions:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;name: &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(func[<span class=\"string\">&#x27;name&#x27;</span>]))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;rtnType: &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(func[<span class=\"string\">&#x27;rtnType&#x27;</span>]))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;parameters: &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(func[<span class=\"string\">&#x27;parameters&#x27;</span>]))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取头文件里定义的宏定义\"><a href=\"#获取头文件里定义的宏定义\" class=\"headerlink\" title=\"获取头文件里定义的宏定义\"></a>获取头文件里定义的宏定义</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> define <span class=\"keyword\">in</span> cppHeader.defines:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(define) <span class=\"comment\"># 类型是str</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取头文件里定义的enum\"><a href=\"#获取头文件里定义的enum\" class=\"headerlink\" title=\"获取头文件里定义的enum\"></a>获取头文件里定义的enum</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneEnum <span class=\"keyword\">in</span> cppHeader.enums:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(oneEnum)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取类里定义的enum\"><a href=\"#获取类里定义的enum\" class=\"headerlink\" title=\"获取类里定义的enum\"></a>获取类里定义的enum</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneEnum <span class=\"keyword\">in</span> cppHeader.classes[<span class=\"string\">&#x27;SampleClass&#x27;</span>][<span class=\"string\">&#x27;enums&#x27;</span>][<span class=\"string\">&#x27;public&#x27;</span>]:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(oneEnum)</span><br><span class=\"line\"><span class=\"comment\"># 注意，这个enum是定义在SampleClass的public区</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取头文件里定义的变量\"><a href=\"#获取头文件里定义的变量\" class=\"headerlink\" title=\"获取头文件里定义的变量\"></a>获取头文件里定义的变量</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> oneVar <span class=\"keyword\">in</span> cppHeader.variables:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(oneVar)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h3><p>使用下面的命令对整个头文件的解析结果进行总览，结果会以json格式打印出来，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m CppHeaderParser.tojson ./SampleClass.h</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">总览的好处是可以根据需要进行查看，因为很多属性不是很清楚，总览看一下就很方便。</span></span><br></pre></td></tr></table></figure>\n","slug":"CPP-Python解析头文件","updated":"2022-11-27T10:39:22.787Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/09/22/CPP-Python%E8%A7%A3%E6%9E%90%E5%A4%B4%E6%96%87%E4%BB%B6/","excerpt":"本文主要讲述使用Python解析C++头文件，使用的python库叫robotpy-cppheaderparsergithub地址：https://github.com/robotpy/robotpy-cppheaderparser接口文档：https://cppheaderparser.readthedocs.io/en/stable/index.html","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://vwin.github.io/tags/c/"},{"name":"头文件","slug":"头文件","permalink":"http://vwin.github.io/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"}]},{"title":"CPP-性能分析工具","date":"2022-09-22T07:17:14.000Z","path":"2022/09/22/CPP-性能分析工具/","text":"工具介绍perf12345678910111213perf支持命令非常多，常用的有以下几个perf list查看可采样的指标perf stat查看cpu占用率、进程上下文切换、CPU迁移、缺页中断等指标总体情况perf record采样某个指标的具体情况perf report根据采样结果生成报告 关于perf原理可查看：https://zhuanlan.zhihu.com/p/22194920 火焰图perf工具生成的报告不够直观，可以使用https://github.com/brendangregg/FlameGraph 工具将采样结果生成火焰图，方便查看。 strace采样进程系统系统调用情况。 示例使用上述工具，采样一个程序的运行情况。 启动进程启动本地实例，通过ps -ef | grep proc查找进程pid。 使用perf采样数据使用 1perf record -e task-clock -g -p pid // 采样进程的cpu使用详情。 其中-e task-clock表示采样各个任务占用cpu时间，-g表示获取任务间的调用链，-p pid表示采样指定进程。可以通过CTRL+C可以结束采样，采样结束后会在本地路径生成一个名为perf.data的采样文件。 使用perf查看报告可以通过 1perf report -i perf.data //命令生成报告 其中-i perf.data表示指定数据源，perf.data是perf record的采样结果。命令执行结果如下。+表示可以展开调用链，按下回车键即可。从下面结果我们就可以查看函数执行占用的cpu时间比例。 使用火焰图perf生成的报告可以查看结果，但是没有火焰图直观，可以通过https://github.com/brendangregg/FlameGraph 工具来生成，具体操作如下，执行下面几个命令生成svg文件。 1234567perf script -i perf.data &gt; perf.unfold./FlameGraph/stackcollapse-perf.pl perf.unfold &gt; perf.folded./FlameGraph/flamegraph.pl perf.folded &gt; perf.svg上述命令可以通过管道简化为:perf script -i perf.data | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl &gt; process.svg 生成svg文件，可以将其在浏览器打开，查看火焰图，如下所示。 查看系统调用执行 1strace -o output.txt -c -e trace=all -p pid 命令，将系统调用统计结果记录到output.txt文件中，按下CTRL+C可以结束跟踪，结果如下。","raw":"---\ntitle: CPP-性能分析工具\ntoc: true\ndate: 2022-09-22 15:17:14\ntags: [c++,性能分析,perf,火焰图]\ncategories: [技术]\ndescription:\n---\n\n## 工具介绍\n### perf\n```shell\nperf支持命令非常多，常用的有以下几个\n\nperf list\n查看可采样的指标\n\nperf stat\n查看cpu占用率、进程上下文切换、CPU迁移、缺页中断等指标总体情况\n\nperf record\n采样某个指标的具体情况\n\nperf report\n根据采样结果生成报告\n```\n\n关于perf原理可查看：https://zhuanlan.zhihu.com/p/22194920\n\n### 火焰图\nperf工具生成的报告不够直观，可以使用https://github.com/brendangregg/FlameGraph 工具将采样结果生成火焰图，方便查看。\n\n### strace\n采样进程系统系统调用情况。\n\n## 示例\n使用上述工具，采样一个程序的运行情况。\n1. 启动进程\n启动本地实例，通过ps -ef | grep proc查找进程pid。\n\n2. 使用perf采样数据\n使用\n```shell\nperf record -e task-clock -g -p pid // 采样进程的cpu使用详情。\n```\n其中-e task-clock表示采样各个任务占用cpu时间，-g表示获取任务间的调用链，-p pid表示采样指定进程。\n可以通过CTRL+C可以结束采样，采样结束后会在本地路径生成一个名为perf.data的采样文件。\n\n3. 使用perf查看报告\n可以通过\n```shell\nperf report -i perf.data  //命令生成报告\n```\n其中-i perf.data表示指定数据源，perf.data是perf record的采样结果。\n命令执行结果如下。+表示可以展开调用链，按下回车键即可。从下面结果我们就可以查看函数执行占用的cpu时间比例。\n![Perf](http://cdn.yuleweici.com/CPP-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/p1.png)\n\n1. 使用火焰图\nperf生成的报告可以查看结果，但是没有火焰图直观，可以通过https://github.com/brendangregg/FlameGraph 工具来生成，具体操作如下，执行下面几个命令生成svg文件。\n```shell\nperf script -i perf.data > perf.unfold\n./FlameGraph/stackcollapse-perf.pl perf.unfold > perf.folded\n./FlameGraph/flamegraph.pl perf.folded > perf.svg\n\n上述命令可以通过管道简化为:\n\nperf script -i perf.data | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl > process.svg\n```\n生成svg文件，可以将其在浏览器打开，查看火焰图，如下所示。\n![Perf2](http://cdn.yuleweici.com/CPP-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/p2.png)\n\n1. 查看系统调用\n执行\n```shell\nstrace -o output.txt -c -e trace=all -p pid\n```\n命令，将系统调用统计结果记录到output.txt文件中，按下CTRL+C可以结束跟踪，结果如下。\n![Perf3](http://cdn.yuleweici.com/CPP-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/p3.png)","content":"<h2 id=\"工具介绍\"><a href=\"#工具介绍\" class=\"headerlink\" title=\"工具介绍\"></a>工具介绍</h2><h3 id=\"perf\"><a href=\"#perf\" class=\"headerlink\" title=\"perf\"></a>perf</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf支持命令非常多，常用的有以下几个</span><br><span class=\"line\"></span><br><span class=\"line\">perf list</span><br><span class=\"line\">查看可采样的指标</span><br><span class=\"line\"></span><br><span class=\"line\">perf stat</span><br><span class=\"line\">查看cpu占用率、进程上下文切换、CPU迁移、缺页中断等指标总体情况</span><br><span class=\"line\"></span><br><span class=\"line\">perf record</span><br><span class=\"line\">采样某个指标的具体情况</span><br><span class=\"line\"></span><br><span class=\"line\">perf report</span><br><span class=\"line\">根据采样结果生成报告</span><br></pre></td></tr></table></figure>\n\n<p>关于perf原理可查看：<a href=\"https://zhuanlan.zhihu.com/p/22194920\">https://zhuanlan.zhihu.com/p/22194920</a></p>\n<h3 id=\"火焰图\"><a href=\"#火焰图\" class=\"headerlink\" title=\"火焰图\"></a>火焰图</h3><p>perf工具生成的报告不够直观，可以使用<a href=\"https://github.com/brendangregg/FlameGraph\">https://github.com/brendangregg/FlameGraph</a> 工具将采样结果生成火焰图，方便查看。</p>\n<h3 id=\"strace\"><a href=\"#strace\" class=\"headerlink\" title=\"strace\"></a>strace</h3><p>采样进程系统系统调用情况。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>使用上述工具，采样一个程序的运行情况。</p>\n<ol>\n<li><p>启动进程<br>启动本地实例，通过ps -ef | grep proc查找进程pid。</p>\n</li>\n<li><p>使用perf采样数据<br>使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf record -e task-clock -g -p pid // 采样进程的cpu使用详情。</span><br></pre></td></tr></table></figure>\n<p>其中-e task-clock表示采样各个任务占用cpu时间，-g表示获取任务间的调用链，-p pid表示采样指定进程。<br>可以通过CTRL+C可以结束采样，采样结束后会在本地路径生成一个名为perf.data的采样文件。</p>\n</li>\n<li><p>使用perf查看报告<br>可以通过</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf report -i perf.data  //命令生成报告</span><br></pre></td></tr></table></figure>\n<p>其中-i perf.data表示指定数据源，perf.data是perf record的采样结果。<br>命令执行结果如下。+表示可以展开调用链，按下回车键即可。从下面结果我们就可以查看函数执行占用的cpu时间比例。<br><img src=\"http://cdn.yuleweici.com/CPP-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/p1.png\" alt=\"Perf\"></p>\n</li>\n<li><p>使用火焰图<br>perf生成的报告可以查看结果，但是没有火焰图直观，可以通过<a href=\"https://github.com/brendangregg/FlameGraph\">https://github.com/brendangregg/FlameGraph</a> 工具来生成，具体操作如下，执行下面几个命令生成svg文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf script -i perf.data &gt; perf.unfold</span><br><span class=\"line\">./FlameGraph/stackcollapse-perf.pl perf.unfold &gt; perf.folded</span><br><span class=\"line\">./FlameGraph/flamegraph.pl perf.folded &gt; perf.svg</span><br><span class=\"line\"></span><br><span class=\"line\">上述命令可以通过管道简化为:</span><br><span class=\"line\"></span><br><span class=\"line\">perf script -i perf.data | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl &gt; process.svg</span><br></pre></td></tr></table></figure>\n<p>生成svg文件，可以将其在浏览器打开，查看火焰图，如下所示。<br><img src=\"http://cdn.yuleweici.com/CPP-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/p2.png\" alt=\"Perf2\"></p>\n</li>\n<li><p>查看系统调用<br>执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strace -o output.txt -c -e trace=all -p pid</span><br></pre></td></tr></table></figure>\n<p>命令，将系统调用统计结果记录到output.txt文件中，按下CTRL+C可以结束跟踪，结果如下。<br><img src=\"http://cdn.yuleweici.com/CPP-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/p3.png\" alt=\"Perf3\"></p>\n</li>\n</ol>\n","slug":"CPP-性能分析工具","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/09/22/CPP-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://vwin.github.io/tags/c/"},{"name":"性能分析","slug":"性能分析","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"perf","slug":"perf","permalink":"http://vwin.github.io/tags/perf/"},{"name":"火焰图","slug":"火焰图","permalink":"http://vwin.github.io/tags/%E7%81%AB%E7%84%B0%E5%9B%BE/"}]},{"title":"自动驾驶-道格拉斯普克(Douglas-Peuker)算法及python实现","date":"2022-09-16T10:01:04.000Z","path":"2022/09/16/自动驾驶-道格拉斯普克-Douglas-Peuker-算法及python实现/","text":"在学习自动驾驶相关内容时遇到使用道格拉斯-普克算法，学习整理 算法简介道格拉斯-普克算法（Douglas–Peucker algorithm），亦称为拉默-道格拉斯-普克算法（Ramer–Douglas–Peucker algorithm），这个算法最初由拉默（Urs Ramer）于1972年提出，1973年道格拉斯（David Douglas）和普克（Thomas Peucker）二人又独立于拉默提出了该算法。 在计算机当中，曲线可以用足够多的点来描述，那么如何用尽可能少的点来描述这条曲线呢，这就是该算法要实现的目标，同时因为用来描述曲线的点变少了，也可以认为其对数据进行了压缩，减少了数据量。也叫道格拉斯抽稀算法。 基础思想 首先明确程序的输入是一系列的点构成的曲线，输出的是其中一部分点构成的曲线； 将曲线首尾AB两点连成一条直线（程序中应当是理论计算出）； 然后分别计算曲线上各点到这条直线的距离，并取出其中的最远距离与阈值进行比较（该阈值通常人为确定）； 若是大于阈值，则保留该最大距离对应的点C，此时可以生成两条直线AC、CB，重复步骤三； 若是小于阈值，则算法结束。 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import mathimport reimport matplotlib.pyplot as pltdef DPeucker(dataOrigin, epsilon=0.6): data = list() # to make sure that the datatype is list type instead of numpy list # print(type(dataOrigin)) if(type(dataOrigin) == type([])): print(&quot;the type is right&quot;) else: for i in range(dataOrigin.shape[0]): data.append(list(dataOrigin[i])) # print(data) removeLabel = list() label_init = lineSegments(data, 0, len(data), removeLabel, epsilon) # from bigger to smaller to remove the redundant data, sort it and remove the repeat data. labelFinal = list() label_init.sort(reverse=True) for item in label_init: if not item in labelFinal: labelFinal.append(item) # remove the redundant point for i in range(len(labelFinal)): del data[labelFinal[i]] # get the point # print(data) if(type(dataOrigin) == type(np.array(0))): data = np.array(data) return datadef calLinePara(start, end): # input parameters is two end points if(end[0] - start[0] != 0): k = (end[1] - start[1]) / (end[0] - start[0]) b = (end[0] * start[1] - end[1] * start[0]) / (end[0] - start[0]) if(end[1] - start[1] != 0): x_axis = -b / k else: x_axis = None else: k = None b = None # mean the paras is inexistence. x_axis = end[0] return (k, b, x_axis)# figure out the distance from dot to line def dotToLIneDistance(point, k, b, a_axis): if k == None and b == None: distance = abs(a_axis - point[0]) else: distance = abs(k * point[0] - point[1] + b) / math.sqrt(k * k + 1) return distance# recall itself to finish segments itself def lineSegments(listData, startLabel, endLabel, removeLabel, epsilon): # removeLabel is a list as a formal parameter, and will be changed by the function if((endLabel - startLabel) &lt;= 1): return removeLabel else: k, b, x_axis = calLinePara(listData[startLabel], listData[endLabel-1]) distance = list() for i in range(startLabel+1, endLabel): # print(dotToLIneDistance(listData[i], k, b, x_axis)) distance.append(dotToLIneDistance(listData[i], k, b, x_axis)) # print(distance) # print(max(distance)) if(max(distance) &lt;= epsilon): # print(endLabel-1, startLabel) for i in range(startLabel+1, endLabel): # for i in range(endLabel-1,-1, int(startLabel)): removeLabel.append(i) else: middleLabel = distance.index(max(distance)) + startLabel + 1 lineSegments(listData, middleLabel, endLabel, removeLabel, epsilon) lineSegments(listData, startLabel, middleLabel, removeLabel, epsilon) return removeLabel 算法demo1234567891011121314151617181920212223import mathimport reimport sysfrom pathlib import Path# use the dp algorithm to simplify the line. current_folder = Path(__file__).absolute().parentfather_folder = str(current_folder.parent)sys.path.append(father_folder)import matplotlib.pyplot as pltimport numpy as npfrom package.func import *if __name__ == &quot;__main__&quot;: filepath = r&quot;14_15.txt&quot; x, z = load_txt(filepath) show_pic(x, z) # 数据拼接 dataList = np.c_[x, z] dataFinal = DPeucker(dataList, epsilon=0.6) x_out = np.array(dataFinal)[:, 0] z_out = np.array(dataFinal)[:, 1] show_pic(x_out, z_out) 实现结果原始数据： 处理后的： 参考https://blog.csdn.net/Lee_gc/article/details/80141238维基百科","raw":"---\ntitle: 自动驾驶-道格拉斯普克(Douglas-Peuker)算法及python实现\ntoc: true\ndate: 2022-09-16 18:01:04\ntags: [自动驾驶,道格拉斯,算法,python]\ncategories: [技术]\ndescription: 道格拉斯-普克算法学习及python实现\n---\n\n在学习自动驾驶相关内容时遇到使用道格拉斯-普克算法，学习整理\n\n<!-- more -->\n## 算法简介\n道格拉斯-普克算法（Douglas–Peucker algorithm），亦称为拉默-道格拉斯-普克算法（Ramer–Douglas–Peucker algorithm），这个算法最初由拉默（Urs Ramer）于1972年提出，1973年道格拉斯（David Douglas）和普克（Thomas Peucker）二人又独立于拉默提出了该算法。\n\n在计算机当中，曲线可以用足够多的点来描述，那么如何用尽可能少的点来描述这条曲线呢，这就是该算法要实现的目标，同时因为用来描述曲线的点变少了，也可以认为其对数据进行了压缩，减少了数据量。也叫道格拉斯抽稀算法。\n\n## 基础思想\n1. 首先明确程序的输入是一系列的点构成的曲线，输出的是其中一部分点构成的曲线；\n2. 将曲线首尾AB两点连成一条直线（程序中应当是理论计算出）；\n3. 然后分别计算曲线上各点到这条直线的距离，并取出其中的最远距离与阈值进行比较（该阈值通常人为确定）；\n4. 若是大于阈值，则保留该最大距离对应的点C，此时可以生成两条直线AC、CB，重复步骤三；\n5. 若是小于阈值，则算法结束。\n\n![算法动图](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B-Douglas-Peuker-%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/s1.gif)\n\n## Python实现\n\n```python\nimport math\nimport re\nimport matplotlib.pyplot as plt\n\n\ndef DPeucker(dataOrigin, epsilon=0.6):\n    data = list()\n    # to make sure that the datatype is list type instead of numpy list     # print(type(dataOrigin))     if(type(dataOrigin) == type([])):\n        print(\"the type is right\")\n    else:\n        for i in range(dataOrigin.shape[0]):\n            data.append(list(dataOrigin[i]))\n    # print(data)     removeLabel = list()\n    label_init = lineSegments(data, 0, len(data), removeLabel, epsilon)\n    # from bigger to smaller to remove the redundant data, sort it and remove the repeat data.     labelFinal = list()\n    label_init.sort(reverse=True)\n    for item in label_init:\n        if not item in labelFinal:\n            labelFinal.append(item)\n    # remove the redundant point     for i in range(len(labelFinal)):\n        del data[labelFinal[i]]\n    # get the point     # print(data)     if(type(dataOrigin) == type(np.array(0))):\n        data = np.array(data)\n    return data\n\n\ndef calLinePara(start, end):\n    # input parameters is two end points \n    if(end[0] - start[0] != 0):\n        k = (end[1] - start[1]) / (end[0] - start[0])\n        b = (end[0] * start[1] - end[1] * start[0]) / (end[0] - start[0])\n        if(end[1] - start[1] != 0):\n            x_axis = -b / k\n        else:\n            x_axis = None\n    else:\n        k = None\n        b = None  # mean the paras is inexistence.         x_axis = end[0]\n    return (k, b, x_axis)\n\n\n# figure out the distance from dot to line def dotToLIneDistance(point, k, b, a_axis):\n    if k == None and b == None:\n        distance = abs(a_axis - point[0])\n    else:\n        distance = abs(k * point[0] - point[1] + b) / math.sqrt(k * k + 1)\n    return distance\n\n\n# recall itself to finish segments itself def lineSegments(listData, startLabel, endLabel, removeLabel, epsilon):\n    # removeLabel is a list as a formal parameter, and will be changed by the function     if((endLabel - startLabel) <= 1):\n        return removeLabel\n    else:\n        k, b, x_axis = calLinePara(listData[startLabel], listData[endLabel-1])\n        distance = list()\n        for i in range(startLabel+1, endLabel):\n            # print(dotToLIneDistance(listData[i], k, b, x_axis))             distance.append(dotToLIneDistance(listData[i], k, b, x_axis))\n        # print(distance)         # print(max(distance))         if(max(distance) <= epsilon):\n            # print(endLabel-1, startLabel)             for i in range(startLabel+1, endLabel):\n                # for i in range(endLabel-1,-1, int(startLabel)):                 removeLabel.append(i)\n        else:\n            middleLabel = distance.index(max(distance)) + startLabel + 1\n            lineSegments(listData, middleLabel, endLabel, removeLabel, epsilon)\n            lineSegments(listData, startLabel,\n                         middleLabel, removeLabel, epsilon)\n    return removeLabel\n```\n\n### 算法demo\n\n```python\nimport math\nimport re\nimport sys\nfrom pathlib import Path\n\n# use the dp algorithm to simplify the line. current_folder = Path(__file__).absolute().parent\nfather_folder = str(current_folder.parent)\nsys.path.append(father_folder)\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom package.func import *\n\nif __name__ == \"__main__\":\n    filepath = r\"14_15.txt\"\n    x, z = load_txt(filepath)\n    show_pic(x, z)\n\t\n    # 数据拼接     dataList = np.c_[x, z]\n    dataFinal = DPeucker(dataList, epsilon=0.6)\n\n    x_out = np.array(dataFinal)[:, 0]\n    z_out = np.array(dataFinal)[:, 1]\n    show_pic(x_out, z_out)\n```\n\n### 实现结果\n原始数据：\n![原始](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B-Douglas-Peuker-%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/s2.png)\n\n处理后的：\n![处理](http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B-Douglas-Peuker-%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/s3.png)\n\n## 参考\nhttps://blog.csdn.net/Lee_gc/article/details/80141238\n[维基百科](https://zh.m.wikipedia.org/zh-hans/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95)","content":"<p>在学习自动驾驶相关内容时遇到使用道格拉斯-普克算法，学习整理</p>\n<span id=\"more\"></span>\n<h2 id=\"算法简介\"><a href=\"#算法简介\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h2><p>道格拉斯-普克算法（Douglas–Peucker algorithm），亦称为拉默-道格拉斯-普克算法（Ramer–Douglas–Peucker algorithm），这个算法最初由拉默（Urs Ramer）于1972年提出，1973年道格拉斯（David Douglas）和普克（Thomas Peucker）二人又独立于拉默提出了该算法。</p>\n<p>在计算机当中，曲线可以用足够多的点来描述，那么如何用尽可能少的点来描述这条曲线呢，这就是该算法要实现的目标，同时因为用来描述曲线的点变少了，也可以认为其对数据进行了压缩，减少了数据量。也叫道格拉斯抽稀算法。</p>\n<h2 id=\"基础思想\"><a href=\"#基础思想\" class=\"headerlink\" title=\"基础思想\"></a>基础思想</h2><ol>\n<li>首先明确程序的输入是一系列的点构成的曲线，输出的是其中一部分点构成的曲线；</li>\n<li>将曲线首尾AB两点连成一条直线（程序中应当是理论计算出）；</li>\n<li>然后分别计算曲线上各点到这条直线的距离，并取出其中的最远距离与阈值进行比较（该阈值通常人为确定）；</li>\n<li>若是大于阈值，则保留该最大距离对应的点C，此时可以生成两条直线AC、CB，重复步骤三；</li>\n<li>若是小于阈值，则算法结束。</li>\n</ol>\n<p><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B-Douglas-Peuker-%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/s1.gif\" alt=\"算法动图\"></p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">DPeucker</span>(<span class=\"params\">dataOrigin, epsilon=<span class=\"number\">0.6</span></span>):</span><br><span class=\"line\">    data = <span class=\"built_in\">list</span>()</span><br><span class=\"line\">    <span class=\"comment\"># to make sure that the datatype is list type instead of numpy list     # print(type(dataOrigin))     if(type(dataOrigin) == type([])):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;the type is right&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(dataOrigin.shape[<span class=\"number\">0</span>]):</span><br><span class=\"line\">            data.append(<span class=\"built_in\">list</span>(dataOrigin[i]))</span><br><span class=\"line\">    <span class=\"comment\"># print(data)     removeLabel = list()</span></span><br><span class=\"line\">    label_init = lineSegments(data, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(data), removeLabel, epsilon)</span><br><span class=\"line\">    <span class=\"comment\"># from bigger to smaller to remove the redundant data, sort it and remove the repeat data.     labelFinal = list()</span></span><br><span class=\"line\">    label_init.sort(reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> label_init:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> item <span class=\"keyword\">in</span> labelFinal:</span><br><span class=\"line\">            labelFinal.append(item)</span><br><span class=\"line\">    <span class=\"comment\"># remove the redundant point     for i in range(len(labelFinal)):</span></span><br><span class=\"line\">        <span class=\"keyword\">del</span> data[labelFinal[i]]</span><br><span class=\"line\">    <span class=\"comment\"># get the point     # print(data)     if(type(dataOrigin) == type(np.array(0))):</span></span><br><span class=\"line\">        data = np.array(data)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calLinePara</span>(<span class=\"params\">start, end</span>):</span><br><span class=\"line\">    <span class=\"comment\"># input parameters is two end points </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(end[<span class=\"number\">0</span>] - start[<span class=\"number\">0</span>] != <span class=\"number\">0</span>):</span><br><span class=\"line\">        k = (end[<span class=\"number\">1</span>] - start[<span class=\"number\">1</span>]) / (end[<span class=\"number\">0</span>] - start[<span class=\"number\">0</span>])</span><br><span class=\"line\">        b = (end[<span class=\"number\">0</span>] * start[<span class=\"number\">1</span>] - end[<span class=\"number\">1</span>] * start[<span class=\"number\">0</span>]) / (end[<span class=\"number\">0</span>] - start[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(end[<span class=\"number\">1</span>] - start[<span class=\"number\">1</span>] != <span class=\"number\">0</span>):</span><br><span class=\"line\">            x_axis = -b / k</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            x_axis = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        k = <span class=\"literal\">None</span></span><br><span class=\"line\">        b = <span class=\"literal\">None</span>  <span class=\"comment\"># mean the paras is inexistence.         x_axis = end[0]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (k, b, x_axis)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># figure out the distance from dot to line def dotToLIneDistance(point, k, b, a_axis):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> k == <span class=\"literal\">None</span> <span class=\"keyword\">and</span> b == <span class=\"literal\">None</span>:</span><br><span class=\"line\">        distance = <span class=\"built_in\">abs</span>(a_axis - point[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        distance = <span class=\"built_in\">abs</span>(k * point[<span class=\"number\">0</span>] - point[<span class=\"number\">1</span>] + b) / math.sqrt(k * k + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> distance</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># recall itself to finish segments itself def lineSegments(listData, startLabel, endLabel, removeLabel, epsilon):</span></span><br><span class=\"line\">    <span class=\"comment\"># removeLabel is a list as a formal parameter, and will be changed by the function     if((endLabel - startLabel) &lt;= 1):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> removeLabel</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        k, b, x_axis = calLinePara(listData[startLabel], listData[endLabel-<span class=\"number\">1</span>])</span><br><span class=\"line\">        distance = <span class=\"built_in\">list</span>()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(startLabel+<span class=\"number\">1</span>, endLabel):</span><br><span class=\"line\">            <span class=\"comment\"># print(dotToLIneDistance(listData[i], k, b, x_axis))             distance.append(dotToLIneDistance(listData[i], k, b, x_axis))</span></span><br><span class=\"line\">        <span class=\"comment\"># print(distance)         # print(max(distance))         if(max(distance) &lt;= epsilon):</span></span><br><span class=\"line\">            <span class=\"comment\"># print(endLabel-1, startLabel)             for i in range(startLabel+1, endLabel):</span></span><br><span class=\"line\">                <span class=\"comment\"># for i in range(endLabel-1,-1, int(startLabel)):                 removeLabel.append(i)</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            middleLabel = distance.index(<span class=\"built_in\">max</span>(distance)) + startLabel + <span class=\"number\">1</span></span><br><span class=\"line\">            lineSegments(listData, middleLabel, endLabel, removeLabel, epsilon)</span><br><span class=\"line\">            lineSegments(listData, startLabel,</span><br><span class=\"line\">                         middleLabel, removeLabel, epsilon)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removeLabel</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"算法demo\"><a href=\"#算法demo\" class=\"headerlink\" title=\"算法demo\"></a>算法demo</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">from</span> pathlib <span class=\"keyword\">import</span> Path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># use the dp algorithm to simplify the line. current_folder = Path(__file__).absolute().parent</span></span><br><span class=\"line\">father_folder = <span class=\"built_in\">str</span>(current_folder.parent)</span><br><span class=\"line\">sys.path.append(father_folder)</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> package.func <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    filepath = <span class=\"string\">r&quot;14_15.txt&quot;</span></span><br><span class=\"line\">    x, z = load_txt(filepath)</span><br><span class=\"line\">    show_pic(x, z)</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\"># 数据拼接     dataList = np.c_[x, z]</span></span><br><span class=\"line\">    dataFinal = DPeucker(dataList, epsilon=<span class=\"number\">0.6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    x_out = np.array(dataFinal)[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">    z_out = np.array(dataFinal)[:, <span class=\"number\">1</span>]</span><br><span class=\"line\">    show_pic(x_out, z_out)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现结果\"><a href=\"#实现结果\" class=\"headerlink\" title=\"实现结果\"></a>实现结果</h3><p>原始数据：<br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B-Douglas-Peuker-%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/s2.png\" alt=\"原始\"></p>\n<p>处理后的：<br><img src=\"http://cdn.yuleweici.com/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B-Douglas-Peuker-%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/s3.png\" alt=\"处理\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/Lee_gc/article/details/80141238\">https://blog.csdn.net/Lee_gc/article/details/80141238</a><br><a href=\"https://zh.m.wikipedia.org/zh-hans/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF-%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95\">维基百科</a></p>\n","slug":"自动驾驶-道格拉斯普克-Douglas-Peuker-算法及python实现","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/09/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B-Douglas-Peuker-%E7%AE%97%E6%B3%95%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","excerpt":"在学习自动驾驶相关内容时遇到使用道格拉斯-普克算法，学习整理","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"自动驾驶","slug":"自动驾驶","permalink":"http://vwin.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"},{"name":"道格拉斯","slug":"道格拉斯","permalink":"http://vwin.github.io/tags/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF/"},{"name":"算法","slug":"算法","permalink":"http://vwin.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"压测-线上全链路压测实践总结篇","date":"2022-09-15T07:51:01.000Z","path":"2022/09/15/压测-线上全链路压测实践总结篇/","text":"总结：为什么要做线上全链路压测？典型应用场景以及5种典型的线上压测方案，全链路压测的方法论，典型性能问题总结 什么是全链路压测全链路压测是可以在现网环境实施的尽可能模拟真实环境流量的场景化压测，通过全链路压测，业务可以探测系统级复杂链路的性能瓶颈，辅助其作出相应的容量规划。 随着分布式架构和业务快速发展给业务系统带来了不确定性，分布式环境的任何节点都可能成为瓶颈&#x2F;短板&#x2F;问题。拿如下这个简单系统为例，用户对系统的一次请求，经过负载均衡、接入层服务、逻辑服务，最终请求到了外部服务，同时产生的用户数据也被存储下来。在这条链路中，其中任何一个服务节点或者存储节点出现性能瓶颈，都可能导致整个系统受到影响。 当然，在得出这条结论之前需要具备一些前提条件：第一、拥有“上帝视角”获取到了调用接口背后的链路拓扑图；第二、同时拥有完备的监控数据做支撑。而这些可能是我们日常进行普通压测所缺乏的。普通压测更多的关注在发压能力以及发压端，对于被压端却是黑盒的。普通压测与全链路压测的区别总结如下： 可见全链路压测的特点在于： 支持脏数据隔离与流量隔离； 支持高负载等异常发现能力，实现压测任务自动化熔断； 支持压测接口背后依赖的的节点链路透视； 支持实时监控被压链路的指标数据； 为什么要做线上全链路压测？ 举一个典型例子：某大促期间，系统在0点，出现大面积瘫痪，重启后又瘫痪； 为什么出现这个问题？是系统间存在依赖关联，对整个全交易链条上的各个环节的系统承压能力不清楚。 最好的办法就是模拟完全的真实情况来做到提前实战演练。即线上全链路压测： 提早发现问题，保障重大活动时系统稳定运行； 找出各个系统的性能瓶颈，明确优化目标； 精准的容量评估：压测结论作为申请扩容资源的依据，活动结束后再归还资源，这样做到成本最低化。 典型的线上全链路压测应用场景 五种典型线上压测方案简述几种典型的线上压测方案，并重点分析每种方案可能的风险和踩坑。 阿里全链路压测方案通过模拟线上真实流量，对整条链路进行全方位、安全、真实的压测核心实现思路是：通过压测流量全局识别、透传，数据进影子区域，且监控区分压测流程和业务流量。 流量标记：业务系统、中间件改造，全链路标记压测流量 分区压测：识别压测流量，将流量转发到压测分区，隔离正常业务 影子表：识别压测流量，缓存和存储将压测数据落入影子表&#x2F;影子区域，不影响正常业务 监控：压测流量、业务流量，分开监控 全链路压测，除技术挑战外，在团队协作上，还有两个难点： 全链路流量梳理汇总： 全链路发压的时候，并不是各压各的，而是需要一起梳理发压流量。比如春晚营销自己压测的时候，需要压5个接口，但是全链路的时候，有3个接口是被上游系统调用的，就不需要营销自己发压，只要接受上游服务的压力就好了。 对齐压测方案，比如单机房发压，要保证压同一个机房等。 压测时的统筹把控： 全链路压测涉及多个团队，几十个系统同时压测，因此需要整体统筹，分配每人的职责，包括发压，看监控等，一旦出现问题能快速发现，及时停止压力，联合定位问题。 纯查询单机房改代码线上压测该方案是通过机房隔离，改代码上线到不承接线上流量的单机房，链路梳理，mock掉不可接受的下游第三方服务、mock掉造成写操作的逻辑，构造词表或引流进行压测。 目前我们大部分系统的查询接口线上压测，都是用这个方案。 虽然看上很安全，但是还有不少风险，主要体现在: 下游系统风险：虽然被压系统与在线业务做了物理隔离，但该系统的下游通常也是真实线上环境，所以有很大的第三方风险。 解决思路：梳理整体链路，压测时提前通知下游系统，尤其是公共服务，可根据情况mock一些下游服务； 写操作梳理遗漏： 该方案的前提是纯查询类的请求，需要业务梳理所有被压的接口，确保没有任何写操作，否则会引入脏数据。但实际上，我们很难梳理全一个接口和他请求的所有下游服务都没有写操作，一旦漏掉，就会带来线上脏数据。 几种典型的容易漏掉的写操作： 缓存，查询接口通常都有缓存，如果压测时不注意，可能写进去的脏数据又被读到，影响线上; 统计BI类的数据，通常不在业务逻辑里，通过埋点或者日志来提取，很容易漏掉； 解决思路：①梳理业务时，尤其注意这两类操作；②尽可能的使用内部同学账号，这样万一出现问题影响还可控; 切流量不干净： 部分模块链接入口不规范，可能导致切流量切不干净 解决思路：检查切流量后的机房，确保无线上流量，尤其是要单机房上线改造代码的时候，保证不能影响到没切干净的流量。 切流量，目前只能保证最上层被压模块切到单机房，如果没有”智能流量转发平台”（优先访问相同机房的机器，若访问失败再访问其他机房），下游业务的流量是切不走的，这种其实没有很好的解决下游模块的服务不可用风险。 解决思路：被压测的所有系统都通过”智能流量转发平台”，流量低峰期压测，以减少服务不可用风险; 上线导致mock代码失效： 这个问题在春节红包压测过程中就出现了，原本mock掉了下游发短信，但是因为压测过程中其它rd上线，覆盖了压测代码逻辑，导致压测流量请求了真实第三方，引起问题。 解决思路： 这类风险在所有需要改压测代码的方案都存在，我们一定要规范压测流程， 周知到所有人这段时间不能上线； 尽可能的使用内部同学的账号，多重保障。 利用待上线&#x2F; 扩容系统进行线上压测该方案算是类线上压测，在条件允许的情况下，利用待上线或者扩容的环境进行压测，通过构造的词表或者线上流量录制的词表进行发压，进行容量评估&#x2F;瓶颈定位&amp;解决，最终来保障活动稳定进行。 该方案相对安全，但是还是有一定风险，主要体现在: 下游系统风险：虽然被压系统是待上线或者扩容的环境，但该系统的下游通常也是真实线上环境，所以有很大的第三方风险。 解决思路：梳理整体链路，压测时提前通知下游系统，根据情况mock一些下游服务; 数据风险： 通常压测待上线系统都有写接口压测，而且是通过上线前清理数据的方式避免脏数据影响。但是这里还有三个风险： 数据清理不干净，可能因为漏清部分数据导致影响线上; 连错数据库，通常我们预期连到扩容的数据库进行压测，但是一旦连接错了，连到线上，就会污染线上数据； 数据清理过快，导致数据库占用资源过高，影响线上； 解决思路：一定要在压测的时候反复检查是否连对数据库，并且压测数据和线上数据隔离双重保证，清理数据时一定注意清理速度。 环境不稳定风险： 这个也是待上线系统独特的特点，因为没有线上流量，系统rd自运维，或者出现上线不规范的情况，这样很可能将压测特殊的代码或配置覆盖掉 比如：上线导致mock的第三方服务或数据库链接配置失效。 解决思路：每次压测的时候都一定要检查diff压测改造代码和配置。 写流量数据隔离+清库线上压测（类影子库）该方案是通过与在线业务隔离的压测数据，真实压测线上系统，事后清理压测脏数据。 比如：压测红包活动使用特殊号段userId，发券压测使用压测账号发测试券，事后清理脏数据。 该方案风险大，属于高危方案，风险是： 一旦失效，影响线上用户，资金安全，或污染线上数据，甚至导致在线业务不可用 解决思路：多重保证避免 压测流量标记，透传; 压测账号隔离等，一定要反复检查请求是否符合预期，线上逻辑处理是否符合预期； 在压测工具和线上代码中添加校验检查，比如：压测流量不在指定数据范围内的流量拒掉。结合业务做风险分析，多重机制保证。 异步流量堆积发送线上压测方案是：通过配置化控制缓冲池的消费速度进行压测。 最大的好处是，完全不增加额外的线上流量，使写操作的数据风险降到最低。 该方案最大的风险是：线上服务可用性，主要体现在两点: 积压释放的流量本身的可用性： 因为是积压释放，在大压力下可能导致服务异常处理失败，而失败的这部分流量是线上真实用户的，这样会降低系统的可用性。 解决思路：重试 or 补单 or 对账来解决； 对线上服务可用性： 可能会将系统压挂（原因是：通常写服务，数据库是无法切机房的，所以一旦堆积的流量把服务压挂，会严重影响线上） 解决思路：业务低峰期进行，以减轻风险。 全链路压测方法论总结标准化流程明确压测目标，压测前、压测中和压测后的各个环节的checklist，是做好全链路压测的标准化流程。 核心流程和注意事项该核心流程描述了要做一次线上性能测试，整个过程中在什么时间点要做什么事，照着这个流程能保证我们线上性能测试能够有序且不会遗漏重要的东西。 风险评估&amp;解决方案线上压测，就会对在线业务有影响，风险评估及解决方案总结： 典型性能问题总结结合项目，压测遇到，较典型的性能问题，见下： redis 压力不均衡，有热点：构造的key总会落到一台机器上，形成热点（出现场景有：统计结果集中过期、统计设置过期时间、压测的统计词表、频繁读一个队列数据）–解决方法：key值打散 压力只在8000端口上，cpu使用率很高–解决方法：一是通过域名使用多端口访问，二是使用proxy，BGW或VIP方式，将压力打散；更推荐第二个方案；之前出现过域名平台低版本导致转发不均衡的问题。 cpu0核打满–解决方法：一是开启网卡多队列优化；二是扩容 内存达到80%–解决方法：一是修改程序，部分业务功能迁移到别的redis集群；二是扩容 应用 队列积压–解决方法：一是增加消费线程数，或改为批量处理；二是扩容，增加消费模块的机器；三是增加开关控制，仅活动事件不入上述队列。 模块间采用http调用方式耗时长–解决方法：改为nio方式调用，耗时节省约 前置校验补全规则分析，高压力下耗时长，单机3000qps耗时170ms–解决方法：若非必要流程可去掉，活动请求不过校验补全规则。 系统开关控制查redis或DB的功能，高压力下配置成查redis，会提升系统性能。 多个任务处理共用一个线程池，导致任务积压影响性能或其他业务– 规则引擎耗时长 youngGC，fullGC次数多且耗时长，影响性能 凌晨切日志或有定时任务，影响性能 因机器问题导致系统雪崩：一台机器性能差，报警无可用连接后，平响瞬间升高，一系列连锁反应，会拖垮应用–解决方案：通过逐步升高压力，摘掉报出无可用连接的机器 联合其他业务压测：词表影响在线业务，及变量传默认值，需改造后压测，否则影响压测效果；压测结束后恢复需求状态。 稳定性&amp;健壮性 开启重试判断后，系统出现雪崩；一般高压力活动场景，不会增加重试机制，会大大影响性能。若有重试，系统应防范雪崩发生。 压力超过一定范围后，持续压测出现模块挂掉，耗时瞬间升高情况–原因：一是规则引擎耗时长，二是机器问题。 高压力下频繁操作起停规则，耗时瞬间上升 多个任务处理共用一个线程池，导致任务积压，影响其他业务–解决方法：一是各个任务间线程池隔离；二是活动机器和在线业务机器全部隔离；三是监控本地队列，数据有积压则报警 压测工具问题 压力不稳–原因有：一是连接的redis跨机房、二是达到发压力极限，发压机器cpu打满；目前单机发压可达5kqps。 压不上去–可调整slave个数，单机一般配置6个slave没问题。 压力工具监控，压力超过一定范围后，qps计算不准","raw":"---\ntitle: 压测-线上全链路压测实践总结篇\ntoc: true\ndate: 2022-09-15 15:51:01\ntags: [压测,全链路]\ncategories: [测试]\ndescription:\n---\n总结：为什么要做线上全链路压测？典型应用场景以及5种典型的线上压测方案，全链路压测的方法论，典型性能问题总结\n\n<!-- more -->\n# 什么是全链路压测\n全链路压测是可以在现网环境实施的尽可能模拟真实环境流量的场景化压测，通过全链路压测，业务可以探测系统级复杂链路的性能瓶颈，辅助其作出相应的容量规划。\n\n随着分布式架构和业务快速发展给业务系统带来了不确定性，分布式环境的任何节点都可能成为瓶颈/短板/问题。拿如下这个简单系统为例，用户对系统的一次请求，经过负载均衡、接入层服务、逻辑服务，最终请求到了外部服务，同时产生的用户数据也被存储下来。\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_7.png)\n在这条链路中，其中任何一个服务节点或者存储节点出现性能瓶颈，都可能导致整个系统受到影响。\n\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_8.png)\n\n当然，在得出这条结论之前需要具备一些前提条件：第一、拥有“上帝视角”获取到了调用接口背后的链路拓扑图；第二、同时拥有完备的监控数据做支撑。而这些可能是我们日常进行普通压测所缺乏的。普通压测更多的关注在发压能力以及发压端，对于被压端却是黑盒的。普通压测与全链路压测的区别总结如下：\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_9.png)\n\n可见全链路压测的特点在于：\n1. 支持脏数据隔离与流量隔离；\n2. 支持高负载等异常发现能力，实现压测任务自动化熔断；\n3. 支持压测接口背后依赖的的节点链路透视；\n4. 支持实时监控被压链路的指标数据；\n\n\n\n# 为什么要做线上全链路压测？\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img.png)\n\n举一个典型例子：某大促期间，系统在0点，出现大面积瘫痪，重启后又瘫痪；\n\n为什么出现这个问题？是系统间存在依赖关联，对整个全交易链条上的各个环节的系统承压能力不清楚。\n\n最好的办法就是模拟完全的真实情况来做到提前实战演练。即线上全链路压测：\n\n- 提早发现问题，保障重大活动时系统稳定运行； \n- 找出各个系统的性能瓶颈，明确优化目标； \n- 精准的容量评估：压测结论作为申请扩容资源的依据，活动结束后再归还资源，这样做到成本最低化。\n\n# 典型的线上全链路压测应用场景\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_1.png)\n\n# 五种典型线上压测方案\n简述几种典型的线上压测方案，并重点分析每种方案可能的风险和踩坑。\n## 阿里全链路压测方案\n通过模拟线上真实流量，对整条链路进行全方位、安全、真实的压测\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_2.png)\n核心实现思路是：通过压测流量全局识别、透传，数据进影子区域，且监控区分压测流程和业务流量。\n\n- 流量标记：业务系统、中间件改造，全链路标记压测流量 \n- 分区压测：识别压测流量，将流量转发到压测分区，隔离正常业务 \n- 影子表：识别压测流量，缓存和存储将压测数据落入影子表/影子区域，不影响正常业务 \n- 监控：压测流量、业务流量，分开监控\n  ![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_3.png)\n\n全链路压测，除技术挑战外，在团队协作上，还有两个难点：\n\n1. 全链路流量梳理汇总： \n   1. 全链路发压的时候，并不是各压各的，而是需要一起梳理发压流量。比如春晚营销自己压测的时候，需要压5个接口，但是全链路的时候，有3个接口是被上游系统调用的，就不需要营销自己发压，只要接受上游服务的压力就好了。\n   2. 对齐压测方案，比如单机房发压，要保证压同一个机房等。\n\n2. 压测时的统筹把控： \n   1. 全链路压测涉及多个团队，几十个系统同时压测，因此需要整体统筹，分配每人的职责，包括发压，看监控等，一旦出现问题能快速发现，及时停止压力，联合定位问题。\n\n## 纯查询单机房改代码线上压测\n该方案是通过机房隔离，改代码上线到不承接线上流量的单机房，链路梳理，mock掉不可接受的下游第三方服务、mock掉造成写操作的逻辑，构造词表或引流进行压测。\n\n目前我们大部分系统的查询接口线上压测，都是用这个方案。\n\n虽然看上很安全，但是还有不少风险，主要体现在:\n\n- 下游系统风险：虽然被压系统与在线业务做了物理隔离，但该系统的下游通常也是真实线上环境，所以有很大的第三方风险。 \n  - 解决思路：梳理整体链路，压测时提前通知下游系统，尤其是公共服务，可根据情况mock一些下游服务；\n- 写操作梳理遗漏： \n  - 该方案的前提是纯查询类的请求，需要业务梳理所有被压的接口，确保没有任何写操作，否则会引入脏数据。但实际上，我们很难梳理全一个接口和他请求的所有下游服务都没有写操作，一旦漏掉，就会带来线上脏数据。 \n  - 几种典型的容易漏掉的写操作：\n    - 缓存，查询接口通常都有缓存，如果压测时不注意，可能写进去的脏数据又被读到，影响线上;\n    - 统计BI类的数据，通常不在业务逻辑里，通过埋点或者日志来提取，很容易漏掉； \n  - 解决思路：①梳理业务时，尤其注意这两类操作；②尽可能的使用内部同学账号，这样万一出现问题影响还可控;\n- 切流量不干净： \n  - 部分模块链接入口不规范，可能导致切流量切不干净 \n    - 解决思路：检查切流量后的机房，确保无线上流量，尤其是要单机房上线改造代码的时候，保证不能影响到没切干净的流量。 \n  - 切流量，目前只能保证最上层被压模块切到单机房，如果没有\"智能流量转发平台\"（优先访问相同机房的机器，若访问失败再访问其他机房），下游业务的流量是切不走的，这种其实没有很好的解决下游模块的服务不可用风险。 \n    - 解决思路：被压测的所有系统都通过\"智能流量转发平台\"，流量低峰期压测，以减少服务不可用风险;\n- 上线导致mock代码失效： \n  - 这个问题在春节红包压测过程中就出现了，原本mock掉了下游发短信，但是因为压测过程中其它rd上线，覆盖了压测代码逻辑，导致压测流量请求了真实第三方，引起问题。 \n  - 解决思路：\n    - 这类风险在所有需要改压测代码的方案都存在，我们一定要规范压测流程， 周知到所有人这段时间不能上线；\n    - 尽可能的使用内部同学的账号，多重保障。\n\n## 利用待上线/ 扩容系统进行线上压测\n该方案算是类线上压测，在条件允许的情况下，利用待上线或者扩容的环境进行压测，通过构造的词表或者线上流量录制的词表进行发压，进行容量评估/瓶颈定位&解决，最终来保障活动稳定进行。\n\n该方案相对安全，但是还是有一定风险，主要体现在:\n- 下游系统风险：虽然被压系统是待上线或者扩容的环境，但该系统的下游通常也是真实线上环境，所以有很大的第三方风险。 \n  - 解决思路：梳理整体链路，压测时提前通知下游系统，根据情况mock一些下游服务; \n- 数据风险： \n  - 通常压测待上线系统都有写接口压测，而且是通过上线前清理数据的方式避免脏数据影响。但是这里还有三个风险： \n    - 数据清理不干净，可能因为漏清部分数据导致影响线上; \n    - 连错数据库，通常我们预期连到扩容的数据库进行压测，但是一旦连接错了，连到线上，就会污染线上数据； \n    - 数据清理过快，导致数据库占用资源过高，影响线上； \n  - 解决思路：一定要在压测的时候反复检查是否连对数据库，并且压测数据和线上数据隔离双重保证，清理数据时一定注意清理速度。\n\n- 环境不稳定风险： \n  - 这个也是待上线系统独特的特点，因为没有线上流量，系统rd自运维，或者出现上线不规范的情况，这样很可能将压测特殊的代码或配置覆盖掉 \n  - 比如：上线导致mock的第三方服务或数据库链接配置失效。 \n  - 解决思路：每次压测的时候都一定要检查diff压测改造代码和配置。\n\n## 写流量数据隔离+清库线上压测（类影子库）\n该方案是通过与在线业务隔离的压测数据，真实压测线上系统，事后清理压测脏数据。\n\n比如：压测红包活动使用特殊号段userId，发券压测使用压测账号发测试券，事后清理脏数据。\n\n该方案风险大，属于高危方案，风险是：\n\n一旦失效，影响线上用户，资金安全，或污染线上数据，甚至导致在线业务不可用\n\n解决思路：多重保证避免\n\n1. 压测流量标记，透传; \n2. 压测账号隔离等，一定要反复检查请求是否符合预期，线上逻辑处理是否符合预期； \n3. 在压测工具和线上代码中添加校验检查，比如：压测流量不在指定数据范围内的流量拒掉。结合业务做风险分析，多重机制保证。\n\n## 异步流量堆积发送线上压测\n方案是：通过配置化控制缓冲池的消费速度进行压测。\n\n最大的好处是，完全不增加额外的线上流量，使写操作的数据风险降到最低。\n\n该方案最大的风险是：线上服务可用性，主要体现在两点:\n\n积压释放的流量本身的可用性：\n\n因为是积压释放，在大压力下可能导致服务异常处理失败，而失败的这部分流量是线上真实用户的，这样会降低系统的可用性。\n\n解决思路：重试 or 补单 or 对账来解决；\n\n对线上服务可用性：\n\n可能会将系统压挂（原因是：通常写服务，数据库是无法切机房的，所以一旦堆积的流量把服务压挂，会严重影响线上）\n\n解决思路：业务低峰期进行，以减轻风险。\n\n# 全链路压测方法论总结\n## 标准化流程\n明确压测目标，压测前、压测中和压测后的各个环节的checklist，是做好全链路压测的标准化流程。\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_4.png)\n\n## 核心流程和注意事项\n该核心流程描述了要做一次线上性能测试，整个过程中在什么时间点要做什么事，照着这个流程能保证我们线上性能测试能够有序且不会遗漏重要的东西。\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_5.png)\n\n## 风险评估&解决方案\n线上压测，就会对在线业务有影响，风险评估及解决方案总结：\n![](http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_6.png)\n\n# 典型性能问题总结\n结合项目，压测遇到，较典型的性能问题，见下：\n\n## redis\n- 压力不均衡，有热点：构造的key总会落到一台机器上，形成热点（出现场景有：统计结果集中过期、统计设置过期时间、压测的统计词表、频繁读一个队列数据）--解决方法：key值打散\n\n- 压力只在8000端口上，cpu使用率很高--解决方法：一是通过域名使用多端口访问，二是使用proxy，BGW或VIP方式，将压力打散；更推荐第二个方案；之前出现过域名平台低版本导致转发不均衡的问题。\n\n- cpu0核打满--解决方法：一是开启网卡多队列优化；二是扩容\n\n- 内存达到80%--解决方法：一是修改程序，部分业务功能迁移到别的redis集群；二是扩容\n\n## 应用\n- 队列积压--解决方法：一是增加消费线程数，或改为批量处理；二是扩容，增加消费模块的机器；三是增加开关控制，仅活动事件不入上述队列。\n\n- 模块间采用http调用方式耗时长–解决方法：改为nio方式调用，耗时节省约\n\n- 前置校验补全规则分析，高压力下耗时长，单机3000qps耗时170ms–解决方法：若非必要流程可去掉，活动请求不过校验补全规则。\n\n- 系统开关控制查redis或DB的功能，高压力下配置成查redis，会提升系统性能。\n\n- 多个任务处理共用一个线程池，导致任务积压影响性能或其他业务--\n\n- 规则引擎耗时长\n\n- youngGC，fullGC次数多且耗时长，影响性能\n\n- 凌晨切日志或有定时任务，影响性能\n\n- 因机器问题导致系统雪崩：一台机器性能差，报警无可用连接后，平响瞬间升高，一系列连锁反应，会拖垮应用--解决方案：通过逐步升高压力，摘掉报出无可用连接的机器\n\n- 联合其他业务压测：词表影响在线业务，及变量传默认值，需改造后压测，否则影响压测效果；压测结束后恢复需求状态。\n\n## 稳定性&健壮性\n- 开启重试判断后，系统出现雪崩；一般高压力活动场景，不会增加重试机制，会大大影响性能。若有重试，系统应防范雪崩发生。\n\n- 压力超过一定范围后，持续压测出现模块挂掉，耗时瞬间升高情况--原因：一是规则引擎耗时长，二是机器问题。\n\n- 高压力下频繁操作起停规则，耗时瞬间上升\n\n- 多个任务处理共用一个线程池，导致任务积压，影响其他业务--解决方法：一是各个任务间线程池隔离；二是活动机器和在线业务机器全部隔离；三是监控本地队列，数据有积压则报警\n\n## 压测工具问题\n- 压力不稳--原因有：一是连接的redis跨机房、二是达到发压力极限，发压机器cpu打满；目前单机发压可达5kqps。\n\n- 压不上去--可调整slave个数，单机一般配置6个slave没问题。\n\n- 压力工具监控，压力超过一定范围后，qps计算不准\n\n\n\n\n\n","content":"<p>总结：为什么要做线上全链路压测？典型应用场景以及5种典型的线上压测方案，全链路压测的方法论，典型性能问题总结</p>\n<span id=\"more\"></span>\n<h1 id=\"什么是全链路压测\"><a href=\"#什么是全链路压测\" class=\"headerlink\" title=\"什么是全链路压测\"></a>什么是全链路压测</h1><p>全链路压测是可以在现网环境实施的尽可能模拟真实环境流量的场景化压测，通过全链路压测，业务可以探测系统级复杂链路的性能瓶颈，辅助其作出相应的容量规划。</p>\n<p>随着分布式架构和业务快速发展给业务系统带来了不确定性，分布式环境的任何节点都可能成为瓶颈&#x2F;短板&#x2F;问题。拿如下这个简单系统为例，用户对系统的一次请求，经过负载均衡、接入层服务、逻辑服务，最终请求到了外部服务，同时产生的用户数据也被存储下来。<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_7.png\"><br>在这条链路中，其中任何一个服务节点或者存储节点出现性能瓶颈，都可能导致整个系统受到影响。</p>\n<p><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_8.png\"></p>\n<p>当然，在得出这条结论之前需要具备一些前提条件：第一、拥有“上帝视角”获取到了调用接口背后的链路拓扑图；第二、同时拥有完备的监控数据做支撑。而这些可能是我们日常进行普通压测所缺乏的。普通压测更多的关注在发压能力以及发压端，对于被压端却是黑盒的。普通压测与全链路压测的区别总结如下：<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_9.png\"></p>\n<p>可见全链路压测的特点在于：</p>\n<ol>\n<li>支持脏数据隔离与流量隔离；</li>\n<li>支持高负载等异常发现能力，实现压测任务自动化熔断；</li>\n<li>支持压测接口背后依赖的的节点链路透视；</li>\n<li>支持实时监控被压链路的指标数据；</li>\n</ol>\n<h1 id=\"为什么要做线上全链路压测？\"><a href=\"#为什么要做线上全链路压测？\" class=\"headerlink\" title=\"为什么要做线上全链路压测？\"></a>为什么要做线上全链路压测？</h1><p><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img.png\"></p>\n<p>举一个典型例子：某大促期间，系统在0点，出现大面积瘫痪，重启后又瘫痪；</p>\n<p>为什么出现这个问题？是系统间存在依赖关联，对整个全交易链条上的各个环节的系统承压能力不清楚。</p>\n<p>最好的办法就是模拟完全的真实情况来做到提前实战演练。即线上全链路压测：</p>\n<ul>\n<li>提早发现问题，保障重大活动时系统稳定运行； </li>\n<li>找出各个系统的性能瓶颈，明确优化目标； </li>\n<li>精准的容量评估：压测结论作为申请扩容资源的依据，活动结束后再归还资源，这样做到成本最低化。</li>\n</ul>\n<h1 id=\"典型的线上全链路压测应用场景\"><a href=\"#典型的线上全链路压测应用场景\" class=\"headerlink\" title=\"典型的线上全链路压测应用场景\"></a>典型的线上全链路压测应用场景</h1><p><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_1.png\"></p>\n<h1 id=\"五种典型线上压测方案\"><a href=\"#五种典型线上压测方案\" class=\"headerlink\" title=\"五种典型线上压测方案\"></a>五种典型线上压测方案</h1><p>简述几种典型的线上压测方案，并重点分析每种方案可能的风险和踩坑。</p>\n<h2 id=\"阿里全链路压测方案\"><a href=\"#阿里全链路压测方案\" class=\"headerlink\" title=\"阿里全链路压测方案\"></a>阿里全链路压测方案</h2><p>通过模拟线上真实流量，对整条链路进行全方位、安全、真实的压测<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_2.png\"><br>核心实现思路是：通过压测流量全局识别、透传，数据进影子区域，且监控区分压测流程和业务流量。</p>\n<ul>\n<li>流量标记：业务系统、中间件改造，全链路标记压测流量 </li>\n<li>分区压测：识别压测流量，将流量转发到压测分区，隔离正常业务 </li>\n<li>影子表：识别压测流量，缓存和存储将压测数据落入影子表&#x2F;影子区域，不影响正常业务 </li>\n<li>监控：压测流量、业务流量，分开监控<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_3.png\"></li>\n</ul>\n<p>全链路压测，除技术挑战外，在团队协作上，还有两个难点：</p>\n<ol>\n<li><p>全链路流量梳理汇总： </p>\n<ol>\n<li>全链路发压的时候，并不是各压各的，而是需要一起梳理发压流量。比如春晚营销自己压测的时候，需要压5个接口，但是全链路的时候，有3个接口是被上游系统调用的，就不需要营销自己发压，只要接受上游服务的压力就好了。</li>\n<li>对齐压测方案，比如单机房发压，要保证压同一个机房等。</li>\n</ol>\n</li>\n<li><p>压测时的统筹把控： </p>\n<ol>\n<li>全链路压测涉及多个团队，几十个系统同时压测，因此需要整体统筹，分配每人的职责，包括发压，看监控等，一旦出现问题能快速发现，及时停止压力，联合定位问题。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"纯查询单机房改代码线上压测\"><a href=\"#纯查询单机房改代码线上压测\" class=\"headerlink\" title=\"纯查询单机房改代码线上压测\"></a>纯查询单机房改代码线上压测</h2><p>该方案是通过机房隔离，改代码上线到不承接线上流量的单机房，链路梳理，mock掉不可接受的下游第三方服务、mock掉造成写操作的逻辑，构造词表或引流进行压测。</p>\n<p>目前我们大部分系统的查询接口线上压测，都是用这个方案。</p>\n<p>虽然看上很安全，但是还有不少风险，主要体现在:</p>\n<ul>\n<li>下游系统风险：虽然被压系统与在线业务做了物理隔离，但该系统的下游通常也是真实线上环境，所以有很大的第三方风险。 <ul>\n<li>解决思路：梳理整体链路，压测时提前通知下游系统，尤其是公共服务，可根据情况mock一些下游服务；</li>\n</ul>\n</li>\n<li>写操作梳理遗漏： <ul>\n<li>该方案的前提是纯查询类的请求，需要业务梳理所有被压的接口，确保没有任何写操作，否则会引入脏数据。但实际上，我们很难梳理全一个接口和他请求的所有下游服务都没有写操作，一旦漏掉，就会带来线上脏数据。 </li>\n<li>几种典型的容易漏掉的写操作：<ul>\n<li>缓存，查询接口通常都有缓存，如果压测时不注意，可能写进去的脏数据又被读到，影响线上;</li>\n<li>统计BI类的数据，通常不在业务逻辑里，通过埋点或者日志来提取，很容易漏掉；</li>\n</ul>\n</li>\n<li>解决思路：①梳理业务时，尤其注意这两类操作；②尽可能的使用内部同学账号，这样万一出现问题影响还可控;</li>\n</ul>\n</li>\n<li>切流量不干净： <ul>\n<li>部分模块链接入口不规范，可能导致切流量切不干净 <ul>\n<li>解决思路：检查切流量后的机房，确保无线上流量，尤其是要单机房上线改造代码的时候，保证不能影响到没切干净的流量。</li>\n</ul>\n</li>\n<li>切流量，目前只能保证最上层被压模块切到单机房，如果没有”智能流量转发平台”（优先访问相同机房的机器，若访问失败再访问其他机房），下游业务的流量是切不走的，这种其实没有很好的解决下游模块的服务不可用风险。 <ul>\n<li>解决思路：被压测的所有系统都通过”智能流量转发平台”，流量低峰期压测，以减少服务不可用风险;</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>上线导致mock代码失效： <ul>\n<li>这个问题在春节红包压测过程中就出现了，原本mock掉了下游发短信，但是因为压测过程中其它rd上线，覆盖了压测代码逻辑，导致压测流量请求了真实第三方，引起问题。 </li>\n<li>解决思路：<ul>\n<li>这类风险在所有需要改压测代码的方案都存在，我们一定要规范压测流程， 周知到所有人这段时间不能上线；</li>\n<li>尽可能的使用内部同学的账号，多重保障。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"利用待上线-x2F-扩容系统进行线上压测\"><a href=\"#利用待上线-x2F-扩容系统进行线上压测\" class=\"headerlink\" title=\"利用待上线&#x2F; 扩容系统进行线上压测\"></a>利用待上线&#x2F; 扩容系统进行线上压测</h2><p>该方案算是类线上压测，在条件允许的情况下，利用待上线或者扩容的环境进行压测，通过构造的词表或者线上流量录制的词表进行发压，进行容量评估&#x2F;瓶颈定位&amp;解决，最终来保障活动稳定进行。</p>\n<p>该方案相对安全，但是还是有一定风险，主要体现在:</p>\n<ul>\n<li><p>下游系统风险：虽然被压系统是待上线或者扩容的环境，但该系统的下游通常也是真实线上环境，所以有很大的第三方风险。 </p>\n<ul>\n<li>解决思路：梳理整体链路，压测时提前通知下游系统，根据情况mock一些下游服务;</li>\n</ul>\n</li>\n<li><p>数据风险： </p>\n<ul>\n<li>通常压测待上线系统都有写接口压测，而且是通过上线前清理数据的方式避免脏数据影响。但是这里还有三个风险： <ul>\n<li>数据清理不干净，可能因为漏清部分数据导致影响线上; </li>\n<li>连错数据库，通常我们预期连到扩容的数据库进行压测，但是一旦连接错了，连到线上，就会污染线上数据； </li>\n<li>数据清理过快，导致数据库占用资源过高，影响线上；</li>\n</ul>\n</li>\n<li>解决思路：一定要在压测的时候反复检查是否连对数据库，并且压测数据和线上数据隔离双重保证，清理数据时一定注意清理速度。</li>\n</ul>\n</li>\n<li><p>环境不稳定风险： </p>\n<ul>\n<li>这个也是待上线系统独特的特点，因为没有线上流量，系统rd自运维，或者出现上线不规范的情况，这样很可能将压测特殊的代码或配置覆盖掉 </li>\n<li>比如：上线导致mock的第三方服务或数据库链接配置失效。 </li>\n<li>解决思路：每次压测的时候都一定要检查diff压测改造代码和配置。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"写流量数据隔离-清库线上压测（类影子库）\"><a href=\"#写流量数据隔离-清库线上压测（类影子库）\" class=\"headerlink\" title=\"写流量数据隔离+清库线上压测（类影子库）\"></a>写流量数据隔离+清库线上压测（类影子库）</h2><p>该方案是通过与在线业务隔离的压测数据，真实压测线上系统，事后清理压测脏数据。</p>\n<p>比如：压测红包活动使用特殊号段userId，发券压测使用压测账号发测试券，事后清理脏数据。</p>\n<p>该方案风险大，属于高危方案，风险是：</p>\n<p>一旦失效，影响线上用户，资金安全，或污染线上数据，甚至导致在线业务不可用</p>\n<p>解决思路：多重保证避免</p>\n<ol>\n<li>压测流量标记，透传; </li>\n<li>压测账号隔离等，一定要反复检查请求是否符合预期，线上逻辑处理是否符合预期； </li>\n<li>在压测工具和线上代码中添加校验检查，比如：压测流量不在指定数据范围内的流量拒掉。结合业务做风险分析，多重机制保证。</li>\n</ol>\n<h2 id=\"异步流量堆积发送线上压测\"><a href=\"#异步流量堆积发送线上压测\" class=\"headerlink\" title=\"异步流量堆积发送线上压测\"></a>异步流量堆积发送线上压测</h2><p>方案是：通过配置化控制缓冲池的消费速度进行压测。</p>\n<p>最大的好处是，完全不增加额外的线上流量，使写操作的数据风险降到最低。</p>\n<p>该方案最大的风险是：线上服务可用性，主要体现在两点:</p>\n<p>积压释放的流量本身的可用性：</p>\n<p>因为是积压释放，在大压力下可能导致服务异常处理失败，而失败的这部分流量是线上真实用户的，这样会降低系统的可用性。</p>\n<p>解决思路：重试 or 补单 or 对账来解决；</p>\n<p>对线上服务可用性：</p>\n<p>可能会将系统压挂（原因是：通常写服务，数据库是无法切机房的，所以一旦堆积的流量把服务压挂，会严重影响线上）</p>\n<p>解决思路：业务低峰期进行，以减轻风险。</p>\n<h1 id=\"全链路压测方法论总结\"><a href=\"#全链路压测方法论总结\" class=\"headerlink\" title=\"全链路压测方法论总结\"></a>全链路压测方法论总结</h1><h2 id=\"标准化流程\"><a href=\"#标准化流程\" class=\"headerlink\" title=\"标准化流程\"></a>标准化流程</h2><p>明确压测目标，压测前、压测中和压测后的各个环节的checklist，是做好全链路压测的标准化流程。<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_4.png\"></p>\n<h2 id=\"核心流程和注意事项\"><a href=\"#核心流程和注意事项\" class=\"headerlink\" title=\"核心流程和注意事项\"></a>核心流程和注意事项</h2><p>该核心流程描述了要做一次线上性能测试，整个过程中在什么时间点要做什么事，照着这个流程能保证我们线上性能测试能够有序且不会遗漏重要的东西。<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_5.png\"></p>\n<h2 id=\"风险评估-amp-解决方案\"><a href=\"#风险评估-amp-解决方案\" class=\"headerlink\" title=\"风险评估&amp;解决方案\"></a>风险评估&amp;解决方案</h2><p>线上压测，就会对在线业务有影响，风险评估及解决方案总结：<br><img src=\"http://cdn.yuleweici.com/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/img_6.png\"></p>\n<h1 id=\"典型性能问题总结\"><a href=\"#典型性能问题总结\" class=\"headerlink\" title=\"典型性能问题总结\"></a>典型性能问题总结</h1><p>结合项目，压测遇到，较典型的性能问题，见下：</p>\n<h2 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h2><ul>\n<li><p>压力不均衡，有热点：构造的key总会落到一台机器上，形成热点（出现场景有：统计结果集中过期、统计设置过期时间、压测的统计词表、频繁读一个队列数据）–解决方法：key值打散</p>\n</li>\n<li><p>压力只在8000端口上，cpu使用率很高–解决方法：一是通过域名使用多端口访问，二是使用proxy，BGW或VIP方式，将压力打散；更推荐第二个方案；之前出现过域名平台低版本导致转发不均衡的问题。</p>\n</li>\n<li><p>cpu0核打满–解决方法：一是开启网卡多队列优化；二是扩容</p>\n</li>\n<li><p>内存达到80%–解决方法：一是修改程序，部分业务功能迁移到别的redis集群；二是扩容</p>\n</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ul>\n<li><p>队列积压–解决方法：一是增加消费线程数，或改为批量处理；二是扩容，增加消费模块的机器；三是增加开关控制，仅活动事件不入上述队列。</p>\n</li>\n<li><p>模块间采用http调用方式耗时长–解决方法：改为nio方式调用，耗时节省约</p>\n</li>\n<li><p>前置校验补全规则分析，高压力下耗时长，单机3000qps耗时170ms–解决方法：若非必要流程可去掉，活动请求不过校验补全规则。</p>\n</li>\n<li><p>系统开关控制查redis或DB的功能，高压力下配置成查redis，会提升系统性能。</p>\n</li>\n<li><p>多个任务处理共用一个线程池，导致任务积压影响性能或其他业务–</p>\n</li>\n<li><p>规则引擎耗时长</p>\n</li>\n<li><p>youngGC，fullGC次数多且耗时长，影响性能</p>\n</li>\n<li><p>凌晨切日志或有定时任务，影响性能</p>\n</li>\n<li><p>因机器问题导致系统雪崩：一台机器性能差，报警无可用连接后，平响瞬间升高，一系列连锁反应，会拖垮应用–解决方案：通过逐步升高压力，摘掉报出无可用连接的机器</p>\n</li>\n<li><p>联合其他业务压测：词表影响在线业务，及变量传默认值，需改造后压测，否则影响压测效果；压测结束后恢复需求状态。</p>\n</li>\n</ul>\n<h2 id=\"稳定性-amp-健壮性\"><a href=\"#稳定性-amp-健壮性\" class=\"headerlink\" title=\"稳定性&amp;健壮性\"></a>稳定性&amp;健壮性</h2><ul>\n<li><p>开启重试判断后，系统出现雪崩；一般高压力活动场景，不会增加重试机制，会大大影响性能。若有重试，系统应防范雪崩发生。</p>\n</li>\n<li><p>压力超过一定范围后，持续压测出现模块挂掉，耗时瞬间升高情况–原因：一是规则引擎耗时长，二是机器问题。</p>\n</li>\n<li><p>高压力下频繁操作起停规则，耗时瞬间上升</p>\n</li>\n<li><p>多个任务处理共用一个线程池，导致任务积压，影响其他业务–解决方法：一是各个任务间线程池隔离；二是活动机器和在线业务机器全部隔离；三是监控本地队列，数据有积压则报警</p>\n</li>\n</ul>\n<h2 id=\"压测工具问题\"><a href=\"#压测工具问题\" class=\"headerlink\" title=\"压测工具问题\"></a>压测工具问题</h2><ul>\n<li><p>压力不稳–原因有：一是连接的redis跨机房、二是达到发压力极限，发压机器cpu打满；目前单机发压可达5kqps。</p>\n</li>\n<li><p>压不上去–可调整slave个数，单机一般配置6个slave没问题。</p>\n</li>\n<li><p>压力工具监控，压力超过一定范围后，qps计算不准</p>\n</li>\n</ul>\n","slug":"压测-线上全链路压测实践总结篇","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/09/15/%E5%8E%8B%E6%B5%8B-%E7%BA%BF%E4%B8%8A%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E7%AF%87/","excerpt":"总结：为什么要做线上全链路压测？典型应用场景以及5种典型的线上压测方案，全链路压测的方法论，典型性能问题总结","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"压测","slug":"压测","permalink":"http://vwin.github.io/tags/%E5%8E%8B%E6%B5%8B/"},{"name":"全链路","slug":"全链路","permalink":"http://vwin.github.io/tags/%E5%85%A8%E9%93%BE%E8%B7%AF/"}]},{"title":"云IaaS测试系列一利用SystemTap模拟磁盘故障","date":"2022-09-15T07:36:42.000Z","path":"2022/09/15/云IaaS测试系列一利用SystemTap模拟磁盘故障/","text":"分布式存储系统运行在复杂的集群硬件环境下，要求长时间不停机；遇到硬件设备发生故障时必须能够保证用户数据不丢失。因此在测试分布式存储系统中，稳定性测试和可靠性测试均要求设计一些硬件故障的测试场景。通常测试人员可以通过插拔物理设备，重启系统或者直接使用故障硬件来进行测试，但是这种方式不够方便，同时也无法进行自动化改造；这篇文章运用SystemTap动态跟踪工具，在内核注入故障代码，模拟物理设备故障。经过验证能够到达手工插拔物理设备构造故障场景的测试效果；同时使用接口方便，为进一步实现端到端自动化测试用例提供了基础性工具。 背景故障测试是软件测试的重要场景。软件的运行环境越复杂，越有可能遭遇到各种各样的系统故障。CBS是一种分布式存储系统，对外提供块存储服务。CBS运行在服务器集群中，每台服务器直接连接多个物理磁盘。根据集群路由信息，CBS将虚拟磁盘的读写请求分发到物理磁盘上，实现用户数据的落盘与持久化。CBS运行环境包括主机，内存，磁盘，网络等物理设备，每一种设备均可能发生故障；尤其是磁盘设备的理论寿命为3万小时左右，而重要的用户数据寿命是远远超过磁盘寿命的。因此，在CBS测试项目中针对磁盘故障的可靠性和稳定性专项测试是质量保障体系中很重要的组成部分。这篇文章为测试过程中如何方便地模拟磁盘故障提供了一种解决方案。 原理大家知道，Linux系统分为用户空间（User Space）与内核空间（Kernel Space）；应用程序（Applications）无法直接访问物理设备的各种服务。如图一所示，应用程序运行在用户空间内，运行级别最低，必须通过内核提供的访问调用接口才能使用物理设备的服务。 显然，若需要在系统中注入磁盘故障，存在两种方式；第一种方式最简单，直接使用一块坏盘，但是这种方式很不方便，需要插拔磁盘同时无法实现自动化，另外成本也不小。第二种方式是在内核中通过阻断磁盘处理程序中部分关键节点来模拟磁盘故障，通过内核模拟磁盘故障有三个优点，首先应用程序感知到的设备故障与通过物理插拔磁盘是一致的，其次模拟过程简单方便，再次容易自动化，提升测试效率。 如何在内核中阻断磁盘处理程序？内核是随操作系统发布时安装在服务器上的核心代码，不可能在内核代码中预先设计并开发驻留故障程序。那怎么把故障程序注入到内核代码里？这里有必要了解两个强大的内核跟踪工具SystemTap和KProbes！ 先介绍KProbes。KProbes是Linux中一个轻量级内核调试工具，它可以将程序断点插入到正在运行的内核之中，劫持内核代码执行流程。KProbes 提供了一个强行进入任何内核函数并从中断处理程序中无干扰地收集内核信息的接口。使用KProbes可以轻松地收集处理器寄存器和全局数据结构等调试信息。开发者甚至可以使用 Kprobes来修改寄存器值和全局数据结构的值。最新的KProbes调用了Ftrace内核跟踪框架（出现时间晚于KProbes）提供的一些服务来实现自己的部分接口，但是整体上不影响KProbes对外提供的调试功能。 当运用KProbes跟踪某个内核函数后，该内核函数入口地址的指令被修改成Ftrace提供的特殊指令。该指令修改了内核函数的初始执行流程，在进入内核函数之前执行KProbes指定的处理程序。如下图二所示，该内核函数入口地址的初始指令是nopl（空指令），KProbes生效后，该地址的指令变成了callq ftrace_regs_caller（调用Ftrace框架入口函数）。 理解了KProbes后，掌握SystemTap就很简单了。Systemtap基于KProbes机制实现了内核函数动态跟踪，即最终使用KProbes提供的接口。但对于Systemtap来讲，它提供了一个简单的命令行接口和强大的脚本语言，同时预定义了丰富的脚本库，因此用户可以更简单，更安全地跟踪内核函数。 实现这篇文章主要介绍如何利用SystemTap模拟磁盘故障；应用程序能够感知到的常见磁盘故障比如扇区读写错误（EIO），读写慢盘，读写超时无响应等等。通过SystemTap在内核磁盘处理函数调用路径上注入特殊代码，可以模拟大部分磁盘故障。首先介绍一下Linux内核中SCSI子系统的设计架构。SCSI内核模块分为三个层次，包括SCSI Upper Layer，SCSI Mid Layer, SCSI Lower Layer； SCSI 子系统的较高层（Upper Layer）代表的是内核（设备级）最高级别的接口。它由一组虚拟设备驱动程序组成，比如块设备（SCSI 磁盘和 SCSI CD-ROM）和字符设备（SCSI 磁带和 SCSI Generic）。较高层接受来自上层（比如 VFS）的请求并将其转换成 SCSI 请求。较高层负责完成 SCSI 命令并将状态信息通知上层。SCSI中间层是 SCSI 较高层和较低层的公共服务层。它提供了很多可供较高层和较低层驱动器使用的函数，因而可以充当这两层间的连接层。在最低层的是一组驱动程序，称为SCSI底层驱动器。它们是一些可与物理设备（比如 HBA）匹配的特定驱动程序。LLD提供了自公共中间层到特定于设备的 HBA 的一种抽象。每个LLD都提供了到特定底层硬件的接口，但所使用的到中间层的接口却是一组标准接口。 这篇文章使用到的SCSI内核处理函数位于子系统的中间层，包括了scsi_dispatch_cmd，scsi_decide_disposition，以及位于Linux Block Device子系统的部分通用函数比如blk_complete_request。下面展示SystemTap如何通过探测SCSI内核函数来模拟扇区读请求EIO故障。其中第一个探测点scsi_decide_dispostion在SCSI命令被下层驱动程序处理完成后，向上层返回时被调用；如果参数中$scmd是故障磁盘的读写请求SCSI命令，则修改该命令中的SCSI Sense Buffer状态值，当该SCSI命令返回到上层块设备处理函数时，状态值被解释为SCSI读请求错误。第二个探测点scsi_dispatch_cmd在SCSI命令被下发到物理磁盘驱动程序之前被调用；在探测点处理程序内人为地破坏了命令的关键结构成员值，故意引发下层驱动程序错误。通过一前一后两个探测点有安排地篡改SCSI命令结构值，到达模拟故障磁盘的效果。图三中红色方框内为两处探测点的关键处理代码，分别修改了SCSI命令中的关键数据结构值，构造了SCSI磁盘故障。 演示为了进一步方便地模拟磁盘故障，进而为自动化各种故障测试场景做准备，这篇文章中使用了Linux Shell脚本进一步封装了SystemTap的运行接口与命令。最终通过一条命令进行磁盘故障模拟的执行。下图四与图五演示了如何使用封装后的脚本模拟慢盘和读请求EIO的磁盘故障。这个Shell脚本实现了SystemStap运行环境检查，安装故障模拟内核模块，发起故障模拟，移除故障模拟，以及最后清理运行环境。实现了故障模拟过程的闭环处理 演示一：模拟慢盘故障这个演示模拟磁盘响应IO延时异常增大的故障；重点关注第下图第三个红色方框中的命令，该命令需要五个参数，其中第一个参数和第二个参数指定了模拟故障的磁盘设备区间，第三个和第四个参数指定了模拟故障的扇区区间，第五参数指定了慢盘的时长。演示中的参数表示主设备号从&#x2F;dev&#x2F;sdb到&#x2F;dev&#x2F;sdc的每个磁盘第200扇区至第220扇区模拟3秒慢盘。接下来发起一个dd命令验证模拟效果，通过strace工具检测read()调用的执行时间为2.97秒，符合预期。 演示二：模拟EIO故障这个演示模拟磁盘扇区读IO错误的故障；同样重点关注第下图第三个红色方框中的命令，该命令需要四个参数，其中第一个参数和第二个参数指定了模拟故障的磁盘设备区间，第三个和第四个参数指定了模拟故障的扇区区间。演示中的参数表示主设备号从&#x2F;dev&#x2F;sdb到&#x2F;dev&#x2F;sdc的每个磁盘第200扇区至第220扇区模拟EIO故障。接下来发起一个dd命令验证模拟效果，通过strace工具检测read()调用返回EIO（Input&#x2F;output error），符合预期。另外当第五个红色框内的故障命令拆除故障后，再次访问同一磁盘扇区，系统调用read()正常返回扇区数据。 总结截至目前，这篇文章所介绍的磁盘故障模拟方式可以方便地模拟全盘或部分扇区读错误（EIO）故障，自定义（慢盘时长）慢盘故障。不需要定制内核代码，使用接口非常简单，可以推广到更复杂的测试场景，以及为接下来的测试用例自动化提供基础性工具。下一步计划包括实现其他的磁盘故障比如写故障，超时故障；进一步整合到自动化测试用例中，实现测试用例的端到端自动化。 参考SystemTap介绍使用KProbes调试内核","raw":"---\ntitle: 云IaaS测试系列一利用SystemTap模拟磁盘故障\ntoc: true\ndate: 2022-09-15 15:36:42\ntags: [IaaS,systemtap]\ncategories: [技术]\ndescription:\n---\n\n分布式存储系统运行在复杂的集群硬件环境下，要求长时间不停机；遇到硬件设备发生故障时必须能够保证用户数据不丢失。因此在测试分布式存储系统中，稳定性测试和可靠性测试均要求设计一些硬件故障的测试场景。通常测试人员可以通过插拔物理设备，重启系统或者直接使用故障硬件来进行测试，但是这种方式不够方便，同时也无法进行自动化改造；这篇文章运用SystemTap动态跟踪工具，在内核注入故障代码，模拟物理设备故障。经过验证能够到达手工插拔物理设备构造故障场景的测试效果；同时使用接口方便，为进一步实现端到端自动化测试用例提供了基础性工具。\n\n<!-- more -->\n\n# 背景\n故障测试是软件测试的重要场景。软件的运行环境越复杂，越有可能遭遇到各种各样的系统故障。CBS是一种分布式存储系统，对外提供块存储服务。CBS运行在服务器集群中，每台服务器直接连接多个物理磁盘。根据集群路由信息，CBS将虚拟磁盘的读写请求分发到物理磁盘上，实现用户数据的落盘与持久化。CBS运行环境包括主机，内存，磁盘，网络等物理设备，每一种设备均可能发生故障；尤其是磁盘设备的理论寿命为3万小时左右，而重要的用户数据寿命是远远超过磁盘寿命的。因此，在CBS测试项目中针对磁盘故障的可靠性和稳定性专项测试是质量保障体系中很重要的组成部分。这篇文章为测试过程中如何方便地模拟磁盘故障提供了一种解决方案。\n\n# 原理\n大家知道，Linux系统分为用户空间（User Space）与内核空间（Kernel Space）；应用程序（Applications）无法直接访问物理设备的各种服务。如图一所示，应用程序运行在用户空间内，运行级别最低，必须通过内核提供的访问调用接口才能使用物理设备的服务。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img.png)\n\n显然，若需要在系统中注入磁盘故障，存在两种方式；第一种方式最简单，直接使用一块坏盘，但是这种方式很不方便，需要插拔磁盘同时无法实现自动化，另外成本也不小。第二种方式是在内核中通过阻断磁盘处理程序中部分关键节点来模拟磁盘故障，通过内核模拟磁盘故障有三个优点，首先应用程序感知到的设备故障与通过物理插拔磁盘是一致的，其次模拟过程简单方便，再次容易自动化，提升测试效率。\n\n如何在内核中阻断磁盘处理程序？内核是随操作系统发布时安装在服务器上的核心代码，不可能在内核代码中预先设计并开发驻留故障程序。那怎么把故障程序注入到内核代码里？这里有必要了解两个强大的内核跟踪工具SystemTap和KProbes！\n\n先介绍KProbes。KProbes是Linux中一个轻量级内核调试工具，它可以将程序断点插入到正在运行的内核之中，劫持内核代码执行流程。KProbes 提供了一个强行进入任何内核函数并从中断处理程序中无干扰地收集内核信息的接口。使用KProbes可以轻松地收集处理器寄存器和全局数据结构等调试信息。开发者甚至可以使用 Kprobes来修改寄存器值和全局数据结构的值。最新的KProbes调用了Ftrace内核跟踪框架（出现时间晚于KProbes）提供的一些服务来实现自己的部分接口，但是整体上不影响KProbes对外提供的调试功能。\n\n当运用KProbes跟踪某个内核函数后，该内核函数入口地址的指令被修改成Ftrace提供的特殊指令。该指令修改了内核函数的初始执行流程，在进入内核函数之前执行KProbes指定的处理程序。如下图二所示，该内核函数入口地址的初始指令是nopl（空指令），KProbes生效后，该地址的指令变成了callq ftrace_regs_caller（调用Ftrace框架入口函数）。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_1.png)\n\n理解了KProbes后，掌握SystemTap就很简单了。Systemtap基于KProbes机制实现了内核函数动态跟踪，即最终使用KProbes提供的接口。但对于Systemtap来讲，它提供了一个简单的命令行接口和强大的脚本语言，同时预定义了丰富的脚本库，因此用户可以更简单，更安全地跟踪内核函数。\n\n# 实现\n这篇文章主要介绍如何利用SystemTap模拟磁盘故障；应用程序能够感知到的常见磁盘故障比如扇区读写错误（EIO），读写慢盘，读写超时无响应等等。通过SystemTap在内核磁盘处理函数调用路径上注入特殊代码，可以模拟大部分磁盘故障。首先介绍一下Linux内核中SCSI子系统的设计架构。SCSI内核模块分为三个层次，包括SCSI Upper Layer，SCSI Mid Layer, SCSI Lower Layer；\n\nSCSI 子系统的较高层（Upper Layer）代表的是内核（设备级）最高级别的接口。它由一组虚拟设备驱动程序组成，比如块设备（SCSI 磁盘和 SCSI CD-ROM）和字符设备（SCSI 磁带和 SCSI Generic）。较高层接受来自上层（比如 VFS）的请求并将其转换成 SCSI 请求。较高层负责完成 SCSI 命令并将状态信息通知上层。SCSI中间层是 SCSI 较高层和较低层的公共服务层。它提供了很多可供较高层和较低层驱动器使用的函数，因而可以充当这两层间的连接层。在最低层的是一组驱动程序，称为SCSI底层驱动器。它们是一些可与物理设备（比如 HBA）匹配的特定驱动程序。LLD提供了自公共中间层到特定于设备的 HBA 的一种抽象。每个LLD都提供了到特定底层硬件的接口，但所使用的到中间层的接口却是一组标准接口。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_2.png)\n\n这篇文章使用到的SCSI内核处理函数位于子系统的中间层，包括了scsi_dispatch_cmd，scsi_decide_disposition，以及位于Linux Block Device子系统的部分通用函数比如blk_complete_request。下面展示SystemTap如何通过探测SCSI内核函数来模拟扇区读请求EIO故障。其中第一个探测点scsi_decide_dispostion在SCSI命令被下层驱动程序处理完成后，向上层返回时被调用；如果参数中$scmd是故障磁盘的读写请求SCSI命令，则修改该命令中的SCSI Sense Buffer状态值，当该SCSI命令返回到上层块设备处理函数时，状态值被解释为SCSI读请求错误。第二个探测点scsi_dispatch_cmd在SCSI命令被下发到物理磁盘驱动程序之前被调用；在探测点处理程序内人为地破坏了命令的关键结构成员值，故意引发下层驱动程序错误。通过一前一后两个探测点有安排地篡改SCSI命令结构值，到达模拟故障磁盘的效果。图三中红色方框内为两处探测点的关键处理代码，分别修改了SCSI命令中的关键数据结构值，构造了SCSI磁盘故障。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_3.png)\n\n# 演示\n为了进一步方便地模拟磁盘故障，进而为自动化各种故障测试场景做准备，这篇文章中使用了Linux Shell脚本进一步封装了SystemTap的运行接口与命令。最终通过一条命令进行磁盘故障模拟的执行。下图四与图五演示了如何使用封装后的脚本模拟慢盘和读请求EIO的磁盘故障。这个Shell脚本实现了SystemStap运行环境检查，安装故障模拟内核模块，发起故障模拟，移除故障模拟，以及最后清理运行环境。实现了故障模拟过程的闭环处理\n\n## 演示一：模拟慢盘故障\n这个演示模拟磁盘响应IO延时异常增大的故障；重点关注第下图第三个红色方框中的命令，该命令需要五个参数，其中第一个参数和第二个参数指定了模拟故障的磁盘设备区间，第三个和第四个参数指定了模拟故障的扇区区间，第五参数指定了慢盘的时长。演示中的参数表示主设备号从/dev/sdb到/dev/sdc的每个磁盘第200扇区至第220扇区模拟3秒慢盘。接下来发起一个dd命令验证模拟效果，通过strace工具检测read()调用的执行时间为2.97秒，符合预期。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_4.png)\n\n## 演示二：模拟EIO故障\n这个演示模拟磁盘扇区读IO错误的故障；同样重点关注第下图第三个红色方框中的命令，该命令需要四个参数，其中第一个参数和第二个参数指定了模拟故障的磁盘设备区间，第三个和第四个参数指定了模拟故障的扇区区间。演示中的参数表示主设备号从/dev/sdb到/dev/sdc的每个磁盘第200扇区至第220扇区模拟EIO故障。接下来发起一个dd命令验证模拟效果，通过strace工具检测read()调用返回EIO（Input/output error），符合预期。另外当第五个红色框内的故障命令拆除故障后，再次访问同一磁盘扇区，系统调用read()正常返回扇区数据。\n![](http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_5.png)\n\n# 总结\n截至目前，这篇文章所介绍的磁盘故障模拟方式可以方便地模拟全盘或部分扇区读错误（EIO）故障，自定义（慢盘时长）慢盘故障。不需要定制内核代码，使用接口非常简单，可以推广到更复杂的测试场景，以及为接下来的测试用例自动化提供基础性工具。下一步计划包括实现其他的磁盘故障比如写故障，超时故障；进一步整合到自动化测试用例中，实现测试用例的端到端自动化。\n\n\n# 参考\n[SystemTap介绍](https://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html?ca=drs-)\n[使用KProbes调试内核](https://www.ibm.com/developerworks/cn/linux/l-kprobes.html)","content":"<p>分布式存储系统运行在复杂的集群硬件环境下，要求长时间不停机；遇到硬件设备发生故障时必须能够保证用户数据不丢失。因此在测试分布式存储系统中，稳定性测试和可靠性测试均要求设计一些硬件故障的测试场景。通常测试人员可以通过插拔物理设备，重启系统或者直接使用故障硬件来进行测试，但是这种方式不够方便，同时也无法进行自动化改造；这篇文章运用SystemTap动态跟踪工具，在内核注入故障代码，模拟物理设备故障。经过验证能够到达手工插拔物理设备构造故障场景的测试效果；同时使用接口方便，为进一步实现端到端自动化测试用例提供了基础性工具。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>故障测试是软件测试的重要场景。软件的运行环境越复杂，越有可能遭遇到各种各样的系统故障。CBS是一种分布式存储系统，对外提供块存储服务。CBS运行在服务器集群中，每台服务器直接连接多个物理磁盘。根据集群路由信息，CBS将虚拟磁盘的读写请求分发到物理磁盘上，实现用户数据的落盘与持久化。CBS运行环境包括主机，内存，磁盘，网络等物理设备，每一种设备均可能发生故障；尤其是磁盘设备的理论寿命为3万小时左右，而重要的用户数据寿命是远远超过磁盘寿命的。因此，在CBS测试项目中针对磁盘故障的可靠性和稳定性专项测试是质量保障体系中很重要的组成部分。这篇文章为测试过程中如何方便地模拟磁盘故障提供了一种解决方案。</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>大家知道，Linux系统分为用户空间（User Space）与内核空间（Kernel Space）；应用程序（Applications）无法直接访问物理设备的各种服务。如图一所示，应用程序运行在用户空间内，运行级别最低，必须通过内核提供的访问调用接口才能使用物理设备的服务。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img.png\"></p>\n<p>显然，若需要在系统中注入磁盘故障，存在两种方式；第一种方式最简单，直接使用一块坏盘，但是这种方式很不方便，需要插拔磁盘同时无法实现自动化，另外成本也不小。第二种方式是在内核中通过阻断磁盘处理程序中部分关键节点来模拟磁盘故障，通过内核模拟磁盘故障有三个优点，首先应用程序感知到的设备故障与通过物理插拔磁盘是一致的，其次模拟过程简单方便，再次容易自动化，提升测试效率。</p>\n<p>如何在内核中阻断磁盘处理程序？内核是随操作系统发布时安装在服务器上的核心代码，不可能在内核代码中预先设计并开发驻留故障程序。那怎么把故障程序注入到内核代码里？这里有必要了解两个强大的内核跟踪工具SystemTap和KProbes！</p>\n<p>先介绍KProbes。KProbes是Linux中一个轻量级内核调试工具，它可以将程序断点插入到正在运行的内核之中，劫持内核代码执行流程。KProbes 提供了一个强行进入任何内核函数并从中断处理程序中无干扰地收集内核信息的接口。使用KProbes可以轻松地收集处理器寄存器和全局数据结构等调试信息。开发者甚至可以使用 Kprobes来修改寄存器值和全局数据结构的值。最新的KProbes调用了Ftrace内核跟踪框架（出现时间晚于KProbes）提供的一些服务来实现自己的部分接口，但是整体上不影响KProbes对外提供的调试功能。</p>\n<p>当运用KProbes跟踪某个内核函数后，该内核函数入口地址的指令被修改成Ftrace提供的特殊指令。该指令修改了内核函数的初始执行流程，在进入内核函数之前执行KProbes指定的处理程序。如下图二所示，该内核函数入口地址的初始指令是nopl（空指令），KProbes生效后，该地址的指令变成了callq ftrace_regs_caller（调用Ftrace框架入口函数）。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_1.png\"></p>\n<p>理解了KProbes后，掌握SystemTap就很简单了。Systemtap基于KProbes机制实现了内核函数动态跟踪，即最终使用KProbes提供的接口。但对于Systemtap来讲，它提供了一个简单的命令行接口和强大的脚本语言，同时预定义了丰富的脚本库，因此用户可以更简单，更安全地跟踪内核函数。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>这篇文章主要介绍如何利用SystemTap模拟磁盘故障；应用程序能够感知到的常见磁盘故障比如扇区读写错误（EIO），读写慢盘，读写超时无响应等等。通过SystemTap在内核磁盘处理函数调用路径上注入特殊代码，可以模拟大部分磁盘故障。首先介绍一下Linux内核中SCSI子系统的设计架构。SCSI内核模块分为三个层次，包括SCSI Upper Layer，SCSI Mid Layer, SCSI Lower Layer；</p>\n<p>SCSI 子系统的较高层（Upper Layer）代表的是内核（设备级）最高级别的接口。它由一组虚拟设备驱动程序组成，比如块设备（SCSI 磁盘和 SCSI CD-ROM）和字符设备（SCSI 磁带和 SCSI Generic）。较高层接受来自上层（比如 VFS）的请求并将其转换成 SCSI 请求。较高层负责完成 SCSI 命令并将状态信息通知上层。SCSI中间层是 SCSI 较高层和较低层的公共服务层。它提供了很多可供较高层和较低层驱动器使用的函数，因而可以充当这两层间的连接层。在最低层的是一组驱动程序，称为SCSI底层驱动器。它们是一些可与物理设备（比如 HBA）匹配的特定驱动程序。LLD提供了自公共中间层到特定于设备的 HBA 的一种抽象。每个LLD都提供了到特定底层硬件的接口，但所使用的到中间层的接口却是一组标准接口。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_2.png\"></p>\n<p>这篇文章使用到的SCSI内核处理函数位于子系统的中间层，包括了scsi_dispatch_cmd，scsi_decide_disposition，以及位于Linux Block Device子系统的部分通用函数比如blk_complete_request。下面展示SystemTap如何通过探测SCSI内核函数来模拟扇区读请求EIO故障。其中第一个探测点scsi_decide_dispostion在SCSI命令被下层驱动程序处理完成后，向上层返回时被调用；如果参数中$scmd是故障磁盘的读写请求SCSI命令，则修改该命令中的SCSI Sense Buffer状态值，当该SCSI命令返回到上层块设备处理函数时，状态值被解释为SCSI读请求错误。第二个探测点scsi_dispatch_cmd在SCSI命令被下发到物理磁盘驱动程序之前被调用；在探测点处理程序内人为地破坏了命令的关键结构成员值，故意引发下层驱动程序错误。通过一前一后两个探测点有安排地篡改SCSI命令结构值，到达模拟故障磁盘的效果。图三中红色方框内为两处探测点的关键处理代码，分别修改了SCSI命令中的关键数据结构值，构造了SCSI磁盘故障。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_3.png\"></p>\n<h1 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h1><p>为了进一步方便地模拟磁盘故障，进而为自动化各种故障测试场景做准备，这篇文章中使用了Linux Shell脚本进一步封装了SystemTap的运行接口与命令。最终通过一条命令进行磁盘故障模拟的执行。下图四与图五演示了如何使用封装后的脚本模拟慢盘和读请求EIO的磁盘故障。这个Shell脚本实现了SystemStap运行环境检查，安装故障模拟内核模块，发起故障模拟，移除故障模拟，以及最后清理运行环境。实现了故障模拟过程的闭环处理</p>\n<h2 id=\"演示一：模拟慢盘故障\"><a href=\"#演示一：模拟慢盘故障\" class=\"headerlink\" title=\"演示一：模拟慢盘故障\"></a>演示一：模拟慢盘故障</h2><p>这个演示模拟磁盘响应IO延时异常增大的故障；重点关注第下图第三个红色方框中的命令，该命令需要五个参数，其中第一个参数和第二个参数指定了模拟故障的磁盘设备区间，第三个和第四个参数指定了模拟故障的扇区区间，第五参数指定了慢盘的时长。演示中的参数表示主设备号从&#x2F;dev&#x2F;sdb到&#x2F;dev&#x2F;sdc的每个磁盘第200扇区至第220扇区模拟3秒慢盘。接下来发起一个dd命令验证模拟效果，通过strace工具检测read()调用的执行时间为2.97秒，符合预期。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_4.png\"></p>\n<h2 id=\"演示二：模拟EIO故障\"><a href=\"#演示二：模拟EIO故障\" class=\"headerlink\" title=\"演示二：模拟EIO故障\"></a>演示二：模拟EIO故障</h2><p>这个演示模拟磁盘扇区读IO错误的故障；同样重点关注第下图第三个红色方框中的命令，该命令需要四个参数，其中第一个参数和第二个参数指定了模拟故障的磁盘设备区间，第三个和第四个参数指定了模拟故障的扇区区间。演示中的参数表示主设备号从&#x2F;dev&#x2F;sdb到&#x2F;dev&#x2F;sdc的每个磁盘第200扇区至第220扇区模拟EIO故障。接下来发起一个dd命令验证模拟效果，通过strace工具检测read()调用返回EIO（Input&#x2F;output error），符合预期。另外当第五个红色框内的故障命令拆除故障后，再次访问同一磁盘扇区，系统调用read()正常返回扇区数据。<br><img src=\"http://cdn.yuleweici.com/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/img_5.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>截至目前，这篇文章所介绍的磁盘故障模拟方式可以方便地模拟全盘或部分扇区读错误（EIO）故障，自定义（慢盘时长）慢盘故障。不需要定制内核代码，使用接口非常简单，可以推广到更复杂的测试场景，以及为接下来的测试用例自动化提供基础性工具。下一步计划包括实现其他的磁盘故障比如写故障，超时故障；进一步整合到自动化测试用例中，实现测试用例的端到端自动化。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html?ca=drs-\">SystemTap介绍</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/l-kprobes.html\">使用KProbes调试内核</a></p>\n","slug":"云IaaS测试系列一利用SystemTap模拟磁盘故障","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/09/15/%E4%BA%91IaaS%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%E5%88%A9%E7%94%A8SystemTap%E6%A8%A1%E6%8B%9F%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C/","excerpt":"分布式存储系统运行在复杂的集群硬件环境下，要求长时间不停机；遇到硬件设备发生故障时必须能够保证用户数据不丢失。因此在测试分布式存储系统中，稳定性测试和可靠性测试均要求设计一些硬件故障的测试场景。通常测试人员可以通过插拔物理设备，重启系统或者直接使用故障硬件来进行测试，但是这种方式不够方便，同时也无法进行自动化改造；这篇文章运用SystemTap动态跟踪工具，在内核注入故障代码，模拟物理设备故障。经过验证能够到达手工插拔物理设备构造故障场景的测试效果；同时使用接口方便，为进一步实现端到端自动化测试用例提供了基础性工具。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IaaS","slug":"IaaS","permalink":"http://vwin.github.io/tags/IaaS/"},{"name":"systemtap","slug":"systemtap","permalink":"http://vwin.github.io/tags/systemtap/"}]},{"title":"CPP-理解make/makefile/cmake/nmake","date":"2022-09-08T11:31:46.000Z","path":"2022/09/08/CPP-理解make-makefile-cmake-nmake/","text":"刚开始被make、cmake、makefile… … 这些东西绕晕，整理下 编译器编译器是一种计算机程序，它将某种编程语言（高级编程语言）写成的源代码转换成另一种编程语言（低级编程语言）。一个现代编译器的主要工作流程为：源代码-&gt;预处理器-&gt;编译器-&gt;目标代码-&gt;链接器-&gt;可执行程序，最后打包文件，让计算机运行。编译器的目的是将便于人写的高级编程语言作为源代码，翻译成计算机能够执行的低级机器语言，也就是可执行文件。其中高级语言有C、C++、Java、Python等，低级语言有汇编语言和机器代码。一个编译器可以按照三段式分为：前段（Fontend）、优化器（Optimizer）、后端（Backend）。 LLVMLLVM（Low Level Virtual Machine），即底层虚拟机。它是一个由C++编写而成的编译器基础框架，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化框架。从宏观上来讲，LLVM不仅仅是一个编译器或者虚拟机，它是一个众多编译器工具及低级工具技术的统称，它包含了一个前端、优化器、后端以及众多的函数库和模板。从微观上来讲，可以把它看做后端编译器，用来生成目标代码，前端编译器为Clang。Xcode5版本之前，编译器默认使用的是GCC，从Xcode5之后编译器默认使用LLVM。 gcc它是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。 我们的程序只有一个源文件时，直接就可以用gcc命令编译它。 可是，如果我们的程序包含很多个源文件时，该咋整？用gcc命令逐个去编译时，就发现很容易混乱而且工作量大，所以出现了下面make工具。 g++是GCC的C++编译器 clang是mac上另起炉灶写的一个C语言、C++、Objective-C、Objective-C++语言的轻量级编译器。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。Clang和gcc相比,比gcc编译速度更快一些，而且错误提示更人性化。Clang兼容GCC，所以可以无缝的替换掉GCC。Clang官网：http://clang.llvm.org在某些资料中出现cfe，它是clang front-end的简写，它实际上就是指Clang。 clang++clang的C++编译器 makemake工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。 makefile这个是啥东西？ 简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。 makefile在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改，这时候就出现了下面的Cmake这个工具。 cmakecmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他更牛X功能，就是可以跨平台生成对应平台能用的makefile，我们就不用再自己去修改了。 可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。 CMakeList.txt到最后CMakeLists.txt文件谁写啊？肯定是你自己手写啊！ nmakenmake又是啥东西？ nmake是Microsoft Visual Studio中的附带命令，需要安装VS，实际上可以说相当于linux的make，明白了么？ 总结一下大体流程1.用编辑器编写源代码，如.c文件。2.用编译器编译代码生成目标文件，如.o。3.用链接器连接目标代码生成可执行文件，如.exe。但如果源文件太多，一个一个编译那得多麻烦啊？于是人们想到，为啥不设计一种类似批处理的程序，来批处理编译源文件呢？ 于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。 对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。（cmake中有很多设置库的，此时还不是可执行文件，而make生成后才是二进制可执行文件。）","raw":"---\ntitle: CPP-理解make/makefile/cmake/nmake\ntoc: true\ndate: 2022-09-08 19:31:46\ntags: [C++,cmake,makefile,nmake]\ncategories: [技术]\ndescription:\n---\n刚开始被make、cmake、makefile... ... 这些东西绕晕，整理下\n\n<!--more-->\n## 编译器\n编译器是一种计算机程序，它将某种编程语言（高级编程语言）写成的源代码转换成另一种编程语言（低级编程语言）。一个现代编译器的主要工作流程为：源代码->预处理器->编译器->目标代码->链接器->可执行程序，最后打包文件，让计算机运行。编译器的目的是将便于人写的高级编程语言作为源代码，翻译成计算机能够执行的低级机器语言，也就是可执行文件。其中高级语言有C、C++、Java、Python等，低级语言有汇编语言和机器代码。一个编译器可以按照三段式分为：前段（Fontend）、优化器（Optimizer）、后端（Backend）。\n\n## LLVM\nLLVM（Low Level Virtual Machine），即底层虚拟机。它是一个由C++编写而成的编译器基础框架，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化框架。从宏观上来讲，LLVM不仅仅是一个编译器或者虚拟机，它是一个众多编译器工具及低级工具技术的统称，它包含了一个前端、优化器、后端以及众多的函数库和模板。从微观上来讲，可以把它看做后端编译器，用来生成目标代码，前端编译器为Clang。Xcode5版本之前，编译器默认使用的是GCC，从Xcode5之后编译器默认使用LLVM。\n\n## gcc\n它是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。\n\n我们的程序只有一个源文件时，直接就可以用gcc命令编译它。\n\n可是，如果我们的程序包含很多个源文件时，该咋整？用gcc命令逐个去编译时，就发现很容易混乱而且工作量大，所以出现了下面make工具。\n\n## g++\n是GCC的C++编译器\n\n## clang\n是mac上另起炉灶写的一个C语言、C++、Objective-C、Objective-C++语言的轻量级编译器。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。\nClang和gcc相比,比gcc编译速度更快一些，而且错误提示更人性化。\nClang兼容GCC，所以可以无缝的替换掉GCC。\nClang官网：http://clang.llvm.org\n在某些资料中出现cfe，它是clang front-end的简写，它实际上就是指Clang。\n\n## clang++\nclang的C++编译器\n\n\n## make\nmake工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。\n\n## makefile\n这个是啥东西？\n\n简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。\n\nmakefile在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改，这时候就出现了下面的Cmake这个工具。\n\n## cmake\ncmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他更牛X功能，就是可以跨平台生成对应平台能用的makefile，我们就不用再自己去修改了。\n\n可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。\n\n## CMakeList.txt\n到最后CMakeLists.txt文件谁写啊？肯定是你自己手写啊！\n\n## nmake\nnmake又是啥东西？\n\nnmake是Microsoft Visual Studio中的附带命令，需要安装VS，实际上可以说相当于linux的make，明白了么？\n![nmake](http://cdn.yuleweici.com/CPP-%E7%90%86%E8%A7%A3make-makefile-cmake-nmake/nmake.png)\n\n## 总结一下大体流程\n1.用编辑器编写源代码，如.c文件。\n2.用编译器编译代码生成目标文件，如.o。\n3.用链接器连接目标代码生成可执行文件，如.exe。\n但如果源文件太多，一个一个编译那得多麻烦啊？于是人们想到，为啥不设计一种类似批处理的程序，来批处理编译源文件呢？\n\n于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。\n\n对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。（cmake中有很多设置库的，此时还不是可执行文件，而make生成后才是二进制可执行文件。）","content":"<p>刚开始被make、cmake、makefile… … 这些东西绕晕，整理下</p>\n<span id=\"more\"></span>\n<h2 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h2><p>编译器是一种计算机程序，它将某种编程语言（高级编程语言）写成的源代码转换成另一种编程语言（低级编程语言）。一个现代编译器的主要工作流程为：源代码-&gt;预处理器-&gt;编译器-&gt;目标代码-&gt;链接器-&gt;可执行程序，最后打包文件，让计算机运行。编译器的目的是将便于人写的高级编程语言作为源代码，翻译成计算机能够执行的低级机器语言，也就是可执行文件。其中高级语言有C、C++、Java、Python等，低级语言有汇编语言和机器代码。一个编译器可以按照三段式分为：前段（Fontend）、优化器（Optimizer）、后端（Backend）。</p>\n<h2 id=\"LLVM\"><a href=\"#LLVM\" class=\"headerlink\" title=\"LLVM\"></a>LLVM</h2><p>LLVM（Low Level Virtual Machine），即底层虚拟机。它是一个由C++编写而成的编译器基础框架，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化框架。从宏观上来讲，LLVM不仅仅是一个编译器或者虚拟机，它是一个众多编译器工具及低级工具技术的统称，它包含了一个前端、优化器、后端以及众多的函数库和模板。从微观上来讲，可以把它看做后端编译器，用来生成目标代码，前端编译器为Clang。Xcode5版本之前，编译器默认使用的是GCC，从Xcode5之后编译器默认使用LLVM。</p>\n<h2 id=\"gcc\"><a href=\"#gcc\" class=\"headerlink\" title=\"gcc\"></a>gcc</h2><p>它是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。</p>\n<p>我们的程序只有一个源文件时，直接就可以用gcc命令编译它。</p>\n<p>可是，如果我们的程序包含很多个源文件时，该咋整？用gcc命令逐个去编译时，就发现很容易混乱而且工作量大，所以出现了下面make工具。</p>\n<h2 id=\"g\"><a href=\"#g\" class=\"headerlink\" title=\"g++\"></a>g++</h2><p>是GCC的C++编译器</p>\n<h2 id=\"clang\"><a href=\"#clang\" class=\"headerlink\" title=\"clang\"></a>clang</h2><p>是mac上另起炉灶写的一个C语言、C++、Objective-C、Objective-C++语言的轻量级编译器。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。<br>Clang和gcc相比,比gcc编译速度更快一些，而且错误提示更人性化。<br>Clang兼容GCC，所以可以无缝的替换掉GCC。<br>Clang官网：<a href=\"http://clang.llvm.org/\">http://clang.llvm.org</a><br>在某些资料中出现cfe，它是clang front-end的简写，它实际上就是指Clang。</p>\n<h2 id=\"clang-1\"><a href=\"#clang-1\" class=\"headerlink\" title=\"clang++\"></a>clang++</h2><p>clang的C++编译器</p>\n<h2 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h2><p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。</p>\n<h2 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h2><p>这个是啥东西？</p>\n<p>简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。</p>\n<p>makefile在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改，这时候就出现了下面的Cmake这个工具。</p>\n<h2 id=\"cmake\"><a href=\"#cmake\" class=\"headerlink\" title=\"cmake\"></a>cmake</h2><p>cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他更牛X功能，就是可以跨平台生成对应平台能用的makefile，我们就不用再自己去修改了。</p>\n<p>可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。</p>\n<h2 id=\"CMakeList-txt\"><a href=\"#CMakeList-txt\" class=\"headerlink\" title=\"CMakeList.txt\"></a>CMakeList.txt</h2><p>到最后CMakeLists.txt文件谁写啊？肯定是你自己手写啊！</p>\n<h2 id=\"nmake\"><a href=\"#nmake\" class=\"headerlink\" title=\"nmake\"></a>nmake</h2><p>nmake又是啥东西？</p>\n<p>nmake是Microsoft Visual Studio中的附带命令，需要安装VS，实际上可以说相当于linux的make，明白了么？<br><img src=\"http://cdn.yuleweici.com/CPP-%E7%90%86%E8%A7%A3make-makefile-cmake-nmake/nmake.png\" alt=\"nmake\"></p>\n<h2 id=\"总结一下大体流程\"><a href=\"#总结一下大体流程\" class=\"headerlink\" title=\"总结一下大体流程\"></a>总结一下大体流程</h2><p>1.用编辑器编写源代码，如.c文件。<br>2.用编译器编译代码生成目标文件，如.o。<br>3.用链接器连接目标代码生成可执行文件，如.exe。<br>但如果源文件太多，一个一个编译那得多麻烦啊？于是人们想到，为啥不设计一种类似批处理的程序，来批处理编译源文件呢？</p>\n<p>于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。</p>\n<p>对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。（cmake中有很多设置库的，此时还不是可执行文件，而make生成后才是二进制可执行文件。）</p>\n","slug":"CPP-理解make-makefile-cmake-nmake","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/09/08/CPP-%E7%90%86%E8%A7%A3make-makefile-cmake-nmake/","excerpt":"刚开始被make、cmake、makefile… … 这些东西绕晕，整理下","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://vwin.github.io/tags/C/"},{"name":"cmake","slug":"cmake","permalink":"http://vwin.github.io/tags/cmake/"},{"name":"makefile","slug":"makefile","permalink":"http://vwin.github.io/tags/makefile/"},{"name":"nmake","slug":"nmake","permalink":"http://vwin.github.io/tags/nmake/"}]},{"title":"CPP-包管理器CONAN上手指南","date":"2022-09-08T11:07:05.000Z","path":"2022/09/08/CPP-包管理器CONAN上手指南/","text":"最近接了一个C++写的项目，好久没用过C++了，从头学习整理下C++相关的内容 C++包管理C&#x2F;C++ 项目如果要依赖第三方库，往往有 N 种姿势来完成这个事情： 直接在源码中包裹第三方库的头文件和二进制 把第三方库的源码带入工程中随项目一起编译 依赖系统中安装的组件，而后使用 pkg_config 或 CMake 的 find 系函数来查找依赖 其中方案1，不具备可移植性，但依赖非开源组件且无软件包可用时往往只能用这种方法；方案2，普适性比较强，可以针对源码做定制，但是大大增加了源码的大小和构建的耗时；方案3，Windows 下往往不可用，并且需要用户手动准备环境，每次搭建新环境时比较繁琐。 可以看到，光依赖管理就没有一个比较标准的解决方案，并且这些方法各自也都有很大缺陷。这进一步导致社区的撕裂，其结果就是即便是可移植的开源库，如果你想在项目中引用它，也得看看要用什么方法来引入才能对接到你的 Build System 中。 而在其他的流行语言中，包管理器可以说是一个很常态很普遍的东西了，比如 Python 的 pip，JS 的 npm，C# 的 nuget 等等。 至于为何会这样，也有一个很大的原因是 C&#x2F;C++ 本身的定位和历史原因。它能 Target 到众多的平台上，从 X86、X64 到 Arm，从 Windows、Linux 到 MacOS 甚至于嵌入式的系统中。每个平台的特点都不尽相同，甚至于相同平台使用不同编译器构建后能产生不同的 ABI（application binary interface）。这使得包管理器的设计远比无需编译的 Python、JS 一流复杂很多。 当然我们也看到像微软在这方面做了尝试，弄出了 vcpkg，笔者没有用过，听说是更贴近 apt 的作用，用来安装全局的依赖。 ConanConan 是一个开源的、跨平台的、去中心化的 C++ 包管理器。通过它可以安装、解决构建依赖，更重要的是可以直接集成到 Build System 中使用。同时它也允许你搭建自己的私有仓库，供私有项目使用。具体到细节，当向 Conan 请求安装依赖时，Conan 会拿着编译相关的配置信息去服务器请求是否有对应平台的预构建二进制包，如果有，则直接下载并解压到本地的缓存仓库中，否则，会执行对应的构建脚本，构建出符合当前平台的二进制包。这种方式并无特别之处，但是是可以解决 C++ 平台众多的问题的有效方法。 安装Conan 基于 Python 编写，故需要在开始前安装好 Python3。然后使用标准的 pip 安装即可。 1pip install conan 需要注意的是，Linux 下需要用 sudo 安装全局的 pip 包。而 OSX 下也可以使用 brew 来安装 Conan。 配置Conan 会在第一次启动时自动配置好默认的 Profile 和 Remote 设置。它的配置以及本地的二进制仓库均存储在用户目录下~&#x2F;.conan&#x2F;中（Windows上，是%USERPROFILE%.conan\\）。 其中用户配置文件为conan.conf，通常情况下无需修改，但当需要设置代理时，可以对其进行编辑。 123[proxies]http = http://dev-proxy.oa.com:8080https = http://dev-proxy.oa.com:8080 另外，当使用 Artifactory 来搭建私有仓库时，需要启用 general.revisions_enabled &#x3D; 1这个开关。笔者会在下文介绍如何搭建私有仓库，这里不予展开。 而 Profile 则存储在profiles文件夹中，用于设定各种编译环境和选项。默认会创建一个名为 default 的 Profile 供使用。 Conan基本概念软件包Conan 使用这样的格式来描述一个软件包：名称&#x2F;版本@用户&#x2F;渠道。其中渠道（Channel）用来描述是稳定版（Stable）还是测试版（Testing）等信息，以 boost 为例，我们可以看到这样的包名： 1234567boost/1.64.0@conan/stableboost/1.65.1@conan/stableboost/1.66.0@conan/stableboost/1.67.0@conan/stableboost/1.68.0@conan/stableboost/1.69.0@conan/stableboost/1.70.0@conan/stable 软件包仓库NodeJS 的包管理器 npm 会把依赖存储到工程目录的node_modules文件夹中，此外也能安装全局的包。Python 的包管理器 pip 能把包装到用户目录下或者是全局环境中，所以一般配合 venv 使之把包装在工程中不污染环境。 相比之下，可能是出于 C++ 的库通常需要依据环境编译，并且大小比较大的考量，默认情况下 Conan 只把包装在用户目录下。一般来说，在开发环境中这点已经足够使用了。但是在配合 CI&#x2F;CD 的时候，这里就有可能出现竞争。为此，Conan 提供了一个环境变量CONAN_USER_HOME来让用户指定一个 Conan 的工作目录，这样就能起到类似于 Python 的 Virtual Environment 的作用。 上文中，用户目录的软件包仓库被称为本地缓存（Local Cache）；那么同样的，服务器上也有一个软件包的仓库，文档中称为远端（Remote）。 Conan 提供了几个官方和社区的远端供选择，默认的，安装后会自动配置 Conan Center 这个源： conan-center: https://bintray.com/conan/conan-center conan-transit（废弃）: https://bintray.com/conan/conan-transit bincrafters（开源社区源） : https://bintray.com/bincrafters/public-conan conan-community（类似测试源，不稳定） : https://bintray.com/conan-community/conan 编译环境通常情况下默认的 Profile 就够用了，故本文不赘述配置 Profile 的过程，如有时间会在未来进行补充。 需要注意的是使用 GCC 作编译器时需要手动开启对 C++11 的 ABI 的支持，否则默认位于兼容模式下，将使用老的 ABI。 12conan profile new default --detect # Generates default profile detecting GCC and sets old ABIconan profile update settings.compiler.libcxx=libstdc++11 default # Sets libcxx to C++11 ABI Conan基本操作搜索软件包1conan search boost* -r=conan-center 使用上述命令在默认的中心仓库中搜索 boost 软件包。在不指定-r的情况下，默认搜索本地缓存。 管理远端1234567891011# 添加源conan remote add my-repo http://my-repo.com/xxx# 或者使用insert来将其作为首个源conan remote update my-repo http://my-repo.com/xxx --insert=0# 展示所有源conan remote list# 删除一个源conan remote remove my-repo Conan 的远端是个列表，并有先后顺序，默认在安装软件包的时候会先检查本地缓存，然后依次从软件源中获取软件包。 因此常用源应当使用insert参数使之排到前面。 安装依赖与构建类似于 CMake，Conan 使用一个叫做conanfile.txt的文件来描述工程依赖和导出相关的文件（更进阶的，可以使用conanfile.py来精确控制这个过程）。 以配合 CMake 使用为例，conanfile.txt需要这样编写（官方用例）： 12345[requires]Poco/1.7.8p3@pocoproject/stable[generators]cmake 这里要提一点，如果有包 A 依赖包 C 的 1.0 版本，包 B 依赖包 C 的 1.2 版本，此时就会出现冲突。通过手动在 Requires 中写入C&#x2F;1.2@xxx&#x2F;yyy这样的依赖可以强制提升 C 的版本号为最新，从而解决冲突的问题。 这个 CMake 的 Generator 会在安装依赖后产生一个conanbuildinfo.cmake供 CMake 使用来查找依赖。 那么工程对应的cmakefile.txt会这样编写： 123456789project(FoundationTimer)cmake_minimum_required(VERSION 2.8.12)add_definitions(&quot;-std=c++11&quot;)include($&#123;CMAKE_BINARY_DIR&#125;/conanbuildinfo.cmake)conan_basic_setup()add_executable(timer timer.cpp)target_link_libraries(timer $&#123;CONAN_LIBS&#125;) 其中${CONAN_LIBS}就直接标明了所有的第三方依赖，直接链接（Link）上去就大功告成了。 整个安装依赖和构建的具体命令如下： 123456# 假设位于工程目录下mkdir build # out of source buildcd buildconan install .. # 安装依赖和创建cmake导出文件，使用 --profile=xxx 来指定不同的构建环境cmake ..cmake --build . --config Release Conan进阶Conan 确实极大的简化了依赖安装的过程，但是具体使用过程中也能发现 Conan 目前的弱点： 国内访问中心仓库的速度极慢 可选的软件包少，只涵盖知名度高的和常用的软件包对于这两个缺陷，本文将通过自建软件源和自己编写软件包来解决。 自建仓库Conan 官方提供了一个迷你的服务端来提供仓库的功能，同时也推荐使用Artifactory Community Edition for C&#x2F;C++来自建仓库。当然，如果是为了开源项目，可以直接在 Bintray 上申请一个开源项目账号来上传自制软件包而无需自建仓库（但是实在是太慢了）。 本文使用 Artifactory 来自建仓库，因为功能相对完善。Artifactory 支持配置用户和组以及对应的权限，商业版本还支持高可用和分布式。 安装为了简单起见，本文采取 Docker 镜像的方式安装 Artifactory： 1sudo docker pull docker.bintray.io/jfrog/artifactory-cpp-ce 以官方文档为例，使用下述命令即可创建容器： 1sudo docker run -d --restart=always --name artifactory -v /data/artifactory:/var/opt/jfrog/artifactory -p 8081:8081 -e EXTRA_JAVA_OPTIONS=&#x27;-Xms512m -Xmx2g -Xss256k -XX:+UseG1GC&#x27; docker.bintray.io/jfrog/artifactory-pro:latest 上述命令会暴露在本机的8081端口上，同时挂载数据目录到&#x2F;data&#x2F;artifactory目录下。 注意到，Artifactory 默认会以 UserID 1030 运行服务，一定要注意宿主机的数据目录的权限是否满足要求，如果启动时出现 Permission Denied 错误，记得修改目录权限： 12sudo chown 1030:1030 /data/artifactorysudo chmod 0755 /data/artifactory 你也可以使用–user 1234:4321的方式来指定 Docker 使用哪个用户&#x2F;组权限来执行容器。 配置首次访问http://localhost:8081即可打开配置向导。默认的，配置好 Admin 账户的密码，初始化默认的 Conan 仓库配置即可。向导会提示你创建一个 HTTP Proxy，如果网络够好或者只作私仓使用则可以忽略该配置，否则，建议创建一个代理设置来加速访问 Remote 仓库。 Artifactory 提供了三种类型的 Conan 仓库供不同目的使用： 本地仓库（Local）：即当前 Artifactory 服务器上存储软件包的仓库； 远端仓库（Remote）：即第三方的软件仓库，在本服务器上作为 Proxy 和 Cache 运作； 虚拟仓库（Virtual）：作为一个索引中心，能将其他两类仓库整合到一个仓库名下，方便使用。初始化之后，Artifactory 会创建好一个本地仓库，一个到 Conan Center 的远程仓库和包含上述两个仓库的虚拟仓库。 需要注意的是，默认配置下 Artifactory 是允许匿名访问的，必须在 Admin &gt; Security Configuration 页面中关闭匿名访问才能真正作为私仓使用。 添加到 Conan在仓库管理页面，点击虚拟仓库 Conan，在右上角点击 Set Me Up 按钮即可显示当前仓库如何在 Conan 中配置并作为一个源。 照着上面写的步骤，即可把自建源加入到 Conan 中： 1conan remote add &lt;REMOTE&gt; http://localhost:8081/artifactory/api/conan/conan 在使用之前，还需要修改你的conan.conf，开启revisions_enabled功能才能正常使用私仓。这是因为 Artifactory 并不支持 Conan v1 的协议，必须开启这一功能使用 v2 协议才能正常使用。 如果你配置了 Remote 仓库，则此时，你可以通过自己的私仓来访问到官方源，同时还可以配置上社区源来同时进行访问（然而社区源使用 v1 协议，导致并不能直接下载其上的包，这种情况下可以先下载社区源的包到本地，再上传到你的私仓上）。尤其在安装过官方仓库的软件包后，Artifactory 会将其缓存到本地，之后就会作为本地的 Cache 加速访问。 更多的配置可以参看官方文档，本文不再赘述。 自建软件包因为很多第三方开源项目没有 Conan 官方的支持，使用这些项目的时候就需要自己来编写 Receipe 来告诉 Conan 如何编译、打包第三方库了。 这里以bgfx为例来构造一个 Conan 的二进制包，并提交到我们自建的私仓中。 因为bgfx官方构建方式比较复杂，笔者选取了其 CMake 版本来执行构建。此外 Github 上已经有用户创建过对应的构建脚本了，因此这里可以直接参考别人的写法来进行构建。 使用conan new Hello&#x2F;0.1 -t可以创建一个 HelloWorld 的空白 Receipe。可以看到呈现出这样的目录结构： 12345conanfile.pytest_package CMakeLists.txt conanfile.py example.cpp 其中conanfile.py用来描述构建软件包的编译打包过程，test_package存储一个测试用的样例，用来检查是否成功构建了软件包并且是否能正常使用。 以构建bgfx的脚本为例，修改conanfile.py： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from conans import ConanFile, CMakefrom distutils.dir_util import copy_treeclass BgfxConan(ConanFile): name = &quot;bgfx&quot; version = &quot;20220908.0127cc8x&quot; # 这个地方我乱填的，请遵照SemVer的规范制定版本号 description = &quot;Conan package for bgfx.&quot; url = &quot;https://github.com/vwin/xxx&quot; license = &quot;BSD&quot; settings = &quot;arch&quot;, &quot;build_type&quot;, &quot;compiler&quot;, &quot;os&quot; # 这些选项会被作为包的标识，区分不同的ABI generators = &quot;cmake&quot; options = &#123;&quot;shared&quot;: [True, False]&#125; default_options = &quot;shared=False&quot; def source(self): self.run(&quot;git clone https://github.com/JoshuaBrookover/bgfx.cmake&quot;) copy_tree(&quot;bgfx.cmake&quot;, &quot;.&quot;) self.run(&quot;git reset --hard 018bbc4&quot;) self.run(&quot;git submodule update --init --recursive&quot;) def build(self): cmake = CMake(self) shared_options = &quot;-DBUILD_SHARED_LIBS=ON&quot; if self.options.shared else &quot;-DBUILD_SHARED_LIBS=OFF&quot; fixed_options = &quot;-DBGFX_BUILD_EXAMPLES=OFF&quot; tool_options = &quot;-DBGFX_BUILD_TOOLS=OFF&quot; if self.settings.os == &quot;Emscripten&quot; else &quot;&quot; opengl_version = &quot;-DBGFX_OPENGL_VERSION=33&quot; self.run(&quot;cmake %s %s %s %s %s&quot; % (cmake.command_line, shared_options, fixed_options, tool_options, opengl_version)) self.run(&quot;cmake --build . %s -j8&quot; % cmake.build_config) def collect_headers(self, include_folder): self.copy(&quot;*.h&quot; , dst=&quot;include&quot;, src=include_folder) self.copy(&quot;*.hpp&quot;, dst=&quot;include&quot;, src=include_folder) self.copy(&quot;*.inl&quot;, dst=&quot;include&quot;, src=include_folder) def package(self): self.collect_headers(&quot;bgfx/include&quot;) self.collect_headers(&quot;bimg/include&quot;) self.collect_headers(&quot;bx/include&quot; ) self.copy(&quot;*.a&quot; , dst=&quot;lib&quot;, keep_path=False) self.copy(&quot;*.so&quot; , dst=&quot;lib&quot;, keep_path=False) self.copy(&quot;*.lib&quot;, dst=&quot;lib&quot;, keep_path=False) self.copy(&quot;*.dll&quot;, dst=&quot;bin&quot;, keep_path=False) def package_info(self): self.cpp_info.libs = [&quot;bgfxd&quot;, &quot;bimgd&quot;, &quot;bxd&quot;] if self.settings.build_type == &quot;Debug&quot; else [&quot;bgfx&quot;, &quot;bimg&quot;, &quot;bx&quot;] self.cpp_info.libs.extend([&quot;astc-codec&quot;, &quot;astc&quot;, &quot;edtaa3&quot;, &quot;etc1&quot;, &quot;etc2&quot;, &quot;iqa&quot;, &quot;squish&quot;, &quot;nvtt&quot;, &quot;pvrtc&quot;]) if self.settings.os == &quot;Macos&quot;: self.cpp_info.exelinkflags = [&quot;-framework Cocoa&quot;, &quot;-framework QuartzCore&quot;, &quot;-framework OpenGL&quot;, &quot;-weak_framework Metal&quot;] if self.settings.os == &quot;Linux&quot;: self.cpp_info.libs.extend([&quot;GL&quot;, &quot;X11&quot;, &quot;pthread&quot;, &quot;dl&quot;]) 可以看到整个脚本分为若干个函数。其中，source函数，用于源代码拉取和准备，比如对源码进行一些修改；build函数，调用 CMake 进行构建；package函数，用于执行打包操作；package_info则用于输出构建相关的信息，比如需要链接包中的哪些库文件。 默认的，Conan 以lib、include、bin等文件夹标识头文件库文件目录，也可以在package_info函数中进行修改。此外，Conan 提供了一系列的驱动包装函数来执行各种第三方工具，以及定制版本号规则、设定依赖等等。具体可以通过查阅官方文档来进一步了解，本文仅作抛砖引玉的目的。 在构建完成后，Conan 会以 Settings 和 Options 的取值 Hash 后为软件包指定一个 package_id，因而不同的构建选项会对应到不同的 Id 上。最终拉取预编译包时就会以这个 Id 作为基准。因此，如果构建一个 Header-Only 的包，则可以去掉这些选项，这样在各个平台上都不需要额外构建即可使用了。 编写完 Receipe 后，就可以执行 Conan 来进行构建了。 1conan install bgfx/20220908.0127cc8x@will/stable --build=bgfx 构建完成后会自动执行test_package的内容进行测试。最后使用命令上传到我们的私仓： 1conan upload bgfx/20220908.0127cc8x@will/stable --all -r=my_local_server 然后，我们就能在 Artifactory 中看到我们提交的包了。 配合 CMake 实战上传完自己制作的包，接下来就可以将其作为依赖引入自己的项目之中了。 在这里，推荐使用 Conan 官方提供的CMake脚本将其引入项目中。 123456789101112131415161718192021222324252627282930313233343536373839404142cmake_minimum_required(VERSION 3.1)project(test CXX)######################################## conan package manager ######################################### Download automatically, you can also just copy the conan.cmake fileif(NOT EXISTS &quot;$&#123;CMAKE_BINARY_DIR&#125;/conan.cmake&quot;) message(STATUS &quot;Downloading conan.cmake from https://github.com/conan-io/cmake-conan&quot;) file(DOWNLOAD &quot;https://github.com/conan-io/cmake-conan/raw/v0.14/conan.cmake&quot; &quot;$&#123;CMAKE_BINARY_DIR&#125;/conan.cmake&quot;)endif()include($&#123;CMAKE_BINARY_DIR&#125;/conan.cmake)######################################## dependencies ########################################conan_cmake_run( REQUIRES bgfx/20220908.0127cc8x@will/stable BASIC_SETUP CMAKE_TARGETS BUILD missing)######################################## compiler flags ########################################set(CMAKE_CXX_STANDARD 11)if(MSVC) add_definitions(-D_WIN32_WINNT=0x0600 -D_GNU_SOURCE -D_CRT_SECURE_NO_WARNINGS) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; /utf-8&quot;) set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; /utf-8&quot;)else() set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -Wall -Wextra -Wno-implicit-fallthrough&quot;) set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -g -Wall -Wextra -Wno-implicit-fallthrough&quot;)endif()######################################## targets ########################################file(GLOB_RECURSE TEST_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/*.hpp $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)add_executable(test $&#123;TEST_SRC&#125;)target_include_directories(test PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)target_link_libraries(test CONAN_PKG::bgfx) 通过 conan_cmake_run 来直接指定依赖，这样就不需要写 conanfile.txt 并且会在 CMake 构建的时候自动把依赖安装上，集成到 CMake 中，非常的方便。 此外，由于使用了CMAKE_TARGETS模式，依赖的指定方法也变成了CONAN_PKG::bgfx的方式，这里可以根据需要自行调整。 总结可以说，Conan 为 C++ 的依赖管理提供了非常好的解决方案。支持私仓，使得我们有机会将它作为私有组件的依赖管理工具。跨平台的特性，使得我们有机会配合 CMake 将环境配置、编译构建一条龙化。对于 C++ 的生态，这也是一件非常有益的事情。","raw":"---\ntitle: CPP-包管理器CONAN上手指南\ntoc: true\ndate: 2022-09-08 19:07:05\ntags: [C++,Conan]\ncategories: [技术]\ndescription:\n---\n最近接了一个C++写的项目，好久没用过C++了，从头学习整理下C++相关的内容\n<!-- more -->\n\n## C++包管理\nC/C++ 项目如果要依赖第三方库，往往有 N 种姿势来完成这个事情：\n1. 直接在源码中包裹第三方库的头文件和二进制\n2. 把第三方库的源码带入工程中随项目一起编译\n3. 依赖系统中安装的组件，而后使用 pkg_config 或 CMake 的 find 系函数来查找依赖\n\n其中\n方案1，不具备可移植性，但依赖非开源组件且无软件包可用时往往只能用这种方法；\n方案2，普适性比较强，可以针对源码做定制，但是大大增加了源码的大小和构建的耗时；\n方案3，Windows 下往往不可用，并且需要用户手动准备环境，每次搭建新环境时比较繁琐。\n\n可以看到，光依赖管理就没有一个比较标准的解决方案，并且这些方法各自也都有很大缺陷。这进一步导致社区的撕裂，其结果就是即便是可移植的开源库，如果你想在项目中引用它，也得看看要用什么方法来引入才能对接到你的 Build System 中。\n\n而在其他的流行语言中，包管理器可以说是一个很常态很普遍的东西了，比如 Python 的 pip，JS 的 npm，C# 的 nuget 等等。\n\n至于为何会这样，也有一个很大的原因是 C/C++ 本身的定位和历史原因。它能 Target 到众多的平台上，从 X86、X64 到 Arm，从 Windows、Linux 到 MacOS 甚至于嵌入式的系统中。每个平台的特点都不尽相同，甚至于相同平台使用不同编译器构建后能产生不同的 ABI（application binary interface）。这使得包管理器的设计远比无需编译的 Python、JS 一流复杂很多。\n\n当然我们也看到像微软在这方面做了尝试，弄出了 vcpkg，笔者没有用过，听说是更贴近 apt 的作用，用来安装全局的依赖。\n\n## Conan\nConan 是一个开源的、跨平台的、去中心化的 C++ 包管理器。通过它可以安装、解决构建依赖，更重要的是可以直接集成到 Build System 中使用。同时它也允许你搭建自己的私有仓库，供私有项目使用。具体到细节，当向 Conan 请求安装依赖时，Conan 会拿着编译相关的配置信息去服务器请求是否有对应平台的预构建二进制包，如果有，则直接下载并解压到本地的缓存仓库中，否则，会执行对应的构建脚本，构建出符合当前平台的二进制包。这种方式并无特别之处，但是是可以解决 C++ 平台众多的问题的有效方法。\n![Conan](http://cdn.yuleweici.com/CPP-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/conan-1.png)\n\n### 安装\nConan 基于 Python 编写，故需要在开始前安装好 Python3。然后使用标准的 pip 安装即可。\n```shell\npip install conan\n```\n\n需要注意的是，Linux 下需要用 sudo 安装全局的 pip 包。而 OSX 下也可以使用 brew 来安装 Conan。\n\n### 配置\nConan 会在第一次启动时自动配置好默认的 Profile 和 Remote 设置。它的配置以及本地的二进制仓库均存储在用户目录下~/.conan/中（Windows上，是%USERPROFILE%\\.conan\\）。\n\n其中用户配置文件为conan.conf，通常情况下无需修改，但当需要设置代理时，可以对其进行编辑。\n```shell\n[proxies]\nhttp = http://dev-proxy.oa.com:8080\nhttps = http://dev-proxy.oa.com:8080\n```\n\n另外，当使用 Artifactory 来搭建私有仓库时，需要启用 general.revisions_enabled = 1这个开关。笔者会在下文介绍如何搭建私有仓库，这里不予展开。\n\n而 Profile 则存储在profiles文件夹中，用于设定各种编译环境和选项。默认会创建一个名为 default 的 Profile 供使用。\n\n## Conan基本概念\n### 软件包\nConan 使用这样的格式来描述一个软件包：名称/版本@用户/渠道。其中渠道（Channel）用来描述是稳定版（Stable）还是测试版（Testing）等信息，以 boost 为例，我们可以看到这样的包名：\n```shell\nboost/1.64.0@conan/stable\nboost/1.65.1@conan/stable\nboost/1.66.0@conan/stable\nboost/1.67.0@conan/stable\nboost/1.68.0@conan/stable\nboost/1.69.0@conan/stable\nboost/1.70.0@conan/stable\n```\n\n### 软件包仓库\nNodeJS 的包管理器 npm 会把依赖存储到工程目录的node_modules文件夹中，此外也能安装全局的包。Python 的包管理器 pip 能把包装到用户目录下或者是全局环境中，所以一般配合 venv 使之把包装在工程中不污染环境。\n\n相比之下，可能是出于 C++ 的库通常需要依据环境编译，并且大小比较大的考量，默认情况下 Conan 只把包装在用户目录下。一般来说，在开发环境中这点已经足够使用了。但是在配合 CI/CD 的时候，这里就有可能出现竞争。为此，Conan 提供了一个环境变量CONAN_USER_HOME来让用户指定一个 Conan 的工作目录，这样就能起到类似于 Python 的 Virtual Environment 的作用。\n\n上文中，用户目录的软件包仓库被称为本地缓存（Local Cache）；那么同样的，服务器上也有一个软件包的仓库，文档中称为远端（Remote）。\n\nConan 提供了几个官方和社区的远端供选择，默认的，安装后会自动配置 Conan Center 这个源：\n\n1. conan-center: https://bintray.com/conan/conan-center\n2. conan-transit（废弃）: https://bintray.com/conan/conan-transit\n3. bincrafters（开源社区源） : https://bintray.com/bincrafters/public-conan\n4. conan-community（类似测试源，不稳定） : https://bintray.com/conan-community/conan\n\n### 编译环境\n通常情况下默认的 Profile 就够用了，故本文不赘述配置 Profile 的过程，如有时间会在未来进行补充。\n\n需要注意的是使用 GCC 作编译器时需要手动开启对 C++11 的 ABI 的支持，否则默认位于兼容模式下，将使用老的 ABI。\n```shell\nconan profile new default --detect  # Generates default profile detecting GCC and sets old ABI\nconan profile update settings.compiler.libcxx=libstdc++11 default  # Sets libcxx to C++11 ABI\n```\n\n## Conan基本操作\n### 搜索软件包\n```shell\nconan search boost* -r=conan-center\n```\n使用上述命令在默认的中心仓库中搜索 boost 软件包。在不指定-r的情况下，默认搜索本地缓存。\n\n### 管理远端\n```\n# 添加源\nconan remote add my-repo http://my-repo.com/xxx\n\n# 或者使用insert来将其作为首个源\nconan remote update my-repo http://my-repo.com/xxx --insert=0\n\n# 展示所有源\nconan remote list\n\n# 删除一个源\nconan remote remove my-repo\n```\n\nConan 的远端是个列表，并有先后顺序，默认在安装软件包的时候会先检查本地缓存，然后依次从软件源中获取软件包。\n\n因此常用源应当使用insert参数使之排到前面。\n\n### 安装依赖与构建\n类似于 CMake，Conan 使用一个叫做conanfile.txt的文件来描述工程依赖和导出相关的文件（更进阶的，可以使用conanfile.py来精确控制这个过程）。\n\n以配合 CMake 使用为例，conanfile.txt需要这样编写（官方用例）：\n```shell\n[requires]\nPoco/1.7.8p3@pocoproject/stable\n\n[generators]\ncmake\n```\n\n这里要提一点，如果有包 A 依赖包 C 的 1.0 版本，包 B 依赖包 C 的 1.2 版本，此时就会出现冲突。通过手动在 Requires 中写入C/1.2@xxx/yyy这样的依赖可以强制提升 C 的版本号为最新，从而解决冲突的问题。\n\n这个 CMake 的 Generator 会在安装依赖后产生一个conanbuildinfo.cmake供 CMake 使用来查找依赖。\n\n那么工程对应的cmakefile.txt会这样编写：\n```shell\nproject(FoundationTimer)\ncmake_minimum_required(VERSION 2.8.12)\nadd_definitions(\"-std=c++11\")\n\ninclude(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\nconan_basic_setup()\n\nadd_executable(timer timer.cpp)\ntarget_link_libraries(timer ${CONAN_LIBS})\n```\n其中${CONAN_LIBS}就直接标明了所有的第三方依赖，直接链接（Link）上去就大功告成了。\n\n整个安装依赖和构建的具体命令如下：\n```shell\n# 假设位于工程目录下\nmkdir build  # out of source build\ncd build\nconan install ..  # 安装依赖和创建cmake导出文件，使用 --profile=xxx 来指定不同的构建环境\ncmake ..\ncmake --build . --config Release\n```\n\n## Conan进阶\nConan 确实极大的简化了依赖安装的过程，但是具体使用过程中也能发现 Conan 目前的弱点：\n\n1. 国内访问中心仓库的速度极慢\n2. 可选的软件包少，只涵盖知名度高的和常用的软件包\n对于这两个缺陷，本文将通过自建软件源和自己编写软件包来解决。\n\n### 自建仓库\nConan 官方提供了一个迷你的服务端来提供仓库的功能，同时也推荐使用Artifactory Community Edition for C/C++来自建仓库。当然，如果是为了开源项目，可以直接在 Bintray 上申请一个开源项目账号来上传自制软件包而无需自建仓库（但是实在是太慢了）。\n\n本文使用 Artifactory 来自建仓库，因为功能相对完善。Artifactory 支持配置用户和组以及对应的权限，商业版本还支持高可用和分布式。\n\n#### 安装\n为了简单起见，本文采取 Docker 镜像的方式安装 Artifactory：\n```shell\nsudo docker pull docker.bintray.io/jfrog/artifactory-cpp-ce\n```\n以官方文档为例，使用下述命令即可创建容器：\n```shell\nsudo docker run -d --restart=always --name artifactory -v /data/artifactory:/var/opt/jfrog/artifactory -p 8081:8081 -e EXTRA_JAVA_OPTIONS='-Xms512m -Xmx2g -Xss256k -XX:+UseG1GC' docker.bintray.io/jfrog/artifactory-pro:latest\n```\n上述命令会暴露在本机的8081端口上，同时挂载数据目录到/data/artifactory目录下。\n\n注意到，Artifactory 默认会以 UserID 1030 运行服务，一定要注意宿主机的数据目录的权限是否满足要求，如果启动时出现 Permission Denied 错误，记得修改目录权限：\n```shell\nsudo chown 1030:1030 /data/artifactory\nsudo chmod 0755 /data/artifactory\n```\n你也可以使用--user 1234:4321的方式来指定 Docker 使用哪个用户/组权限来执行容器。\n\n#### 配置\n首次访问http://localhost:8081即可打开配置向导。默认的，配置好 Admin 账户的密码，初始化默认的 Conan 仓库配置即可。向导会提示你创建一个 HTTP Proxy，如果网络够好或者只作私仓使用则可以忽略该配置，否则，建议创建一个代理设置来加速访问 Remote 仓库。\n\nArtifactory 提供了三种类型的 Conan 仓库供不同目的使用：\n\n- 本地仓库（Local）：即当前 Artifactory 服务器上存储软件包的仓库；\n- 远端仓库（Remote）：即第三方的软件仓库，在本服务器上作为 Proxy 和 Cache 运作；\n- 虚拟仓库（Virtual）：作为一个索引中心，能将其他两类仓库整合到一个仓库名下，方便使用。\n初始化之后，Artifactory 会创建好一个本地仓库，一个到 Conan Center 的远程仓库和包含上述两个仓库的虚拟仓库。\n\n需要注意的是，默认配置下 Artifactory 是允许匿名访问的，必须在 Admin > Security Configuration 页面中关闭匿名访问才能真正作为私仓使用。\n\n#### 添加到 Conan\n在仓库管理页面，点击虚拟仓库 Conan，在右上角点击 Set Me Up 按钮即可显示当前仓库如何在 Conan 中配置并作为一个源。\n\n![Conan](http://cdn.yuleweici.com/CPP-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/conan-2.png)\n\n照着上面写的步骤，即可把自建源加入到 Conan 中：\n```shell\nconan remote add <REMOTE> http://localhost:8081/artifactory/api/conan/conan\n```\n在使用之前，还需要修改你的conan.conf，开启revisions_enabled功能才能正常使用私仓。这是因为 Artifactory 并不支持 Conan v1 的协议，必须开启这一功能使用 v2 协议才能正常使用。\n\n如果你配置了 Remote 仓库，则此时，你可以通过自己的私仓来访问到官方源，同时还可以配置上社区源来同时进行访问（然而社区源使用 v1 协议，导致并不能直接下载其上的包，这种情况下可以先下载社区源的包到本地，再上传到你的私仓上）。尤其在安装过官方仓库的软件包后，Artifactory 会将其缓存到本地，之后就会作为本地的 Cache 加速访问。\n\n更多的配置可以参看官方文档，本文不再赘述。\n### 自建软件包\n因为很多第三方开源项目没有 Conan 官方的支持，使用这些项目的时候就需要自己来编写 Receipe 来告诉 Conan 如何编译、打包第三方库了。\n\n![Conan](http://cdn.yuleweici.com/CPP-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/conan-3.png)\n\n这里以bgfx为例来构造一个 Conan 的二进制包，并提交到我们自建的私仓中。\n\n因为bgfx官方构建方式比较复杂，笔者选取了其 CMake 版本来执行构建。此外 Github 上已经有用户创建过对应的构建脚本了，因此这里可以直接参考别人的写法来进行构建。\n\n使用conan new Hello/0.1 -t可以创建一个 HelloWorld 的空白 Receipe。可以看到呈现出这样的目录结构：\n```shell\nconanfile.py\ntest_package\n  CMakeLists.txt\n  conanfile.py\n  example.cpp\n```\n其中conanfile.py用来描述构建软件包的编译打包过程，test_package存储一个测试用的样例，用来检查是否成功构建了软件包并且是否能正常使用。\n\n以构建bgfx的脚本为例，修改conanfile.py：\n```python\nfrom conans import ConanFile, CMake\nfrom distutils.dir_util import copy_tree\n\nclass BgfxConan(ConanFile):\n    name            = \"bgfx\"\n    version         = \"20220908.0127cc8x\"  # 这个地方我乱填的，请遵照SemVer的规范制定版本号\n    description     = \"Conan package for bgfx.\"\n    url             = \"https://github.com/vwin/xxx\"\n    license         = \"BSD\"\n    settings        = \"arch\", \"build_type\", \"compiler\", \"os\"  # 这些选项会被作为包的标识，区分不同的ABI\n    generators      = \"cmake\"\n    options         = {\"shared\": [True, False]}\n    default_options = \"shared=False\"\n\n    def source(self):\n        self.run(\"git clone https://github.com/JoshuaBrookover/bgfx.cmake\")\n        copy_tree(\"bgfx.cmake\", \".\")\n        self.run(\"git reset --hard 018bbc4\")\n        self.run(\"git submodule update --init --recursive\")\n\n    def build(self):\n        cmake          = CMake(self)\n        shared_options = \"-DBUILD_SHARED_LIBS=ON\" if self.options.shared else \"-DBUILD_SHARED_LIBS=OFF\"\n        fixed_options  = \"-DBGFX_BUILD_EXAMPLES=OFF\"\n        tool_options   = \"-DBGFX_BUILD_TOOLS=OFF\" if self.settings.os == \"Emscripten\" else \"\"\n        opengl_version = \"-DBGFX_OPENGL_VERSION=33\"\n        self.run(\"cmake %s %s %s %s %s\" % (cmake.command_line, shared_options, fixed_options, tool_options, opengl_version))\n        self.run(\"cmake --build . %s -j8\" % cmake.build_config)\n\n    def collect_headers(self, include_folder):\n        self.copy(\"*.h\"  , dst=\"include\", src=include_folder)\n        self.copy(\"*.hpp\", dst=\"include\", src=include_folder)\n        self.copy(\"*.inl\", dst=\"include\", src=include_folder)\n\n    def package(self):\n        self.collect_headers(\"bgfx/include\")\n        self.collect_headers(\"bimg/include\")\n        self.collect_headers(\"bx/include\"  )\n        self.copy(\"*.a\"  , dst=\"lib\", keep_path=False)\n        self.copy(\"*.so\" , dst=\"lib\", keep_path=False)\n        self.copy(\"*.lib\", dst=\"lib\", keep_path=False)\n        self.copy(\"*.dll\", dst=\"bin\", keep_path=False)\n\n    def package_info(self):\n        self.cpp_info.libs = [\"bgfxd\", \"bimgd\", \"bxd\"] if self.settings.build_type == \"Debug\" else [\"bgfx\", \"bimg\", \"bx\"]\n        self.cpp_info.libs.extend([\"astc-codec\", \"astc\", \"edtaa3\", \"etc1\", \"etc2\", \"iqa\", \"squish\", \"nvtt\", \"pvrtc\"])\n        if self.settings.os == \"Macos\":\n            self.cpp_info.exelinkflags = [\"-framework Cocoa\", \"-framework QuartzCore\", \"-framework OpenGL\", \"-weak_framework Metal\"]\n        if self.settings.os == \"Linux\":\n            self.cpp_info.libs.extend([\"GL\", \"X11\", \"pthread\", \"dl\"])\n```\n\n可以看到整个脚本分为若干个函数。其中，source函数，用于源代码拉取和准备，比如对源码进行一些修改；build函数，调用 CMake 进行构建；package函数，用于执行打包操作；package_info则用于输出构建相关的信息，比如需要链接包中的哪些库文件。\n\n默认的，Conan 以lib、include、bin等文件夹标识头文件库文件目录，也可以在package_info函数中进行修改。此外，Conan 提供了一系列的驱动包装函数来执行各种第三方工具，以及定制版本号规则、设定依赖等等。具体可以通过查阅官方文档来进一步了解，本文仅作抛砖引玉的目的。\n\n在构建完成后，Conan 会以 Settings 和 Options 的取值 Hash 后为软件包指定一个 package_id，因而不同的构建选项会对应到不同的 Id 上。最终拉取预编译包时就会以这个 Id 作为基准。因此，如果构建一个 Header-Only 的包，则可以去掉这些选项，这样在各个平台上都不需要额外构建即可使用了。\n\n编写完 Receipe 后，就可以执行 Conan 来进行构建了。\n\n```shell\nconan install bgfx/20220908.0127cc8x@will/stable --build=bgfx\n```\n\n构建完成后会自动执行test_package的内容进行测试。最后使用命令上传到我们的私仓：\n\n\n```shell\nconan upload bgfx/20220908.0127cc8x@will/stable --all -r=my_local_server\n```\n\n然后，我们就能在 Artifactory 中看到我们提交的包了。\n\n### 配合 CMake 实战\n上传完自己制作的包，接下来就可以将其作为依赖引入自己的项目之中了。\n\n在这里，推荐使用 Conan 官方提供的[CMake](https://github.com/conan-io/cmake-conan)脚本将其引入项目中。\n\n```C\ncmake_minimum_required(VERSION 3.1)\nproject(test CXX)\n\n######################################## conan package manager ########################################\n\n# Download automatically, you can also just copy the conan.cmake file\nif(NOT EXISTS \"${CMAKE_BINARY_DIR}/conan.cmake\")\n    message(STATUS \"Downloading conan.cmake from https://github.com/conan-io/cmake-conan\")\n    file(DOWNLOAD \"https://github.com/conan-io/cmake-conan/raw/v0.14/conan.cmake\"\n        \"${CMAKE_BINARY_DIR}/conan.cmake\")\nendif()\n\ninclude(${CMAKE_BINARY_DIR}/conan.cmake)\n\n######################################## dependencies ########################################\n\nconan_cmake_run(\n    REQUIRES\n        bgfx/20220908.0127cc8x@will/stable\n    BASIC_SETUP CMAKE_TARGETS\n    BUILD missing)\n\n######################################## compiler flags ########################################\n\nset(CMAKE_CXX_STANDARD 11)\n\nif(MSVC)\n    add_definitions(-D_WIN32_WINNT=0x0600 -D_GNU_SOURCE -D_CRT_SECURE_NO_WARNINGS)\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /utf-8\")\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /utf-8\")\nelse()\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g -Wall -Wextra -Wno-implicit-fallthrough\")\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -g -Wall -Wextra -Wno-implicit-fallthrough\")\nendif()\n\n######################################## targets ########################################\n\nfile(GLOB_RECURSE TEST_SRC ${CMAKE_CURRENT_SOURCE_DIR}/include/*.hpp ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)\n\nadd_executable(test ${TEST_SRC})\ntarget_include_directories(test PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include)\ntarget_link_libraries(test CONAN_PKG::bgfx)\n```\n\n通过 conan_cmake_run 来直接指定依赖，这样就不需要写 conanfile.txt 并且会在 CMake 构建的时候自动把依赖安装上，集成到 CMake 中，非常的方便。\n\n此外，由于使用了CMAKE_TARGETS模式，依赖的指定方法也变成了CONAN_PKG::bgfx的方式，这里可以根据需要自行调整。\n\n\n## 总结\n可以说，Conan 为 C++ 的依赖管理提供了非常好的解决方案。支持私仓，使得我们有机会将它作为私有组件的依赖管理工具。跨平台的特性，使得我们有机会配合 CMake 将环境配置、编译构建一条龙化。对于 C++ 的生态，这也是一件非常有益的事情。\n\n\n","content":"<p>最近接了一个C++写的项目，好久没用过C++了，从头学习整理下C++相关的内容</p>\n<span id=\"more\"></span>\n\n<h2 id=\"C-包管理\"><a href=\"#C-包管理\" class=\"headerlink\" title=\"C++包管理\"></a>C++包管理</h2><p>C&#x2F;C++ 项目如果要依赖第三方库，往往有 N 种姿势来完成这个事情：</p>\n<ol>\n<li>直接在源码中包裹第三方库的头文件和二进制</li>\n<li>把第三方库的源码带入工程中随项目一起编译</li>\n<li>依赖系统中安装的组件，而后使用 pkg_config 或 CMake 的 find 系函数来查找依赖</li>\n</ol>\n<p>其中<br>方案1，不具备可移植性，但依赖非开源组件且无软件包可用时往往只能用这种方法；<br>方案2，普适性比较强，可以针对源码做定制，但是大大增加了源码的大小和构建的耗时；<br>方案3，Windows 下往往不可用，并且需要用户手动准备环境，每次搭建新环境时比较繁琐。</p>\n<p>可以看到，光依赖管理就没有一个比较标准的解决方案，并且这些方法各自也都有很大缺陷。这进一步导致社区的撕裂，其结果就是即便是可移植的开源库，如果你想在项目中引用它，也得看看要用什么方法来引入才能对接到你的 Build System 中。</p>\n<p>而在其他的流行语言中，包管理器可以说是一个很常态很普遍的东西了，比如 Python 的 pip，JS 的 npm，C# 的 nuget 等等。</p>\n<p>至于为何会这样，也有一个很大的原因是 C&#x2F;C++ 本身的定位和历史原因。它能 Target 到众多的平台上，从 X86、X64 到 Arm，从 Windows、Linux 到 MacOS 甚至于嵌入式的系统中。每个平台的特点都不尽相同，甚至于相同平台使用不同编译器构建后能产生不同的 ABI（application binary interface）。这使得包管理器的设计远比无需编译的 Python、JS 一流复杂很多。</p>\n<p>当然我们也看到像微软在这方面做了尝试，弄出了 vcpkg，笔者没有用过，听说是更贴近 apt 的作用，用来安装全局的依赖。</p>\n<h2 id=\"Conan\"><a href=\"#Conan\" class=\"headerlink\" title=\"Conan\"></a>Conan</h2><p>Conan 是一个开源的、跨平台的、去中心化的 C++ 包管理器。通过它可以安装、解决构建依赖，更重要的是可以直接集成到 Build System 中使用。同时它也允许你搭建自己的私有仓库，供私有项目使用。具体到细节，当向 Conan 请求安装依赖时，Conan 会拿着编译相关的配置信息去服务器请求是否有对应平台的预构建二进制包，如果有，则直接下载并解压到本地的缓存仓库中，否则，会执行对应的构建脚本，构建出符合当前平台的二进制包。这种方式并无特别之处，但是是可以解决 C++ 平台众多的问题的有效方法。<br><img src=\"http://cdn.yuleweici.com/CPP-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/conan-1.png\" alt=\"Conan\"></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>Conan 基于 Python 编写，故需要在开始前安装好 Python3。然后使用标准的 pip 安装即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install conan</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，Linux 下需要用 sudo 安装全局的 pip 包。而 OSX 下也可以使用 brew 来安装 Conan。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>Conan 会在第一次启动时自动配置好默认的 Profile 和 Remote 设置。它的配置以及本地的二进制仓库均存储在用户目录下~&#x2F;.conan&#x2F;中（Windows上，是%USERPROFILE%.conan\\）。</p>\n<p>其中用户配置文件为conan.conf，通常情况下无需修改，但当需要设置代理时，可以对其进行编辑。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[proxies]</span><br><span class=\"line\">http = http://dev-proxy.oa.com:8080</span><br><span class=\"line\">https = http://dev-proxy.oa.com:8080</span><br></pre></td></tr></table></figure>\n\n<p>另外，当使用 Artifactory 来搭建私有仓库时，需要启用 general.revisions_enabled &#x3D; 1这个开关。笔者会在下文介绍如何搭建私有仓库，这里不予展开。</p>\n<p>而 Profile 则存储在profiles文件夹中，用于设定各种编译环境和选项。默认会创建一个名为 default 的 Profile 供使用。</p>\n<h2 id=\"Conan基本概念\"><a href=\"#Conan基本概念\" class=\"headerlink\" title=\"Conan基本概念\"></a>Conan基本概念</h2><h3 id=\"软件包\"><a href=\"#软件包\" class=\"headerlink\" title=\"软件包\"></a>软件包</h3><p>Conan 使用这样的格式来描述一个软件包：名称&#x2F;版本@用户&#x2F;渠道。其中渠道（Channel）用来描述是稳定版（Stable）还是测试版（Testing）等信息，以 boost 为例，我们可以看到这样的包名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boost/1.64.0@conan/stable</span><br><span class=\"line\">boost/1.65.1@conan/stable</span><br><span class=\"line\">boost/1.66.0@conan/stable</span><br><span class=\"line\">boost/1.67.0@conan/stable</span><br><span class=\"line\">boost/1.68.0@conan/stable</span><br><span class=\"line\">boost/1.69.0@conan/stable</span><br><span class=\"line\">boost/1.70.0@conan/stable</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"软件包仓库\"><a href=\"#软件包仓库\" class=\"headerlink\" title=\"软件包仓库\"></a>软件包仓库</h3><p>NodeJS 的包管理器 npm 会把依赖存储到工程目录的node_modules文件夹中，此外也能安装全局的包。Python 的包管理器 pip 能把包装到用户目录下或者是全局环境中，所以一般配合 venv 使之把包装在工程中不污染环境。</p>\n<p>相比之下，可能是出于 C++ 的库通常需要依据环境编译，并且大小比较大的考量，默认情况下 Conan 只把包装在用户目录下。一般来说，在开发环境中这点已经足够使用了。但是在配合 CI&#x2F;CD 的时候，这里就有可能出现竞争。为此，Conan 提供了一个环境变量CONAN_USER_HOME来让用户指定一个 Conan 的工作目录，这样就能起到类似于 Python 的 Virtual Environment 的作用。</p>\n<p>上文中，用户目录的软件包仓库被称为本地缓存（Local Cache）；那么同样的，服务器上也有一个软件包的仓库，文档中称为远端（Remote）。</p>\n<p>Conan 提供了几个官方和社区的远端供选择，默认的，安装后会自动配置 Conan Center 这个源：</p>\n<ol>\n<li>conan-center: <a href=\"https://bintray.com/conan/conan-center\">https://bintray.com/conan/conan-center</a></li>\n<li>conan-transit（废弃）: <a href=\"https://bintray.com/conan/conan-transit\">https://bintray.com/conan/conan-transit</a></li>\n<li>bincrafters（开源社区源） : <a href=\"https://bintray.com/bincrafters/public-conan\">https://bintray.com/bincrafters/public-conan</a></li>\n<li>conan-community（类似测试源，不稳定） : <a href=\"https://bintray.com/conan-community/conan\">https://bintray.com/conan-community/conan</a></li>\n</ol>\n<h3 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h3><p>通常情况下默认的 Profile 就够用了，故本文不赘述配置 Profile 的过程，如有时间会在未来进行补充。</p>\n<p>需要注意的是使用 GCC 作编译器时需要手动开启对 C++11 的 ABI 的支持，否则默认位于兼容模式下，将使用老的 ABI。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conan profile new default --detect  # Generates default profile detecting GCC and sets old ABI</span><br><span class=\"line\">conan profile update settings.compiler.libcxx=libstdc++11 default  # Sets libcxx to C++11 ABI</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Conan基本操作\"><a href=\"#Conan基本操作\" class=\"headerlink\" title=\"Conan基本操作\"></a>Conan基本操作</h2><h3 id=\"搜索软件包\"><a href=\"#搜索软件包\" class=\"headerlink\" title=\"搜索软件包\"></a>搜索软件包</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conan search boost* -r=conan-center</span><br></pre></td></tr></table></figure>\n<p>使用上述命令在默认的中心仓库中搜索 boost 软件包。在不指定-r的情况下，默认搜索本地缓存。</p>\n<h3 id=\"管理远端\"><a href=\"#管理远端\" class=\"headerlink\" title=\"管理远端\"></a>管理远端</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加源</span><br><span class=\"line\">conan remote add my-repo http://my-repo.com/xxx</span><br><span class=\"line\"></span><br><span class=\"line\"># 或者使用insert来将其作为首个源</span><br><span class=\"line\">conan remote update my-repo http://my-repo.com/xxx --insert=0</span><br><span class=\"line\"></span><br><span class=\"line\"># 展示所有源</span><br><span class=\"line\">conan remote list</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除一个源</span><br><span class=\"line\">conan remote remove my-repo</span><br></pre></td></tr></table></figure>\n\n<p>Conan 的远端是个列表，并有先后顺序，默认在安装软件包的时候会先检查本地缓存，然后依次从软件源中获取软件包。</p>\n<p>因此常用源应当使用insert参数使之排到前面。</p>\n<h3 id=\"安装依赖与构建\"><a href=\"#安装依赖与构建\" class=\"headerlink\" title=\"安装依赖与构建\"></a>安装依赖与构建</h3><p>类似于 CMake，Conan 使用一个叫做conanfile.txt的文件来描述工程依赖和导出相关的文件（更进阶的，可以使用conanfile.py来精确控制这个过程）。</p>\n<p>以配合 CMake 使用为例，conanfile.txt需要这样编写（官方用例）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[requires]</span><br><span class=\"line\">Poco/1.7.8p3@pocoproject/stable</span><br><span class=\"line\"></span><br><span class=\"line\">[generators]</span><br><span class=\"line\">cmake</span><br></pre></td></tr></table></figure>\n\n<p>这里要提一点，如果有包 A 依赖包 C 的 1.0 版本，包 B 依赖包 C 的 1.2 版本，此时就会出现冲突。通过手动在 Requires 中写入C&#x2F;1.2@xxx&#x2F;yyy这样的依赖可以强制提升 C 的版本号为最新，从而解决冲突的问题。</p>\n<p>这个 CMake 的 Generator 会在安装依赖后产生一个conanbuildinfo.cmake供 CMake 使用来查找依赖。</p>\n<p>那么工程对应的cmakefile.txt会这样编写：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project(FoundationTimer)</span><br><span class=\"line\">cmake_minimum_required(VERSION 2.8.12)</span><br><span class=\"line\">add_definitions(&quot;-std=c++11&quot;)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">include($</span><span class=\"language-bash\">&#123;CMAKE_BINARY_DIR&#125;/conanbuildinfo.cmake)</span></span><br><span class=\"line\">conan_basic_setup()</span><br><span class=\"line\"></span><br><span class=\"line\">add_executable(timer timer.cpp)</span><br><span class=\"line\">target_link_libraries(timer $&#123;CONAN_LIBS&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中${CONAN_LIBS}就直接标明了所有的第三方依赖，直接链接（Link）上去就大功告成了。</p>\n<p>整个安装依赖和构建的具体命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">假设位于工程目录下</span></span><br><span class=\"line\">mkdir build  # out of source build</span><br><span class=\"line\">cd build</span><br><span class=\"line\">conan install ..  # 安装依赖和创建cmake导出文件，使用 --profile=xxx 来指定不同的构建环境</span><br><span class=\"line\">cmake ..</span><br><span class=\"line\">cmake --build . --config Release</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Conan进阶\"><a href=\"#Conan进阶\" class=\"headerlink\" title=\"Conan进阶\"></a>Conan进阶</h2><p>Conan 确实极大的简化了依赖安装的过程，但是具体使用过程中也能发现 Conan 目前的弱点：</p>\n<ol>\n<li>国内访问中心仓库的速度极慢</li>\n<li>可选的软件包少，只涵盖知名度高的和常用的软件包<br>对于这两个缺陷，本文将通过自建软件源和自己编写软件包来解决。</li>\n</ol>\n<h3 id=\"自建仓库\"><a href=\"#自建仓库\" class=\"headerlink\" title=\"自建仓库\"></a>自建仓库</h3><p>Conan 官方提供了一个迷你的服务端来提供仓库的功能，同时也推荐使用Artifactory Community Edition for C&#x2F;C++来自建仓库。当然，如果是为了开源项目，可以直接在 Bintray 上申请一个开源项目账号来上传自制软件包而无需自建仓库（但是实在是太慢了）。</p>\n<p>本文使用 Artifactory 来自建仓库，因为功能相对完善。Artifactory 支持配置用户和组以及对应的权限，商业版本还支持高可用和分布式。</p>\n<h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>为了简单起见，本文采取 Docker 镜像的方式安装 Artifactory：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull docker.bintray.io/jfrog/artifactory-cpp-ce</span><br></pre></td></tr></table></figure>\n<p>以官方文档为例，使用下述命令即可创建容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -d --restart=always --name artifactory -v /data/artifactory:/var/opt/jfrog/artifactory -p 8081:8081 -e EXTRA_JAVA_OPTIONS=&#x27;-Xms512m -Xmx2g -Xss256k -XX:+UseG1GC&#x27; docker.bintray.io/jfrog/artifactory-pro:latest</span><br></pre></td></tr></table></figure>\n<p>上述命令会暴露在本机的8081端口上，同时挂载数据目录到&#x2F;data&#x2F;artifactory目录下。</p>\n<p>注意到，Artifactory 默认会以 UserID 1030 运行服务，一定要注意宿主机的数据目录的权限是否满足要求，如果启动时出现 Permission Denied 错误，记得修改目录权限：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown 1030:1030 /data/artifactory</span><br><span class=\"line\">sudo chmod 0755 /data/artifactory</span><br></pre></td></tr></table></figure>\n<p>你也可以使用–user 1234:4321的方式来指定 Docker 使用哪个用户&#x2F;组权限来执行容器。</p>\n<h4 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>首次访问<a href=\"http://localhost:8081即可打开配置向导。默认的，配置好\">http://localhost:8081即可打开配置向导。默认的，配置好</a> Admin 账户的密码，初始化默认的 Conan 仓库配置即可。向导会提示你创建一个 HTTP Proxy，如果网络够好或者只作私仓使用则可以忽略该配置，否则，建议创建一个代理设置来加速访问 Remote 仓库。</p>\n<p>Artifactory 提供了三种类型的 Conan 仓库供不同目的使用：</p>\n<ul>\n<li>本地仓库（Local）：即当前 Artifactory 服务器上存储软件包的仓库；</li>\n<li>远端仓库（Remote）：即第三方的软件仓库，在本服务器上作为 Proxy 和 Cache 运作；</li>\n<li>虚拟仓库（Virtual）：作为一个索引中心，能将其他两类仓库整合到一个仓库名下，方便使用。<br>初始化之后，Artifactory 会创建好一个本地仓库，一个到 Conan Center 的远程仓库和包含上述两个仓库的虚拟仓库。</li>\n</ul>\n<p>需要注意的是，默认配置下 Artifactory 是允许匿名访问的，必须在 Admin &gt; Security Configuration 页面中关闭匿名访问才能真正作为私仓使用。</p>\n<h4 id=\"添加到-Conan\"><a href=\"#添加到-Conan\" class=\"headerlink\" title=\"添加到 Conan\"></a>添加到 Conan</h4><p>在仓库管理页面，点击虚拟仓库 Conan，在右上角点击 Set Me Up 按钮即可显示当前仓库如何在 Conan 中配置并作为一个源。</p>\n<p><img src=\"http://cdn.yuleweici.com/CPP-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/conan-2.png\" alt=\"Conan\"></p>\n<p>照着上面写的步骤，即可把自建源加入到 Conan 中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conan remote add &lt;REMOTE&gt; http://localhost:8081/artifactory/api/conan/conan</span><br></pre></td></tr></table></figure>\n<p>在使用之前，还需要修改你的conan.conf，开启revisions_enabled功能才能正常使用私仓。这是因为 Artifactory 并不支持 Conan v1 的协议，必须开启这一功能使用 v2 协议才能正常使用。</p>\n<p>如果你配置了 Remote 仓库，则此时，你可以通过自己的私仓来访问到官方源，同时还可以配置上社区源来同时进行访问（然而社区源使用 v1 协议，导致并不能直接下载其上的包，这种情况下可以先下载社区源的包到本地，再上传到你的私仓上）。尤其在安装过官方仓库的软件包后，Artifactory 会将其缓存到本地，之后就会作为本地的 Cache 加速访问。</p>\n<p>更多的配置可以参看官方文档，本文不再赘述。</p>\n<h3 id=\"自建软件包\"><a href=\"#自建软件包\" class=\"headerlink\" title=\"自建软件包\"></a>自建软件包</h3><p>因为很多第三方开源项目没有 Conan 官方的支持，使用这些项目的时候就需要自己来编写 Receipe 来告诉 Conan 如何编译、打包第三方库了。</p>\n<p><img src=\"http://cdn.yuleweici.com/CPP-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/conan-3.png\" alt=\"Conan\"></p>\n<p>这里以bgfx为例来构造一个 Conan 的二进制包，并提交到我们自建的私仓中。</p>\n<p>因为bgfx官方构建方式比较复杂，笔者选取了其 CMake 版本来执行构建。此外 Github 上已经有用户创建过对应的构建脚本了，因此这里可以直接参考别人的写法来进行构建。</p>\n<p>使用conan new Hello&#x2F;0.1 -t可以创建一个 HelloWorld 的空白 Receipe。可以看到呈现出这样的目录结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conanfile.py</span><br><span class=\"line\">test_package</span><br><span class=\"line\">  CMakeLists.txt</span><br><span class=\"line\">  conanfile.py</span><br><span class=\"line\">  example.cpp</span><br></pre></td></tr></table></figure>\n<p>其中conanfile.py用来描述构建软件包的编译打包过程，test_package存储一个测试用的样例，用来检查是否成功构建了软件包并且是否能正常使用。</p>\n<p>以构建bgfx的脚本为例，修改conanfile.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> conans <span class=\"keyword\">import</span> ConanFile, CMake</span><br><span class=\"line\"><span class=\"keyword\">from</span> distutils.dir_util <span class=\"keyword\">import</span> copy_tree</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BgfxConan</span>(<span class=\"title class_ inherited__\">ConanFile</span>):</span><br><span class=\"line\">    name            = <span class=\"string\">&quot;bgfx&quot;</span></span><br><span class=\"line\">    version         = <span class=\"string\">&quot;20220908.0127cc8x&quot;</span>  <span class=\"comment\"># 这个地方我乱填的，请遵照SemVer的规范制定版本号</span></span><br><span class=\"line\">    description     = <span class=\"string\">&quot;Conan package for bgfx.&quot;</span></span><br><span class=\"line\">    url             = <span class=\"string\">&quot;https://github.com/vwin/xxx&quot;</span></span><br><span class=\"line\">    license         = <span class=\"string\">&quot;BSD&quot;</span></span><br><span class=\"line\">    settings        = <span class=\"string\">&quot;arch&quot;</span>, <span class=\"string\">&quot;build_type&quot;</span>, <span class=\"string\">&quot;compiler&quot;</span>, <span class=\"string\">&quot;os&quot;</span>  <span class=\"comment\"># 这些选项会被作为包的标识，区分不同的ABI</span></span><br><span class=\"line\">    generators      = <span class=\"string\">&quot;cmake&quot;</span></span><br><span class=\"line\">    options         = &#123;<span class=\"string\">&quot;shared&quot;</span>: [<span class=\"literal\">True</span>, <span class=\"literal\">False</span>]&#125;</span><br><span class=\"line\">    default_options = <span class=\"string\">&quot;shared=False&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">source</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.run(<span class=\"string\">&quot;git clone https://github.com/JoshuaBrookover/bgfx.cmake&quot;</span>)</span><br><span class=\"line\">        copy_tree(<span class=\"string\">&quot;bgfx.cmake&quot;</span>, <span class=\"string\">&quot;.&quot;</span>)</span><br><span class=\"line\">        self.run(<span class=\"string\">&quot;git reset --hard 018bbc4&quot;</span>)</span><br><span class=\"line\">        self.run(<span class=\"string\">&quot;git submodule update --init --recursive&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">build</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        cmake          = CMake(self)</span><br><span class=\"line\">        shared_options = <span class=\"string\">&quot;-DBUILD_SHARED_LIBS=ON&quot;</span> <span class=\"keyword\">if</span> self.options.shared <span class=\"keyword\">else</span> <span class=\"string\">&quot;-DBUILD_SHARED_LIBS=OFF&quot;</span></span><br><span class=\"line\">        fixed_options  = <span class=\"string\">&quot;-DBGFX_BUILD_EXAMPLES=OFF&quot;</span></span><br><span class=\"line\">        tool_options   = <span class=\"string\">&quot;-DBGFX_BUILD_TOOLS=OFF&quot;</span> <span class=\"keyword\">if</span> self.settings.os == <span class=\"string\">&quot;Emscripten&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        opengl_version = <span class=\"string\">&quot;-DBGFX_OPENGL_VERSION=33&quot;</span></span><br><span class=\"line\">        self.run(<span class=\"string\">&quot;cmake %s %s %s %s %s&quot;</span> % (cmake.command_line, shared_options, fixed_options, tool_options, opengl_version))</span><br><span class=\"line\">        self.run(<span class=\"string\">&quot;cmake --build . %s -j8&quot;</span> % cmake.build_config)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">collect_headers</span>(<span class=\"params\">self, include_folder</span>):</span><br><span class=\"line\">        self.copy(<span class=\"string\">&quot;*.h&quot;</span>  , dst=<span class=\"string\">&quot;include&quot;</span>, src=include_folder)</span><br><span class=\"line\">        self.copy(<span class=\"string\">&quot;*.hpp&quot;</span>, dst=<span class=\"string\">&quot;include&quot;</span>, src=include_folder)</span><br><span class=\"line\">        self.copy(<span class=\"string\">&quot;*.inl&quot;</span>, dst=<span class=\"string\">&quot;include&quot;</span>, src=include_folder)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">package</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.collect_headers(<span class=\"string\">&quot;bgfx/include&quot;</span>)</span><br><span class=\"line\">        self.collect_headers(<span class=\"string\">&quot;bimg/include&quot;</span>)</span><br><span class=\"line\">        self.collect_headers(<span class=\"string\">&quot;bx/include&quot;</span>  )</span><br><span class=\"line\">        self.copy(<span class=\"string\">&quot;*.a&quot;</span>  , dst=<span class=\"string\">&quot;lib&quot;</span>, keep_path=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        self.copy(<span class=\"string\">&quot;*.so&quot;</span> , dst=<span class=\"string\">&quot;lib&quot;</span>, keep_path=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        self.copy(<span class=\"string\">&quot;*.lib&quot;</span>, dst=<span class=\"string\">&quot;lib&quot;</span>, keep_path=<span class=\"literal\">False</span>)</span><br><span class=\"line\">        self.copy(<span class=\"string\">&quot;*.dll&quot;</span>, dst=<span class=\"string\">&quot;bin&quot;</span>, keep_path=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">package_info</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.cpp_info.libs = [<span class=\"string\">&quot;bgfxd&quot;</span>, <span class=\"string\">&quot;bimgd&quot;</span>, <span class=\"string\">&quot;bxd&quot;</span>] <span class=\"keyword\">if</span> self.settings.build_type == <span class=\"string\">&quot;Debug&quot;</span> <span class=\"keyword\">else</span> [<span class=\"string\">&quot;bgfx&quot;</span>, <span class=\"string\">&quot;bimg&quot;</span>, <span class=\"string\">&quot;bx&quot;</span>]</span><br><span class=\"line\">        self.cpp_info.libs.extend([<span class=\"string\">&quot;astc-codec&quot;</span>, <span class=\"string\">&quot;astc&quot;</span>, <span class=\"string\">&quot;edtaa3&quot;</span>, <span class=\"string\">&quot;etc1&quot;</span>, <span class=\"string\">&quot;etc2&quot;</span>, <span class=\"string\">&quot;iqa&quot;</span>, <span class=\"string\">&quot;squish&quot;</span>, <span class=\"string\">&quot;nvtt&quot;</span>, <span class=\"string\">&quot;pvrtc&quot;</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.settings.os == <span class=\"string\">&quot;Macos&quot;</span>:</span><br><span class=\"line\">            self.cpp_info.exelinkflags = [<span class=\"string\">&quot;-framework Cocoa&quot;</span>, <span class=\"string\">&quot;-framework QuartzCore&quot;</span>, <span class=\"string\">&quot;-framework OpenGL&quot;</span>, <span class=\"string\">&quot;-weak_framework Metal&quot;</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.settings.os == <span class=\"string\">&quot;Linux&quot;</span>:</span><br><span class=\"line\">            self.cpp_info.libs.extend([<span class=\"string\">&quot;GL&quot;</span>, <span class=\"string\">&quot;X11&quot;</span>, <span class=\"string\">&quot;pthread&quot;</span>, <span class=\"string\">&quot;dl&quot;</span>])</span><br></pre></td></tr></table></figure>\n\n<p>可以看到整个脚本分为若干个函数。其中，source函数，用于源代码拉取和准备，比如对源码进行一些修改；build函数，调用 CMake 进行构建；package函数，用于执行打包操作；package_info则用于输出构建相关的信息，比如需要链接包中的哪些库文件。</p>\n<p>默认的，Conan 以lib、include、bin等文件夹标识头文件库文件目录，也可以在package_info函数中进行修改。此外，Conan 提供了一系列的驱动包装函数来执行各种第三方工具，以及定制版本号规则、设定依赖等等。具体可以通过查阅官方文档来进一步了解，本文仅作抛砖引玉的目的。</p>\n<p>在构建完成后，Conan 会以 Settings 和 Options 的取值 Hash 后为软件包指定一个 package_id，因而不同的构建选项会对应到不同的 Id 上。最终拉取预编译包时就会以这个 Id 作为基准。因此，如果构建一个 Header-Only 的包，则可以去掉这些选项，这样在各个平台上都不需要额外构建即可使用了。</p>\n<p>编写完 Receipe 后，就可以执行 Conan 来进行构建了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conan install bgfx/20220908.0127cc8x@will/stable --build=bgfx</span><br></pre></td></tr></table></figure>\n\n<p>构建完成后会自动执行test_package的内容进行测试。最后使用命令上传到我们的私仓：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conan upload bgfx/20220908.0127cc8x@will/stable --all -r=my_local_server</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们就能在 Artifactory 中看到我们提交的包了。</p>\n<h3 id=\"配合-CMake-实战\"><a href=\"#配合-CMake-实战\" class=\"headerlink\" title=\"配合 CMake 实战\"></a>配合 CMake 实战</h3><p>上传完自己制作的包，接下来就可以将其作为依赖引入自己的项目之中了。</p>\n<p>在这里，推荐使用 Conan 官方提供的<a href=\"https://github.com/conan-io/cmake-conan\">CMake</a>脚本将其引入项目中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION <span class=\"number\">3.1</span>)</span><br><span class=\"line\">project(test CXX)</span><br><span class=\"line\"></span><br><span class=\"line\">#######################################<span class=\"meta\"># conan package manager ########################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"># Download automatically, you can also just copy the conan.cmake file</span><br><span class=\"line\"><span class=\"title function_\">if</span><span class=\"params\">(NOT EXISTS <span class=\"string\">&quot;$&#123;CMAKE_BINARY_DIR&#125;/conan.cmake&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"title function_\">message</span><span class=\"params\">(STATUS <span class=\"string\">&quot;Downloading conan.cmake from https://github.com/conan-io/cmake-conan&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"title function_\">file</span><span class=\"params\">(DOWNLOAD <span class=\"string\">&quot;https://github.com/conan-io/cmake-conan/raw/v0.14/conan.cmake&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"string\">&quot;$&#123;CMAKE_BINARY_DIR&#125;/conan.cmake&quot;</span>)</span></span><br><span class=\"line\"><span class=\"title function_\">endif</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">include</span><span class=\"params\">($&#123;CMAKE_BINARY_DIR&#125;/conan.cmake)</span></span><br><span class=\"line\"></span><br><span class=\"line\">#######################################<span class=\"meta\"># dependencies ########################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">conan_cmake_run</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    REQUIRES</span></span><br><span class=\"line\"><span class=\"params\">        bgfx/<span class=\"number\">20220908.0127</span>cc8x@will/stable</span></span><br><span class=\"line\"><span class=\"params\">    BASIC_SETUP CMAKE_TARGETS</span></span><br><span class=\"line\"><span class=\"params\">    BUILD missing)</span></span><br><span class=\"line\"></span><br><span class=\"line\">#######################################<span class=\"meta\"># compiler flags ########################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">set</span><span class=\"params\">(CMAKE_CXX_STANDARD <span class=\"number\">11</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">if</span><span class=\"params\">(MSVC)</span></span><br><span class=\"line\">    <span class=\"title function_\">add_definitions</span><span class=\"params\">(-D_WIN32_WINNT=<span class=\"number\">0x0600</span> -D_GNU_SOURCE -D_CRT_SECURE_NO_WARNINGS)</span></span><br><span class=\"line\">    <span class=\"title function_\">set</span><span class=\"params\">(CMAKE_CXX_FLAGS <span class=\"string\">&quot;$&#123;CMAKE_CXX_FLAGS&#125; /utf-8&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"title function_\">set</span><span class=\"params\">(CMAKE_C_FLAGS <span class=\"string\">&quot;$&#123;CMAKE_C_FLAGS&#125; /utf-8&quot;</span>)</span></span><br><span class=\"line\"><span class=\"title function_\">else</span><span class=\"params\">()</span></span><br><span class=\"line\">    <span class=\"title function_\">set</span><span class=\"params\">(CMAKE_CXX_FLAGS <span class=\"string\">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -Wall -Wextra -Wno-implicit-fallthrough&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"title function_\">set</span><span class=\"params\">(CMAKE_C_FLAGS <span class=\"string\">&quot;$&#123;CMAKE_C_FLAGS&#125; -g -Wall -Wextra -Wno-implicit-fallthrough&quot;</span>)</span></span><br><span class=\"line\"><span class=\"title function_\">endif</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\">#######################################<span class=\"meta\"># targets ########################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">file</span><span class=\"params\">(GLOB_RECURSE TEST_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include<span class=\"comment\">/*.hpp $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\">add_executable(test $&#123;TEST_SRC&#125;)</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\">target_include_directories(test PRIVATE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"params\">target_link_libraries(test CONAN_PKG::bgfx)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>通过 conan_cmake_run 来直接指定依赖，这样就不需要写 conanfile.txt 并且会在 CMake 构建的时候自动把依赖安装上，集成到 CMake 中，非常的方便。</p>\n<p>此外，由于使用了CMAKE_TARGETS模式，依赖的指定方法也变成了CONAN_PKG::bgfx的方式，这里可以根据需要自行调整。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可以说，Conan 为 C++ 的依赖管理提供了非常好的解决方案。支持私仓，使得我们有机会将它作为私有组件的依赖管理工具。跨平台的特性，使得我们有机会配合 CMake 将环境配置、编译构建一条龙化。对于 C++ 的生态，这也是一件非常有益的事情。</p>\n","slug":"CPP-包管理器CONAN上手指南","updated":"2022-11-27T10:39:22.787Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/09/08/CPP-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/","excerpt":"最近接了一个C++写的项目，好久没用过C++了，从头学习整理下C++相关的内容","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://vwin.github.io/tags/C/"},{"name":"Conan","slug":"Conan","permalink":"http://vwin.github.io/tags/Conan/"}]},{"title":"Python-对ZIP处理","date":"2022-08-26T03:21:07.000Z","path":"2022/08/26/Python-对ZIP处理/","text":"需求：对方提供处理文件的接口，本地将待处理文件压缩后，通过http post multipart方式上传，等待处理完成后从相应连接下载结果 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import osimport timeimport zipfileimport requestsfrom requests_toolbelt.multipart.encoder import MultipartEncoder class FuncZip(object): def __init__(self): self.remote_result = 0 # 压缩文件 def zip_dir(self, dirname, zipfilename): filelist = [] if os.path.isfile(dirname): filelist.append(dirname) else: for root, dirs, files in os.walk(dirname): for name in files: filelist.append(os.path.join(root, name)) zf = zipfile.ZipFile(zipfilename, mode=&quot;w&quot;, compression=zipfile.zlib.DEFLATED, allowZip64=True) for tar in filelist: arcname = tar[len(dirname):] zf.write(tar, arcname) zf.close() # 解压文件 def unzip_file(self, zipfilename, unziptodir): if not os.path.exists(unziptodir): os.mkdir(unziptodir) zfobj = zipfile.ZipFile(zipfilename) for name in zfobj.namelist(): # name = name.replace(&#x27;\\&#x27;, &#x27;/&#x27;) if name.endswith(&#x27;/&#x27;): os.mkdir(os.path.join(unziptodir, name)) else: ext_filename = os.path.join(unziptodir, name) ext_dir = os.path.dirname(ext_filename) if not os.path.exists(ext_dir): os.mkdir(ext_dir) outfile = open(ext_filename, &#x27;wb&#x27;) outfile.write(zfobj.read(name)) outfile.close() # 下载 def download_result(self, filename): filename = &quot;xxx/xxx&quot; # filename.replace(&#x27;\\&#x27;, &#x27;/&#x27;) file = filename.split(&#x27;/&#x27;)[-1] URL = &#x27;--------------&#x27; re = requests.get(URL+&#x27;?name=&#x27;+file, stream=True) self.remote_result = re.status_code if self.remote_result == 200: print(&quot;find result,try to download&quot;) f = open(&quot;download_&quot;+file, &quot;wb&quot;) for chunk in re.iter_content(chunk_size=512): if chunk: f.write(chunk) print(&quot;download result success&quot;) return self.remote_result # 上传 def upload_zip(self, filename): self.remote_result = 0 filename = &quot;xxx/xxx&quot; file = filename.split(&#x27;/&#x27;)[-1] file_tup = (file, open(filename, &#x27;rb&#x27;), &#x27;application/zip&#x27;) URL = &#x27;-----------------&#x27; #fields属性根据对方接口说明设置 m = MultipartEncoder( fields=&#123;&#x27;name&#x27;: file, &#x27;zipfile&#x27;: file_tup&#125; ) re = requests.post(URL, data=m, headers=&#123;&#x27;Content-Type&#x27;: m.content_type&#125;) self.remote_result = re.status_code if self.remote_result == 200: print(&quot;upload success&quot;) else: print(&quot;upload failed&quot;) return self.remote_result http协议本身的原始方法不支持multipart&#x2F;form-data请求，这个请求由原始方法演变而来的。multipart&#x2F;form-data的基础方法是post，也就是说是由post方法来组合实现的，与post方法的不同之处：请求头，请求体。multipart&#x2F;form-data的请求头必须包含一个特殊的头信息：Content-Type，且其值也必须规定为multipart&#x2F;form-data，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，不然接收方就无法正常解析和还原这个文件了。 具体的头信息如下： 1Content-Type: multipart/form-data; boundary=$&#123;bound&#125;","raw":"---\ntitle: Python-对ZIP处理\ntoc: true\ndate: 2022-08-26 11:21:07\ntags: [python,zip]\ncategories: [技术]\ndescription:\n---\n需求：对方提供处理文件的接口，本地将待处理文件压缩后，通过http post multipart方式上传，等待处理完成后从相应连接下载结果\n\n<!--more-->\n代码：\n```python\nimport os\nimport time\nimport zipfile\nimport requests\nfrom requests_toolbelt.multipart.encoder import MultipartEncoder\n \n \nclass FuncZip(object):\n \n  def __init__(self):\n    self.remote_result = 0\n  \n  # 压缩文件 \n  def zip_dir(self, dirname, zipfilename):\n    filelist = []\n    if os.path.isfile(dirname):\n      filelist.append(dirname)\n    else:\n      for root, dirs, files in os.walk(dirname):\n        for name in files:\n          filelist.append(os.path.join(root, name))\n      zf = zipfile.ZipFile(zipfilename, mode=\"w\", compression=zipfile.zlib.DEFLATED, allowZip64=True)\n      for tar in filelist:\n        arcname = tar[len(dirname):]\n        zf.write(tar, arcname)\n      zf.close()\n  \n  # 解压文件 \n  def unzip_file(self, zipfilename, unziptodir):\n    if not os.path.exists(unziptodir):\n      os.mkdir(unziptodir)\n    zfobj = zipfile.ZipFile(zipfilename)\n    for name in zfobj.namelist():\n    #   name = name.replace('\\', '/')\n      if name.endswith('/'):\n        os.mkdir(os.path.join(unziptodir, name))\n      else:\n        ext_filename = os.path.join(unziptodir, name)\n        ext_dir = os.path.dirname(ext_filename)\n        if not os.path.exists(ext_dir):\n          os.mkdir(ext_dir)\n        outfile = open(ext_filename, 'wb')\n        outfile.write(zfobj.read(name))\n        outfile.close()\n  \n  # 下载\n  def download_result(self, filename):\n    filename = \"xxx/xxx\"\n    # filename.replace('\\', '/')\n    file = filename.split('/')[-1]\n    URL = '--------------'\n    re = requests.get(URL+'?name='+file, stream=True)\n    self.remote_result = re.status_code\n    if self.remote_result == 200:\n      print(\"find result,try to download\")\n      f = open(\"download_\"+file, \"wb\")\n      for chunk in re.iter_content(chunk_size=512):\n        if chunk:\n          f.write(chunk)\n      print(\"download result success\")\n    return self.remote_result\n  \n  # 上传\n  def upload_zip(self, filename):\n    self.remote_result = 0\n    filename = \"xxx/xxx\"\n    file = filename.split('/')[-1]\n    file_tup = (file, open(filename, 'rb'), 'application/zip')\n    URL = '-----------------'\n\n    #fields属性根据对方接口说明设置\n    m = MultipartEncoder(\n      fields={'name': file, 'zipfile': file_tup}\n    )\n    \n    re = requests.post(URL, data=m, headers={'Content-Type': m.content_type})\n    self.remote_result = re.status_code\n    if self.remote_result == 200:\n      print(\"upload success\")\n    else:\n      print(\"upload failed\")\n    return self.remote_result\n```\n\nhttp协议本身的原始方法不支持multipart/form-data请求，这个请求由原始方法演变而来的。\nmultipart/form-data的基础方法是post，也就是说是由post方法来组合实现的，与post方法的不同之处：请求头，请求体。\nmultipart/form-data的请求头必须包含一个特殊的头信息：\nContent-Type，且其值也必须规定为multipart/form-data，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，不然接收方就无法正常解析和还原这个文件了。\n\n具体的头信息如下：\n```shell\nContent-Type: multipart/form-data; boundary=${bound}\n```","content":"<p>需求：对方提供处理文件的接口，本地将待处理文件压缩后，通过http post multipart方式上传，等待处理完成后从相应连接下载结果</p>\n<span id=\"more\"></span>\n<p>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> zipfile</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> requests_toolbelt.multipart.encoder <span class=\"keyword\">import</span> MultipartEncoder</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FuncZip</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    self.remote_result = <span class=\"number\">0</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\"># 压缩文件 </span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">zip_dir</span>(<span class=\"params\">self, dirname, zipfilename</span>):</span><br><span class=\"line\">    filelist = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.isfile(dirname):</span><br><span class=\"line\">      filelist.append(dirname)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      <span class=\"keyword\">for</span> root, dirs, files <span class=\"keyword\">in</span> os.walk(dirname):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> files:</span><br><span class=\"line\">          filelist.append(os.path.join(root, name))</span><br><span class=\"line\">      zf = zipfile.ZipFile(zipfilename, mode=<span class=\"string\">&quot;w&quot;</span>, compression=zipfile.zlib.DEFLATED, allowZip64=<span class=\"literal\">True</span>)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> tar <span class=\"keyword\">in</span> filelist:</span><br><span class=\"line\">        arcname = tar[<span class=\"built_in\">len</span>(dirname):]</span><br><span class=\"line\">        zf.write(tar, arcname)</span><br><span class=\"line\">      zf.close()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\"># 解压文件 </span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">unzip_file</span>(<span class=\"params\">self, zipfilename, unziptodir</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(unziptodir):</span><br><span class=\"line\">      os.mkdir(unziptodir)</span><br><span class=\"line\">    zfobj = zipfile.ZipFile(zipfilename)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> zfobj.namelist():</span><br><span class=\"line\">    <span class=\"comment\">#   name = name.replace(&#x27;\\&#x27;, &#x27;/&#x27;)</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> name.endswith(<span class=\"string\">&#x27;/&#x27;</span>):</span><br><span class=\"line\">        os.mkdir(os.path.join(unziptodir, name))</span><br><span class=\"line\">      <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        ext_filename = os.path.join(unziptodir, name)</span><br><span class=\"line\">        ext_dir = os.path.dirname(ext_filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(ext_dir):</span><br><span class=\"line\">          os.mkdir(ext_dir)</span><br><span class=\"line\">        outfile = <span class=\"built_in\">open</span>(ext_filename, <span class=\"string\">&#x27;wb&#x27;</span>)</span><br><span class=\"line\">        outfile.write(zfobj.read(name))</span><br><span class=\"line\">        outfile.close()</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\"># 下载</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">download_result</span>(<span class=\"params\">self, filename</span>):</span><br><span class=\"line\">    filename = <span class=\"string\">&quot;xxx/xxx&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># filename.replace(&#x27;\\&#x27;, &#x27;/&#x27;)</span></span><br><span class=\"line\">    file = filename.split(<span class=\"string\">&#x27;/&#x27;</span>)[-<span class=\"number\">1</span>]</span><br><span class=\"line\">    URL = <span class=\"string\">&#x27;--------------&#x27;</span></span><br><span class=\"line\">    re = requests.get(URL+<span class=\"string\">&#x27;?name=&#x27;</span>+file, stream=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    self.remote_result = re.status_code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.remote_result == <span class=\"number\">200</span>:</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;find result,try to download&quot;</span>)</span><br><span class=\"line\">      f = <span class=\"built_in\">open</span>(<span class=\"string\">&quot;download_&quot;</span>+file, <span class=\"string\">&quot;wb&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> chunk <span class=\"keyword\">in</span> re.iter_content(chunk_size=<span class=\"number\">512</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> chunk:</span><br><span class=\"line\">          f.write(chunk)</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;download result success&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.remote_result</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\"># 上传</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">upload_zip</span>(<span class=\"params\">self, filename</span>):</span><br><span class=\"line\">    self.remote_result = <span class=\"number\">0</span></span><br><span class=\"line\">    filename = <span class=\"string\">&quot;xxx/xxx&quot;</span></span><br><span class=\"line\">    file = filename.split(<span class=\"string\">&#x27;/&#x27;</span>)[-<span class=\"number\">1</span>]</span><br><span class=\"line\">    file_tup = (file, <span class=\"built_in\">open</span>(filename, <span class=\"string\">&#x27;rb&#x27;</span>), <span class=\"string\">&#x27;application/zip&#x27;</span>)</span><br><span class=\"line\">    URL = <span class=\"string\">&#x27;-----------------&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#fields属性根据对方接口说明设置</span></span><br><span class=\"line\">    m = MultipartEncoder(</span><br><span class=\"line\">      fields=&#123;<span class=\"string\">&#x27;name&#x27;</span>: file, <span class=\"string\">&#x27;zipfile&#x27;</span>: file_tup&#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    re = requests.post(URL, data=m, headers=&#123;<span class=\"string\">&#x27;Content-Type&#x27;</span>: m.content_type&#125;)</span><br><span class=\"line\">    self.remote_result = re.status_code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.remote_result == <span class=\"number\">200</span>:</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;upload success&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;upload failed&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.remote_result</span><br></pre></td></tr></table></figure>\n\n<p>http协议本身的原始方法不支持multipart&#x2F;form-data请求，这个请求由原始方法演变而来的。<br>multipart&#x2F;form-data的基础方法是post，也就是说是由post方法来组合实现的，与post方法的不同之处：请求头，请求体。<br>multipart&#x2F;form-data的请求头必须包含一个特殊的头信息：<br>Content-Type，且其值也必须规定为multipart&#x2F;form-data，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，不然接收方就无法正常解析和还原这个文件了。</p>\n<p>具体的头信息如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: multipart/form-data; boundary=$&#123;bound&#125;</span><br></pre></td></tr></table></figure>","slug":"Python-对ZIP处理","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/08/26/Python-%E5%AF%B9ZIP%E5%A4%84%E7%90%86/","excerpt":"需求：对方提供处理文件的接口，本地将待处理文件压缩后，通过http post multipart方式上传，等待处理完成后从相应连接下载结果","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"zip","slug":"zip","permalink":"http://vwin.github.io/tags/zip/"}]},{"title":"UI自动化-基于AirTest+Python的ios自动化测试","date":"2022-08-25T11:08:23.000Z","path":"2022/08/25/UI自动化-基于AirTest-Python的ios自动化测试/","text":"使用Airtest框架如何在IOS上做UI自动化？ Airtest介绍AirtestProject是由网易游戏推出的UI自动化测试解决方案，项目构成如下： Airtest框架Airtest 是一个跨平台的、 基于图像识别 的UI自动化测试框架，适用于游戏和App，支持平台有Windows、Android和iOS： Airtest源码 Airtest API文档 Poco框架Poco 是一款 基于UI控件识别 的自动化测试框架，目前支持Android原生、iOS原生、Unity3D、cocos2dx、UE4和Egret等平台，也可以在其他引擎中自行接入poco-sdk来使用。 Poco 源码 Poco API文档 AirtestIDEAirtestIDE 是一款跨平台的 UI自动化测试编辑器 ，内置了Airtest和Poco的相关插件功能，能够使用它快速简单地编写 Airtest 和 Poco 代码。 官方下载网址 AirtestIDE使用文档 手机集群解决方案-DeviceFarmDeviceFarm 是网易推出的自动化测试集群解决方案，它是软硬件一体化方案，包含设备集群建设、集群设备批量维护管理、监控报警和云端真机等功能，可以为您在企业内部搭建稳定高效的设备管理平台, 提升设备利用率，赋能自动化测试流程搭建： DeviceFarm集群解决方案 Airlab云测试平台Airlab云测试平台支持用例管理、脚本管理、任务预约、任务调度、云端报告等功能，可以快速构建企业自动化测试全流程，支持ios和安卓的回归测试及兼容测试。 Airlab云测试平台 Airtest文档：https://airtest.doc.io.netease.com/ WebDriverAgent 是什么?WebDriverAgent是Facebook 推出的一款iOS 移动测试框架，WebDriverAgent 在 iOS 端实现了一个 WebDriver server ，借助这个 server 我们可以远程控制 iOS 设备。你可以启动、杀死应用，点击、滚动视图，或者确定页面展示是否正确。官方github：https://github.com/facebook/WebDriverAgent （官方版本目前已不进行维护）特点： 支持真机+模拟机 简单易上手 在做iOS自动化测试的时候，一般都需要确保手机上已经安装有WebDriverAgent应用，这个WDA应用可以是Airtest修改版、Appium修改版也可以是Facebook原版，本文以Appium修改版为例来进行说明，其他版本同样适用。 Appium对 WebDriverAgent工具进行了封装 Airtest的 iOS-Tagent工具也对WebDriverAgent工具进行了封装。 既可以使用Appium的 WebDriverAgent 工具来部署iOS真机 也可以使用Airtest底下的 iOS-Tagent 工具来部署iOS真机。 对于低版本的iOS（iOS11以下），建议使用Airtest的 iOS-Tagent 工具。 高版本的使用Appium的 WebDriverAgent 工具。 安装部署环境准备注意：尽量升级Xcode到最新版本，iPhone版本大于14，我这里使用的版本情况如下：Xcode版本：13.4.1iPhone版本：15.6.1MacOS版本：12.4Python版本：3.8+ 安装Airtest的iOS-Tagent参考：https://github.com/AirtestProject/iOS-Tagent/blob/master/Introduction/README_zh.md 安装Appium的WebDriverAgent工具拉取代码1git clone https://github.com/appium/WebDriverAgent Xcode设置 进入WebDriverAgent项目根目录，双击打开WebDriverAgent.xcodeproj，然后在Xcode中的TARGETS里选中WebDriverAgentLib，按照下图数字序号依次点击，注意步骤4要开启自动管理签名。 在Team选项那里添加账户然后选中，这里的账户可以是个人免费账户也可以是付费开发者账户，区别在下面会提及。 接着在TARGETS里面选中WebDriverAgentRunner，用步骤1、2中同样的方法设置好证书。 如果是个人免费版的证书，还需要修改下WebDriverAgent的BundleID，随便加后缀，不要跟别人重复就好，如果是付费版开发者证书则不需要这步操作。 运行测试 iPhone通过usb连接电脑，在设备里如果可以看到自己的手机即可: xcode和ios版本需要对应，可在这查看对应关系：https://xcodereleases.com/ 按照下图中提示，分别选择WebDriverAgentRunner和目标设备： 然后点击Product菜单下的Test，这时候会提示输入本机电脑的密码，输入完成后点击始终允许即可。 如果是个人免费版证书还会弹出下面的提示： 这是因为WDA应用没有被信任，需要进入手机设置-&gt; 通用-&gt; 描述文件与设备管理，点击开发者APP信任一下就可以了 然后再次运行Test，就可以在Xcode控制台看到下面的输出信息： 通过上面给出的IP和端口，加上&#x2F;status合成一个url地址，例如http://127.0.0.1:8100/status 然后浏览器打开，如果出现下图的输出，就说明WDA安装成功了。 但是有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上，这个时候执行下面的命令即可：12brew install --HEAD usbmuxdiproxy 8100 8100 连接Airtest上述步骤执行完成没有问题后就可以用Airtest连接iPhone进行case编写 写自动化caseiOS 的测试和其他设备差不多，支持图像识别和UI检索，下面简单介绍一个iOS测试例子： 连接设备 点击home键 截屏 执行滑动操作 使用poco点击app Safari 使用poco点击浏览器的搜索框，获取焦点 在搜索框输入“airtest” 在搜索页面往下滑动 判断是否存在airtest官网地址 12345678910111213141516171819202122232425262728from airtest.core.api import *from poco.drivers.ios import iosPoco# 连接设备auto_setup(__file__)connect_device(&quot;ios:///http://127.0.0.1:8100&quot;)# 初始化iOS原生pocopoco = iosPoco()# 点击Home键keyevent(&quot;HOME&quot;)# 截屏snapshot()# 滑动操作swipe(Template(r&quot;xxx.png&quot;, record_pos=(0.356, -0.174), resolution=(750.0, 1334.0)), vector=[-0.685, 0.0481])# 点击app Safaripoco(&quot;Safari&quot;).click()# 点击浏览器的搜索框poco(&quot;URL&quot;).click()# 输入“airtest”text(&quot;airtest&quot;)# poco的滑动poco(&quot;People also search for&quot;).swipe([-0.0541, -0.4206])# 判断是否存在某个截图目标exists(Template(r&quot;xxx.png&quot;, record_pos=(-0.292, 0.688), resolution=(x, y))) poco入门airtest使用 重复执行 拔掉手机后重新连接usb需要做 打开WebDriverAgent工程，选择WebDriverAgentRunner，运行菜单栏Product-&gt;Test 执行 12iproxy 8100 8100 浏览器访问：127.0.0.1:8100/status或者localhost:8100/status 看到手机信息即表示连接成功 编写运行自动化case Airtest技巧iOS自动化实操–设备基本信息获取与计算器案例详解 局部截图 打开airtest设置 鼠标放到手机上会自动显示该点的坐标 实例代码1234567891011121314# -*- encoding=utf8 -*-from airtest.core.api import *from poco.drivers.ios import iosPocofrom airtest.aircv import *# file_path未文件保存路径，比如：/Users/Desktop/test.pngfile_path=&quot;xxx&quot;screen = G.DEVICE.snapshot()# crop_image的参数：1. 图片，2. 截图坐标（0,270）是左上角坐标，（1284,2650）是右下角坐标screen = aircv.crop_image(screen, (0, 270, 1284, 2650))aircv.imwrite(file_path, screen, 99)print(&quot;截图完成..&quot;)","raw":"---\ntitle: UI自动化-基于AirTest+Python的ios自动化测试\ntoc: true\ndate: 2022-08-25 19:08:23\ntags: [UI自动化,airtest,ios]\ncategories: [测试]\ndescription: UI自动化-基于AirTest+Python的ios自动化测试\n---\n使用Airtest框架如何在IOS上做UI自动化？\n<!--more-->\n\n# Airtest介绍\nAirtestProject是由网易游戏推出的UI自动化测试解决方案，项目构成如下：\n1. Airtest框架\nAirtest 是一个跨平台的、 基于图像识别 的UI自动化测试框架，适用于游戏和App，支持平台有Windows、Android和iOS：\n   - [Airtest源码](https://github.com/AirtestProject/Airtest)\n   - [Airtest API文档](https://airtest.readthedocs.io/zh_CN/latest/)\n\n2. Poco框架\nPoco 是一款 基于UI控件识别 的自动化测试框架，目前支持Android原生、iOS原生、Unity3D、cocos2dx、UE4和Egret等平台，也可以在其他引擎中自行接入poco-sdk来使用。\n   - [Poco 源码](https://github.com/AirtestProject/Poco)\n   - [Poco API文档](http://poco.readthedocs.io/zh_CN/latest/)\n3. AirtestIDE\nAirtestIDE 是一款跨平台的 UI自动化测试编辑器 ，内置了Airtest和Poco的相关插件功能，能够使用它快速简单地编写 Airtest 和 Poco 代码。\n\n   - [官方下载网址](https://airtest.netease.com/home/)\n   - [AirtestIDE使用文档](https://airtest.doc.io.netease.com/)\n\n4. 手机集群解决方案-DeviceFarm\nDeviceFarm 是网易推出的自动化测试集群解决方案，它是软硬件一体化方案，包含设备集群建设、集群设备批量维护管理、监控报警和云端真机等功能，可以为您在企业内部搭建稳定高效的设备管理平台, 提升设备利用率，赋能自动化测试流程搭建：\n\n   - [DeviceFarm集群解决方案](https://airtest.doc.io.netease.com/commercial/commercial/#1_2)\n\n5. Airlab云测试平台\nAirlab云测试平台支持用例管理、脚本管理、任务预约、任务调度、云端报告等功能，可以快速构建企业自动化测试全流程，支持ios和安卓的回归测试及兼容测试。\n\n   - [Airlab云测试平台](https://airtest.doc.io.netease.com/commercial/commercial/#4)\n\nAirtest文档：https://airtest.doc.io.netease.com/ \n\n# WebDriverAgent 是什么?\nWebDriverAgent是Facebook 推出的一款iOS 移动测试框架，WebDriverAgent 在 iOS 端实现了一个 WebDriver server ，借助这个 server 我们可以远程控制 iOS 设备。你可以启动、杀死应用，点击、滚动视图，或者确定页面展示是否正确。\n官方github：https://github.com/facebook/WebDriverAgent  （官方版本目前已不进行维护）\n特点：\n1. 支持真机+模拟机\n2. 简单易上手\n\n在做iOS自动化测试的时候，一般都需要确保手机上已经安装有WebDriverAgent应用，这个WDA应用可以是Airtest修改版、Appium修改版也可以是Facebook原版，本文以Appium修改版为例来进行说明，其他版本同样适用。\n\n1. Appium对 WebDriverAgent工具进行了封装\n2. Airtest的 iOS-Tagent工具也对WebDriverAgent工具进行了封装。\n3. 既可以使用Appium的 WebDriverAgent 工具来部署iOS真机\n4. 也可以使用Airtest底下的 iOS-Tagent 工具来部署iOS真机。\n5. 对于低版本的iOS（iOS11以下），建议使用Airtest的 iOS-Tagent 工具。\n6. 高版本的使用Appium的 WebDriverAgent 工具。\n\n# 安装部署\n## 环境准备\n注意：尽量升级Xcode到最新版本，iPhone版本大于14，我这里使用的版本情况如下：\nXcode版本：13.4.1\niPhone版本：15.6.1\nMacOS版本：12.4\nPython版本：3.8+\n\n## 安装Airtest的iOS-Tagent\n参考：https://github.com/AirtestProject/iOS-Tagent/blob/master/Introduction/README_zh.md \n\n## 安装Appium的WebDriverAgent工具\n\n### 拉取代码\n```shell\ngit clone https://github.com/appium/WebDriverAgent\n```\n\n### Xcode设置\n1. 进入WebDriverAgent项目根目录，双击打开WebDriverAgent.xcodeproj，然后在Xcode中的TARGETS里选中WebDriverAgentLib，按照下图数字序号依次点击，注意步骤4要开启自动管理签名。\n![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-1.png)\n\n1. 在Team选项那里添加账户然后选中，这里的账户可以是个人免费账户也可以是付费开发者账户，区别在下面会提及。\n\n![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-2.png)\n\n1. 接着在TARGETS里面选中WebDriverAgentRunner，用步骤1、2中同样的方法设置好证书。\n![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-3.png)\n\n1. 如果是个人免费版的证书，还需要修改下WebDriverAgent的BundleID，随便加后缀，不要跟别人重复就好，如果是付费版开发者证书则不需要这步操作。\n![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-4.png)\n\n1. 运行测试\n   1. iPhone通过usb连接电脑，在设备里如果可以看到自己的手机即可: ![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-5.png)\n   2. xcode和ios版本需要对应，可在这查看对应关系：https://xcodereleases.com/ \n   3. 按照下图中提示，分别选择WebDriverAgentRunner和目标设备：![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-6.png)\n   4. 然后点击Product菜单下的Test，这时候会提示输入本机电脑的密码，输入完成后点击始终允许即可。\n   5. 如果是个人免费版证书还会弹出下面的提示：![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-7.png)\n   6. 这是因为WDA应用没有被信任，需要进入手机设置-> 通用-> 描述文件与设备管理，点击开发者APP信任一下就可以了\n   7. 然后再次运行Test，就可以在Xcode控制台看到下面的输出信息：![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-8.png)\n   8. 通过上面给出的IP和端口，加上/status合成一个url地址，例如http://127.0.0.1:8100/status\n   9. 然后浏览器打开，如果出现下图的输出，就说明WDA安装成功了。 ![Xcode设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-9.png)\n   10. 但是有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上，这个时候执行下面的命令即可：\n   ```shell\n   brew install --HEAD usbmuxd\n   iproxy 8100 8100\n   ```\n\n### 连接Airtest\n上述步骤执行完成没有问题后就可以用Airtest连接iPhone进行case编写\n![Airtest设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/air-1.png)\n\n### 写自动化case\niOS 的测试和其他设备差不多，支持图像识别和UI检索，下面简单介绍一个iOS测试例子： \n1. 连接设备 \n2. 点击home键 \n3. 截屏 \n4. 执行滑动操作 \n5. 使用poco点击app Safari \n6. 使用poco点击浏览器的搜索框，获取焦点 \n7. 在搜索框输入“airtest” \n8. 在搜索页面往下滑动 \n9. 判断是否存在airtest官网地址\n\n```python\nfrom airtest.core.api import *\nfrom poco.drivers.ios import iosPoco\n\n# 连接设备\nauto_setup(__file__)\nconnect_device(\"ios:///http://127.0.0.1:8100\")\n\n# 初始化iOS原生poco\npoco = iosPoco()\n# 点击Home键\nkeyevent(\"HOME\")\n# 截屏\nsnapshot()\n# 滑动操作\nswipe(Template(r\"xxx.png\", record_pos=(0.356, -0.174), resolution=(750.0, 1334.0)), vector=[-0.685, 0.0481])\n\n# 点击app Safari\npoco(\"Safari\").click()\n# 点击浏览器的搜索框\npoco(\"URL\").click()\n# 输入“airtest”\ntext(\"airtest\")\n\n# poco的滑动\npoco(\"People also search for\").swipe([-0.0541, -0.4206])\n# 判断是否存在某个截图目标\nexists(Template(r\"xxx.png\", record_pos=(-0.292, 0.688), resolution=(x, y)))\n\n```\n\n[poco入门](https://airtest.doc.io.netease.com/IDEdocs/poco_framework/1_poco_info/)\n[airtest使用](https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/0_airtest_info/)\n\n\n\n### 重复执行\n1. 拔掉手机后重新连接usb需要做\n   1. 打开WebDriverAgent工程，选择WebDriverAgentRunner，运行菜单栏Product->Test\n   2. 执行  \n    ```shell \n    iproxy 8100 8100 \n    浏览器访问：127.0.0.1:8100/status或者localhost:8100/status 看到手机信息即表示连接成功\n    ```\n   3. 编写运行自动化case \n\n\n# Airtest技巧\n[iOS自动化实操--设备基本信息获取与计算器案例详解](https://mp.weixin.qq.com/s?__biz=MzUxMDc4NTkwMA==&mid=2247485597&idx=1&sn=4cbb64ca301fce3e611cc18db2404770&chksm=f97ce89ece0b6188ab316d7761afd53ba34959812bd962884ce616568ae27a8664b153a47fc4&cur_album_id=1725180541206855681&scene=189#wechat_redirect)\n## 局部截图\n1. 打开airtest设置\n![Airtest设置](http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/air-2.png)\n1. 鼠标放到手机上会自动显示该点的坐标\n2. 实例代码\n```python\n# -*- encoding=utf8 -*-\n\nfrom airtest.core.api import *\nfrom poco.drivers.ios import iosPoco\nfrom airtest.aircv import *\n\n# file_path未文件保存路径，比如：/Users/Desktop/test.png\nfile_path=\"xxx\"\nscreen = G.DEVICE.snapshot()\n# crop_image的参数：1. 图片，2. 截图坐标（0,270）是左上角坐标，（1284,2650）是右下角坐标\nscreen = aircv.crop_image(screen, (0, 270, 1284, 2650))\naircv.imwrite(file_path, screen, 99)\nprint(\"截图完成..\")\n\n```","content":"<p>使用Airtest框架如何在IOS上做UI自动化？</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Airtest介绍\"><a href=\"#Airtest介绍\" class=\"headerlink\" title=\"Airtest介绍\"></a>Airtest介绍</h1><p>AirtestProject是由网易游戏推出的UI自动化测试解决方案，项目构成如下：</p>\n<ol>\n<li><p>Airtest框架<br>Airtest 是一个跨平台的、 基于图像识别 的UI自动化测试框架，适用于游戏和App，支持平台有Windows、Android和iOS：</p>\n<ul>\n<li><a href=\"https://github.com/AirtestProject/Airtest\">Airtest源码</a></li>\n<li><a href=\"https://airtest.readthedocs.io/zh_CN/latest/\">Airtest API文档</a></li>\n</ul>\n</li>\n<li><p>Poco框架<br>Poco 是一款 基于UI控件识别 的自动化测试框架，目前支持Android原生、iOS原生、Unity3D、cocos2dx、UE4和Egret等平台，也可以在其他引擎中自行接入poco-sdk来使用。</p>\n<ul>\n<li><a href=\"https://github.com/AirtestProject/Poco\">Poco 源码</a></li>\n<li><a href=\"http://poco.readthedocs.io/zh_CN/latest/\">Poco API文档</a></li>\n</ul>\n</li>\n<li><p>AirtestIDE<br>AirtestIDE 是一款跨平台的 UI自动化测试编辑器 ，内置了Airtest和Poco的相关插件功能，能够使用它快速简单地编写 Airtest 和 Poco 代码。</p>\n<ul>\n<li><a href=\"https://airtest.netease.com/home/\">官方下载网址</a></li>\n<li><a href=\"https://airtest.doc.io.netease.com/\">AirtestIDE使用文档</a></li>\n</ul>\n</li>\n<li><p>手机集群解决方案-DeviceFarm<br>DeviceFarm 是网易推出的自动化测试集群解决方案，它是软硬件一体化方案，包含设备集群建设、集群设备批量维护管理、监控报警和云端真机等功能，可以为您在企业内部搭建稳定高效的设备管理平台, 提升设备利用率，赋能自动化测试流程搭建：</p>\n<ul>\n<li><a href=\"https://airtest.doc.io.netease.com/commercial/commercial/#1_2\">DeviceFarm集群解决方案</a></li>\n</ul>\n</li>\n<li><p>Airlab云测试平台<br>Airlab云测试平台支持用例管理、脚本管理、任务预约、任务调度、云端报告等功能，可以快速构建企业自动化测试全流程，支持ios和安卓的回归测试及兼容测试。</p>\n<ul>\n<li><a href=\"https://airtest.doc.io.netease.com/commercial/commercial/#4\">Airlab云测试平台</a></li>\n</ul>\n</li>\n</ol>\n<p>Airtest文档：<a href=\"https://airtest.doc.io.netease.com/\">https://airtest.doc.io.netease.com/</a> </p>\n<h1 id=\"WebDriverAgent-是什么\"><a href=\"#WebDriverAgent-是什么\" class=\"headerlink\" title=\"WebDriverAgent 是什么?\"></a>WebDriverAgent 是什么?</h1><p>WebDriverAgent是Facebook 推出的一款iOS 移动测试框架，WebDriverAgent 在 iOS 端实现了一个 WebDriver server ，借助这个 server 我们可以远程控制 iOS 设备。你可以启动、杀死应用，点击、滚动视图，或者确定页面展示是否正确。<br>官方github：<a href=\"https://github.com/facebook/WebDriverAgent\">https://github.com/facebook/WebDriverAgent</a>  （官方版本目前已不进行维护）<br>特点：</p>\n<ol>\n<li>支持真机+模拟机</li>\n<li>简单易上手</li>\n</ol>\n<p>在做iOS自动化测试的时候，一般都需要确保手机上已经安装有WebDriverAgent应用，这个WDA应用可以是Airtest修改版、Appium修改版也可以是Facebook原版，本文以Appium修改版为例来进行说明，其他版本同样适用。</p>\n<ol>\n<li>Appium对 WebDriverAgent工具进行了封装</li>\n<li>Airtest的 iOS-Tagent工具也对WebDriverAgent工具进行了封装。</li>\n<li>既可以使用Appium的 WebDriverAgent 工具来部署iOS真机</li>\n<li>也可以使用Airtest底下的 iOS-Tagent 工具来部署iOS真机。</li>\n<li>对于低版本的iOS（iOS11以下），建议使用Airtest的 iOS-Tagent 工具。</li>\n<li>高版本的使用Appium的 WebDriverAgent 工具。</li>\n</ol>\n<h1 id=\"安装部署\"><a href=\"#安装部署\" class=\"headerlink\" title=\"安装部署\"></a>安装部署</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>注意：尽量升级Xcode到最新版本，iPhone版本大于14，我这里使用的版本情况如下：<br>Xcode版本：13.4.1<br>iPhone版本：15.6.1<br>MacOS版本：12.4<br>Python版本：3.8+</p>\n<h2 id=\"安装Airtest的iOS-Tagent\"><a href=\"#安装Airtest的iOS-Tagent\" class=\"headerlink\" title=\"安装Airtest的iOS-Tagent\"></a>安装Airtest的iOS-Tagent</h2><p>参考：<a href=\"https://github.com/AirtestProject/iOS-Tagent/blob/master/Introduction/README_zh.md\">https://github.com/AirtestProject/iOS-Tagent/blob/master/Introduction/README_zh.md</a> </p>\n<h2 id=\"安装Appium的WebDriverAgent工具\"><a href=\"#安装Appium的WebDriverAgent工具\" class=\"headerlink\" title=\"安装Appium的WebDriverAgent工具\"></a>安装Appium的WebDriverAgent工具</h2><h3 id=\"拉取代码\"><a href=\"#拉取代码\" class=\"headerlink\" title=\"拉取代码\"></a>拉取代码</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/appium/WebDriverAgent</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Xcode设置\"><a href=\"#Xcode设置\" class=\"headerlink\" title=\"Xcode设置\"></a>Xcode设置</h3><ol>\n<li><p>进入WebDriverAgent项目根目录，双击打开WebDriverAgent.xcodeproj，然后在Xcode中的TARGETS里选中WebDriverAgentLib，按照下图数字序号依次点击，注意步骤4要开启自动管理签名。<br><img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-1.png\" alt=\"Xcode设置\"></p>\n</li>\n<li><p>在Team选项那里添加账户然后选中，这里的账户可以是个人免费账户也可以是付费开发者账户，区别在下面会提及。</p>\n</li>\n</ol>\n<p><img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-2.png\" alt=\"Xcode设置\"></p>\n<ol>\n<li><p>接着在TARGETS里面选中WebDriverAgentRunner，用步骤1、2中同样的方法设置好证书。<br><img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-3.png\" alt=\"Xcode设置\"></p>\n</li>\n<li><p>如果是个人免费版的证书，还需要修改下WebDriverAgent的BundleID，随便加后缀，不要跟别人重复就好，如果是付费版开发者证书则不需要这步操作。<br><img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-4.png\" alt=\"Xcode设置\"></p>\n</li>\n<li><p>运行测试</p>\n<ol>\n<li>iPhone通过usb连接电脑，在设备里如果可以看到自己的手机即可: <img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-5.png\" alt=\"Xcode设置\"></li>\n<li>xcode和ios版本需要对应，可在这查看对应关系：<a href=\"https://xcodereleases.com/\">https://xcodereleases.com/</a> </li>\n<li>按照下图中提示，分别选择WebDriverAgentRunner和目标设备：<img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-6.png\" alt=\"Xcode设置\"></li>\n<li>然后点击Product菜单下的Test，这时候会提示输入本机电脑的密码，输入完成后点击始终允许即可。</li>\n<li>如果是个人免费版证书还会弹出下面的提示：<img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-7.png\" alt=\"Xcode设置\"></li>\n<li>这是因为WDA应用没有被信任，需要进入手机设置-&gt; 通用-&gt; 描述文件与设备管理，点击开发者APP信任一下就可以了</li>\n<li>然后再次运行Test，就可以在Xcode控制台看到下面的输出信息：<img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-8.png\" alt=\"Xcode设置\"></li>\n<li>通过上面给出的IP和端口，加上&#x2F;status合成一个url地址，例如<a href=\"http://127.0.0.1:8100/status\">http://127.0.0.1:8100/status</a></li>\n<li>然后浏览器打开，如果出现下图的输出，就说明WDA安装成功了。 <img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/xcode-9.png\" alt=\"Xcode设置\"></li>\n<li>但是有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上，这个时候执行下面的命令即可：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install --HEAD usbmuxd</span><br><span class=\"line\">iproxy 8100 8100</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"连接Airtest\"><a href=\"#连接Airtest\" class=\"headerlink\" title=\"连接Airtest\"></a>连接Airtest</h3><p>上述步骤执行完成没有问题后就可以用Airtest连接iPhone进行case编写<br><img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/air-1.png\" alt=\"Airtest设置\"></p>\n<h3 id=\"写自动化case\"><a href=\"#写自动化case\" class=\"headerlink\" title=\"写自动化case\"></a>写自动化case</h3><p>iOS 的测试和其他设备差不多，支持图像识别和UI检索，下面简单介绍一个iOS测试例子： </p>\n<ol>\n<li>连接设备 </li>\n<li>点击home键 </li>\n<li>截屏 </li>\n<li>执行滑动操作 </li>\n<li>使用poco点击app Safari </li>\n<li>使用poco点击浏览器的搜索框，获取焦点 </li>\n<li>在搜索框输入“airtest” </li>\n<li>在搜索页面往下滑动 </li>\n<li>判断是否存在airtest官网地址</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> airtest.core.api <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> poco.drivers.ios <span class=\"keyword\">import</span> iosPoco</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连接设备</span></span><br><span class=\"line\">auto_setup(__file__)</span><br><span class=\"line\">connect_device(<span class=\"string\">&quot;ios:///http://127.0.0.1:8100&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化iOS原生poco</span></span><br><span class=\"line\">poco = iosPoco()</span><br><span class=\"line\"><span class=\"comment\"># 点击Home键</span></span><br><span class=\"line\">keyevent(<span class=\"string\">&quot;HOME&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 截屏</span></span><br><span class=\"line\">snapshot()</span><br><span class=\"line\"><span class=\"comment\"># 滑动操作</span></span><br><span class=\"line\">swipe(Template(<span class=\"string\">r&quot;xxx.png&quot;</span>, record_pos=(<span class=\"number\">0.356</span>, -<span class=\"number\">0.174</span>), resolution=(<span class=\"number\">750.0</span>, <span class=\"number\">1334.0</span>)), vector=[-<span class=\"number\">0.685</span>, <span class=\"number\">0.0481</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 点击app Safari</span></span><br><span class=\"line\">poco(<span class=\"string\">&quot;Safari&quot;</span>).click()</span><br><span class=\"line\"><span class=\"comment\"># 点击浏览器的搜索框</span></span><br><span class=\"line\">poco(<span class=\"string\">&quot;URL&quot;</span>).click()</span><br><span class=\"line\"><span class=\"comment\"># 输入“airtest”</span></span><br><span class=\"line\">text(<span class=\"string\">&quot;airtest&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># poco的滑动</span></span><br><span class=\"line\">poco(<span class=\"string\">&quot;People also search for&quot;</span>).swipe([-<span class=\"number\">0.0541</span>, -<span class=\"number\">0.4206</span>])</span><br><span class=\"line\"><span class=\"comment\"># 判断是否存在某个截图目标</span></span><br><span class=\"line\">exists(Template(<span class=\"string\">r&quot;xxx.png&quot;</span>, record_pos=(-<span class=\"number\">0.292</span>, <span class=\"number\">0.688</span>), resolution=(x, y)))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://airtest.doc.io.netease.com/IDEdocs/poco_framework/1_poco_info/\">poco入门</a><br><a href=\"https://airtest.doc.io.netease.com/IDEdocs/airtest_framework/0_airtest_info/\">airtest使用</a></p>\n<h3 id=\"重复执行\"><a href=\"#重复执行\" class=\"headerlink\" title=\"重复执行\"></a>重复执行</h3><ol>\n<li>拔掉手机后重新连接usb需要做<ol>\n<li>打开WebDriverAgent工程，选择WebDriverAgentRunner，运行菜单栏Product-&gt;Test</li>\n<li>执行   <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iproxy 8100 8100 </span><br><span class=\"line\">浏览器访问：127.0.0.1:8100/status或者localhost:8100/status 看到手机信息即表示连接成功</span><br></pre></td></tr></table></figure></li>\n<li>编写运行自动化case</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Airtest技巧\"><a href=\"#Airtest技巧\" class=\"headerlink\" title=\"Airtest技巧\"></a>Airtest技巧</h1><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMDc4NTkwMA==&mid=2247485597&idx=1&sn=4cbb64ca301fce3e611cc18db2404770&chksm=f97ce89ece0b6188ab316d7761afd53ba34959812bd962884ce616568ae27a8664b153a47fc4&cur_album_id=1725180541206855681&scene=189#wechat_redirect\">iOS自动化实操–设备基本信息获取与计算器案例详解</a></p>\n<h2 id=\"局部截图\"><a href=\"#局部截图\" class=\"headerlink\" title=\"局部截图\"></a>局部截图</h2><ol>\n<li>打开airtest设置<br><img src=\"http://cdn.yuleweici.com/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/air-2.png\" alt=\"Airtest设置\"></li>\n<li>鼠标放到手机上会自动显示该点的坐标</li>\n<li>实例代码<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- encoding=utf8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> airtest.core.api <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> poco.drivers.ios <span class=\"keyword\">import</span> iosPoco</span><br><span class=\"line\"><span class=\"keyword\">from</span> airtest.aircv <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># file_path未文件保存路径，比如：/Users/Desktop/test.png</span></span><br><span class=\"line\">file_path=<span class=\"string\">&quot;xxx&quot;</span></span><br><span class=\"line\">screen = G.DEVICE.snapshot()</span><br><span class=\"line\"><span class=\"comment\"># crop_image的参数：1. 图片，2. 截图坐标（0,270）是左上角坐标，（1284,2650）是右下角坐标</span></span><br><span class=\"line\">screen = aircv.crop_image(screen, (<span class=\"number\">0</span>, <span class=\"number\">270</span>, <span class=\"number\">1284</span>, <span class=\"number\">2650</span>))</span><br><span class=\"line\">aircv.imwrite(file_path, screen, <span class=\"number\">99</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;截图完成..&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n","slug":"UI自动化-基于AirTest-Python的ios自动化测试","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/08/25/UI%E8%87%AA%E5%8A%A8%E5%8C%96-%E5%9F%BA%E4%BA%8EAirTest-Python%E7%9A%84ios%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","excerpt":"使用Airtest框架如何在IOS上做UI自动化？","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"UI自动化","slug":"UI自动化","permalink":"http://vwin.github.io/tags/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"airtest","slug":"airtest","permalink":"http://vwin.github.io/tags/airtest/"},{"name":"ios","slug":"ios","permalink":"http://vwin.github.io/tags/ios/"}]},{"title":"2020年1月中华人民共和国县以上行政区划代码","date":"2022-08-24T01:23:33.000Z","path":"2022/08/24/2020年1月中华人民共和国县以上行政区划代码/","text":"https://www.mca.gov.cn/article/sj/xzqh/2020/2020/202003061536.html 2020年1月中华人民共和国县以上行政区划代码 行政区划代码 单位名称 110000 北京市 110101 东城区 110102 西城区 110105 朝阳区 110106 丰台区 110107 石景山区 110108 海淀区 110109 门头沟区 110111 房山区 110112 通州区 110113 顺义区 110114 昌平区 110115 大兴区 110116 怀柔区 110117 平谷区 110118 密云区 110119 延庆区 120000 天津市 120101 和平区 120102 河东区 120103 河西区 120104 南开区 120105 河北区 120106 红桥区 120110 东丽区 120111 西青区 120112 津南区 120113 北辰区 120114 武清区 120115 宝坻区 120116 滨海新区 120117 宁河区 120118 静海区 120119 蓟州区 130000 河北省 130100 石家庄市 130102 长安区 130104 桥西区 130105 新华区 130107 井陉矿区 130108 裕华区 130109 藁城区 130110 鹿泉区 130111 栾城区 130121 井陉县 130123 正定县 130125 行唐县 130126 灵寿县 130127 高邑县 130128 深泽县 130129 赞皇县 130130 无极县 130131 平山县 130132 元氏县 130133 赵县 130181 辛集市 130183 晋州市 130184 新乐市 130200 唐山市 130202 路南区 130203 路北区 130204 古冶区 130205 开平区 130207 丰南区 130208 丰润区 130209 曹妃甸区 130224 滦南县 130225 乐亭县 130227 迁西县 130229 玉田县 130281 遵化市 130283 迁安市 130284 滦州市 130300 秦皇岛市 130302 海港区 130303 山海关区 130304 北戴河区 130306 抚宁区 130321 青龙满族自治县 130322 昌黎县 130324 卢龙县 130400 邯郸市 130402 邯山区 130403 丛台区 130404 复兴区 130406 峰峰矿区 130407 肥乡区 130408 永年区 130423 临漳县 130424 成安县 130425 大名县 130426 涉县 130427 磁县 130430 邱县 130431 鸡泽县 130432 广平县 130433 馆陶县 130434 魏县 130435 曲周县 130481 武安市 130500 邢台市 130502 桥东区 130503 桥西区 130521 邢台县 130522 临城县 130523 内丘县 130524 柏乡县 130525 隆尧县 130526 任县 130527 南和县 130528 宁晋县 130529 巨鹿县 130530 新河县 130531 广宗县 130532 平乡县 130533 威县 130534 清河县 130535 临西县 130581 南宫市 130582 沙河市 130600 保定市 130602 竞秀区 130606 莲池区 130607 满城区 130608 清苑区 130609 徐水区 130623 涞水县 130624 阜平县 130626 定兴县 130627 唐县 130628 高阳县 130629 容城县 130630 涞源县 130631 望都县 130632 安新县 130633 易县 130634 曲阳县 130635 蠡县 130636 顺平县 130637 博野县 130638 雄县 130681 涿州市 130682 定州市 130683 安国市 130684 高碑店市 130700 张家口市 130702 桥东区 130703 桥西区 130705 宣化区 130706 下花园区 130708 万全区 130709 崇礼区 130722 张北县 130723 康保县 130724 沽源县 130725 尚义县 130726 蔚县 130727 阳原县 130728 怀安县 130730 怀来县 130731 涿鹿县 130732 赤城县 130800 承德市 130802 双桥区 130803 双滦区 130804 鹰手营子矿区 130821 承德县 130822 兴隆县 130824 滦平县 130825 隆化县 130826 丰宁满族自治县 130827 宽城满族自治县 130828 围场满族蒙古族自治县 130881 平泉市 130900 沧州市 130902 新华区 130903 运河区 130921 沧县 130922 青县 130923 东光县 130924 海兴县 130925 盐山县 130926 肃宁县 130927 南皮县 130928 吴桥县 130929 献县 130930 孟村回族自治县 130981 泊头市 130982 任丘市 130983 黄骅市 130984 河间市 131000 廊坊市 131002 安次区 131003 广阳区 131022 固安县 131023 永清县 131024 香河县 131025 大城县 131026 文安县 131028 大厂回族自治县 131081 霸州市 131082 三河市 131100 衡水市 131102 桃城区 131103 冀州区 131121 枣强县 131122 武邑县 131123 武强县 131124 饶阳县 131125 安平县 131126 故城县 131127 景县 131128 阜城县 131182 深州市 140000 山西省 140100 太原市 140105 小店区 140106 迎泽区 140107 杏花岭区 140108 尖草坪区 140109 万柏林区 140110 晋源区 140121 清徐县 140122 阳曲县 140123 娄烦县 140181 古交市 140200 大同市 140212 新荣区 140213 平城区 140214 云冈区 140215 云州区 140221 阳高县 140222 天镇县 140223 广灵县 140224 灵丘县 140225 浑源县 140226 左云县 140300 阳泉市 140302 城区 140303 矿区 140311 郊区 140321 平定县 140322 盂县 140400 长治市 140403 潞州区 140404 上党区 140405 屯留区 140406 潞城区 140423 襄垣县 140425 平顺县 140426 黎城县 140427 壶关县 140428 长子县 140429 武乡县 140430 沁县 140431 沁源县 140500 晋城市 140502 城区 140521 沁水县 140522 阳城县 140524 陵川县 140525 泽州县 140581 高平市 140600 朔州市 140602 朔城区 140603 平鲁区 140621 山阴县 140622 应县 140623 右玉县 140681 怀仁市 140700 晋中市 140702 榆次区 140703 太谷区 140721 榆社县 140722 左权县 140723 和顺县 140724 昔阳县 140725 寿阳县 140727 祁县 140728 平遥县 140729 灵石县 140781 介休市 140800 运城市 140802 盐湖区 140821 临猗县 140822 万荣县 140823 闻喜县 140824 稷山县 140825 新绛县 140826 绛县 140827 垣曲县 140828 夏县 140829 平陆县 140830 芮城县 140881 永济市 140882 河津市 140900 忻州市 140902 忻府区 140921 定襄县 140922 五台县 140923 代县 140924 繁峙县 140925 宁武县 140926 静乐县 140927 神池县 140928 五寨县 140929 岢岚县 140930 河曲县 140931 保德县 140932 偏关县 140981 原平市 141000 临汾市 141002 尧都区 141021 曲沃县 141022 翼城县 141023 襄汾县 141024 洪洞县 141025 古县 141026 安泽县 141027 浮山县 141028 吉县 141029 乡宁县 141030 大宁县 141031 隰县 141032 永和县 141033 蒲县 141034 汾西县 141081 侯马市 141082 霍州市 141100 吕梁市 141102 离石区 141121 文水县 141122 交城县 141123 兴县 141124 临县 141125 柳林县 141126 石楼县 141127 岚县 141128 方山县 141129 中阳县 141130 交口县 141181 孝义市 141182 汾阳市 150000 内蒙古自治区 150100 呼和浩特市 150102 新城区 150103 回民区 150104 玉泉区 150105 赛罕区 150121 土默特左旗 150122 托克托县 150123 和林格尔县 150124 清水河县 150125 武川县 150200 包头市 150202 东河区 150203 昆都仑区 150204 青山区 150205 石拐区 150206 白云鄂博矿区 150207 九原区 150221 土默特右旗 150222 固阳县 150223 达尔罕茂明安联合旗 150300 乌海市 150302 海勃湾区 150303 海南区 150304 乌达区 150400 赤峰市 150402 红山区 150403 元宝山区 150404 松山区 150421 阿鲁科尔沁旗 150422 巴林左旗 150423 巴林右旗 150424 林西县 150425 克什克腾旗 150426 翁牛特旗 150428 喀喇沁旗 150429 宁城县 150430 敖汉旗 150500 通辽市 150502 科尔沁区 150521 科尔沁左翼中旗 150522 科尔沁左翼后旗 150523 开鲁县 150524 库伦旗 150525 奈曼旗 150526 扎鲁特旗 150581 霍林郭勒市 150600 鄂尔多斯市 150602 东胜区 150603 康巴什区 150621 达拉特旗 150622 准格尔旗 150623 鄂托克前旗 150624 鄂托克旗 150625 杭锦旗 150626 乌审旗 150627 伊金霍洛旗 150700 呼伦贝尔市 150702 海拉尔区 150703 扎赉诺尔区 150721 阿荣旗 150722 莫力达瓦达斡尔族自治旗 150723 鄂伦春自治旗 150724 鄂温克族自治旗 150725 陈巴尔虎旗 150726 新巴尔虎左旗 150727 新巴尔虎右旗 150781 满洲里市 150782 牙克石市 150783 扎兰屯市 150784 额尔古纳市 150785 根河市 150800 巴彦淖尔市 150802 临河区 150821 五原县 150822 磴口县 150823 乌拉特前旗 150824 乌拉特中旗 150825 乌拉特后旗 150826 杭锦后旗 150900 乌兰察布市 150902 集宁区 150921 卓资县 150922 化德县 150923 商都县 150924 兴和县 150925 凉城县 150926 察哈尔右翼前旗 150927 察哈尔右翼中旗 150928 察哈尔右翼后旗 150929 四子王旗 150981 丰镇市 152200 兴安盟 152201 乌兰浩特市 152202 阿尔山市 152221 科尔沁右翼前旗 152222 科尔沁右翼中旗 152223 扎赉特旗 152224 突泉县 152500 锡林郭勒盟 152501 二连浩特市 152502 锡林浩特市 152522 阿巴嘎旗 152523 苏尼特左旗 152524 苏尼特右旗 152525 东乌珠穆沁旗 152526 西乌珠穆沁旗 152527 太仆寺旗 152528 镶黄旗 152529 正镶白旗 152530 正蓝旗 152531 多伦县 152900 阿拉善盟 152921 阿拉善左旗 152922 阿拉善右旗 152923 额济纳旗 210000 辽宁省 210100 沈阳市 210102 和平区 210103 沈河区 210104 大东区 210105 皇姑区 210106 铁西区 210111 苏家屯区 210112 浑南区 210113 沈北新区 210114 于洪区 210115 辽中区 210123 康平县 210124 法库县 210181 新民市 210200 大连市 210202 中山区 210203 西岗区 210204 沙河口区 210211 甘井子区 210212 旅顺口区 210213 金州区 210214 普兰店区 210224 长海县 210281 瓦房店市 210283 庄河市 210300 鞍山市 210302 铁东区 210303 铁西区 210304 立山区 210311 千山区 210321 台安县 210323 岫岩满族自治县 210381 海城市 210400 抚顺市 210402 新抚区 210403 东洲区 210404 望花区 210411 顺城区 210421 抚顺县 210422 新宾满族自治县 210423 清原满族自治县 210500 本溪市 210502 平山区 210503 溪湖区 210504 明山区 210505 南芬区 210521 本溪满族自治县 210522 桓仁满族自治县 210600 丹东市 210602 元宝区 210603 振兴区 210604 振安区 210624 宽甸满族自治县 210681 东港市 210682 凤城市 210700 锦州市 210702 古塔区 210703 凌河区 210711 太和区 210726 黑山县 210727 义县 210781 凌海市 210782 北镇市 210800 营口市 210802 站前区 210803 西市区 210804 鲅鱼圈区 210811 老边区 210881 盖州市 210882 大石桥市 210900 阜新市 210902 海州区 210903 新邱区 210904 太平区 210905 清河门区 210911 细河区 210921 阜新蒙古族自治县 210922 彰武县 211000 辽阳市 211002 白塔区 211003 文圣区 211004 宏伟区 211005 弓长岭区 211011 太子河区 211021 辽阳县 211081 灯塔市 211100 盘锦市 211102 双台子区 211103 兴隆台区 211104 大洼区 211122 盘山县 211200 铁岭市 211202 银州区 211204 清河区 211221 铁岭县 211223 西丰县 211224 昌图县 211281 调兵山市 211282 开原市 211300 朝阳市 211302 双塔区 211303 龙城区 211321 朝阳县 211322 建平县 211324 喀喇沁左翼蒙古族自治县 211381 北票市 211382 凌源市 211400 葫芦岛市 211402 连山区 211403 龙港区 211404 南票区 211421 绥中县 211422 建昌县 211481 兴城市 220000 吉林省 220100 长春市 220102 南关区 220103 宽城区 220104 朝阳区 220105 二道区 220106 绿园区 220112 双阳区 220113 九台区 220122 农安县 220182 榆树市 220183 德惠市 220200 吉林市 220202 昌邑区 220203 龙潭区 220204 船营区 220211 丰满区 220221 永吉县 220281 蛟河市 220282 桦甸市 220283 舒兰市 220284 磐石市 220300 四平市 220302 铁西区 220303 铁东区 220322 梨树县 220323 伊通满族自治县 220381 公主岭市 220382 双辽市 220400 辽源市 220402 龙山区 220403 西安区 220421 东丰县 220422 东辽县 220500 通化市 220502 东昌区 220503 二道江区 220521 通化县 220523 辉南县 220524 柳河县 220581 梅河口市 220582 集安市 220600 白山市 220602 浑江区 220605 江源区 220621 抚松县 220622 靖宇县 220623 长白朝鲜族自治县 220681 临江市 220700 松原市 220702 宁江区 220721 前郭尔罗斯蒙古族自治县 220722 长岭县 220723 乾安县 220781 扶余市 220800 白城市 220802 洮北区 220821 镇赉县 220822 通榆县 220881 洮南市 220882 大安市 222400 延边朝鲜族自治州 222401 延吉市 222402 图们市 222403 敦化市 222404 珲春市 222405 龙井市 222406 和龙市 222424 汪清县 222426 安图县 230000 黑龙江省 230100 哈尔滨市 230102 道里区 230103 南岗区 230104 道外区 230108 平房区 230109 松北区 230110 香坊区 230111 呼兰区 230112 阿城区 230113 双城区 230123 依兰县 230124 方正县 230125 宾县 230126 巴彦县 230127 木兰县 230128 通河县 230129 延寿县 230183 尚志市 230184 五常市 230200 齐齐哈尔市 230202 龙沙区 230203 建华区 230204 铁锋区 230205 昂昂溪区 230206 富拉尔基区 230207 碾子山区 230208 梅里斯达斡尔族区 230221 龙江县 230223 依安县 230224 泰来县 230225 甘南县 230227 富裕县 230229 克山县 230230 克东县 230231 拜泉县 230281 讷河市 230300 鸡西市 230302 鸡冠区 230303 恒山区 230304 滴道区 230305 梨树区 230306 城子河区 230307 麻山区 230321 鸡东县 230381 虎林市 230382 密山市 230400 鹤岗市 230402 向阳区 230403 工农区 230404 南山区 230405 兴安区 230406 东山区 230407 兴山区 230421 萝北县 230422 绥滨县 230500 双鸭山市 230502 尖山区 230503 岭东区 230505 四方台区 230506 宝山区 230521 集贤县 230522 友谊县 230523 宝清县 230524 饶河县 230600 大庆市 230602 萨尔图区 230603 龙凤区 230604 让胡路区 230605 红岗区 230606 大同区 230621 肇州县 230622 肇源县 230623 林甸县 230624 杜尔伯特蒙古族自治县 230700 伊春市 230717 伊美区 230718 乌翠区 230719 友好区 230722 嘉荫县 230723 汤旺县 230724 丰林县 230725 大箐山县 230726 南岔县 230751 金林区 230781 铁力市 230800 佳木斯市 230803 向阳区 230804 前进区 230805 东风区 230811 郊区 230822 桦南县 230826 桦川县 230828 汤原县 230881 同江市 230882 富锦市 230883 抚远市 230900 七台河市 230902 新兴区 230903 桃山区 230904 茄子河区 230921 勃利县 231000 牡丹江市 231002 东安区 231003 阳明区 231004 爱民区 231005 西安区 231025 林口县 231081 绥芬河市 231083 海林市 231084 宁安市 231085 穆棱市 231086 东宁市 231100 黑河市 231102 爱辉区 231123 逊克县 231124 孙吴县 231181 北安市 231182 五大连池市 231183 嫩江市 231200 绥化市 231202 北林区 231221 望奎县 231222 兰西县 231223 青冈县 231224 庆安县 231225 明水县 231226 绥棱县 231281 安达市 231282 肇东市 231283 海伦市 232700 大兴安岭地区 232701 漠河市 232721 呼玛县 232722 塔河县 310000 上海市 310101 黄浦区 310104 徐汇区 310105 长宁区 310106 静安区 310107 普陀区 310109 虹口区 310110 杨浦区 310112 闵行区 310113 宝山区 310114 嘉定区 310115 浦东新区 310116 金山区 310117 松江区 310118 青浦区 310120 奉贤区 310151 崇明区 320000 江苏省 320100 南京市 320102 玄武区 320104 秦淮区 320105 建邺区 320106 鼓楼区 320111 浦口区 320113 栖霞区 320114 雨花台区 320115 江宁区 320116 六合区 320117 溧水区 320118 高淳区 320200 无锡市 320205 锡山区 320206 惠山区 320211 滨湖区 320213 梁溪区 320214 新吴区 320281 江阴市 320282 宜兴市 320300 徐州市 320302 鼓楼区 320303 云龙区 320305 贾汪区 320311 泉山区 320312 铜山区 320321 丰县 320322 沛县 320324 睢宁县 320381 新沂市 320382 邳州市 320400 常州市 320402 天宁区 320404 钟楼区 320411 新北区 320412 武进区 320413 金坛区 320481 溧阳市 320500 苏州市 320505 虎丘区 320506 吴中区 320507 相城区 320508 姑苏区 320509 吴江区 320581 常熟市 320582 张家港市 320583 昆山市 320585 太仓市 320600 南通市 320602 崇川区 320611 港闸区 320612 通州区 320623 如东县 320681 启东市 320682 如皋市 320684 海门市 320685 海安市 320700 连云港市 320703 连云区 320706 海州区 320707 赣榆区 320722 东海县 320723 灌云县 320724 灌南县 320800 淮安市 320803 淮安区 320804 淮阴区 320812 清江浦区 320813 洪泽区 320826 涟水县 320830 盱眙县 320831 金湖县 320900 盐城市 320902 亭湖区 320903 盐都区 320904 大丰区 320921 响水县 320922 滨海县 320923 阜宁县 320924 射阳县 320925 建湖县 320981 东台市 321000 扬州市 321002 广陵区 321003 邗江区 321012 江都区 321023 宝应县 321081 仪征市 321084 高邮市 321100 镇江市 321102 京口区 321111 润州区 321112 丹徒区 321181 丹阳市 321182 扬中市 321183 句容市 321200 泰州市 321202 海陵区 321203 高港区 321204 姜堰区 321281 兴化市 321282 靖江市 321283 泰兴市 321300 宿迁市 321302 宿城区 321311 宿豫区 321322 沭阳县 321323 泗阳县 321324 泗洪县 330000 浙江省 330100 杭州市 330102 上城区 330103 下城区 330104 江干区 330105 拱墅区 330106 西湖区 330108 滨江区 330109 萧山区 330110 余杭区 330111 富阳区 330112 临安区 330122 桐庐县 330127 淳安县 330182 建德市 330200 宁波市 330203 海曙区 330205 江北区 330206 北仑区 330211 镇海区 330212 鄞州区 330213 奉化区 330225 象山县 330226 宁海县 330281 余姚市 330282 慈溪市 330300 温州市 330302 鹿城区 330303 龙湾区 330304 瓯海区 330305 洞头区 330324 永嘉县 330326 平阳县 330327 苍南县 330328 文成县 330329 泰顺县 330381 瑞安市 330382 乐清市 330383 龙港市 330400 嘉兴市 330402 南湖区 330411 秀洲区 330421 嘉善县 330424 海盐县 330481 海宁市 330482 平湖市 330483 桐乡市 330500 湖州市 330502 吴兴区 330503 南浔区 330521 德清县 330522 长兴县 330523 安吉县 330600 绍兴市 330602 越城区 330603 柯桥区 330604 上虞区 330624 新昌县 330681 诸暨市 330683 嵊州市 330700 金华市 330702 婺城区 330703 金东区 330723 武义县 330726 浦江县 330727 磐安县 330781 兰溪市 330782 义乌市 330783 东阳市 330784 永康市 330800 衢州市 330802 柯城区 330803 衢江区 330822 常山县 330824 开化县 330825 龙游县 330881 江山市 330900 舟山市 330902 定海区 330903 普陀区 330921 岱山县 330922 嵊泗县 331000 台州市 331002 椒江区 331003 黄岩区 331004 路桥区 331022 三门县 331023 天台县 331024 仙居县 331081 温岭市 331082 临海市 331083 玉环市 331100 丽水市 331102 莲都区 331121 青田县 331122 缙云县 331123 遂昌县 331124 松阳县 331125 云和县 331126 庆元县 331127 景宁畲族自治县 331181 龙泉市 340000 安徽省 340100 合肥市 340102 瑶海区 340103 庐阳区 340104 蜀山区 340111 包河区 340121 长丰县 340122 肥东县 340123 肥西县 340124 庐江县 340181 巢湖市 340200 芜湖市 340202 镜湖区 340203 弋江区 340207 鸠江区 340208 三山区 340221 芜湖县 340222 繁昌县 340223 南陵县 340281 无为市 340300 蚌埠市 340302 龙子湖区 340303 蚌山区 340304 禹会区 340311 淮上区 340321 怀远县 340322 五河县 340323 固镇县 340400 淮南市 340402 大通区 340403 田家庵区 340404 谢家集区 340405 八公山区 340406 潘集区 340421 凤台县 340422 寿县 340500 马鞍山市 340503 花山区 340504 雨山区 340506 博望区 340521 当涂县 340522 含山县 340523 和县 340600 淮北市 340602 杜集区 340603 相山区 340604 烈山区 340621 濉溪县 340700 铜陵市 340705 铜官区 340706 义安区 340711 郊区 340722 枞阳县 340800 安庆市 340802 迎江区 340803 大观区 340811 宜秀区 340822 怀宁县 340825 太湖县 340826 宿松县 340827 望江县 340828 岳西县 340881 桐城市 340882 潜山市 341000 黄山市 341002 屯溪区 341003 黄山区 341004 徽州区 341021 歙县 341022 休宁县 341023 黟县 341024 祁门县 341100 滁州市 341102 琅琊区 341103 南谯区 341122 来安县 341124 全椒县 341125 定远县 341126 凤阳县 341181 天长市 341182 明光市 341200 阜阳市 341202 颍州区 341203 颍东区 341204 颍泉区 341221 临泉县 341222 太和县 341225 阜南县 341226 颍上县 341282 界首市 341300 宿州市 341302 埇桥区 341321 砀山县 341322 萧县 341323 灵璧县 341324 泗县 341500 六安市 341502 金安区 341503 裕安区 341504 叶集区 341522 霍邱县 341523 舒城县 341524 金寨县 341525 霍山县 341600 亳州市 341602 谯城区 341621 涡阳县 341622 蒙城县 341623 利辛县 341700 池州市 341702 贵池区 341721 东至县 341722 石台县 341723 青阳县 341800 宣城市 341802 宣州区 341821 郎溪县 341823 泾县 341824 绩溪县 341825 旌德县 341881 宁国市 341882 广德市 350000 福建省 350100 福州市 350102 鼓楼区 350103 台江区 350104 仓山区 350105 马尾区 350111 晋安区 350112 长乐区 350121 闽侯县 350122 连江县 350123 罗源县 350124 闽清县 350125 永泰县 350128 平潭县 350181 福清市 350200 厦门市 350203 思明区 350205 海沧区 350206 湖里区 350211 集美区 350212 同安区 350213 翔安区 350300 莆田市 350302 城厢区 350303 涵江区 350304 荔城区 350305 秀屿区 350322 仙游县 350400 三明市 350402 梅列区 350403 三元区 350421 明溪县 350423 清流县 350424 宁化县 350425 大田县 350426 尤溪县 350427 沙县 350428 将乐县 350429 泰宁县 350430 建宁县 350481 永安市 350500 泉州市 350502 鲤城区 350503 丰泽区 350504 洛江区 350505 泉港区 350521 惠安县 350524 安溪县 350525 永春县 350526 德化县 350527 金门县 350581 石狮市 350582 晋江市 350583 南安市 350600 漳州市 350602 芗城区 350603 龙文区 350622 云霄县 350623 漳浦县 350624 诏安县 350625 长泰县 350626 东山县 350627 南靖县 350628 平和县 350629 华安县 350681 龙海市 350700 南平市 350702 延平区 350703 建阳区 350721 顺昌县 350722 浦城县 350723 光泽县 350724 松溪县 350725 政和县 350781 邵武市 350782 武夷山市 350783 建瓯市 350800 龙岩市 350802 新罗区 350803 永定区 350821 长汀县 350823 上杭县 350824 武平县 350825 连城县 350881 漳平市 350900 宁德市 350902 蕉城区 350921 霞浦县 350922 古田县 350923 屏南县 350924 寿宁县 350925 周宁县 350926 柘荣县 350981 福安市 350982 福鼎市 360000 江西省 360100 南昌市 360102 东湖区 360103 西湖区 360104 青云谱区 360111 青山湖区 360112 新建区 360113 红谷滩区 360121 南昌县 360123 安义县 360124 进贤县 360200 景德镇市 360202 昌江区 360203 珠山区 360222 浮梁县 360281 乐平市 360300 萍乡市 360302 安源区 360313 湘东区 360321 莲花县 360322 上栗县 360323 芦溪县 360400 九江市 360402 濂溪区 360403 浔阳区 360404 柴桑区 360423 武宁县 360424 修水县 360425 永修县 360426 德安县 360428 都昌县 360429 湖口县 360430 彭泽县 360481 瑞昌市 360482 共青城市 360483 庐山市 360500 新余市 360502 渝水区 360521 分宜县 360600 鹰潭市 360602 月湖区 360603 余江区 360681 贵溪市 360700 赣州市 360702 章贡区 360703 南康区 360704 赣县区 360722 信丰县 360723 大余县 360724 上犹县 360725 崇义县 360726 安远县 360727 龙南县 360728 定南县 360729 全南县 360730 宁都县 360731 于都县 360732 兴国县 360733 会昌县 360734 寻乌县 360735 石城县 360781 瑞金市 360800 吉安市 360802 吉州区 360803 青原区 360821 吉安县 360822 吉水县 360823 峡江县 360824 新干县 360825 永丰县 360826 泰和县 360827 遂川县 360828 万安县 360829 安福县 360830 永新县 360881 井冈山市 360900 宜春市 360902 袁州区 360921 奉新县 360922 万载县 360923 上高县 360924 宜丰县 360925 靖安县 360926 铜鼓县 360981 丰城市 360982 樟树市 360983 高安市 361000 抚州市 361002 临川区 361003 东乡区 361021 南城县 361022 黎川县 361023 南丰县 361024 崇仁县 361025 乐安县 361026 宜黄县 361027 金溪县 361028 资溪县 361030 广昌县 361100 上饶市 361102 信州区 361103 广丰区 361104 广信区 361123 玉山县 361124 铅山县 361125 横峰县 361126 弋阳县 361127 余干县 361128 鄱阳县 361129 万年县 361130 婺源县 361181 德兴市 370000 山东省 370100 济南市 370102 历下区 370103 市中区 370104 槐荫区 370105 天桥区 370112 历城区 370113 长清区 370114 章丘区 370115 济阳区 370116 莱芜区 370117 钢城区 370124 平阴县 370126 商河县 370200 青岛市 370202 市南区 370203 市北区 370211 黄岛区 370212 崂山区 370213 李沧区 370214 城阳区 370215 即墨区 370281 胶州市 370283 平度市 370285 莱西市 370300 淄博市 370302 淄川区 370303 张店区 370304 博山区 370305 临淄区 370306 周村区 370321 桓台县 370322 高青县 370323 沂源县 370400 枣庄市 370402 市中区 370403 薛城区 370404 峄城区 370405 台儿庄区 370406 山亭区 370481 滕州市 370500 东营市 370502 东营区 370503 河口区 370505 垦利区 370522 利津县 370523 广饶县 370600 烟台市 370602 芝罘区 370611 福山区 370612 牟平区 370613 莱山区 370634 长岛县 370681 龙口市 370682 莱阳市 370683 莱州市 370684 蓬莱市 370685 招远市 370686 栖霞市 370687 海阳市 370700 潍坊市 370702 潍城区 370703 寒亭区 370704 坊子区 370705 奎文区 370724 临朐县 370725 昌乐县 370781 青州市 370782 诸城市 370783 寿光市 370784 安丘市 370785 高密市 370786 昌邑市 370800 济宁市 370811 任城区 370812 兖州区 370826 微山县 370827 鱼台县 370828 金乡县 370829 嘉祥县 370830 汶上县 370831 泗水县 370832 梁山县 370881 曲阜市 370883 邹城市 370900 泰安市 370902 泰山区 370911 岱岳区 370921 宁阳县 370923 东平县 370982 新泰市 370983 肥城市 371000 威海市 371002 环翠区 371003 文登区 371082 荣成市 371083 乳山市 371100 日照市 371102 东港区 371103 岚山区 371121 五莲县 371122 莒县 371300 临沂市 371302 兰山区 371311 罗庄区 371312 河东区 371321 沂南县 371322 郯城县 371323 沂水县 371324 兰陵县 371325 费县 371326 平邑县 371327 莒南县 371328 蒙阴县 371329 临沭县 371400 德州市 371402 德城区 371403 陵城区 371422 宁津县 371423 庆云县 371424 临邑县 371425 齐河县 371426 平原县 371427 夏津县 371428 武城县 371481 乐陵市 371482 禹城市 371500 聊城市 371502 东昌府区 371503 茌平区 371521 阳谷县 371522 莘县 371524 东阿县 371525 冠县 371526 高唐县 371581 临清市 371600 滨州市 371602 滨城区 371603 沾化区 371621 惠民县 371622 阳信县 371623 无棣县 371625 博兴县 371681 邹平市 371700 菏泽市 371702 牡丹区 371703 定陶区 371721 曹县 371722 单县 371723 成武县 371724 巨野县 371725 郓城县 371726 鄄城县 371728 东明县 410000 河南省 410100 郑州市 410102 中原区 410103 二七区 410104 管城回族区 410105 金水区 410106 上街区 410108 惠济区 410122 中牟县 410181 巩义市 410182 荥阳市 410183 新密市 410184 新郑市 410185 登封市 410200 开封市 410202 龙亭区 410203 顺河回族区 410204 鼓楼区 410205 禹王台区 410212 祥符区 410221 杞县 410222 通许县 410223 尉氏县 410225 兰考县 410300 洛阳市 410302 老城区 410303 西工区 410304 瀍河回族区 410305 涧西区 410306 吉利区 410311 洛龙区 410322 孟津县 410323 新安县 410324 栾川县 410325 嵩县 410326 汝阳县 410327 宜阳县 410328 洛宁县 410329 伊川县 410381 偃师市 410400 平顶山市 410402 新华区 410403 卫东区 410404 石龙区 410411 湛河区 410421 宝丰县 410422 叶县 410423 鲁山县 410425 郏县 410481 舞钢市 410482 汝州市 410500 安阳市 410502 文峰区 410503 北关区 410505 殷都区 410506 龙安区 410522 安阳县 410523 汤阴县 410526 滑县 410527 内黄县 410581 林州市 410600 鹤壁市 410602 鹤山区 410603 山城区 410611 淇滨区 410621 浚县 410622 淇县 410700 新乡市 410702 红旗区 410703 卫滨区 410704 凤泉区 410711 牧野区 410721 新乡县 410724 获嘉县 410725 原阳县 410726 延津县 410727 封丘县 410781 卫辉市 410782 辉县市 410783 长垣市 410800 焦作市 410802 解放区 410803 中站区 410804 马村区 410811 山阳区 410821 修武县 410822 博爱县 410823 武陟县 410825 温县 410882 沁阳市 410883 孟州市 410900 濮阳市 410902 华龙区 410922 清丰县 410923 南乐县 410926 范县 410927 台前县 410928 濮阳县 411000 许昌市 411002 魏都区 411003 建安区 411024 鄢陵县 411025 襄城县 411081 禹州市 411082 长葛市 411100 漯河市 411102 源汇区 411103 郾城区 411104 召陵区 411121 舞阳县 411122 临颍县 411200 三门峡市 411202 湖滨区 411203 陕州区 411221 渑池县 411224 卢氏县 411281 义马市 411282 灵宝市 411300 南阳市 411302 宛城区 411303 卧龙区 411321 南召县 411322 方城县 411323 西峡县 411324 镇平县 411325 内乡县 411326 淅川县 411327 社旗县 411328 唐河县 411329 新野县 411330 桐柏县 411381 邓州市 411400 商丘市 411402 梁园区 411403 睢阳区 411421 民权县 411422 睢县 411423 宁陵县 411424 柘城县 411425 虞城县 411426 夏邑县 411481 永城市 411500 信阳市 411502 浉河区 411503 平桥区 411521 罗山县 411522 光山县 411523 新县 411524 商城县 411525 固始县 411526 潢川县 411527 淮滨县 411528 息县 411600 周口市 411602 川汇区 411603 淮阳区 411621 扶沟县 411622 西华县 411623 商水县 411624 沈丘县 411625 郸城县 411627 太康县 411628 鹿邑县 411681 项城市 411700 驻马店市 411702 驿城区 411721 西平县 411722 上蔡县 411723 平舆县 411724 正阳县 411725 确山县 411726 泌阳县 411727 汝南县 411728 遂平县 411729 新蔡县 419001 济源市 420000 湖北省 420100 武汉市 420102 江岸区 420103 江汉区 420104 硚口区 420105 汉阳区 420106 武昌区 420107 青山区 420111 洪山区 420112 东西湖区 420113 汉南区 420114 蔡甸区 420115 江夏区 420116 黄陂区 420117 新洲区 420200 黄石市 420202 黄石港区 420203 西塞山区 420204 下陆区 420205 铁山区 420222 阳新县 420281 大冶市 420300 十堰市 420302 茅箭区 420303 张湾区 420304 郧阳区 420322 郧西县 420323 竹山县 420324 竹溪县 420325 房县 420381 丹江口市 420500 宜昌市 420502 西陵区 420503 伍家岗区 420504 点军区 420505 猇亭区 420506 夷陵区 420525 远安县 420526 兴山县 420527 秭归县 420528 长阳土家族自治县 420529 五峰土家族自治县 420581 宜都市 420582 当阳市 420583 枝江市 420600 襄阳市 420602 襄城区 420606 樊城区 420607 襄州区 420624 南漳县 420625 谷城县 420626 保康县 420682 老河口市 420683 枣阳市 420684 宜城市 420700 鄂州市 420702 梁子湖区 420703 华容区 420704 鄂城区 420800 荆门市 420802 东宝区 420804 掇刀区 420822 沙洋县 420881 钟祥市 420882 京山市 420900 孝感市 420902 孝南区 420921 孝昌县 420922 大悟县 420923 云梦县 420981 应城市 420982 安陆市 420984 汉川市 421000 荆州市 421002 沙市区 421003 荆州区 421022 公安县 421023 监利县 421024 江陵县 421081 石首市 421083 洪湖市 421087 松滋市 421100 黄冈市 421102 黄州区 421121 团风县 421122 红安县 421123 罗田县 421124 英山县 421125 浠水县 421126 蕲春县 421127 黄梅县 421181 麻城市 421182 武穴市 421200 咸宁市 421202 咸安区 421221 嘉鱼县 421222 通城县 421223 崇阳县 421224 通山县 421281 赤壁市 421300 随州市 421303 曾都区 421321 随县 421381 广水市 422800 恩施土家族苗族自治州 422801 恩施市 422802 利川市 422822 建始县 422823 巴东县 422825 宣恩县 422826 咸丰县 422827 来凤县 422828 鹤峰县 429004 仙桃市 429005 潜江市 429006 天门市 429021 神农架林区 430000 湖南省 430100 长沙市 430102 芙蓉区 430103 天心区 430104 岳麓区 430105 开福区 430111 雨花区 430112 望城区 430121 长沙县 430181 浏阳市 430182 宁乡市 430200 株洲市 430202 荷塘区 430203 芦淞区 430204 石峰区 430211 天元区 430212 渌口区 430223 攸县 430224 茶陵县 430225 炎陵县 430281 醴陵市 430300 湘潭市 430302 雨湖区 430304 岳塘区 430321 湘潭县 430381 湘乡市 430382 韶山市 430400 衡阳市 430405 珠晖区 430406 雁峰区 430407 石鼓区 430408 蒸湘区 430412 南岳区 430421 衡阳县 430422 衡南县 430423 衡山县 430424 衡东县 430426 祁东县 430481 耒阳市 430482 常宁市 430500 邵阳市 430502 双清区 430503 大祥区 430511 北塔区 430522 新邵县 430523 邵阳县 430524 隆回县 430525 洞口县 430527 绥宁县 430528 新宁县 430529 城步苗族自治县 430581 武冈市 430582 邵东市 430600 岳阳市 430602 岳阳楼区 430603 云溪区 430611 君山区 430621 岳阳县 430623 华容县 430624 湘阴县 430626 平江县 430681 汨罗市 430682 临湘市 430700 常德市 430702 武陵区 430703 鼎城区 430721 安乡县 430722 汉寿县 430723 澧县 430724 临澧县 430725 桃源县 430726 石门县 430781 津市市 430800 张家界市 430802 永定区 430811 武陵源区 430821 慈利县 430822 桑植县 430900 益阳市 430902 资阳区 430903 赫山区 430921 南县 430922 桃江县 430923 安化县 430981 沅江市 431000 郴州市 431002 北湖区 431003 苏仙区 431021 桂阳县 431022 宜章县 431023 永兴县 431024 嘉禾县 431025 临武县 431026 汝城县 431027 桂东县 431028 安仁县 431081 资兴市 431100 永州市 431102 零陵区 431103 冷水滩区 431121 祁阳县 431122 东安县 431123 双牌县 431124 道县 431125 江永县 431126 宁远县 431127 蓝山县 431128 新田县 431129 江华瑶族自治县 431200 怀化市 431202 鹤城区 431221 中方县 431222 沅陵县 431223 辰溪县 431224 溆浦县 431225 会同县 431226 麻阳苗族自治县 431227 新晃侗族自治县 431228 芷江侗族自治县 431229 靖州苗族侗族自治县 431230 通道侗族自治县 431281 洪江市 431300 娄底市 431302 娄星区 431321 双峰县 431322 新化县 431381 冷水江市 431382 涟源市 433100 湘西土家族苗族自治州 433101 吉首市 433122 泸溪县 433123 凤凰县 433124 花垣县 433125 保靖县 433126 古丈县 433127 永顺县 433130 龙山县 440000 广东省 440100 广州市 440103 荔湾区 440104 越秀区 440105 海珠区 440106 天河区 440111 白云区 440112 黄埔区 440113 番禺区 440114 花都区 440115 南沙区 440117 从化区 440118 增城区 440200 韶关市 440203 武江区 440204 浈江区 440205 曲江区 440222 始兴县 440224 仁化县 440229 翁源县 440232 乳源瑶族自治县 440233 新丰县 440281 乐昌市 440282 南雄市 440300 深圳市 440303 罗湖区 440304 福田区 440305 南山区 440306 宝安区 440307 龙岗区 440308 盐田区 440309 龙华区 440310 坪山区 440311 光明区 440400 珠海市 440402 香洲区 440403 斗门区 440404 金湾区 440500 汕头市 440507 龙湖区 440511 金平区 440512 濠江区 440513 潮阳区 440514 潮南区 440515 澄海区 440523 南澳县 440600 佛山市 440604 禅城区 440605 南海区 440606 顺德区 440607 三水区 440608 高明区 440700 江门市 440703 蓬江区 440704 江海区 440705 新会区 440781 台山市 440783 开平市 440784 鹤山市 440785 恩平市 440800 湛江市 440802 赤坎区 440803 霞山区 440804 坡头区 440811 麻章区 440823 遂溪县 440825 徐闻县 440881 廉江市 440882 雷州市 440883 吴川市 440900 茂名市 440902 茂南区 440904 电白区 440981 高州市 440982 化州市 440983 信宜市 441200 肇庆市 441202 端州区 441203 鼎湖区 441204 高要区 441223 广宁县 441224 怀集县 441225 封开县 441226 德庆县 441284 四会市 441300 惠州市 441302 惠城区 441303 惠阳区 441322 博罗县 441323 惠东县 441324 龙门县 441400 梅州市 441402 梅江区 441403 梅县区 441422 大埔县 441423 丰顺县 441424 五华县 441426 平远县 441427 蕉岭县 441481 兴宁市 441500 汕尾市 441502 城区 441521 海丰县 441523 陆河县 441581 陆丰市 441600 河源市 441602 源城区 441621 紫金县 441622 龙川县 441623 连平县 441624 和平县 441625 东源县 441700 阳江市 441702 江城区 441704 阳东区 441721 阳西县 441781 阳春市 441800 清远市 441802 清城区 441803 清新区 441821 佛冈县 441823 阳山县 441825 连山壮族瑶族自治县 441826 连南瑶族自治县 441881 英德市 441882 连州市 441900 东莞市 442000 中山市 445100 潮州市 445102 湘桥区 445103 潮安区 445122 饶平县 445200 揭阳市 445202 榕城区 445203 揭东区 445222 揭西县 445224 惠来县 445281 普宁市 445300 云浮市 445302 云城区 445303 云安区 445321 新兴县 445322 郁南县 445381 罗定市 450000 广西壮族自治区 450100 南宁市 450102 兴宁区 450103 青秀区 450105 江南区 450107 西乡塘区 450108 良庆区 450109 邕宁区 450110 武鸣区 450123 隆安县 450124 马山县 450125 上林县 450126 宾阳县 450127 横县 450200 柳州市 450202 城中区 450203 鱼峰区 450204 柳南区 450205 柳北区 450206 柳江区 450222 柳城县 450223 鹿寨县 450224 融安县 450225 融水苗族自治县 450226 三江侗族自治县 450300 桂林市 450302 秀峰区 450303 叠彩区 450304 象山区 450305 七星区 450311 雁山区 450312 临桂区 450321 阳朔县 450323 灵川县 450324 全州县 450325 兴安县 450326 永福县 450327 灌阳县 450328 龙胜各族自治县 450329 资源县 450330 平乐县 450381 荔浦市 450332 恭城瑶族自治县 450400 梧州市 450403 万秀区 450405 长洲区 450406 龙圩区 450421 苍梧县 450422 藤县 450423 蒙山县 450481 岑溪市 450500 北海市 450502 海城区 450503 银海区 450512 铁山港区 450521 合浦县 450600 防城港市 450602 港口区 450603 防城区 450621 上思县 450681 东兴市 450700 钦州市 450702 钦南区 450703 钦北区 450721 灵山县 450722 浦北县 450800 贵港市 450802 港北区 450803 港南区 450804 覃塘区 450821 平南县 450881 桂平市 450900 玉林市 450902 玉州区 450903 福绵区 450921 容县 450922 陆川县 450923 博白县 450924 兴业县 450981 北流市 451000 百色市 451002 右江区 451003 田阳区 451022 田东县 451024 德保县 451026 那坡县 451027 凌云县 451028 乐业县 451029 田林县 451030 西林县 451031 隆林各族自治县 451081 靖西市 451082 平果市 451100 贺州市 451102 八步区 451103 平桂区 451121 昭平县 451122 钟山县 451123 富川瑶族自治县 451200 河池市 451202 金城江区 451203 宜州区 451221 南丹县 451222 天峨县 451223 凤山县 451224 东兰县 451225 罗城仫佬族自治县 451226 环江毛南族自治县 451227 巴马瑶族自治县 451228 都安瑶族自治县 451229 大化瑶族自治县 451300 来宾市 451302 兴宾区 451321 忻城县 451322 象州县 451323 武宣县 451324 金秀瑶族自治县 451381 合山市 451400 崇左市 451402 江州区 451421 扶绥县 451422 宁明县 451423 龙州县 451424 大新县 451425 天等县 451481 凭祥市 460000 海南省 460100 海口市 460105 秀英区 460106 龙华区 460107 琼山区 460108 美兰区 460200 三亚市 460202 海棠区 460203 吉阳区 460204 天涯区 460205 崖州区 460300 三沙市 460400 儋州市 469001 五指山市 469002 琼海市 469005 文昌市 469006 万宁市 469007 东方市 469021 定安县 469022 屯昌县 469023 澄迈县 469024 临高县 469025 白沙黎族自治县 469026 昌江黎族自治县 469027 乐东黎族自治县 469028 陵水黎族自治县 469029 保亭黎族苗族自治县 469030 琼中黎族苗族自治县 500000 重庆市 500101 万州区 500102 涪陵区 500103 渝中区 500104 大渡口区 500105 江北区 500106 沙坪坝区 500107 九龙坡区 500108 南岸区 500109 北碚区 500110 綦江区 500111 大足区 500112 渝北区 500113 巴南区 500114 黔江区 500115 长寿区 500116 江津区 500117 合川区 500118 永川区 500119 南川区 500120 璧山区 500151 铜梁区 500152 潼南区 500153 荣昌区 500154 开州区 500155 梁平区 500156 武隆区 500229 城口县 500230 丰都县 500231 垫江县 500233 忠县 500235 云阳县 500236 奉节县 500237 巫山县 500238 巫溪县 500240 石柱土家族自治县 500241 秀山土家族苗族自治县 500242 酉阳土家族苗族自治县 500243 彭水苗族土家族自治县 510000 四川省 510100 成都市 510104 锦江区 510105 青羊区 510106 金牛区 510107 武侯区 510108 成华区 510112 龙泉驿区 510113 青白江区 510114 新都区 510115 温江区 510116 双流区 510117 郫都区 510121 金堂县 510129 大邑县 510131 蒲江县 510132 新津县 510181 都江堰市 510182 彭州市 510183 邛崃市 510184 崇州市 510185 简阳市 510300 自贡市 510302 自流井区 510303 贡井区 510304 大安区 510311 沿滩区 510321 荣县 510322 富顺县 510400 攀枝花市 510402 东区 510403 西区 510411 仁和区 510421 米易县 510422 盐边县 510500 泸州市 510502 江阳区 510503 纳溪区 510504 龙马潭区 510521 泸县 510522 合江县 510524 叙永县 510525 古蔺县 510600 德阳市 510603 旌阳区 510604 罗江区 510623 中江县 510681 广汉市 510682 什邡市 510683 绵竹市 510700 绵阳市 510703 涪城区 510704 游仙区 510705 安州区 510722 三台县 510723 盐亭县 510725 梓潼县 510726 北川羌族自治县 510727 平武县 510781 江油市 510800 广元市 510802 利州区 510811 昭化区 510812 朝天区 510821 旺苍县 510822 青川县 510823 剑阁县 510824 苍溪县 510900 遂宁市 510903 船山区 510904 安居区 510921 蓬溪县 510923 大英县 510981 射洪市 511000 内江市 511002 市中区 511011 东兴区 511024 威远县 511025 资中县 511083 隆昌市 511100 乐山市 511102 市中区 511111 沙湾区 511112 五通桥区 511113 金口河区 511123 犍为县 511124 井研县 511126 夹江县 511129 沐川县 511132 峨边彝族自治县 511133 马边彝族自治县 511181 峨眉山市 511300 南充市 511302 顺庆区 511303 高坪区 511304 嘉陵区 511321 南部县 511322 营山县 511323 蓬安县 511324 仪陇县 511325 西充县 511381 阆中市 511400 眉山市 511402 东坡区 511403 彭山区 511421 仁寿县 511423 洪雅县 511424 丹棱县 511425 青神县 511500 宜宾市 511502 翠屏区 511503 南溪区 511504 叙州区 511523 江安县 511524 长宁县 511525 高县 511526 珙县 511527 筠连县 511528 兴文县 511529 屏山县 511600 广安市 511602 广安区 511603 前锋区 511621 岳池县 511622 武胜县 511623 邻水县 511681 华蓥市 511700 达州市 511702 通川区 511703 达川区 511722 宣汉县 511723 开江县 511724 大竹县 511725 渠县 511781 万源市 511800 雅安市 511802 雨城区 511803 名山区 511822 荥经县 511823 汉源县 511824 石棉县 511825 天全县 511826 芦山县 511827 宝兴县 511900 巴中市 511902 巴州区 511903 恩阳区 511921 通江县 511922 南江县 511923 平昌县 512000 资阳市 512002 雁江区 512021 安岳县 512022 乐至县 513200 阿坝藏族羌族自治州 513201 马尔康市 513221 汶川县 513222 理县 513223 茂县 513224 松潘县 513225 九寨沟县 513226 金川县 513227 小金县 513228 黑水县 513230 壤塘县 513231 阿坝县 513232 若尔盖县 513233 红原县 513300 甘孜藏族自治州 513301 康定市 513322 泸定县 513323 丹巴县 513324 九龙县 513325 雅江县 513326 道孚县 513327 炉霍县 513328 甘孜县 513329 新龙县 513330 德格县 513331 白玉县 513332 石渠县 513333 色达县 513334 理塘县 513335 巴塘县 513336 乡城县 513337 稻城县 513338 得荣县 513400 凉山彝族自治州 513401 西昌市 513422 木里藏族自治县 513423 盐源县 513424 德昌县 513425 会理县 513426 会东县 513427 宁南县 513428 普格县 513429 布拖县 513430 金阳县 513431 昭觉县 513432 喜德县 513433 冕宁县 513434 越西县 513435 甘洛县 513436 美姑县 513437 雷波县 520000 贵州省 520100 贵阳市 520102 南明区 520103 云岩区 520111 花溪区 520112 乌当区 520113 白云区 520115 观山湖区 520121 开阳县 520122 息烽县 520123 修文县 520181 清镇市 520200 六盘水市 520201 钟山区 520203 六枝特区 520221 水城县 520281 盘州市 520300 遵义市 520302 红花岗区 520303 汇川区 520304 播州区 520322 桐梓县 520323 绥阳县 520324 正安县 520325 道真仡佬族苗族自治县 520326 务川仡佬族苗族自治县 520327 凤冈县 520328 湄潭县 520329 余庆县 520330 习水县 520381 赤水市 520382 仁怀市 520400 安顺市 520402 西秀区 520403 平坝区 520422 普定县 520423 镇宁布依族苗族自治县 520424 关岭布依族苗族自治县 520425 紫云苗族布依族自治县 520500 毕节市 520502 七星关区 520521 大方县 520522 黔西县 520523 金沙县 520524 织金县 520525 纳雍县 520526 威宁彝族回族苗族自治县 520527 赫章县 520600 铜仁市 520602 碧江区 520603 万山区 520621 江口县 520622 玉屏侗族自治县 520623 石阡县 520624 思南县 520625 印江土家族苗族自治县 520626 德江县 520627 沿河土家族自治县 520628 松桃苗族自治县 522300 黔西南布依族苗族自治州 522301 兴义市 522302 兴仁市 522323 普安县 522324 晴隆县 522325 贞丰县 522326 望谟县 522327 册亨县 522328 安龙县 522600 黔东南苗族侗族自治州 522601 凯里市 522622 黄平县 522623 施秉县 522624 三穗县 522625 镇远县 522626 岑巩县 522627 天柱县 522628 锦屏县 522629 剑河县 522630 台江县 522631 黎平县 522632 榕江县 522633 从江县 522634 雷山县 522635 麻江县 522636 丹寨县 522700 黔南布依族苗族自治州 522701 都匀市 522702 福泉市 522722 荔波县 522723 贵定县 522725 瓮安县 522726 独山县 522727 平塘县 522728 罗甸县 522729 长顺县 522730 龙里县 522731 惠水县 522732 三都水族自治县 530000 云南省 530100 昆明市 530102 五华区 530103 盘龙区 530111 官渡区 530112 西山区 530113 东川区 530114 呈贡区 530115 晋宁区 530124 富民县 530125 宜良县 530126 石林彝族自治县 530127 嵩明县 530128 禄劝彝族苗族自治县 530129 寻甸回族彝族自治县 530181 安宁市 530300 曲靖市 530302 麒麟区 530303 沾益区 530304 马龙区 530322 陆良县 530323 师宗县 530324 罗平县 530325 富源县 530326 会泽县 530381 宣威市 530400 玉溪市 530402 红塔区 530403 江川区 530423 通海县 530424 华宁县 530425 易门县 530426 峨山彝族自治县 530427 新平彝族傣族自治县 530428 元江哈尼族彝族傣族自治县 530481 澄江市 530500 保山市 530502 隆阳区 530521 施甸县 530523 龙陵县 530524 昌宁县 530581 腾冲市 530600 昭通市 530602 昭阳区 530621 鲁甸县 530622 巧家县 530623 盐津县 530624 大关县 530625 永善县 530626 绥江县 530627 镇雄县 530628 彝良县 530629 威信县 530681 水富市 530700 丽江市 530702 古城区 530721 玉龙纳西族自治县 530722 永胜县 530723 华坪县 530724 宁蒗彝族自治县 530800 普洱市 530802 思茅区 530821 宁洱哈尼族彝族自治县 530822 墨江哈尼族自治县 530823 景东彝族自治县 530824 景谷傣族彝族自治县 530825 镇沅彝族哈尼族拉祜族自治县 530826 江城哈尼族彝族自治县 530827 孟连傣族拉祜族佤族自治县 530828 澜沧拉祜族自治县 530829 西盟佤族自治县 530900 临沧市 530902 临翔区 530921 凤庆县 530922 云县 530923 永德县 530924 镇康县 530925 双江拉祜族佤族布朗族傣族自治县 530926 耿马傣族佤族自治县 530927 沧源佤族自治县 532300 楚雄彝族自治州 532301 楚雄市 532322 双柏县 532323 牟定县 532324 南华县 532325 姚安县 532326 大姚县 532327 永仁县 532328 元谋县 532329 武定县 532331 禄丰县 532500 红河哈尼族彝族自治州 532501 个旧市 532502 开远市 532503 蒙自市 532504 弥勒市 532523 屏边苗族自治县 532524 建水县 532525 石屏县 532527 泸西县 532528 元阳县 532529 红河县 532530 金平苗族瑶族傣族自治县 532531 绿春县 532532 河口瑶族自治县 532600 文山壮族苗族自治州 532601 文山市 532622 砚山县 532623 西畴县 532624 麻栗坡县 532625 马关县 532626 丘北县 532627 广南县 532628 富宁县 532800 西双版纳傣族自治州 532801 景洪市 532822 勐海县 532823 勐腊县 532900 大理白族自治州 532901 大理市 532922 漾濞彝族自治县 532923 祥云县 532924 宾川县 532925 弥渡县 532926 南涧彝族自治县 532927 巍山彝族回族自治县 532928 永平县 532929 云龙县 532930 洱源县 532931 剑川县 532932 鹤庆县 533100 德宏傣族景颇族自治州 533102 瑞丽市 533103 芒市 533122 梁河县 533123 盈江县 533124 陇川县 533300 怒江傈僳族自治州 533301 泸水市 533323 福贡县 533324 贡山独龙族怒族自治县 533325 兰坪白族普米族自治县 533400 迪庆藏族自治州 533401 香格里拉市 533422 德钦县 533423 维西傈僳族自治县 540000 西藏自治区 540100 拉萨市 540102 城关区 540103 堆龙德庆区 540104 达孜区 540121 林周县 540122 当雄县 540123 尼木县 540124 曲水县 540127 墨竹工卡县 540200 日喀则市 540202 桑珠孜区 540221 南木林县 540222 江孜县 540223 定日县 540224 萨迦县 540225 拉孜县 540226 昂仁县 540227 谢通门县 540228 白朗县 540229 仁布县 540230 康马县 540231 定结县 540232 仲巴县 540233 亚东县 540234 吉隆县 540235 聂拉木县 540236 萨嘎县 540237 岗巴县 540300 昌都市 540302 卡若区 540321 江达县 540322 贡觉县 540323 类乌齐县 540324 丁青县 540325 察雅县 540326 八宿县 540327 左贡县 540328 芒康县 540329 洛隆县 540330 边坝县 540400 林芝市 540402 巴宜区 540421 工布江达县 540422 米林县 540423 墨脱县 540424 波密县 540425 察隅县 540426 朗县 540500 山南市 540502 乃东区 540521 扎囊县 540522 贡嘎县 540523 桑日县 540524 琼结县 540525 曲松县 540526 措美县 540527 洛扎县 540528 加查县 540529 隆子县 540530 错那县 540531 浪卡子县 540600 那曲市 540602 色尼区 540621 嘉黎县 540622 比如县 540623 聂荣县 540624 安多县 540625 申扎县 540626 索县 540627 班戈县 540628 巴青县 540629 尼玛县 540630 双湖县 542500 阿里地区 542521 普兰县 542522 札达县 542523 噶尔县 542524 日土县 542525 革吉县 542526 改则县 542527 措勤县 610000 陕西省 610100 西安市 610102 新城区 610103 碑林区 610104 莲湖区 610111 灞桥区 610112 未央区 610113 雁塔区 610114 阎良区 610115 临潼区 610116 长安区 610117 高陵区 610118 鄠邑区 610122 蓝田县 610124 周至县 610200 铜川市 610202 王益区 610203 印台区 610204 耀州区 610222 宜君县 610300 宝鸡市 610302 渭滨区 610303 金台区 610304 陈仓区 610322 凤翔县 610323 岐山县 610324 扶风县 610326 眉县 610327 陇县 610328 千阳县 610329 麟游县 610330 凤县 610331 太白县 610400 咸阳市 610402 秦都区 610403 杨陵区 610404 渭城区 610422 三原县 610423 泾阳县 610424 乾县 610425 礼泉县 610426 永寿县 610428 长武县 610429 旬邑县 610430 淳化县 610431 武功县 610481 兴平市 610482 彬州市 610500 渭南市 610502 临渭区 610503 华州区 610522 潼关县 610523 大荔县 610524 合阳县 610525 澄城县 610526 蒲城县 610527 白水县 610528 富平县 610581 韩城市 610582 华阴市 610600 延安市 610602 宝塔区 610603 安塞区 610621 延长县 610622 延川县 610625 志丹县 610626 吴起县 610627 甘泉县 610628 富县 610629 洛川县 610630 宜川县 610631 黄龙县 610632 黄陵县 610681 子长市 610700 汉中市 610702 汉台区 610703 南郑区 610722 城固县 610723 洋县 610724 西乡县 610725 勉县 610726 宁强县 610727 略阳县 610728 镇巴县 610729 留坝县 610730 佛坪县 610800 榆林市 610802 榆阳区 610803 横山区 610822 府谷县 610824 靖边县 610825 定边县 610826 绥德县 610827 米脂县 610828 佳县 610829 吴堡县 610830 清涧县 610831 子洲县 610881 神木市 610900 安康市 610902 汉滨区 610921 汉阴县 610922 石泉县 610923 宁陕县 610924 紫阳县 610925 岚皋县 610926 平利县 610927 镇坪县 610928 旬阳县 610929 白河县 611000 商洛市 611002 商州区 611021 洛南县 611022 丹凤县 611023 商南县 611024 山阳县 611025 镇安县 611026 柞水县 620000 甘肃省 620100 兰州市 620102 城关区 620103 七里河区 620104 西固区 620105 安宁区 620111 红古区 620121 永登县 620122 皋兰县 620123 榆中县 620200 嘉峪关市 620300 金昌市 620302 金川区 620321 永昌县 620400 白银市 620402 白银区 620403 平川区 620421 靖远县 620422 会宁县 620423 景泰县 620500 天水市 620502 秦州区 620503 麦积区 620521 清水县 620522 秦安县 620523 甘谷县 620524 武山县 620525 张家川回族自治县 620600 武威市 620602 凉州区 620621 民勤县 620622 古浪县 620623 天祝藏族自治县 620700 张掖市 620702 甘州区 620721 肃南裕固族自治县 620722 民乐县 620723 临泽县 620724 高台县 620725 山丹县 620800 平凉市 620802 崆峒区 620821 泾川县 620822 灵台县 620823 崇信县 620825 庄浪县 620826 静宁县 620881 华亭市 620900 酒泉市 620902 肃州区 620921 金塔县 620922 瓜州县 620923 肃北蒙古族自治县 620924 阿克塞哈萨克族自治县 620981 玉门市 620982 敦煌市 621000 庆阳市 621002 西峰区 621021 庆城县 621022 环县 621023 华池县 621024 合水县 621025 正宁县 621026 宁县 621027 镇原县 621100 定西市 621102 安定区 621121 通渭县 621122 陇西县 621123 渭源县 621124 临洮县 621125 漳县 621126 岷县 621200 陇南市 621202 武都区 621221 成县 621222 文县 621223 宕昌县 621224 康县 621225 西和县 621226 礼县 621227 徽县 621228 两当县 622900 临夏回族自治州 622901 临夏市 622921 临夏县 622922 康乐县 622923 永靖县 622924 广河县 622925 和政县 622926 东乡族自治县 622927 积石山保安族东乡族撒拉族自治县 623000 甘南藏族自治州 623001 合作市 623021 临潭县 623022 卓尼县 623023 舟曲县 623024 迭部县 623025 玛曲县 623026 碌曲县 623027 夏河县 630000 青海省 630100 西宁市 630102 城东区 630103 城中区 630104 城西区 630105 城北区 630106 湟中区 630121 大通回族土族自治县 630123 湟源县 630200 海东市 630202 乐都区 630203 平安区 630222 民和回族土族自治县 630223 互助土族自治县 630224 化隆回族自治县 630225 循化撒拉族自治县 632200 海北藏族自治州 632221 门源回族自治县 632222 祁连县 632223 海晏县 632224 刚察县 632300 黄南藏族自治州 632321 同仁县 632322 尖扎县 632323 泽库县 632324 河南蒙古族自治县 632500 海南藏族自治州 632521 共和县 632522 同德县 632523 贵德县 632524 兴海县 632525 贵南县 632600 果洛藏族自治州 632621 玛沁县 632622 班玛县 632623 甘德县 632624 达日县 632625 久治县 632626 玛多县 632700 玉树藏族自治州 632701 玉树市 632722 杂多县 632723 称多县 632724 治多县 632725 囊谦县 632726 曲麻莱县 632800 海西蒙古族藏族自治州 632801 格尔木市 632802 德令哈市 632803 茫崖市 632821 乌兰县 632822 都兰县 632823 天峻县 640000 宁夏回族自治区 640100 银川市 640104 兴庆区 640105 西夏区 640106 金凤区 640121 永宁县 640122 贺兰县 640181 灵武市 640200 石嘴山市 640202 大武口区 640205 惠农区 640221 平罗县 640300 吴忠市 640302 利通区 640303 红寺堡区 640323 盐池县 640324 同心县 640381 青铜峡市 640400 固原市 640402 原州区 640422 西吉县 640423 隆德县 640424 泾源县 640425 彭阳县 640500 中卫市 640502 沙坡头区 640521 中宁县 640522 海原县 650000 新疆维吾尔自治区 650100 乌鲁木齐市 650102 天山区 650103 沙依巴克区 650104 新市区 650105 水磨沟区 650106 头屯河区 650107 达坂城区 650109 米东区 650121 乌鲁木齐县 650200 克拉玛依市 650202 独山子区 650203 克拉玛依区 650204 白碱滩区 650205 乌尔禾区 650400 吐鲁番市 650402 高昌区 650421 鄯善县 650422 托克逊县 650500 哈密市 650502 伊州区 650521 巴里坤哈萨克自治县 650522 伊吾县 652300 昌吉回族自治州 652301 昌吉市 652302 阜康市 652323 呼图壁县 652324 玛纳斯县 652325 奇台县 652327 吉木萨尔县 652328 木垒哈萨克自治县 652700 博尔塔拉蒙古自治州 652701 博乐市 652702 阿拉山口市 652722 精河县 652723 温泉县 652800 巴音郭楞蒙古自治州 652801 库尔勒市 652822 轮台县 652823 尉犁县 652824 若羌县 652825 且末县 652826 焉耆回族自治县 652827 和静县 652828 和硕县 652829 博湖县 652900 阿克苏地区 652901 阿克苏市 652902 库车市 652922 温宿县 652924 沙雅县 652925 新和县 652926 拜城县 652927 乌什县 652928 阿瓦提县 652929 柯坪县 653000 克孜勒苏柯尔克孜自治州 653001 阿图什市 653022 阿克陶县 653023 阿合奇县 653024 乌恰县 653100 喀什地区 653101 喀什市 653121 疏附县 653122 疏勒县 653123 英吉沙县 653124 泽普县 653125 莎车县 653126 叶城县 653127 麦盖提县 653128 岳普湖县 653129 伽师县 653130 巴楚县 653131 塔什库尔干塔吉克自治县 653200 和田地区 653201 和田市 653221 和田县 653222 墨玉县 653223 皮山县 653224 洛浦县 653225 策勒县 653226 于田县 653227 民丰县 654000 伊犁哈萨克自治州 654002 伊宁市 654003 奎屯市 654004 霍尔果斯市 654021 伊宁县 654022 察布查尔锡伯自治县 654023 霍城县 654024 巩留县 654025 新源县 654026 昭苏县 654027 特克斯县 654028 尼勒克县 654200 塔城地区 654201 塔城市 654202 乌苏市 654221 额敏县 654223 沙湾县 654224 托里县 654225 裕民县 654226 和布克赛尔蒙古自治县 654300 阿勒泰地区 654301 阿勒泰市 654321 布尔津县 654322 富蕴县 654323 福海县 654324 哈巴河县 654325 青河县 654326 吉木乃县 659001 石河子市 659002 阿拉尔市 659003 图木舒克市 659004 五家渠市 659005 北屯市 659006 铁门关市 659007 双河市 659008 可克达拉市 659009 昆玉市 659010 胡杨河市 710000 台湾省 810000 香港特别行政区 820000 澳门特别行政区 注：1、台湾省、香港特别行政区和澳门特别行政区暂缺地市和区县信息。 2.本表由统计人员每月根据民政统计信息管理系统中上报单位名称变动情况搜集相关文件编制，略滞后于区划调整文件发布时间。 3.为保证上下年度统计工作有效衔接，各级民政统计人员将在当年12月底与区划部门核对并调整统计系统中所有上报单位名称，同时编制发布本表。","raw":"---\ntitle: 2020年1月中华人民共和国县以上行政区划代码\ntoc: true\ndate: 2022-08-24 09:23:33\ntags: [行政区]\ncategories: [工作]\ndescription:\n---\n\nhttps://www.mca.gov.cn/article/sj/xzqh/2020/2020/202003061536.html \n\n\n2020年1月中华人民共和国县以上行政区划代码\t\t\n| 行政区划代码 | 单位名称                       |\n| :----------- | :----------------------------- |\n| 110000       | 北京市                         |\n| 110101       | 东城区                         |\n| 110102       | 西城区                         |\n| 110105       | 朝阳区                         |\n| 110106       | 丰台区                         |\n| 110107       | 石景山区                       |\n| 110108       | 海淀区                         |\n| 110109       | 门头沟区                       |\n| 110111       | 房山区                         |\n| 110112       | 通州区                         |\n| 110113       | 顺义区                         |\n| 110114       | 昌平区                         |\n| 110115       | 大兴区                         |\n| 110116       | 怀柔区                         |\n| 110117       | 平谷区                         |\n| 110118       | 密云区                         |\n| 110119       | 延庆区                         |\n| 120000       | 天津市                         |\n| 120101       | 和平区                         |\n| 120102       | 河东区                         |\n| 120103       | 河西区                         |\n| 120104       | 南开区                         |\n| 120105       | 河北区                         |\n| 120106       | 红桥区                         |\n| 120110       | 东丽区                         |\n| 120111       | 西青区                         |\n| 120112       | 津南区                         |\n| 120113       | 北辰区                         |\n| 120114       | 武清区                         |\n| 120115       | 宝坻区                         |\n| 120116       | 滨海新区                       |\n| 120117       | 宁河区                         |\n| 120118       | 静海区                         |\n| 120119       | 蓟州区                         |\n| 130000       | 河北省                         |\n| 130100       | 石家庄市                       |\n| 130102       | 长安区                         |\n| 130104       | 桥西区                         |\n| 130105       | 新华区                         |\n| 130107       | 井陉矿区                       |\n| 130108       | 裕华区                         |\n| 130109       | 藁城区                         |\n| 130110       | 鹿泉区                         |\n| 130111       | 栾城区                         |\n| 130121       | 井陉县                         |\n| 130123       | 正定县                         |\n| 130125       | 行唐县                         |\n| 130126       | 灵寿县                         |\n| 130127       | 高邑县                         |\n| 130128       | 深泽县                         |\n| 130129       | 赞皇县                         |\n| 130130       | 无极县                         |\n| 130131       | 平山县                         |\n| 130132       | 元氏县                         |\n| 130133       | 赵县                           |\n| 130181       | 辛集市                         |\n| 130183       | 晋州市                         |\n| 130184       | 新乐市                         |\n| 130200       | 唐山市                         |\n| 130202       | 路南区                         |\n| 130203       | 路北区                         |\n| 130204       | 古冶区                         |\n| 130205       | 开平区                         |\n| 130207       | 丰南区                         |\n| 130208       | 丰润区                         |\n| 130209       | 曹妃甸区                       |\n| 130224       | 滦南县                         |\n| 130225       | 乐亭县                         |\n| 130227       | 迁西县                         |\n| 130229       | 玉田县                         |\n| 130281       | 遵化市                         |\n| 130283       | 迁安市                         |\n| 130284       | 滦州市                         |\n| 130300       | 秦皇岛市                       |\n| 130302       | 海港区                         |\n| 130303       | 山海关区                       |\n| 130304       | 北戴河区                       |\n| 130306       | 抚宁区                         |\n| 130321       | 青龙满族自治县                 |\n| 130322       | 昌黎县                         |\n| 130324       | 卢龙县                         |\n| 130400       | 邯郸市                         |\n| 130402       | 邯山区                         |\n| 130403       | 丛台区                         |\n| 130404       | 复兴区                         |\n| 130406       | 峰峰矿区                       |\n| 130407       | 肥乡区                         |\n| 130408       | 永年区                         |\n| 130423       | 临漳县                         |\n| 130424       | 成安县                         |\n| 130425       | 大名县                         |\n| 130426       | 涉县                           |\n| 130427       | 磁县                           |\n| 130430       | 邱县                           |\n| 130431       | 鸡泽县                         |\n| 130432       | 广平县                         |\n| 130433       | 馆陶县                         |\n| 130434       | 魏县                           |\n| 130435       | 曲周县                         |\n| 130481       | 武安市                         |\n| 130500       | 邢台市                         |\n| 130502       | 桥东区                         |\n| 130503       | 桥西区                         |\n| 130521       | 邢台县                         |\n| 130522       | 临城县                         |\n| 130523       | 内丘县                         |\n| 130524       | 柏乡县                         |\n| 130525       | 隆尧县                         |\n| 130526       | 任县                           |\n| 130527       | 南和县                         |\n| 130528       | 宁晋县                         |\n| 130529       | 巨鹿县                         |\n| 130530       | 新河县                         |\n| 130531       | 广宗县                         |\n| 130532       | 平乡县                         |\n| 130533       | 威县                           |\n| 130534       | 清河县                         |\n| 130535       | 临西县                         |\n| 130581       | 南宫市                         |\n| 130582       | 沙河市                         |\n| 130600       | 保定市                         |\n| 130602       | 竞秀区                         |\n| 130606       | 莲池区                         |\n| 130607       | 满城区                         |\n| 130608       | 清苑区                         |\n| 130609       | 徐水区                         |\n| 130623       | 涞水县                         |\n| 130624       | 阜平县                         |\n| 130626       | 定兴县                         |\n| 130627       | 唐县                           |\n| 130628       | 高阳县                         |\n| 130629       | 容城县                         |\n| 130630       | 涞源县                         |\n| 130631       | 望都县                         |\n| 130632       | 安新县                         |\n| 130633       | 易县                           |\n| 130634       | 曲阳县                         |\n| 130635       | 蠡县                           |\n| 130636       | 顺平县                         |\n| 130637       | 博野县                         |\n| 130638       | 雄县                           |\n| 130681       | 涿州市                         |\n| 130682       | 定州市                         |\n| 130683       | 安国市                         |\n| 130684       | 高碑店市                       |\n| 130700       | 张家口市                       |\n| 130702       | 桥东区                         |\n| 130703       | 桥西区                         |\n| 130705       | 宣化区                         |\n| 130706       | 下花园区                       |\n| 130708       | 万全区                         |\n| 130709       | 崇礼区                         |\n| 130722       | 张北县                         |\n| 130723       | 康保县                         |\n| 130724       | 沽源县                         |\n| 130725       | 尚义县                         |\n| 130726       | 蔚县                           |\n| 130727       | 阳原县                         |\n| 130728       | 怀安县                         |\n| 130730       | 怀来县                         |\n| 130731       | 涿鹿县                         |\n| 130732       | 赤城县                         |\n| 130800       | 承德市                         |\n| 130802       | 双桥区                         |\n| 130803       | 双滦区                         |\n| 130804       | 鹰手营子矿区                   |\n| 130821       | 承德县                         |\n| 130822       | 兴隆县                         |\n| 130824       | 滦平县                         |\n| 130825       | 隆化县                         |\n| 130826       | 丰宁满族自治县                 |\n| 130827       | 宽城满族自治县                 |\n| 130828       | 围场满族蒙古族自治县           |\n| 130881       | 平泉市                         |\n| 130900       | 沧州市                         |\n| 130902       | 新华区                         |\n| 130903       | 运河区                         |\n| 130921       | 沧县                           |\n| 130922       | 青县                           |\n| 130923       | 东光县                         |\n| 130924       | 海兴县                         |\n| 130925       | 盐山县                         |\n| 130926       | 肃宁县                         |\n| 130927       | 南皮县                         |\n| 130928       | 吴桥县                         |\n| 130929       | 献县                           |\n| 130930       | 孟村回族自治县                 |\n| 130981       | 泊头市                         |\n| 130982       | 任丘市                         |\n| 130983       | 黄骅市                         |\n| 130984       | 河间市                         |\n| 131000       | 廊坊市                         |\n| 131002       | 安次区                         |\n| 131003       | 广阳区                         |\n| 131022       | 固安县                         |\n| 131023       | 永清县                         |\n| 131024       | 香河县                         |\n| 131025       | 大城县                         |\n| 131026       | 文安县                         |\n| 131028       | 大厂回族自治县                 |\n| 131081       | 霸州市                         |\n| 131082       | 三河市                         |\n| 131100       | 衡水市                         |\n| 131102       | 桃城区                         |\n| 131103       | 冀州区                         |\n| 131121       | 枣强县                         |\n| 131122       | 武邑县                         |\n| 131123       | 武强县                         |\n| 131124       | 饶阳县                         |\n| 131125       | 安平县                         |\n| 131126       | 故城县                         |\n| 131127       | 景县                           |\n| 131128       | 阜城县                         |\n| 131182       | 深州市                         |\n| 140000       | 山西省                         |\n| 140100       | 太原市                         |\n| 140105       | 小店区                         |\n| 140106       | 迎泽区                         |\n| 140107       | 杏花岭区                       |\n| 140108       | 尖草坪区                       |\n| 140109       | 万柏林区                       |\n| 140110       | 晋源区                         |\n| 140121       | 清徐县                         |\n| 140122       | 阳曲县                         |\n| 140123       | 娄烦县                         |\n| 140181       | 古交市                         |\n| 140200       | 大同市                         |\n| 140212       | 新荣区                         |\n| 140213       | 平城区                         |\n| 140214       | 云冈区                         |\n| 140215       | 云州区                         |\n| 140221       | 阳高县                         |\n| 140222       | 天镇县                         |\n| 140223       | 广灵县                         |\n| 140224       | 灵丘县                         |\n| 140225       | 浑源县                         |\n| 140226       | 左云县                         |\n| 140300       | 阳泉市                         |\n| 140302       | 城区                           |\n| 140303       | 矿区                           |\n| 140311       | 郊区                           |\n| 140321       | 平定县                         |\n| 140322       | 盂县                           |\n| 140400       | 长治市                         |\n| 140403       | 潞州区                         |\n| 140404       | 上党区                         |\n| 140405       | 屯留区                         |\n| 140406       | 潞城区                         |\n| 140423       | 襄垣县                         |\n| 140425       | 平顺县                         |\n| 140426       | 黎城县                         |\n| 140427       | 壶关县                         |\n| 140428       | 长子县                         |\n| 140429       | 武乡县                         |\n| 140430       | 沁县                           |\n| 140431       | 沁源县                         |\n| 140500       | 晋城市                         |\n| 140502       | 城区                           |\n| 140521       | 沁水县                         |\n| 140522       | 阳城县                         |\n| 140524       | 陵川县                         |\n| 140525       | 泽州县                         |\n| 140581       | 高平市                         |\n| 140600       | 朔州市                         |\n| 140602       | 朔城区                         |\n| 140603       | 平鲁区                         |\n| 140621       | 山阴县                         |\n| 140622       | 应县                           |\n| 140623       | 右玉县                         |\n| 140681       | 怀仁市                         |\n| 140700       | 晋中市                         |\n| 140702       | 榆次区                         |\n| 140703       | 太谷区                         |\n| 140721       | 榆社县                         |\n| 140722       | 左权县                         |\n| 140723       | 和顺县                         |\n| 140724       | 昔阳县                         |\n| 140725       | 寿阳县                         |\n| 140727       | 祁县                           |\n| 140728       | 平遥县                         |\n| 140729       | 灵石县                         |\n| 140781       | 介休市                         |\n| 140800       | 运城市                         |\n| 140802       | 盐湖区                         |\n| 140821       | 临猗县                         |\n| 140822       | 万荣县                         |\n| 140823       | 闻喜县                         |\n| 140824       | 稷山县                         |\n| 140825       | 新绛县                         |\n| 140826       | 绛县                           |\n| 140827       | 垣曲县                         |\n| 140828       | 夏县                           |\n| 140829       | 平陆县                         |\n| 140830       | 芮城县                         |\n| 140881       | 永济市                         |\n| 140882       | 河津市                         |\n| 140900       | 忻州市                         |\n| 140902       | 忻府区                         |\n| 140921       | 定襄县                         |\n| 140922       | 五台县                         |\n| 140923       | 代县                           |\n| 140924       | 繁峙县                         |\n| 140925       | 宁武县                         |\n| 140926       | 静乐县                         |\n| 140927       | 神池县                         |\n| 140928       | 五寨县                         |\n| 140929       | 岢岚县                         |\n| 140930       | 河曲县                         |\n| 140931       | 保德县                         |\n| 140932       | 偏关县                         |\n| 140981       | 原平市                         |\n| 141000       | 临汾市                         |\n| 141002       | 尧都区                         |\n| 141021       | 曲沃县                         |\n| 141022       | 翼城县                         |\n| 141023       | 襄汾县                         |\n| 141024       | 洪洞县                         |\n| 141025       | 古县                           |\n| 141026       | 安泽县                         |\n| 141027       | 浮山县                         |\n| 141028       | 吉县                           |\n| 141029       | 乡宁县                         |\n| 141030       | 大宁县                         |\n| 141031       | 隰县                           |\n| 141032       | 永和县                         |\n| 141033       | 蒲县                           |\n| 141034       | 汾西县                         |\n| 141081       | 侯马市                         |\n| 141082       | 霍州市                         |\n| 141100       | 吕梁市                         |\n| 141102       | 离石区                         |\n| 141121       | 文水县                         |\n| 141122       | 交城县                         |\n| 141123       | 兴县                           |\n| 141124       | 临县                           |\n| 141125       | 柳林县                         |\n| 141126       | 石楼县                         |\n| 141127       | 岚县                           |\n| 141128       | 方山县                         |\n| 141129       | 中阳县                         |\n| 141130       | 交口县                         |\n| 141181       | 孝义市                         |\n| 141182       | 汾阳市                         |\n| 150000       | 内蒙古自治区                   |\n| 150100       | 呼和浩特市                     |\n| 150102       | 新城区                         |\n| 150103       | 回民区                         |\n| 150104       | 玉泉区                         |\n| 150105       | 赛罕区                         |\n| 150121       | 土默特左旗                     |\n| 150122       | 托克托县                       |\n| 150123       | 和林格尔县                     |\n| 150124       | 清水河县                       |\n| 150125       | 武川县                         |\n| 150200       | 包头市                         |\n| 150202       | 东河区                         |\n| 150203       | 昆都仑区                       |\n| 150204       | 青山区                         |\n| 150205       | 石拐区                         |\n| 150206       | 白云鄂博矿区                   |\n| 150207       | 九原区                         |\n| 150221       | 土默特右旗                     |\n| 150222       | 固阳县                         |\n| 150223       | 达尔罕茂明安联合旗             |\n| 150300       | 乌海市                         |\n| 150302       | 海勃湾区                       |\n| 150303       | 海南区                         |\n| 150304       | 乌达区                         |\n| 150400       | 赤峰市                         |\n| 150402       | 红山区                         |\n| 150403       | 元宝山区                       |\n| 150404       | 松山区                         |\n| 150421       | 阿鲁科尔沁旗                   |\n| 150422       | 巴林左旗                       |\n| 150423       | 巴林右旗                       |\n| 150424       | 林西县                         |\n| 150425       | 克什克腾旗                     |\n| 150426       | 翁牛特旗                       |\n| 150428       | 喀喇沁旗                       |\n| 150429       | 宁城县                         |\n| 150430       | 敖汉旗                         |\n| 150500       | 通辽市                         |\n| 150502       | 科尔沁区                       |\n| 150521       | 科尔沁左翼中旗                 |\n| 150522       | 科尔沁左翼后旗                 |\n| 150523       | 开鲁县                         |\n| 150524       | 库伦旗                         |\n| 150525       | 奈曼旗                         |\n| 150526       | 扎鲁特旗                       |\n| 150581       | 霍林郭勒市                     |\n| 150600       | 鄂尔多斯市                     |\n| 150602       | 东胜区                         |\n| 150603       | 康巴什区                       |\n| 150621       | 达拉特旗                       |\n| 150622       | 准格尔旗                       |\n| 150623       | 鄂托克前旗                     |\n| 150624       | 鄂托克旗                       |\n| 150625       | 杭锦旗                         |\n| 150626       | 乌审旗                         |\n| 150627       | 伊金霍洛旗                     |\n| 150700       | 呼伦贝尔市                     |\n| 150702       | 海拉尔区                       |\n| 150703       | 扎赉诺尔区                     |\n| 150721       | 阿荣旗                         |\n| 150722       | 莫力达瓦达斡尔族自治旗         |\n| 150723       | 鄂伦春自治旗                   |\n| 150724       | 鄂温克族自治旗                 |\n| 150725       | 陈巴尔虎旗                     |\n| 150726       | 新巴尔虎左旗                   |\n| 150727       | 新巴尔虎右旗                   |\n| 150781       | 满洲里市                       |\n| 150782       | 牙克石市                       |\n| 150783       | 扎兰屯市                       |\n| 150784       | 额尔古纳市                     |\n| 150785       | 根河市                         |\n| 150800       | 巴彦淖尔市                     |\n| 150802       | 临河区                         |\n| 150821       | 五原县                         |\n| 150822       | 磴口县                         |\n| 150823       | 乌拉特前旗                     |\n| 150824       | 乌拉特中旗                     |\n| 150825       | 乌拉特后旗                     |\n| 150826       | 杭锦后旗                       |\n| 150900       | 乌兰察布市                     |\n| 150902       | 集宁区                         |\n| 150921       | 卓资县                         |\n| 150922       | 化德县                         |\n| 150923       | 商都县                         |\n| 150924       | 兴和县                         |\n| 150925       | 凉城县                         |\n| 150926       | 察哈尔右翼前旗                 |\n| 150927       | 察哈尔右翼中旗                 |\n| 150928       | 察哈尔右翼后旗                 |\n| 150929       | 四子王旗                       |\n| 150981       | 丰镇市                         |\n| 152200       | 兴安盟                         |\n| 152201       | 乌兰浩特市                     |\n| 152202       | 阿尔山市                       |\n| 152221       | 科尔沁右翼前旗                 |\n| 152222       | 科尔沁右翼中旗                 |\n| 152223       | 扎赉特旗                       |\n| 152224       | 突泉县                         |\n| 152500       | 锡林郭勒盟                     |\n| 152501       | 二连浩特市                     |\n| 152502       | 锡林浩特市                     |\n| 152522       | 阿巴嘎旗                       |\n| 152523       | 苏尼特左旗                     |\n| 152524       | 苏尼特右旗                     |\n| 152525       | 东乌珠穆沁旗                   |\n| 152526       | 西乌珠穆沁旗                   |\n| 152527       | 太仆寺旗                       |\n| 152528       | 镶黄旗                         |\n| 152529       | 正镶白旗                       |\n| 152530       | 正蓝旗                         |\n| 152531       | 多伦县                         |\n| 152900       | 阿拉善盟                       |\n| 152921       | 阿拉善左旗                     |\n| 152922       | 阿拉善右旗                     |\n| 152923       | 额济纳旗                       |\n| 210000       | 辽宁省                         |\n| 210100       | 沈阳市                         |\n| 210102       | 和平区                         |\n| 210103       | 沈河区                         |\n| 210104       | 大东区                         |\n| 210105       | 皇姑区                         |\n| 210106       | 铁西区                         |\n| 210111       | 苏家屯区                       |\n| 210112       | 浑南区                         |\n| 210113       | 沈北新区                       |\n| 210114       | 于洪区                         |\n| 210115       | 辽中区                         |\n| 210123       | 康平县                         |\n| 210124       | 法库县                         |\n| 210181       | 新民市                         |\n| 210200       | 大连市                         |\n| 210202       | 中山区                         |\n| 210203       | 西岗区                         |\n| 210204       | 沙河口区                       |\n| 210211       | 甘井子区                       |\n| 210212       | 旅顺口区                       |\n| 210213       | 金州区                         |\n| 210214       | 普兰店区                       |\n| 210224       | 长海县                         |\n| 210281       | 瓦房店市                       |\n| 210283       | 庄河市                         |\n| 210300       | 鞍山市                         |\n| 210302       | 铁东区                         |\n| 210303       | 铁西区                         |\n| 210304       | 立山区                         |\n| 210311       | 千山区                         |\n| 210321       | 台安县                         |\n| 210323       | 岫岩满族自治县                 |\n| 210381       | 海城市                         |\n| 210400       | 抚顺市                         |\n| 210402       | 新抚区                         |\n| 210403       | 东洲区                         |\n| 210404       | 望花区                         |\n| 210411       | 顺城区                         |\n| 210421       | 抚顺县                         |\n| 210422       | 新宾满族自治县                 |\n| 210423       | 清原满族自治县                 |\n| 210500       | 本溪市                         |\n| 210502       | 平山区                         |\n| 210503       | 溪湖区                         |\n| 210504       | 明山区                         |\n| 210505       | 南芬区                         |\n| 210521       | 本溪满族自治县                 |\n| 210522       | 桓仁满族自治县                 |\n| 210600       | 丹东市                         |\n| 210602       | 元宝区                         |\n| 210603       | 振兴区                         |\n| 210604       | 振安区                         |\n| 210624       | 宽甸满族自治县                 |\n| 210681       | 东港市                         |\n| 210682       | 凤城市                         |\n| 210700       | 锦州市                         |\n| 210702       | 古塔区                         |\n| 210703       | 凌河区                         |\n| 210711       | 太和区                         |\n| 210726       | 黑山县                         |\n| 210727       | 义县                           |\n| 210781       | 凌海市                         |\n| 210782       | 北镇市                         |\n| 210800       | 营口市                         |\n| 210802       | 站前区                         |\n| 210803       | 西市区                         |\n| 210804       | 鲅鱼圈区                       |\n| 210811       | 老边区                         |\n| 210881       | 盖州市                         |\n| 210882       | 大石桥市                       |\n| 210900       | 阜新市                         |\n| 210902       | 海州区                         |\n| 210903       | 新邱区                         |\n| 210904       | 太平区                         |\n| 210905       | 清河门区                       |\n| 210911       | 细河区                         |\n| 210921       | 阜新蒙古族自治县               |\n| 210922       | 彰武县                         |\n| 211000       | 辽阳市                         |\n| 211002       | 白塔区                         |\n| 211003       | 文圣区                         |\n| 211004       | 宏伟区                         |\n| 211005       | 弓长岭区                       |\n| 211011       | 太子河区                       |\n| 211021       | 辽阳县                         |\n| 211081       | 灯塔市                         |\n| 211100       | 盘锦市                         |\n| 211102       | 双台子区                       |\n| 211103       | 兴隆台区                       |\n| 211104       | 大洼区                         |\n| 211122       | 盘山县                         |\n| 211200       | 铁岭市                         |\n| 211202       | 银州区                         |\n| 211204       | 清河区                         |\n| 211221       | 铁岭县                         |\n| 211223       | 西丰县                         |\n| 211224       | 昌图县                         |\n| 211281       | 调兵山市                       |\n| 211282       | 开原市                         |\n| 211300       | 朝阳市                         |\n| 211302       | 双塔区                         |\n| 211303       | 龙城区                         |\n| 211321       | 朝阳县                         |\n| 211322       | 建平县                         |\n| 211324       | 喀喇沁左翼蒙古族自治县         |\n| 211381       | 北票市                         |\n| 211382       | 凌源市                         |\n| 211400       | 葫芦岛市                       |\n| 211402       | 连山区                         |\n| 211403       | 龙港区                         |\n| 211404       | 南票区                         |\n| 211421       | 绥中县                         |\n| 211422       | 建昌县                         |\n| 211481       | 兴城市                         |\n| 220000       | 吉林省                         |\n| 220100       | 长春市                         |\n| 220102       | 南关区                         |\n| 220103       | 宽城区                         |\n| 220104       | 朝阳区                         |\n| 220105       | 二道区                         |\n| 220106       | 绿园区                         |\n| 220112       | 双阳区                         |\n| 220113       | 九台区                         |\n| 220122       | 农安县                         |\n| 220182       | 榆树市                         |\n| 220183       | 德惠市                         |\n| 220200       | 吉林市                         |\n| 220202       | 昌邑区                         |\n| 220203       | 龙潭区                         |\n| 220204       | 船营区                         |\n| 220211       | 丰满区                         |\n| 220221       | 永吉县                         |\n| 220281       | 蛟河市                         |\n| 220282       | 桦甸市                         |\n| 220283       | 舒兰市                         |\n| 220284       | 磐石市                         |\n| 220300       | 四平市                         |\n| 220302       | 铁西区                         |\n| 220303       | 铁东区                         |\n| 220322       | 梨树县                         |\n| 220323       | 伊通满族自治县                 |\n| 220381       | 公主岭市                       |\n| 220382       | 双辽市                         |\n| 220400       | 辽源市                         |\n| 220402       | 龙山区                         |\n| 220403       | 西安区                         |\n| 220421       | 东丰县                         |\n| 220422       | 东辽县                         |\n| 220500       | 通化市                         |\n| 220502       | 东昌区                         |\n| 220503       | 二道江区                       |\n| 220521       | 通化县                         |\n| 220523       | 辉南县                         |\n| 220524       | 柳河县                         |\n| 220581       | 梅河口市                       |\n| 220582       | 集安市                         |\n| 220600       | 白山市                         |\n| 220602       | 浑江区                         |\n| 220605       | 江源区                         |\n| 220621       | 抚松县                         |\n| 220622       | 靖宇县                         |\n| 220623       | 长白朝鲜族自治县               |\n| 220681       | 临江市                         |\n| 220700       | 松原市                         |\n| 220702       | 宁江区                         |\n| 220721       | 前郭尔罗斯蒙古族自治县         |\n| 220722       | 长岭县                         |\n| 220723       | 乾安县                         |\n| 220781       | 扶余市                         |\n| 220800       | 白城市                         |\n| 220802       | 洮北区                         |\n| 220821       | 镇赉县                         |\n| 220822       | 通榆县                         |\n| 220881       | 洮南市                         |\n| 220882       | 大安市                         |\n| 222400       | 延边朝鲜族自治州               |\n| 222401       | 延吉市                         |\n| 222402       | 图们市                         |\n| 222403       | 敦化市                         |\n| 222404       | 珲春市                         |\n| 222405       | 龙井市                         |\n| 222406       | 和龙市                         |\n| 222424       | 汪清县                         |\n| 222426       | 安图县                         |\n| 230000       | 黑龙江省                       |\n| 230100       | 哈尔滨市                       |\n| 230102       | 道里区                         |\n| 230103       | 南岗区                         |\n| 230104       | 道外区                         |\n| 230108       | 平房区                         |\n| 230109       | 松北区                         |\n| 230110       | 香坊区                         |\n| 230111       | 呼兰区                         |\n| 230112       | 阿城区                         |\n| 230113       | 双城区                         |\n| 230123       | 依兰县                         |\n| 230124       | 方正县                         |\n| 230125       | 宾县                           |\n| 230126       | 巴彦县                         |\n| 230127       | 木兰县                         |\n| 230128       | 通河县                         |\n| 230129       | 延寿县                         |\n| 230183       | 尚志市                         |\n| 230184       | 五常市                         |\n| 230200       | 齐齐哈尔市                     |\n| 230202       | 龙沙区                         |\n| 230203       | 建华区                         |\n| 230204       | 铁锋区                         |\n| 230205       | 昂昂溪区                       |\n| 230206       | 富拉尔基区                     |\n| 230207       | 碾子山区                       |\n| 230208       | 梅里斯达斡尔族区               |\n| 230221       | 龙江县                         |\n| 230223       | 依安县                         |\n| 230224       | 泰来县                         |\n| 230225       | 甘南县                         |\n| 230227       | 富裕县                         |\n| 230229       | 克山县                         |\n| 230230       | 克东县                         |\n| 230231       | 拜泉县                         |\n| 230281       | 讷河市                         |\n| 230300       | 鸡西市                         |\n| 230302       | 鸡冠区                         |\n| 230303       | 恒山区                         |\n| 230304       | 滴道区                         |\n| 230305       | 梨树区                         |\n| 230306       | 城子河区                       |\n| 230307       | 麻山区                         |\n| 230321       | 鸡东县                         |\n| 230381       | 虎林市                         |\n| 230382       | 密山市                         |\n| 230400       | 鹤岗市                         |\n| 230402       | 向阳区                         |\n| 230403       | 工农区                         |\n| 230404       | 南山区                         |\n| 230405       | 兴安区                         |\n| 230406       | 东山区                         |\n| 230407       | 兴山区                         |\n| 230421       | 萝北县                         |\n| 230422       | 绥滨县                         |\n| 230500       | 双鸭山市                       |\n| 230502       | 尖山区                         |\n| 230503       | 岭东区                         |\n| 230505       | 四方台区                       |\n| 230506       | 宝山区                         |\n| 230521       | 集贤县                         |\n| 230522       | 友谊县                         |\n| 230523       | 宝清县                         |\n| 230524       | 饶河县                         |\n| 230600       | 大庆市                         |\n| 230602       | 萨尔图区                       |\n| 230603       | 龙凤区                         |\n| 230604       | 让胡路区                       |\n| 230605       | 红岗区                         |\n| 230606       | 大同区                         |\n| 230621       | 肇州县                         |\n| 230622       | 肇源县                         |\n| 230623       | 林甸县                         |\n| 230624       | 杜尔伯特蒙古族自治县           |\n| 230700       | 伊春市                         |\n| 230717       | 伊美区                         |\n| 230718       | 乌翠区                         |\n| 230719       | 友好区                         |\n| 230722       | 嘉荫县                         |\n| 230723       | 汤旺县                         |\n| 230724       | 丰林县                         |\n| 230725       | 大箐山县                       |\n| 230726       | 南岔县                         |\n| 230751       | 金林区                         |\n| 230781       | 铁力市                         |\n| 230800       | 佳木斯市                       |\n| 230803       | 向阳区                         |\n| 230804       | 前进区                         |\n| 230805       | 东风区                         |\n| 230811       | 郊区                           |\n| 230822       | 桦南县                         |\n| 230826       | 桦川县                         |\n| 230828       | 汤原县                         |\n| 230881       | 同江市                         |\n| 230882       | 富锦市                         |\n| 230883       | 抚远市                         |\n| 230900       | 七台河市                       |\n| 230902       | 新兴区                         |\n| 230903       | 桃山区                         |\n| 230904       | 茄子河区                       |\n| 230921       | 勃利县                         |\n| 231000       | 牡丹江市                       |\n| 231002       | 东安区                         |\n| 231003       | 阳明区                         |\n| 231004       | 爱民区                         |\n| 231005       | 西安区                         |\n| 231025       | 林口县                         |\n| 231081       | 绥芬河市                       |\n| 231083       | 海林市                         |\n| 231084       | 宁安市                         |\n| 231085       | 穆棱市                         |\n| 231086       | 东宁市                         |\n| 231100       | 黑河市                         |\n| 231102       | 爱辉区                         |\n| 231123       | 逊克县                         |\n| 231124       | 孙吴县                         |\n| 231181       | 北安市                         |\n| 231182       | 五大连池市                     |\n| 231183       | 嫩江市                         |\n| 231200       | 绥化市                         |\n| 231202       | 北林区                         |\n| 231221       | 望奎县                         |\n| 231222       | 兰西县                         |\n| 231223       | 青冈县                         |\n| 231224       | 庆安县                         |\n| 231225       | 明水县                         |\n| 231226       | 绥棱县                         |\n| 231281       | 安达市                         |\n| 231282       | 肇东市                         |\n| 231283       | 海伦市                         |\n| 232700       | 大兴安岭地区                   |\n| 232701       | 漠河市                         |\n| 232721       | 呼玛县                         |\n| 232722       | 塔河县                         |\n| 310000       | 上海市                         |\n| 310101       | 黄浦区                         |\n| 310104       | 徐汇区                         |\n| 310105       | 长宁区                         |\n| 310106       | 静安区                         |\n| 310107       | 普陀区                         |\n| 310109       | 虹口区                         |\n| 310110       | 杨浦区                         |\n| 310112       | 闵行区                         |\n| 310113       | 宝山区                         |\n| 310114       | 嘉定区                         |\n| 310115       | 浦东新区                       |\n| 310116       | 金山区                         |\n| 310117       | 松江区                         |\n| 310118       | 青浦区                         |\n| 310120       | 奉贤区                         |\n| 310151       | 崇明区                         |\n| 320000       | 江苏省                         |\n| 320100       | 南京市                         |\n| 320102       | 玄武区                         |\n| 320104       | 秦淮区                         |\n| 320105       | 建邺区                         |\n| 320106       | 鼓楼区                         |\n| 320111       | 浦口区                         |\n| 320113       | 栖霞区                         |\n| 320114       | 雨花台区                       |\n| 320115       | 江宁区                         |\n| 320116       | 六合区                         |\n| 320117       | 溧水区                         |\n| 320118       | 高淳区                         |\n| 320200       | 无锡市                         |\n| 320205       | 锡山区                         |\n| 320206       | 惠山区                         |\n| 320211       | 滨湖区                         |\n| 320213       | 梁溪区                         |\n| 320214       | 新吴区                         |\n| 320281       | 江阴市                         |\n| 320282       | 宜兴市                         |\n| 320300       | 徐州市                         |\n| 320302       | 鼓楼区                         |\n| 320303       | 云龙区                         |\n| 320305       | 贾汪区                         |\n| 320311       | 泉山区                         |\n| 320312       | 铜山区                         |\n| 320321       | 丰县                           |\n| 320322       | 沛县                           |\n| 320324       | 睢宁县                         |\n| 320381       | 新沂市                         |\n| 320382       | 邳州市                         |\n| 320400       | 常州市                         |\n| 320402       | 天宁区                         |\n| 320404       | 钟楼区                         |\n| 320411       | 新北区                         |\n| 320412       | 武进区                         |\n| 320413       | 金坛区                         |\n| 320481       | 溧阳市                         |\n| 320500       | 苏州市                         |\n| 320505       | 虎丘区                         |\n| 320506       | 吴中区                         |\n| 320507       | 相城区                         |\n| 320508       | 姑苏区                         |\n| 320509       | 吴江区                         |\n| 320581       | 常熟市                         |\n| 320582       | 张家港市                       |\n| 320583       | 昆山市                         |\n| 320585       | 太仓市                         |\n| 320600       | 南通市                         |\n| 320602       | 崇川区                         |\n| 320611       | 港闸区                         |\n| 320612       | 通州区                         |\n| 320623       | 如东县                         |\n| 320681       | 启东市                         |\n| 320682       | 如皋市                         |\n| 320684       | 海门市                         |\n| 320685       | 海安市                         |\n| 320700       | 连云港市                       |\n| 320703       | 连云区                         |\n| 320706       | 海州区                         |\n| 320707       | 赣榆区                         |\n| 320722       | 东海县                         |\n| 320723       | 灌云县                         |\n| 320724       | 灌南县                         |\n| 320800       | 淮安市                         |\n| 320803       | 淮安区                         |\n| 320804       | 淮阴区                         |\n| 320812       | 清江浦区                       |\n| 320813       | 洪泽区                         |\n| 320826       | 涟水县                         |\n| 320830       | 盱眙县                         |\n| 320831       | 金湖县                         |\n| 320900       | 盐城市                         |\n| 320902       | 亭湖区                         |\n| 320903       | 盐都区                         |\n| 320904       | 大丰区                         |\n| 320921       | 响水县                         |\n| 320922       | 滨海县                         |\n| 320923       | 阜宁县                         |\n| 320924       | 射阳县                         |\n| 320925       | 建湖县                         |\n| 320981       | 东台市                         |\n| 321000       | 扬州市                         |\n| 321002       | 广陵区                         |\n| 321003       | 邗江区                         |\n| 321012       | 江都区                         |\n| 321023       | 宝应县                         |\n| 321081       | 仪征市                         |\n| 321084       | 高邮市                         |\n| 321100       | 镇江市                         |\n| 321102       | 京口区                         |\n| 321111       | 润州区                         |\n| 321112       | 丹徒区                         |\n| 321181       | 丹阳市                         |\n| 321182       | 扬中市                         |\n| 321183       | 句容市                         |\n| 321200       | 泰州市                         |\n| 321202       | 海陵区                         |\n| 321203       | 高港区                         |\n| 321204       | 姜堰区                         |\n| 321281       | 兴化市                         |\n| 321282       | 靖江市                         |\n| 321283       | 泰兴市                         |\n| 321300       | 宿迁市                         |\n| 321302       | 宿城区                         |\n| 321311       | 宿豫区                         |\n| 321322       | 沭阳县                         |\n| 321323       | 泗阳县                         |\n| 321324       | 泗洪县                         |\n| 330000       | 浙江省                         |\n| 330100       | 杭州市                         |\n| 330102       | 上城区                         |\n| 330103       | 下城区                         |\n| 330104       | 江干区                         |\n| 330105       | 拱墅区                         |\n| 330106       | 西湖区                         |\n| 330108       | 滨江区                         |\n| 330109       | 萧山区                         |\n| 330110       | 余杭区                         |\n| 330111       | 富阳区                         |\n| 330112       | 临安区                         |\n| 330122       | 桐庐县                         |\n| 330127       | 淳安县                         |\n| 330182       | 建德市                         |\n| 330200       | 宁波市                         |\n| 330203       | 海曙区                         |\n| 330205       | 江北区                         |\n| 330206       | 北仑区                         |\n| 330211       | 镇海区                         |\n| 330212       | 鄞州区                         |\n| 330213       | 奉化区                         |\n| 330225       | 象山县                         |\n| 330226       | 宁海县                         |\n| 330281       | 余姚市                         |\n| 330282       | 慈溪市                         |\n| 330300       | 温州市                         |\n| 330302       | 鹿城区                         |\n| 330303       | 龙湾区                         |\n| 330304       | 瓯海区                         |\n| 330305       | 洞头区                         |\n| 330324       | 永嘉县                         |\n| 330326       | 平阳县                         |\n| 330327       | 苍南县                         |\n| 330328       | 文成县                         |\n| 330329       | 泰顺县                         |\n| 330381       | 瑞安市                         |\n| 330382       | 乐清市                         |\n| 330383       | 龙港市                         |\n| 330400       | 嘉兴市                         |\n| 330402       | 南湖区                         |\n| 330411       | 秀洲区                         |\n| 330421       | 嘉善县                         |\n| 330424       | 海盐县                         |\n| 330481       | 海宁市                         |\n| 330482       | 平湖市                         |\n| 330483       | 桐乡市                         |\n| 330500       | 湖州市                         |\n| 330502       | 吴兴区                         |\n| 330503       | 南浔区                         |\n| 330521       | 德清县                         |\n| 330522       | 长兴县                         |\n| 330523       | 安吉县                         |\n| 330600       | 绍兴市                         |\n| 330602       | 越城区                         |\n| 330603       | 柯桥区                         |\n| 330604       | 上虞区                         |\n| 330624       | 新昌县                         |\n| 330681       | 诸暨市                         |\n| 330683       | 嵊州市                         |\n| 330700       | 金华市                         |\n| 330702       | 婺城区                         |\n| 330703       | 金东区                         |\n| 330723       | 武义县                         |\n| 330726       | 浦江县                         |\n| 330727       | 磐安县                         |\n| 330781       | 兰溪市                         |\n| 330782       | 义乌市                         |\n| 330783       | 东阳市                         |\n| 330784       | 永康市                         |\n| 330800       | 衢州市                         |\n| 330802       | 柯城区                         |\n| 330803       | 衢江区                         |\n| 330822       | 常山县                         |\n| 330824       | 开化县                         |\n| 330825       | 龙游县                         |\n| 330881       | 江山市                         |\n| 330900       | 舟山市                         |\n| 330902       | 定海区                         |\n| 330903       | 普陀区                         |\n| 330921       | 岱山县                         |\n| 330922       | 嵊泗县                         |\n| 331000       | 台州市                         |\n| 331002       | 椒江区                         |\n| 331003       | 黄岩区                         |\n| 331004       | 路桥区                         |\n| 331022       | 三门县                         |\n| 331023       | 天台县                         |\n| 331024       | 仙居县                         |\n| 331081       | 温岭市                         |\n| 331082       | 临海市                         |\n| 331083       | 玉环市                         |\n| 331100       | 丽水市                         |\n| 331102       | 莲都区                         |\n| 331121       | 青田县                         |\n| 331122       | 缙云县                         |\n| 331123       | 遂昌县                         |\n| 331124       | 松阳县                         |\n| 331125       | 云和县                         |\n| 331126       | 庆元县                         |\n| 331127       | 景宁畲族自治县                 |\n| 331181       | 龙泉市                         |\n| 340000       | 安徽省                         |\n| 340100       | 合肥市                         |\n| 340102       | 瑶海区                         |\n| 340103       | 庐阳区                         |\n| 340104       | 蜀山区                         |\n| 340111       | 包河区                         |\n| 340121       | 长丰县                         |\n| 340122       | 肥东县                         |\n| 340123       | 肥西县                         |\n| 340124       | 庐江县                         |\n| 340181       | 巢湖市                         |\n| 340200       | 芜湖市                         |\n| 340202       | 镜湖区                         |\n| 340203       | 弋江区                         |\n| 340207       | 鸠江区                         |\n| 340208       | 三山区                         |\n| 340221       | 芜湖县                         |\n| 340222       | 繁昌县                         |\n| 340223       | 南陵县                         |\n| 340281       | 无为市                         |\n| 340300       | 蚌埠市                         |\n| 340302       | 龙子湖区                       |\n| 340303       | 蚌山区                         |\n| 340304       | 禹会区                         |\n| 340311       | 淮上区                         |\n| 340321       | 怀远县                         |\n| 340322       | 五河县                         |\n| 340323       | 固镇县                         |\n| 340400       | 淮南市                         |\n| 340402       | 大通区                         |\n| 340403       | 田家庵区                       |\n| 340404       | 谢家集区                       |\n| 340405       | 八公山区                       |\n| 340406       | 潘集区                         |\n| 340421       | 凤台县                         |\n| 340422       | 寿县                           |\n| 340500       | 马鞍山市                       |\n| 340503       | 花山区                         |\n| 340504       | 雨山区                         |\n| 340506       | 博望区                         |\n| 340521       | 当涂县                         |\n| 340522       | 含山县                         |\n| 340523       | 和县                           |\n| 340600       | 淮北市                         |\n| 340602       | 杜集区                         |\n| 340603       | 相山区                         |\n| 340604       | 烈山区                         |\n| 340621       | 濉溪县                         |\n| 340700       | 铜陵市                         |\n| 340705       | 铜官区                         |\n| 340706       | 义安区                         |\n| 340711       | 郊区                           |\n| 340722       | 枞阳县                         |\n| 340800       | 安庆市                         |\n| 340802       | 迎江区                         |\n| 340803       | 大观区                         |\n| 340811       | 宜秀区                         |\n| 340822       | 怀宁县                         |\n| 340825       | 太湖县                         |\n| 340826       | 宿松县                         |\n| 340827       | 望江县                         |\n| 340828       | 岳西县                         |\n| 340881       | 桐城市                         |\n| 340882       | 潜山市                         |\n| 341000       | 黄山市                         |\n| 341002       | 屯溪区                         |\n| 341003       | 黄山区                         |\n| 341004       | 徽州区                         |\n| 341021       | 歙县                           |\n| 341022       | 休宁县                         |\n| 341023       | 黟县                           |\n| 341024       | 祁门县                         |\n| 341100       | 滁州市                         |\n| 341102       | 琅琊区                         |\n| 341103       | 南谯区                         |\n| 341122       | 来安县                         |\n| 341124       | 全椒县                         |\n| 341125       | 定远县                         |\n| 341126       | 凤阳县                         |\n| 341181       | 天长市                         |\n| 341182       | 明光市                         |\n| 341200       | 阜阳市                         |\n| 341202       | 颍州区                         |\n| 341203       | 颍东区                         |\n| 341204       | 颍泉区                         |\n| 341221       | 临泉县                         |\n| 341222       | 太和县                         |\n| 341225       | 阜南县                         |\n| 341226       | 颍上县                         |\n| 341282       | 界首市                         |\n| 341300       | 宿州市                         |\n| 341302       | 埇桥区                         |\n| 341321       | 砀山县                         |\n| 341322       | 萧县                           |\n| 341323       | 灵璧县                         |\n| 341324       | 泗县                           |\n| 341500       | 六安市                         |\n| 341502       | 金安区                         |\n| 341503       | 裕安区                         |\n| 341504       | 叶集区                         |\n| 341522       | 霍邱县                         |\n| 341523       | 舒城县                         |\n| 341524       | 金寨县                         |\n| 341525       | 霍山县                         |\n| 341600       | 亳州市                         |\n| 341602       | 谯城区                         |\n| 341621       | 涡阳县                         |\n| 341622       | 蒙城县                         |\n| 341623       | 利辛县                         |\n| 341700       | 池州市                         |\n| 341702       | 贵池区                         |\n| 341721       | 东至县                         |\n| 341722       | 石台县                         |\n| 341723       | 青阳县                         |\n| 341800       | 宣城市                         |\n| 341802       | 宣州区                         |\n| 341821       | 郎溪县                         |\n| 341823       | 泾县                           |\n| 341824       | 绩溪县                         |\n| 341825       | 旌德县                         |\n| 341881       | 宁国市                         |\n| 341882       | 广德市                         |\n| 350000       | 福建省                         |\n| 350100       | 福州市                         |\n| 350102       | 鼓楼区                         |\n| 350103       | 台江区                         |\n| 350104       | 仓山区                         |\n| 350105       | 马尾区                         |\n| 350111       | 晋安区                         |\n| 350112       | 长乐区                         |\n| 350121       | 闽侯县                         |\n| 350122       | 连江县                         |\n| 350123       | 罗源县                         |\n| 350124       | 闽清县                         |\n| 350125       | 永泰县                         |\n| 350128       | 平潭县                         |\n| 350181       | 福清市                         |\n| 350200       | 厦门市                         |\n| 350203       | 思明区                         |\n| 350205       | 海沧区                         |\n| 350206       | 湖里区                         |\n| 350211       | 集美区                         |\n| 350212       | 同安区                         |\n| 350213       | 翔安区                         |\n| 350300       | 莆田市                         |\n| 350302       | 城厢区                         |\n| 350303       | 涵江区                         |\n| 350304       | 荔城区                         |\n| 350305       | 秀屿区                         |\n| 350322       | 仙游县                         |\n| 350400       | 三明市                         |\n| 350402       | 梅列区                         |\n| 350403       | 三元区                         |\n| 350421       | 明溪县                         |\n| 350423       | 清流县                         |\n| 350424       | 宁化县                         |\n| 350425       | 大田县                         |\n| 350426       | 尤溪县                         |\n| 350427       | 沙县                           |\n| 350428       | 将乐县                         |\n| 350429       | 泰宁县                         |\n| 350430       | 建宁县                         |\n| 350481       | 永安市                         |\n| 350500       | 泉州市                         |\n| 350502       | 鲤城区                         |\n| 350503       | 丰泽区                         |\n| 350504       | 洛江区                         |\n| 350505       | 泉港区                         |\n| 350521       | 惠安县                         |\n| 350524       | 安溪县                         |\n| 350525       | 永春县                         |\n| 350526       | 德化县                         |\n| 350527       | 金门县                         |\n| 350581       | 石狮市                         |\n| 350582       | 晋江市                         |\n| 350583       | 南安市                         |\n| 350600       | 漳州市                         |\n| 350602       | 芗城区                         |\n| 350603       | 龙文区                         |\n| 350622       | 云霄县                         |\n| 350623       | 漳浦县                         |\n| 350624       | 诏安县                         |\n| 350625       | 长泰县                         |\n| 350626       | 东山县                         |\n| 350627       | 南靖县                         |\n| 350628       | 平和县                         |\n| 350629       | 华安县                         |\n| 350681       | 龙海市                         |\n| 350700       | 南平市                         |\n| 350702       | 延平区                         |\n| 350703       | 建阳区                         |\n| 350721       | 顺昌县                         |\n| 350722       | 浦城县                         |\n| 350723       | 光泽县                         |\n| 350724       | 松溪县                         |\n| 350725       | 政和县                         |\n| 350781       | 邵武市                         |\n| 350782       | 武夷山市                       |\n| 350783       | 建瓯市                         |\n| 350800       | 龙岩市                         |\n| 350802       | 新罗区                         |\n| 350803       | 永定区                         |\n| 350821       | 长汀县                         |\n| 350823       | 上杭县                         |\n| 350824       | 武平县                         |\n| 350825       | 连城县                         |\n| 350881       | 漳平市                         |\n| 350900       | 宁德市                         |\n| 350902       | 蕉城区                         |\n| 350921       | 霞浦县                         |\n| 350922       | 古田县                         |\n| 350923       | 屏南县                         |\n| 350924       | 寿宁县                         |\n| 350925       | 周宁县                         |\n| 350926       | 柘荣县                         |\n| 350981       | 福安市                         |\n| 350982       | 福鼎市                         |\n| 360000       | 江西省                         |\n| 360100       | 南昌市                         |\n| 360102       | 东湖区                         |\n| 360103       | 西湖区                         |\n| 360104       | 青云谱区                       |\n| 360111       | 青山湖区                       |\n| 360112       | 新建区                         |\n| 360113       | 红谷滩区                       |\n| 360121       | 南昌县                         |\n| 360123       | 安义县                         |\n| 360124       | 进贤县                         |\n| 360200       | 景德镇市                       |\n| 360202       | 昌江区                         |\n| 360203       | 珠山区                         |\n| 360222       | 浮梁县                         |\n| 360281       | 乐平市                         |\n| 360300       | 萍乡市                         |\n| 360302       | 安源区                         |\n| 360313       | 湘东区                         |\n| 360321       | 莲花县                         |\n| 360322       | 上栗县                         |\n| 360323       | 芦溪县                         |\n| 360400       | 九江市                         |\n| 360402       | 濂溪区                         |\n| 360403       | 浔阳区                         |\n| 360404       | 柴桑区                         |\n| 360423       | 武宁县                         |\n| 360424       | 修水县                         |\n| 360425       | 永修县                         |\n| 360426       | 德安县                         |\n| 360428       | 都昌县                         |\n| 360429       | 湖口县                         |\n| 360430       | 彭泽县                         |\n| 360481       | 瑞昌市                         |\n| 360482       | 共青城市                       |\n| 360483       | 庐山市                         |\n| 360500       | 新余市                         |\n| 360502       | 渝水区                         |\n| 360521       | 分宜县                         |\n| 360600       | 鹰潭市                         |\n| 360602       | 月湖区                         |\n| 360603       | 余江区                         |\n| 360681       | 贵溪市                         |\n| 360700       | 赣州市                         |\n| 360702       | 章贡区                         |\n| 360703       | 南康区                         |\n| 360704       | 赣县区                         |\n| 360722       | 信丰县                         |\n| 360723       | 大余县                         |\n| 360724       | 上犹县                         |\n| 360725       | 崇义县                         |\n| 360726       | 安远县                         |\n| 360727       | 龙南县                         |\n| 360728       | 定南县                         |\n| 360729       | 全南县                         |\n| 360730       | 宁都县                         |\n| 360731       | 于都县                         |\n| 360732       | 兴国县                         |\n| 360733       | 会昌县                         |\n| 360734       | 寻乌县                         |\n| 360735       | 石城县                         |\n| 360781       | 瑞金市                         |\n| 360800       | 吉安市                         |\n| 360802       | 吉州区                         |\n| 360803       | 青原区                         |\n| 360821       | 吉安县                         |\n| 360822       | 吉水县                         |\n| 360823       | 峡江县                         |\n| 360824       | 新干县                         |\n| 360825       | 永丰县                         |\n| 360826       | 泰和县                         |\n| 360827       | 遂川县                         |\n| 360828       | 万安县                         |\n| 360829       | 安福县                         |\n| 360830       | 永新县                         |\n| 360881       | 井冈山市                       |\n| 360900       | 宜春市                         |\n| 360902       | 袁州区                         |\n| 360921       | 奉新县                         |\n| 360922       | 万载县                         |\n| 360923       | 上高县                         |\n| 360924       | 宜丰县                         |\n| 360925       | 靖安县                         |\n| 360926       | 铜鼓县                         |\n| 360981       | 丰城市                         |\n| 360982       | 樟树市                         |\n| 360983       | 高安市                         |\n| 361000       | 抚州市                         |\n| 361002       | 临川区                         |\n| 361003       | 东乡区                         |\n| 361021       | 南城县                         |\n| 361022       | 黎川县                         |\n| 361023       | 南丰县                         |\n| 361024       | 崇仁县                         |\n| 361025       | 乐安县                         |\n| 361026       | 宜黄县                         |\n| 361027       | 金溪县                         |\n| 361028       | 资溪县                         |\n| 361030       | 广昌县                         |\n| 361100       | 上饶市                         |\n| 361102       | 信州区                         |\n| 361103       | 广丰区                         |\n| 361104       | 广信区                         |\n| 361123       | 玉山县                         |\n| 361124       | 铅山县                         |\n| 361125       | 横峰县                         |\n| 361126       | 弋阳县                         |\n| 361127       | 余干县                         |\n| 361128       | 鄱阳县                         |\n| 361129       | 万年县                         |\n| 361130       | 婺源县                         |\n| 361181       | 德兴市                         |\n| 370000       | 山东省                         |\n| 370100       | 济南市                         |\n| 370102       | 历下区                         |\n| 370103       | 市中区                         |\n| 370104       | 槐荫区                         |\n| 370105       | 天桥区                         |\n| 370112       | 历城区                         |\n| 370113       | 长清区                         |\n| 370114       | 章丘区                         |\n| 370115       | 济阳区                         |\n| 370116       | 莱芜区                         |\n| 370117       | 钢城区                         |\n| 370124       | 平阴县                         |\n| 370126       | 商河县                         |\n| 370200       | 青岛市                         |\n| 370202       | 市南区                         |\n| 370203       | 市北区                         |\n| 370211       | 黄岛区                         |\n| 370212       | 崂山区                         |\n| 370213       | 李沧区                         |\n| 370214       | 城阳区                         |\n| 370215       | 即墨区                         |\n| 370281       | 胶州市                         |\n| 370283       | 平度市                         |\n| 370285       | 莱西市                         |\n| 370300       | 淄博市                         |\n| 370302       | 淄川区                         |\n| 370303       | 张店区                         |\n| 370304       | 博山区                         |\n| 370305       | 临淄区                         |\n| 370306       | 周村区                         |\n| 370321       | 桓台县                         |\n| 370322       | 高青县                         |\n| 370323       | 沂源县                         |\n| 370400       | 枣庄市                         |\n| 370402       | 市中区                         |\n| 370403       | 薛城区                         |\n| 370404       | 峄城区                         |\n| 370405       | 台儿庄区                       |\n| 370406       | 山亭区                         |\n| 370481       | 滕州市                         |\n| 370500       | 东营市                         |\n| 370502       | 东营区                         |\n| 370503       | 河口区                         |\n| 370505       | 垦利区                         |\n| 370522       | 利津县                         |\n| 370523       | 广饶县                         |\n| 370600       | 烟台市                         |\n| 370602       | 芝罘区                         |\n| 370611       | 福山区                         |\n| 370612       | 牟平区                         |\n| 370613       | 莱山区                         |\n| 370634       | 长岛县                         |\n| 370681       | 龙口市                         |\n| 370682       | 莱阳市                         |\n| 370683       | 莱州市                         |\n| 370684       | 蓬莱市                         |\n| 370685       | 招远市                         |\n| 370686       | 栖霞市                         |\n| 370687       | 海阳市                         |\n| 370700       | 潍坊市                         |\n| 370702       | 潍城区                         |\n| 370703       | 寒亭区                         |\n| 370704       | 坊子区                         |\n| 370705       | 奎文区                         |\n| 370724       | 临朐县                         |\n| 370725       | 昌乐县                         |\n| 370781       | 青州市                         |\n| 370782       | 诸城市                         |\n| 370783       | 寿光市                         |\n| 370784       | 安丘市                         |\n| 370785       | 高密市                         |\n| 370786       | 昌邑市                         |\n| 370800       | 济宁市                         |\n| 370811       | 任城区                         |\n| 370812       | 兖州区                         |\n| 370826       | 微山县                         |\n| 370827       | 鱼台县                         |\n| 370828       | 金乡县                         |\n| 370829       | 嘉祥县                         |\n| 370830       | 汶上县                         |\n| 370831       | 泗水县                         |\n| 370832       | 梁山县                         |\n| 370881       | 曲阜市                         |\n| 370883       | 邹城市                         |\n| 370900       | 泰安市                         |\n| 370902       | 泰山区                         |\n| 370911       | 岱岳区                         |\n| 370921       | 宁阳县                         |\n| 370923       | 东平县                         |\n| 370982       | 新泰市                         |\n| 370983       | 肥城市                         |\n| 371000       | 威海市                         |\n| 371002       | 环翠区                         |\n| 371003       | 文登区                         |\n| 371082       | 荣成市                         |\n| 371083       | 乳山市                         |\n| 371100       | 日照市                         |\n| 371102       | 东港区                         |\n| 371103       | 岚山区                         |\n| 371121       | 五莲县                         |\n| 371122       | 莒县                           |\n| 371300       | 临沂市                         |\n| 371302       | 兰山区                         |\n| 371311       | 罗庄区                         |\n| 371312       | 河东区                         |\n| 371321       | 沂南县                         |\n| 371322       | 郯城县                         |\n| 371323       | 沂水县                         |\n| 371324       | 兰陵县                         |\n| 371325       | 费县                           |\n| 371326       | 平邑县                         |\n| 371327       | 莒南县                         |\n| 371328       | 蒙阴县                         |\n| 371329       | 临沭县                         |\n| 371400       | 德州市                         |\n| 371402       | 德城区                         |\n| 371403       | 陵城区                         |\n| 371422       | 宁津县                         |\n| 371423       | 庆云县                         |\n| 371424       | 临邑县                         |\n| 371425       | 齐河县                         |\n| 371426       | 平原县                         |\n| 371427       | 夏津县                         |\n| 371428       | 武城县                         |\n| 371481       | 乐陵市                         |\n| 371482       | 禹城市                         |\n| 371500       | 聊城市                         |\n| 371502       | 东昌府区                       |\n| 371503       | 茌平区                         |\n| 371521       | 阳谷县                         |\n| 371522       | 莘县                           |\n| 371524       | 东阿县                         |\n| 371525       | 冠县                           |\n| 371526       | 高唐县                         |\n| 371581       | 临清市                         |\n| 371600       | 滨州市                         |\n| 371602       | 滨城区                         |\n| 371603       | 沾化区                         |\n| 371621       | 惠民县                         |\n| 371622       | 阳信县                         |\n| 371623       | 无棣县                         |\n| 371625       | 博兴县                         |\n| 371681       | 邹平市                         |\n| 371700       | 菏泽市                         |\n| 371702       | 牡丹区                         |\n| 371703       | 定陶区                         |\n| 371721       | 曹县                           |\n| 371722       | 单县                           |\n| 371723       | 成武县                         |\n| 371724       | 巨野县                         |\n| 371725       | 郓城县                         |\n| 371726       | 鄄城县                         |\n| 371728       | 东明县                         |\n| 410000       | 河南省                         |\n| 410100       | 郑州市                         |\n| 410102       | 中原区                         |\n| 410103       | 二七区                         |\n| 410104       | 管城回族区                     |\n| 410105       | 金水区                         |\n| 410106       | 上街区                         |\n| 410108       | 惠济区                         |\n| 410122       | 中牟县                         |\n| 410181       | 巩义市                         |\n| 410182       | 荥阳市                         |\n| 410183       | 新密市                         |\n| 410184       | 新郑市                         |\n| 410185       | 登封市                         |\n| 410200       | 开封市                         |\n| 410202       | 龙亭区                         |\n| 410203       | 顺河回族区                     |\n| 410204       | 鼓楼区                         |\n| 410205       | 禹王台区                       |\n| 410212       | 祥符区                         |\n| 410221       | 杞县                           |\n| 410222       | 通许县                         |\n| 410223       | 尉氏县                         |\n| 410225       | 兰考县                         |\n| 410300       | 洛阳市                         |\n| 410302       | 老城区                         |\n| 410303       | 西工区                         |\n| 410304       | 瀍河回族区                     |\n| 410305       | 涧西区                         |\n| 410306       | 吉利区                         |\n| 410311       | 洛龙区                         |\n| 410322       | 孟津县                         |\n| 410323       | 新安县                         |\n| 410324       | 栾川县                         |\n| 410325       | 嵩县                           |\n| 410326       | 汝阳县                         |\n| 410327       | 宜阳县                         |\n| 410328       | 洛宁县                         |\n| 410329       | 伊川县                         |\n| 410381       | 偃师市                         |\n| 410400       | 平顶山市                       |\n| 410402       | 新华区                         |\n| 410403       | 卫东区                         |\n| 410404       | 石龙区                         |\n| 410411       | 湛河区                         |\n| 410421       | 宝丰县                         |\n| 410422       | 叶县                           |\n| 410423       | 鲁山县                         |\n| 410425       | 郏县                           |\n| 410481       | 舞钢市                         |\n| 410482       | 汝州市                         |\n| 410500       | 安阳市                         |\n| 410502       | 文峰区                         |\n| 410503       | 北关区                         |\n| 410505       | 殷都区                         |\n| 410506       | 龙安区                         |\n| 410522       | 安阳县                         |\n| 410523       | 汤阴县                         |\n| 410526       | 滑县                           |\n| 410527       | 内黄县                         |\n| 410581       | 林州市                         |\n| 410600       | 鹤壁市                         |\n| 410602       | 鹤山区                         |\n| 410603       | 山城区                         |\n| 410611       | 淇滨区                         |\n| 410621       | 浚县                           |\n| 410622       | 淇县                           |\n| 410700       | 新乡市                         |\n| 410702       | 红旗区                         |\n| 410703       | 卫滨区                         |\n| 410704       | 凤泉区                         |\n| 410711       | 牧野区                         |\n| 410721       | 新乡县                         |\n| 410724       | 获嘉县                         |\n| 410725       | 原阳县                         |\n| 410726       | 延津县                         |\n| 410727       | 封丘县                         |\n| 410781       | 卫辉市                         |\n| 410782       | 辉县市                         |\n| 410783       | 长垣市                         |\n| 410800       | 焦作市                         |\n| 410802       | 解放区                         |\n| 410803       | 中站区                         |\n| 410804       | 马村区                         |\n| 410811       | 山阳区                         |\n| 410821       | 修武县                         |\n| 410822       | 博爱县                         |\n| 410823       | 武陟县                         |\n| 410825       | 温县                           |\n| 410882       | 沁阳市                         |\n| 410883       | 孟州市                         |\n| 410900       | 濮阳市                         |\n| 410902       | 华龙区                         |\n| 410922       | 清丰县                         |\n| 410923       | 南乐县                         |\n| 410926       | 范县                           |\n| 410927       | 台前县                         |\n| 410928       | 濮阳县                         |\n| 411000       | 许昌市                         |\n| 411002       | 魏都区                         |\n| 411003       | 建安区                         |\n| 411024       | 鄢陵县                         |\n| 411025       | 襄城县                         |\n| 411081       | 禹州市                         |\n| 411082       | 长葛市                         |\n| 411100       | 漯河市                         |\n| 411102       | 源汇区                         |\n| 411103       | 郾城区                         |\n| 411104       | 召陵区                         |\n| 411121       | 舞阳县                         |\n| 411122       | 临颍县                         |\n| 411200       | 三门峡市                       |\n| 411202       | 湖滨区                         |\n| 411203       | 陕州区                         |\n| 411221       | 渑池县                         |\n| 411224       | 卢氏县                         |\n| 411281       | 义马市                         |\n| 411282       | 灵宝市                         |\n| 411300       | 南阳市                         |\n| 411302       | 宛城区                         |\n| 411303       | 卧龙区                         |\n| 411321       | 南召县                         |\n| 411322       | 方城县                         |\n| 411323       | 西峡县                         |\n| 411324       | 镇平县                         |\n| 411325       | 内乡县                         |\n| 411326       | 淅川县                         |\n| 411327       | 社旗县                         |\n| 411328       | 唐河县                         |\n| 411329       | 新野县                         |\n| 411330       | 桐柏县                         |\n| 411381       | 邓州市                         |\n| 411400       | 商丘市                         |\n| 411402       | 梁园区                         |\n| 411403       | 睢阳区                         |\n| 411421       | 民权县                         |\n| 411422       | 睢县                           |\n| 411423       | 宁陵县                         |\n| 411424       | 柘城县                         |\n| 411425       | 虞城县                         |\n| 411426       | 夏邑县                         |\n| 411481       | 永城市                         |\n| 411500       | 信阳市                         |\n| 411502       | 浉河区                         |\n| 411503       | 平桥区                         |\n| 411521       | 罗山县                         |\n| 411522       | 光山县                         |\n| 411523       | 新县                           |\n| 411524       | 商城县                         |\n| 411525       | 固始县                         |\n| 411526       | 潢川县                         |\n| 411527       | 淮滨县                         |\n| 411528       | 息县                           |\n| 411600       | 周口市                         |\n| 411602       | 川汇区                         |\n| 411603       | 淮阳区                         |\n| 411621       | 扶沟县                         |\n| 411622       | 西华县                         |\n| 411623       | 商水县                         |\n| 411624       | 沈丘县                         |\n| 411625       | 郸城县                         |\n| 411627       | 太康县                         |\n| 411628       | 鹿邑县                         |\n| 411681       | 项城市                         |\n| 411700       | 驻马店市                       |\n| 411702       | 驿城区                         |\n| 411721       | 西平县                         |\n| 411722       | 上蔡县                         |\n| 411723       | 平舆县                         |\n| 411724       | 正阳县                         |\n| 411725       | 确山县                         |\n| 411726       | 泌阳县                         |\n| 411727       | 汝南县                         |\n| 411728       | 遂平县                         |\n| 411729       | 新蔡县                         |\n| 419001       | 济源市                         |\n| 420000       | 湖北省                         |\n| 420100       | 武汉市                         |\n| 420102       | 江岸区                         |\n| 420103       | 江汉区                         |\n| 420104       | 硚口区                         |\n| 420105       | 汉阳区                         |\n| 420106       | 武昌区                         |\n| 420107       | 青山区                         |\n| 420111       | 洪山区                         |\n| 420112       | 东西湖区                       |\n| 420113       | 汉南区                         |\n| 420114       | 蔡甸区                         |\n| 420115       | 江夏区                         |\n| 420116       | 黄陂区                         |\n| 420117       | 新洲区                         |\n| 420200       | 黄石市                         |\n| 420202       | 黄石港区                       |\n| 420203       | 西塞山区                       |\n| 420204       | 下陆区                         |\n| 420205       | 铁山区                         |\n| 420222       | 阳新县                         |\n| 420281       | 大冶市                         |\n| 420300       | 十堰市                         |\n| 420302       | 茅箭区                         |\n| 420303       | 张湾区                         |\n| 420304       | 郧阳区                         |\n| 420322       | 郧西县                         |\n| 420323       | 竹山县                         |\n| 420324       | 竹溪县                         |\n| 420325       | 房县                           |\n| 420381       | 丹江口市                       |\n| 420500       | 宜昌市                         |\n| 420502       | 西陵区                         |\n| 420503       | 伍家岗区                       |\n| 420504       | 点军区                         |\n| 420505       | 猇亭区                         |\n| 420506       | 夷陵区                         |\n| 420525       | 远安县                         |\n| 420526       | 兴山县                         |\n| 420527       | 秭归县                         |\n| 420528       | 长阳土家族自治县               |\n| 420529       | 五峰土家族自治县               |\n| 420581       | 宜都市                         |\n| 420582       | 当阳市                         |\n| 420583       | 枝江市                         |\n| 420600       | 襄阳市                         |\n| 420602       | 襄城区                         |\n| 420606       | 樊城区                         |\n| 420607       | 襄州区                         |\n| 420624       | 南漳县                         |\n| 420625       | 谷城县                         |\n| 420626       | 保康县                         |\n| 420682       | 老河口市                       |\n| 420683       | 枣阳市                         |\n| 420684       | 宜城市                         |\n| 420700       | 鄂州市                         |\n| 420702       | 梁子湖区                       |\n| 420703       | 华容区                         |\n| 420704       | 鄂城区                         |\n| 420800       | 荆门市                         |\n| 420802       | 东宝区                         |\n| 420804       | 掇刀区                         |\n| 420822       | 沙洋县                         |\n| 420881       | 钟祥市                         |\n| 420882       | 京山市                         |\n| 420900       | 孝感市                         |\n| 420902       | 孝南区                         |\n| 420921       | 孝昌县                         |\n| 420922       | 大悟县                         |\n| 420923       | 云梦县                         |\n| 420981       | 应城市                         |\n| 420982       | 安陆市                         |\n| 420984       | 汉川市                         |\n| 421000       | 荆州市                         |\n| 421002       | 沙市区                         |\n| 421003       | 荆州区                         |\n| 421022       | 公安县                         |\n| 421023       | 监利县                         |\n| 421024       | 江陵县                         |\n| 421081       | 石首市                         |\n| 421083       | 洪湖市                         |\n| 421087       | 松滋市                         |\n| 421100       | 黄冈市                         |\n| 421102       | 黄州区                         |\n| 421121       | 团风县                         |\n| 421122       | 红安县                         |\n| 421123       | 罗田县                         |\n| 421124       | 英山县                         |\n| 421125       | 浠水县                         |\n| 421126       | 蕲春县                         |\n| 421127       | 黄梅县                         |\n| 421181       | 麻城市                         |\n| 421182       | 武穴市                         |\n| 421200       | 咸宁市                         |\n| 421202       | 咸安区                         |\n| 421221       | 嘉鱼县                         |\n| 421222       | 通城县                         |\n| 421223       | 崇阳县                         |\n| 421224       | 通山县                         |\n| 421281       | 赤壁市                         |\n| 421300       | 随州市                         |\n| 421303       | 曾都区                         |\n| 421321       | 随县                           |\n| 421381       | 广水市                         |\n| 422800       | 恩施土家族苗族自治州           |\n| 422801       | 恩施市                         |\n| 422802       | 利川市                         |\n| 422822       | 建始县                         |\n| 422823       | 巴东县                         |\n| 422825       | 宣恩县                         |\n| 422826       | 咸丰县                         |\n| 422827       | 来凤县                         |\n| 422828       | 鹤峰县                         |\n| 429004       | 仙桃市                         |\n| 429005       | 潜江市                         |\n| 429006       | 天门市                         |\n| 429021       | 神农架林区                     |\n| 430000       | 湖南省                         |\n| 430100       | 长沙市                         |\n| 430102       | 芙蓉区                         |\n| 430103       | 天心区                         |\n| 430104       | 岳麓区                         |\n| 430105       | 开福区                         |\n| 430111       | 雨花区                         |\n| 430112       | 望城区                         |\n| 430121       | 长沙县                         |\n| 430181       | 浏阳市                         |\n| 430182       | 宁乡市                         |\n| 430200       | 株洲市                         |\n| 430202       | 荷塘区                         |\n| 430203       | 芦淞区                         |\n| 430204       | 石峰区                         |\n| 430211       | 天元区                         |\n| 430212       | 渌口区                         |\n| 430223       | 攸县                           |\n| 430224       | 茶陵县                         |\n| 430225       | 炎陵县                         |\n| 430281       | 醴陵市                         |\n| 430300       | 湘潭市                         |\n| 430302       | 雨湖区                         |\n| 430304       | 岳塘区                         |\n| 430321       | 湘潭县                         |\n| 430381       | 湘乡市                         |\n| 430382       | 韶山市                         |\n| 430400       | 衡阳市                         |\n| 430405       | 珠晖区                         |\n| 430406       | 雁峰区                         |\n| 430407       | 石鼓区                         |\n| 430408       | 蒸湘区                         |\n| 430412       | 南岳区                         |\n| 430421       | 衡阳县                         |\n| 430422       | 衡南县                         |\n| 430423       | 衡山县                         |\n| 430424       | 衡东县                         |\n| 430426       | 祁东县                         |\n| 430481       | 耒阳市                         |\n| 430482       | 常宁市                         |\n| 430500       | 邵阳市                         |\n| 430502       | 双清区                         |\n| 430503       | 大祥区                         |\n| 430511       | 北塔区                         |\n| 430522       | 新邵县                         |\n| 430523       | 邵阳县                         |\n| 430524       | 隆回县                         |\n| 430525       | 洞口县                         |\n| 430527       | 绥宁县                         |\n| 430528       | 新宁县                         |\n| 430529       | 城步苗族自治县                 |\n| 430581       | 武冈市                         |\n| 430582       | 邵东市                         |\n| 430600       | 岳阳市                         |\n| 430602       | 岳阳楼区                       |\n| 430603       | 云溪区                         |\n| 430611       | 君山区                         |\n| 430621       | 岳阳县                         |\n| 430623       | 华容县                         |\n| 430624       | 湘阴县                         |\n| 430626       | 平江县                         |\n| 430681       | 汨罗市                         |\n| 430682       | 临湘市                         |\n| 430700       | 常德市                         |\n| 430702       | 武陵区                         |\n| 430703       | 鼎城区                         |\n| 430721       | 安乡县                         |\n| 430722       | 汉寿县                         |\n| 430723       | 澧县                           |\n| 430724       | 临澧县                         |\n| 430725       | 桃源县                         |\n| 430726       | 石门县                         |\n| 430781       | 津市市                         |\n| 430800       | 张家界市                       |\n| 430802       | 永定区                         |\n| 430811       | 武陵源区                       |\n| 430821       | 慈利县                         |\n| 430822       | 桑植县                         |\n| 430900       | 益阳市                         |\n| 430902       | 资阳区                         |\n| 430903       | 赫山区                         |\n| 430921       | 南县                           |\n| 430922       | 桃江县                         |\n| 430923       | 安化县                         |\n| 430981       | 沅江市                         |\n| 431000       | 郴州市                         |\n| 431002       | 北湖区                         |\n| 431003       | 苏仙区                         |\n| 431021       | 桂阳县                         |\n| 431022       | 宜章县                         |\n| 431023       | 永兴县                         |\n| 431024       | 嘉禾县                         |\n| 431025       | 临武县                         |\n| 431026       | 汝城县                         |\n| 431027       | 桂东县                         |\n| 431028       | 安仁县                         |\n| 431081       | 资兴市                         |\n| 431100       | 永州市                         |\n| 431102       | 零陵区                         |\n| 431103       | 冷水滩区                       |\n| 431121       | 祁阳县                         |\n| 431122       | 东安县                         |\n| 431123       | 双牌县                         |\n| 431124       | 道县                           |\n| 431125       | 江永县                         |\n| 431126       | 宁远县                         |\n| 431127       | 蓝山县                         |\n| 431128       | 新田县                         |\n| 431129       | 江华瑶族自治县                 |\n| 431200       | 怀化市                         |\n| 431202       | 鹤城区                         |\n| 431221       | 中方县                         |\n| 431222       | 沅陵县                         |\n| 431223       | 辰溪县                         |\n| 431224       | 溆浦县                         |\n| 431225       | 会同县                         |\n| 431226       | 麻阳苗族自治县                 |\n| 431227       | 新晃侗族自治县                 |\n| 431228       | 芷江侗族自治县                 |\n| 431229       | 靖州苗族侗族自治县             |\n| 431230       | 通道侗族自治县                 |\n| 431281       | 洪江市                         |\n| 431300       | 娄底市                         |\n| 431302       | 娄星区                         |\n| 431321       | 双峰县                         |\n| 431322       | 新化县                         |\n| 431381       | 冷水江市                       |\n| 431382       | 涟源市                         |\n| 433100       | 湘西土家族苗族自治州           |\n| 433101       | 吉首市                         |\n| 433122       | 泸溪县                         |\n| 433123       | 凤凰县                         |\n| 433124       | 花垣县                         |\n| 433125       | 保靖县                         |\n| 433126       | 古丈县                         |\n| 433127       | 永顺县                         |\n| 433130       | 龙山县                         |\n| 440000       | 广东省                         |\n| 440100       | 广州市                         |\n| 440103       | 荔湾区                         |\n| 440104       | 越秀区                         |\n| 440105       | 海珠区                         |\n| 440106       | 天河区                         |\n| 440111       | 白云区                         |\n| 440112       | 黄埔区                         |\n| 440113       | 番禺区                         |\n| 440114       | 花都区                         |\n| 440115       | 南沙区                         |\n| 440117       | 从化区                         |\n| 440118       | 增城区                         |\n| 440200       | 韶关市                         |\n| 440203       | 武江区                         |\n| 440204       | 浈江区                         |\n| 440205       | 曲江区                         |\n| 440222       | 始兴县                         |\n| 440224       | 仁化县                         |\n| 440229       | 翁源县                         |\n| 440232       | 乳源瑶族自治县                 |\n| 440233       | 新丰县                         |\n| 440281       | 乐昌市                         |\n| 440282       | 南雄市                         |\n| 440300       | 深圳市                         |\n| 440303       | 罗湖区                         |\n| 440304       | 福田区                         |\n| 440305       | 南山区                         |\n| 440306       | 宝安区                         |\n| 440307       | 龙岗区                         |\n| 440308       | 盐田区                         |\n| 440309       | 龙华区                         |\n| 440310       | 坪山区                         |\n| 440311       | 光明区                         |\n| 440400       | 珠海市                         |\n| 440402       | 香洲区                         |\n| 440403       | 斗门区                         |\n| 440404       | 金湾区                         |\n| 440500       | 汕头市                         |\n| 440507       | 龙湖区                         |\n| 440511       | 金平区                         |\n| 440512       | 濠江区                         |\n| 440513       | 潮阳区                         |\n| 440514       | 潮南区                         |\n| 440515       | 澄海区                         |\n| 440523       | 南澳县                         |\n| 440600       | 佛山市                         |\n| 440604       | 禅城区                         |\n| 440605       | 南海区                         |\n| 440606       | 顺德区                         |\n| 440607       | 三水区                         |\n| 440608       | 高明区                         |\n| 440700       | 江门市                         |\n| 440703       | 蓬江区                         |\n| 440704       | 江海区                         |\n| 440705       | 新会区                         |\n| 440781       | 台山市                         |\n| 440783       | 开平市                         |\n| 440784       | 鹤山市                         |\n| 440785       | 恩平市                         |\n| 440800       | 湛江市                         |\n| 440802       | 赤坎区                         |\n| 440803       | 霞山区                         |\n| 440804       | 坡头区                         |\n| 440811       | 麻章区                         |\n| 440823       | 遂溪县                         |\n| 440825       | 徐闻县                         |\n| 440881       | 廉江市                         |\n| 440882       | 雷州市                         |\n| 440883       | 吴川市                         |\n| 440900       | 茂名市                         |\n| 440902       | 茂南区                         |\n| 440904       | 电白区                         |\n| 440981       | 高州市                         |\n| 440982       | 化州市                         |\n| 440983       | 信宜市                         |\n| 441200       | 肇庆市                         |\n| 441202       | 端州区                         |\n| 441203       | 鼎湖区                         |\n| 441204       | 高要区                         |\n| 441223       | 广宁县                         |\n| 441224       | 怀集县                         |\n| 441225       | 封开县                         |\n| 441226       | 德庆县                         |\n| 441284       | 四会市                         |\n| 441300       | 惠州市                         |\n| 441302       | 惠城区                         |\n| 441303       | 惠阳区                         |\n| 441322       | 博罗县                         |\n| 441323       | 惠东县                         |\n| 441324       | 龙门县                         |\n| 441400       | 梅州市                         |\n| 441402       | 梅江区                         |\n| 441403       | 梅县区                         |\n| 441422       | 大埔县                         |\n| 441423       | 丰顺县                         |\n| 441424       | 五华县                         |\n| 441426       | 平远县                         |\n| 441427       | 蕉岭县                         |\n| 441481       | 兴宁市                         |\n| 441500       | 汕尾市                         |\n| 441502       | 城区                           |\n| 441521       | 海丰县                         |\n| 441523       | 陆河县                         |\n| 441581       | 陆丰市                         |\n| 441600       | 河源市                         |\n| 441602       | 源城区                         |\n| 441621       | 紫金县                         |\n| 441622       | 龙川县                         |\n| 441623       | 连平县                         |\n| 441624       | 和平县                         |\n| 441625       | 东源县                         |\n| 441700       | 阳江市                         |\n| 441702       | 江城区                         |\n| 441704       | 阳东区                         |\n| 441721       | 阳西县                         |\n| 441781       | 阳春市                         |\n| 441800       | 清远市                         |\n| 441802       | 清城区                         |\n| 441803       | 清新区                         |\n| 441821       | 佛冈县                         |\n| 441823       | 阳山县                         |\n| 441825       | 连山壮族瑶族自治县             |\n| 441826       | 连南瑶族自治县                 |\n| 441881       | 英德市                         |\n| 441882       | 连州市                         |\n| 441900       | 东莞市                         |\n| 442000       | 中山市                         |\n| 445100       | 潮州市                         |\n| 445102       | 湘桥区                         |\n| 445103       | 潮安区                         |\n| 445122       | 饶平县                         |\n| 445200       | 揭阳市                         |\n| 445202       | 榕城区                         |\n| 445203       | 揭东区                         |\n| 445222       | 揭西县                         |\n| 445224       | 惠来县                         |\n| 445281       | 普宁市                         |\n| 445300       | 云浮市                         |\n| 445302       | 云城区                         |\n| 445303       | 云安区                         |\n| 445321       | 新兴县                         |\n| 445322       | 郁南县                         |\n| 445381       | 罗定市                         |\n| 450000       | 广西壮族自治区                 |\n| 450100       | 南宁市                         |\n| 450102       | 兴宁区                         |\n| 450103       | 青秀区                         |\n| 450105       | 江南区                         |\n| 450107       | 西乡塘区                       |\n| 450108       | 良庆区                         |\n| 450109       | 邕宁区                         |\n| 450110       | 武鸣区                         |\n| 450123       | 隆安县                         |\n| 450124       | 马山县                         |\n| 450125       | 上林县                         |\n| 450126       | 宾阳县                         |\n| 450127       | 横县                           |\n| 450200       | 柳州市                         |\n| 450202       | 城中区                         |\n| 450203       | 鱼峰区                         |\n| 450204       | 柳南区                         |\n| 450205       | 柳北区                         |\n| 450206       | 柳江区                         |\n| 450222       | 柳城县                         |\n| 450223       | 鹿寨县                         |\n| 450224       | 融安县                         |\n| 450225       | 融水苗族自治县                 |\n| 450226       | 三江侗族自治县                 |\n| 450300       | 桂林市                         |\n| 450302       | 秀峰区                         |\n| 450303       | 叠彩区                         |\n| 450304       | 象山区                         |\n| 450305       | 七星区                         |\n| 450311       | 雁山区                         |\n| 450312       | 临桂区                         |\n| 450321       | 阳朔县                         |\n| 450323       | 灵川县                         |\n| 450324       | 全州县                         |\n| 450325       | 兴安县                         |\n| 450326       | 永福县                         |\n| 450327       | 灌阳县                         |\n| 450328       | 龙胜各族自治县                 |\n| 450329       | 资源县                         |\n| 450330       | 平乐县                         |\n| 450381       | 荔浦市                         |\n| 450332       | 恭城瑶族自治县                 |\n| 450400       | 梧州市                         |\n| 450403       | 万秀区                         |\n| 450405       | 长洲区                         |\n| 450406       | 龙圩区                         |\n| 450421       | 苍梧县                         |\n| 450422       | 藤县                           |\n| 450423       | 蒙山县                         |\n| 450481       | 岑溪市                         |\n| 450500       | 北海市                         |\n| 450502       | 海城区                         |\n| 450503       | 银海区                         |\n| 450512       | 铁山港区                       |\n| 450521       | 合浦县                         |\n| 450600       | 防城港市                       |\n| 450602       | 港口区                         |\n| 450603       | 防城区                         |\n| 450621       | 上思县                         |\n| 450681       | 东兴市                         |\n| 450700       | 钦州市                         |\n| 450702       | 钦南区                         |\n| 450703       | 钦北区                         |\n| 450721       | 灵山县                         |\n| 450722       | 浦北县                         |\n| 450800       | 贵港市                         |\n| 450802       | 港北区                         |\n| 450803       | 港南区                         |\n| 450804       | 覃塘区                         |\n| 450821       | 平南县                         |\n| 450881       | 桂平市                         |\n| 450900       | 玉林市                         |\n| 450902       | 玉州区                         |\n| 450903       | 福绵区                         |\n| 450921       | 容县                           |\n| 450922       | 陆川县                         |\n| 450923       | 博白县                         |\n| 450924       | 兴业县                         |\n| 450981       | 北流市                         |\n| 451000       | 百色市                         |\n| 451002       | 右江区                         |\n| 451003       | 田阳区                         |\n| 451022       | 田东县                         |\n| 451024       | 德保县                         |\n| 451026       | 那坡县                         |\n| 451027       | 凌云县                         |\n| 451028       | 乐业县                         |\n| 451029       | 田林县                         |\n| 451030       | 西林县                         |\n| 451031       | 隆林各族自治县                 |\n| 451081       | 靖西市                         |\n| 451082       | 平果市                         |\n| 451100       | 贺州市                         |\n| 451102       | 八步区                         |\n| 451103       | 平桂区                         |\n| 451121       | 昭平县                         |\n| 451122       | 钟山县                         |\n| 451123       | 富川瑶族自治县                 |\n| 451200       | 河池市                         |\n| 451202       | 金城江区                       |\n| 451203       | 宜州区                         |\n| 451221       | 南丹县                         |\n| 451222       | 天峨县                         |\n| 451223       | 凤山县                         |\n| 451224       | 东兰县                         |\n| 451225       | 罗城仫佬族自治县               |\n| 451226       | 环江毛南族自治县               |\n| 451227       | 巴马瑶族自治县                 |\n| 451228       | 都安瑶族自治县                 |\n| 451229       | 大化瑶族自治县                 |\n| 451300       | 来宾市                         |\n| 451302       | 兴宾区                         |\n| 451321       | 忻城县                         |\n| 451322       | 象州县                         |\n| 451323       | 武宣县                         |\n| 451324       | 金秀瑶族自治县                 |\n| 451381       | 合山市                         |\n| 451400       | 崇左市                         |\n| 451402       | 江州区                         |\n| 451421       | 扶绥县                         |\n| 451422       | 宁明县                         |\n| 451423       | 龙州县                         |\n| 451424       | 大新县                         |\n| 451425       | 天等县                         |\n| 451481       | 凭祥市                         |\n| 460000       | 海南省                         |\n| 460100       | 海口市                         |\n| 460105       | 秀英区                         |\n| 460106       | 龙华区                         |\n| 460107       | 琼山区                         |\n| 460108       | 美兰区                         |\n| 460200       | 三亚市                         |\n| 460202       | 海棠区                         |\n| 460203       | 吉阳区                         |\n| 460204       | 天涯区                         |\n| 460205       | 崖州区                         |\n| 460300       | 三沙市                         |\n| 460400       | 儋州市                         |\n| 469001       | 五指山市                       |\n| 469002       | 琼海市                         |\n| 469005       | 文昌市                         |\n| 469006       | 万宁市                         |\n| 469007       | 东方市                         |\n| 469021       | 定安县                         |\n| 469022       | 屯昌县                         |\n| 469023       | 澄迈县                         |\n| 469024       | 临高县                         |\n| 469025       | 白沙黎族自治县                 |\n| 469026       | 昌江黎族自治县                 |\n| 469027       | 乐东黎族自治县                 |\n| 469028       | 陵水黎族自治县                 |\n| 469029       | 保亭黎族苗族自治县             |\n| 469030       | 琼中黎族苗族自治县             |\n| 500000       | 重庆市                         |\n| 500101       | 万州区                         |\n| 500102       | 涪陵区                         |\n| 500103       | 渝中区                         |\n| 500104       | 大渡口区                       |\n| 500105       | 江北区                         |\n| 500106       | 沙坪坝区                       |\n| 500107       | 九龙坡区                       |\n| 500108       | 南岸区                         |\n| 500109       | 北碚区                         |\n| 500110       | 綦江区                         |\n| 500111       | 大足区                         |\n| 500112       | 渝北区                         |\n| 500113       | 巴南区                         |\n| 500114       | 黔江区                         |\n| 500115       | 长寿区                         |\n| 500116       | 江津区                         |\n| 500117       | 合川区                         |\n| 500118       | 永川区                         |\n| 500119       | 南川区                         |\n| 500120       | 璧山区                         |\n| 500151       | 铜梁区                         |\n| 500152       | 潼南区                         |\n| 500153       | 荣昌区                         |\n| 500154       | 开州区                         |\n| 500155       | 梁平区                         |\n| 500156       | 武隆区                         |\n| 500229       | 城口县                         |\n| 500230       | 丰都县                         |\n| 500231       | 垫江县                         |\n| 500233       | 忠县                           |\n| 500235       | 云阳县                         |\n| 500236       | 奉节县                         |\n| 500237       | 巫山县                         |\n| 500238       | 巫溪县                         |\n| 500240       | 石柱土家族自治县               |\n| 500241       | 秀山土家族苗族自治县           |\n| 500242       | 酉阳土家族苗族自治县           |\n| 500243       | 彭水苗族土家族自治县           |\n| 510000       | 四川省                         |\n| 510100       | 成都市                         |\n| 510104       | 锦江区                         |\n| 510105       | 青羊区                         |\n| 510106       | 金牛区                         |\n| 510107       | 武侯区                         |\n| 510108       | 成华区                         |\n| 510112       | 龙泉驿区                       |\n| 510113       | 青白江区                       |\n| 510114       | 新都区                         |\n| 510115       | 温江区                         |\n| 510116       | 双流区                         |\n| 510117       | 郫都区                         |\n| 510121       | 金堂县                         |\n| 510129       | 大邑县                         |\n| 510131       | 蒲江县                         |\n| 510132       | 新津县                         |\n| 510181       | 都江堰市                       |\n| 510182       | 彭州市                         |\n| 510183       | 邛崃市                         |\n| 510184       | 崇州市                         |\n| 510185       | 简阳市                         |\n| 510300       | 自贡市                         |\n| 510302       | 自流井区                       |\n| 510303       | 贡井区                         |\n| 510304       | 大安区                         |\n| 510311       | 沿滩区                         |\n| 510321       | 荣县                           |\n| 510322       | 富顺县                         |\n| 510400       | 攀枝花市                       |\n| 510402       | 东区                           |\n| 510403       | 西区                           |\n| 510411       | 仁和区                         |\n| 510421       | 米易县                         |\n| 510422       | 盐边县                         |\n| 510500       | 泸州市                         |\n| 510502       | 江阳区                         |\n| 510503       | 纳溪区                         |\n| 510504       | 龙马潭区                       |\n| 510521       | 泸县                           |\n| 510522       | 合江县                         |\n| 510524       | 叙永县                         |\n| 510525       | 古蔺县                         |\n| 510600       | 德阳市                         |\n| 510603       | 旌阳区                         |\n| 510604       | 罗江区                         |\n| 510623       | 中江县                         |\n| 510681       | 广汉市                         |\n| 510682       | 什邡市                         |\n| 510683       | 绵竹市                         |\n| 510700       | 绵阳市                         |\n| 510703       | 涪城区                         |\n| 510704       | 游仙区                         |\n| 510705       | 安州区                         |\n| 510722       | 三台县                         |\n| 510723       | 盐亭县                         |\n| 510725       | 梓潼县                         |\n| 510726       | 北川羌族自治县                 |\n| 510727       | 平武县                         |\n| 510781       | 江油市                         |\n| 510800       | 广元市                         |\n| 510802       | 利州区                         |\n| 510811       | 昭化区                         |\n| 510812       | 朝天区                         |\n| 510821       | 旺苍县                         |\n| 510822       | 青川县                         |\n| 510823       | 剑阁县                         |\n| 510824       | 苍溪县                         |\n| 510900       | 遂宁市                         |\n| 510903       | 船山区                         |\n| 510904       | 安居区                         |\n| 510921       | 蓬溪县                         |\n| 510923       | 大英县                         |\n| 510981       | 射洪市                         |\n| 511000       | 内江市                         |\n| 511002       | 市中区                         |\n| 511011       | 东兴区                         |\n| 511024       | 威远县                         |\n| 511025       | 资中县                         |\n| 511083       | 隆昌市                         |\n| 511100       | 乐山市                         |\n| 511102       | 市中区                         |\n| 511111       | 沙湾区                         |\n| 511112       | 五通桥区                       |\n| 511113       | 金口河区                       |\n| 511123       | 犍为县                         |\n| 511124       | 井研县                         |\n| 511126       | 夹江县                         |\n| 511129       | 沐川县                         |\n| 511132       | 峨边彝族自治县                 |\n| 511133       | 马边彝族自治县                 |\n| 511181       | 峨眉山市                       |\n| 511300       | 南充市                         |\n| 511302       | 顺庆区                         |\n| 511303       | 高坪区                         |\n| 511304       | 嘉陵区                         |\n| 511321       | 南部县                         |\n| 511322       | 营山县                         |\n| 511323       | 蓬安县                         |\n| 511324       | 仪陇县                         |\n| 511325       | 西充县                         |\n| 511381       | 阆中市                         |\n| 511400       | 眉山市                         |\n| 511402       | 东坡区                         |\n| 511403       | 彭山区                         |\n| 511421       | 仁寿县                         |\n| 511423       | 洪雅县                         |\n| 511424       | 丹棱县                         |\n| 511425       | 青神县                         |\n| 511500       | 宜宾市                         |\n| 511502       | 翠屏区                         |\n| 511503       | 南溪区                         |\n| 511504       | 叙州区                         |\n| 511523       | 江安县                         |\n| 511524       | 长宁县                         |\n| 511525       | 高县                           |\n| 511526       | 珙县                           |\n| 511527       | 筠连县                         |\n| 511528       | 兴文县                         |\n| 511529       | 屏山县                         |\n| 511600       | 广安市                         |\n| 511602       | 广安区                         |\n| 511603       | 前锋区                         |\n| 511621       | 岳池县                         |\n| 511622       | 武胜县                         |\n| 511623       | 邻水县                         |\n| 511681       | 华蓥市                         |\n| 511700       | 达州市                         |\n| 511702       | 通川区                         |\n| 511703       | 达川区                         |\n| 511722       | 宣汉县                         |\n| 511723       | 开江县                         |\n| 511724       | 大竹县                         |\n| 511725       | 渠县                           |\n| 511781       | 万源市                         |\n| 511800       | 雅安市                         |\n| 511802       | 雨城区                         |\n| 511803       | 名山区                         |\n| 511822       | 荥经县                         |\n| 511823       | 汉源县                         |\n| 511824       | 石棉县                         |\n| 511825       | 天全县                         |\n| 511826       | 芦山县                         |\n| 511827       | 宝兴县                         |\n| 511900       | 巴中市                         |\n| 511902       | 巴州区                         |\n| 511903       | 恩阳区                         |\n| 511921       | 通江县                         |\n| 511922       | 南江县                         |\n| 511923       | 平昌县                         |\n| 512000       | 资阳市                         |\n| 512002       | 雁江区                         |\n| 512021       | 安岳县                         |\n| 512022       | 乐至县                         |\n| 513200       | 阿坝藏族羌族自治州             |\n| 513201       | 马尔康市                       |\n| 513221       | 汶川县                         |\n| 513222       | 理县                           |\n| 513223       | 茂县                           |\n| 513224       | 松潘县                         |\n| 513225       | 九寨沟县                       |\n| 513226       | 金川县                         |\n| 513227       | 小金县                         |\n| 513228       | 黑水县                         |\n| 513230       | 壤塘县                         |\n| 513231       | 阿坝县                         |\n| 513232       | 若尔盖县                       |\n| 513233       | 红原县                         |\n| 513300       | 甘孜藏族自治州                 |\n| 513301       | 康定市                         |\n| 513322       | 泸定县                         |\n| 513323       | 丹巴县                         |\n| 513324       | 九龙县                         |\n| 513325       | 雅江县                         |\n| 513326       | 道孚县                         |\n| 513327       | 炉霍县                         |\n| 513328       | 甘孜县                         |\n| 513329       | 新龙县                         |\n| 513330       | 德格县                         |\n| 513331       | 白玉县                         |\n| 513332       | 石渠县                         |\n| 513333       | 色达县                         |\n| 513334       | 理塘县                         |\n| 513335       | 巴塘县                         |\n| 513336       | 乡城县                         |\n| 513337       | 稻城县                         |\n| 513338       | 得荣县                         |\n| 513400       | 凉山彝族自治州                 |\n| 513401       | 西昌市                         |\n| 513422       | 木里藏族自治县                 |\n| 513423       | 盐源县                         |\n| 513424       | 德昌县                         |\n| 513425       | 会理县                         |\n| 513426       | 会东县                         |\n| 513427       | 宁南县                         |\n| 513428       | 普格县                         |\n| 513429       | 布拖县                         |\n| 513430       | 金阳县                         |\n| 513431       | 昭觉县                         |\n| 513432       | 喜德县                         |\n| 513433       | 冕宁县                         |\n| 513434       | 越西县                         |\n| 513435       | 甘洛县                         |\n| 513436       | 美姑县                         |\n| 513437       | 雷波县                         |\n| 520000       | 贵州省                         |\n| 520100       | 贵阳市                         |\n| 520102       | 南明区                         |\n| 520103       | 云岩区                         |\n| 520111       | 花溪区                         |\n| 520112       | 乌当区                         |\n| 520113       | 白云区                         |\n| 520115       | 观山湖区                       |\n| 520121       | 开阳县                         |\n| 520122       | 息烽县                         |\n| 520123       | 修文县                         |\n| 520181       | 清镇市                         |\n| 520200       | 六盘水市                       |\n| 520201       | 钟山区                         |\n| 520203       | 六枝特区                       |\n| 520221       | 水城县                         |\n| 520281       | 盘州市                         |\n| 520300       | 遵义市                         |\n| 520302       | 红花岗区                       |\n| 520303       | 汇川区                         |\n| 520304       | 播州区                         |\n| 520322       | 桐梓县                         |\n| 520323       | 绥阳县                         |\n| 520324       | 正安县                         |\n| 520325       | 道真仡佬族苗族自治县           |\n| 520326       | 务川仡佬族苗族自治县           |\n| 520327       | 凤冈县                         |\n| 520328       | 湄潭县                         |\n| 520329       | 余庆县                         |\n| 520330       | 习水县                         |\n| 520381       | 赤水市                         |\n| 520382       | 仁怀市                         |\n| 520400       | 安顺市                         |\n| 520402       | 西秀区                         |\n| 520403       | 平坝区                         |\n| 520422       | 普定县                         |\n| 520423       | 镇宁布依族苗族自治县           |\n| 520424       | 关岭布依族苗族自治县           |\n| 520425       | 紫云苗族布依族自治县           |\n| 520500       | 毕节市                         |\n| 520502       | 七星关区                       |\n| 520521       | 大方县                         |\n| 520522       | 黔西县                         |\n| 520523       | 金沙县                         |\n| 520524       | 织金县                         |\n| 520525       | 纳雍县                         |\n| 520526       | 威宁彝族回族苗族自治县         |\n| 520527       | 赫章县                         |\n| 520600       | 铜仁市                         |\n| 520602       | 碧江区                         |\n| 520603       | 万山区                         |\n| 520621       | 江口县                         |\n| 520622       | 玉屏侗族自治县                 |\n| 520623       | 石阡县                         |\n| 520624       | 思南县                         |\n| 520625       | 印江土家族苗族自治县           |\n| 520626       | 德江县                         |\n| 520627       | 沿河土家族自治县               |\n| 520628       | 松桃苗族自治县                 |\n| 522300       | 黔西南布依族苗族自治州         |\n| 522301       | 兴义市                         |\n| 522302       | 兴仁市                         |\n| 522323       | 普安县                         |\n| 522324       | 晴隆县                         |\n| 522325       | 贞丰县                         |\n| 522326       | 望谟县                         |\n| 522327       | 册亨县                         |\n| 522328       | 安龙县                         |\n| 522600       | 黔东南苗族侗族自治州           |\n| 522601       | 凯里市                         |\n| 522622       | 黄平县                         |\n| 522623       | 施秉县                         |\n| 522624       | 三穗县                         |\n| 522625       | 镇远县                         |\n| 522626       | 岑巩县                         |\n| 522627       | 天柱县                         |\n| 522628       | 锦屏县                         |\n| 522629       | 剑河县                         |\n| 522630       | 台江县                         |\n| 522631       | 黎平县                         |\n| 522632       | 榕江县                         |\n| 522633       | 从江县                         |\n| 522634       | 雷山县                         |\n| 522635       | 麻江县                         |\n| 522636       | 丹寨县                         |\n| 522700       | 黔南布依族苗族自治州           |\n| 522701       | 都匀市                         |\n| 522702       | 福泉市                         |\n| 522722       | 荔波县                         |\n| 522723       | 贵定县                         |\n| 522725       | 瓮安县                         |\n| 522726       | 独山县                         |\n| 522727       | 平塘县                         |\n| 522728       | 罗甸县                         |\n| 522729       | 长顺县                         |\n| 522730       | 龙里县                         |\n| 522731       | 惠水县                         |\n| 522732       | 三都水族自治县                 |\n| 530000       | 云南省                         |\n| 530100       | 昆明市                         |\n| 530102       | 五华区                         |\n| 530103       | 盘龙区                         |\n| 530111       | 官渡区                         |\n| 530112       | 西山区                         |\n| 530113       | 东川区                         |\n| 530114       | 呈贡区                         |\n| 530115       | 晋宁区                         |\n| 530124       | 富民县                         |\n| 530125       | 宜良县                         |\n| 530126       | 石林彝族自治县                 |\n| 530127       | 嵩明县                         |\n| 530128       | 禄劝彝族苗族自治县             |\n| 530129       | 寻甸回族彝族自治县             |\n| 530181       | 安宁市                         |\n| 530300       | 曲靖市                         |\n| 530302       | 麒麟区                         |\n| 530303       | 沾益区                         |\n| 530304       | 马龙区                         |\n| 530322       | 陆良县                         |\n| 530323       | 师宗县                         |\n| 530324       | 罗平县                         |\n| 530325       | 富源县                         |\n| 530326       | 会泽县                         |\n| 530381       | 宣威市                         |\n| 530400       | 玉溪市                         |\n| 530402       | 红塔区                         |\n| 530403       | 江川区                         |\n| 530423       | 通海县                         |\n| 530424       | 华宁县                         |\n| 530425       | 易门县                         |\n| 530426       | 峨山彝族自治县                 |\n| 530427       | 新平彝族傣族自治县             |\n| 530428       | 元江哈尼族彝族傣族自治县       |\n| 530481       | 澄江市                         |\n| 530500       | 保山市                         |\n| 530502       | 隆阳区                         |\n| 530521       | 施甸县                         |\n| 530523       | 龙陵县                         |\n| 530524       | 昌宁县                         |\n| 530581       | 腾冲市                         |\n| 530600       | 昭通市                         |\n| 530602       | 昭阳区                         |\n| 530621       | 鲁甸县                         |\n| 530622       | 巧家县                         |\n| 530623       | 盐津县                         |\n| 530624       | 大关县                         |\n| 530625       | 永善县                         |\n| 530626       | 绥江县                         |\n| 530627       | 镇雄县                         |\n| 530628       | 彝良县                         |\n| 530629       | 威信县                         |\n| 530681       | 水富市                         |\n| 530700       | 丽江市                         |\n| 530702       | 古城区                         |\n| 530721       | 玉龙纳西族自治县               |\n| 530722       | 永胜县                         |\n| 530723       | 华坪县                         |\n| 530724       | 宁蒗彝族自治县                 |\n| 530800       | 普洱市                         |\n| 530802       | 思茅区                         |\n| 530821       | 宁洱哈尼族彝族自治县           |\n| 530822       | 墨江哈尼族自治县               |\n| 530823       | 景东彝族自治县                 |\n| 530824       | 景谷傣族彝族自治县             |\n| 530825       | 镇沅彝族哈尼族拉祜族自治县     |\n| 530826       | 江城哈尼族彝族自治县           |\n| 530827       | 孟连傣族拉祜族佤族自治县       |\n| 530828       | 澜沧拉祜族自治县               |\n| 530829       | 西盟佤族自治县                 |\n| 530900       | 临沧市                         |\n| 530902       | 临翔区                         |\n| 530921       | 凤庆县                         |\n| 530922       | 云县                           |\n| 530923       | 永德县                         |\n| 530924       | 镇康县                         |\n| 530925       | 双江拉祜族佤族布朗族傣族自治县 |\n| 530926       | 耿马傣族佤族自治县             |\n| 530927       | 沧源佤族自治县                 |\n| 532300       | 楚雄彝族自治州                 |\n| 532301       | 楚雄市                         |\n| 532322       | 双柏县                         |\n| 532323       | 牟定县                         |\n| 532324       | 南华县                         |\n| 532325       | 姚安县                         |\n| 532326       | 大姚县                         |\n| 532327       | 永仁县                         |\n| 532328       | 元谋县                         |\n| 532329       | 武定县                         |\n| 532331       | 禄丰县                         |\n| 532500       | 红河哈尼族彝族自治州           |\n| 532501       | 个旧市                         |\n| 532502       | 开远市                         |\n| 532503       | 蒙自市                         |\n| 532504       | 弥勒市                         |\n| 532523       | 屏边苗族自治县                 |\n| 532524       | 建水县                         |\n| 532525       | 石屏县                         |\n| 532527       | 泸西县                         |\n| 532528       | 元阳县                         |\n| 532529       | 红河县                         |\n| 532530       | 金平苗族瑶族傣族自治县         |\n| 532531       | 绿春县                         |\n| 532532       | 河口瑶族自治县                 |\n| 532600       | 文山壮族苗族自治州             |\n| 532601       | 文山市                         |\n| 532622       | 砚山县                         |\n| 532623       | 西畴县                         |\n| 532624       | 麻栗坡县                       |\n| 532625       | 马关县                         |\n| 532626       | 丘北县                         |\n| 532627       | 广南县                         |\n| 532628       | 富宁县                         |\n| 532800       | 西双版纳傣族自治州             |\n| 532801       | 景洪市                         |\n| 532822       | 勐海县                         |\n| 532823       | 勐腊县                         |\n| 532900       | 大理白族自治州                 |\n| 532901       | 大理市                         |\n| 532922       | 漾濞彝族自治县                 |\n| 532923       | 祥云县                         |\n| 532924       | 宾川县                         |\n| 532925       | 弥渡县                         |\n| 532926       | 南涧彝族自治县                 |\n| 532927       | 巍山彝族回族自治县             |\n| 532928       | 永平县                         |\n| 532929       | 云龙县                         |\n| 532930       | 洱源县                         |\n| 532931       | 剑川县                         |\n| 532932       | 鹤庆县                         |\n| 533100       | 德宏傣族景颇族自治州           |\n| 533102       | 瑞丽市                         |\n| 533103       | 芒市                           |\n| 533122       | 梁河县                         |\n| 533123       | 盈江县                         |\n| 533124       | 陇川县                         |\n| 533300       | 怒江傈僳族自治州               |\n| 533301       | 泸水市                         |\n| 533323       | 福贡县                         |\n| 533324       | 贡山独龙族怒族自治县           |\n| 533325       | 兰坪白族普米族自治县           |\n| 533400       | 迪庆藏族自治州                 |\n| 533401       | 香格里拉市                     |\n| 533422       | 德钦县                         |\n| 533423       | 维西傈僳族自治县               |\n| 540000       | 西藏自治区                     |\n| 540100       | 拉萨市                         |\n| 540102       | 城关区                         |\n| 540103       | 堆龙德庆区                     |\n| 540104       | 达孜区                         |\n| 540121       | 林周县                         |\n| 540122       | 当雄县                         |\n| 540123       | 尼木县                         |\n| 540124       | 曲水县                         |\n| 540127       | 墨竹工卡县                     |\n| 540200       | 日喀则市                       |\n| 540202       | 桑珠孜区                       |\n| 540221       | 南木林县                       |\n| 540222       | 江孜县                         |\n| 540223       | 定日县                         |\n| 540224       | 萨迦县                         |\n| 540225       | 拉孜县                         |\n| 540226       | 昂仁县                         |\n| 540227       | 谢通门县                       |\n| 540228       | 白朗县                         |\n| 540229       | 仁布县                         |\n| 540230       | 康马县                         |\n| 540231       | 定结县                         |\n| 540232       | 仲巴县                         |\n| 540233       | 亚东县                         |\n| 540234       | 吉隆县                         |\n| 540235       | 聂拉木县                       |\n| 540236       | 萨嘎县                         |\n| 540237       | 岗巴县                         |\n| 540300       | 昌都市                         |\n| 540302       | 卡若区                         |\n| 540321       | 江达县                         |\n| 540322       | 贡觉县                         |\n| 540323       | 类乌齐县                       |\n| 540324       | 丁青县                         |\n| 540325       | 察雅县                         |\n| 540326       | 八宿县                         |\n| 540327       | 左贡县                         |\n| 540328       | 芒康县                         |\n| 540329       | 洛隆县                         |\n| 540330       | 边坝县                         |\n| 540400       | 林芝市                         |\n| 540402       | 巴宜区                         |\n| 540421       | 工布江达县                     |\n| 540422       | 米林县                         |\n| 540423       | 墨脱县                         |\n| 540424       | 波密县                         |\n| 540425       | 察隅县                         |\n| 540426       | 朗县                           |\n| 540500       | 山南市                         |\n| 540502       | 乃东区                         |\n| 540521       | 扎囊县                         |\n| 540522       | 贡嘎县                         |\n| 540523       | 桑日县                         |\n| 540524       | 琼结县                         |\n| 540525       | 曲松县                         |\n| 540526       | 措美县                         |\n| 540527       | 洛扎县                         |\n| 540528       | 加查县                         |\n| 540529       | 隆子县                         |\n| 540530       | 错那县                         |\n| 540531       | 浪卡子县                       |\n| 540600       | 那曲市                         |\n| 540602       | 色尼区                         |\n| 540621       | 嘉黎县                         |\n| 540622       | 比如县                         |\n| 540623       | 聂荣县                         |\n| 540624       | 安多县                         |\n| 540625       | 申扎县                         |\n| 540626       | 索县                           |\n| 540627       | 班戈县                         |\n| 540628       | 巴青县                         |\n| 540629       | 尼玛县                         |\n| 540630       | 双湖县                         |\n| 542500       | 阿里地区                       |\n| 542521       | 普兰县                         |\n| 542522       | 札达县                         |\n| 542523       | 噶尔县                         |\n| 542524       | 日土县                         |\n| 542525       | 革吉县                         |\n| 542526       | 改则县                         |\n| 542527       | 措勤县                         |\n| 610000       | 陕西省                         |\n| 610100       | 西安市                         |\n| 610102       | 新城区                         |\n| 610103       | 碑林区                         |\n| 610104       | 莲湖区                         |\n| 610111       | 灞桥区                         |\n| 610112       | 未央区                         |\n| 610113       | 雁塔区                         |\n| 610114       | 阎良区                         |\n| 610115       | 临潼区                         |\n| 610116       | 长安区                         |\n| 610117       | 高陵区                         |\n| 610118       | 鄠邑区                         |\n| 610122       | 蓝田县                         |\n| 610124       | 周至县                         |\n| 610200       | 铜川市                         |\n| 610202       | 王益区                         |\n| 610203       | 印台区                         |\n| 610204       | 耀州区                         |\n| 610222       | 宜君县                         |\n| 610300       | 宝鸡市                         |\n| 610302       | 渭滨区                         |\n| 610303       | 金台区                         |\n| 610304       | 陈仓区                         |\n| 610322       | 凤翔县                         |\n| 610323       | 岐山县                         |\n| 610324       | 扶风县                         |\n| 610326       | 眉县                           |\n| 610327       | 陇县                           |\n| 610328       | 千阳县                         |\n| 610329       | 麟游县                         |\n| 610330       | 凤县                           |\n| 610331       | 太白县                         |\n| 610400       | 咸阳市                         |\n| 610402       | 秦都区                         |\n| 610403       | 杨陵区                         |\n| 610404       | 渭城区                         |\n| 610422       | 三原县                         |\n| 610423       | 泾阳县                         |\n| 610424       | 乾县                           |\n| 610425       | 礼泉县                         |\n| 610426       | 永寿县                         |\n| 610428       | 长武县                         |\n| 610429       | 旬邑县                         |\n| 610430       | 淳化县                         |\n| 610431       | 武功县                         |\n| 610481       | 兴平市                         |\n| 610482       | 彬州市                         |\n| 610500       | 渭南市                         |\n| 610502       | 临渭区                         |\n| 610503       | 华州区                         |\n| 610522       | 潼关县                         |\n| 610523       | 大荔县                         |\n| 610524       | 合阳县                         |\n| 610525       | 澄城县                         |\n| 610526       | 蒲城县                         |\n| 610527       | 白水县                         |\n| 610528       | 富平县                         |\n| 610581       | 韩城市                         |\n| 610582       | 华阴市                         |\n| 610600       | 延安市                         |\n| 610602       | 宝塔区                         |\n| 610603       | 安塞区                         |\n| 610621       | 延长县                         |\n| 610622       | 延川县                         |\n| 610625       | 志丹县                         |\n| 610626       | 吴起县                         |\n| 610627       | 甘泉县                         |\n| 610628       | 富县                           |\n| 610629       | 洛川县                         |\n| 610630       | 宜川县                         |\n| 610631       | 黄龙县                         |\n| 610632       | 黄陵县                         |\n| 610681       | 子长市                         |\n| 610700       | 汉中市                         |\n| 610702       | 汉台区                         |\n| 610703       | 南郑区                         |\n| 610722       | 城固县                         |\n| 610723       | 洋县                           |\n| 610724       | 西乡县                         |\n| 610725       | 勉县                           |\n| 610726       | 宁强县                         |\n| 610727       | 略阳县                         |\n| 610728       | 镇巴县                         |\n| 610729       | 留坝县                         |\n| 610730       | 佛坪县                         |\n| 610800       | 榆林市                         |\n| 610802       | 榆阳区                         |\n| 610803       | 横山区                         |\n| 610822       | 府谷县                         |\n| 610824       | 靖边县                         |\n| 610825       | 定边县                         |\n| 610826       | 绥德县                         |\n| 610827       | 米脂县                         |\n| 610828       | 佳县                           |\n| 610829       | 吴堡县                         |\n| 610830       | 清涧县                         |\n| 610831       | 子洲县                         |\n| 610881       | 神木市                         |\n| 610900       | 安康市                         |\n| 610902       | 汉滨区                         |\n| 610921       | 汉阴县                         |\n| 610922       | 石泉县                         |\n| 610923       | 宁陕县                         |\n| 610924       | 紫阳县                         |\n| 610925       | 岚皋县                         |\n| 610926       | 平利县                         |\n| 610927       | 镇坪县                         |\n| 610928       | 旬阳县                         |\n| 610929       | 白河县                         |\n| 611000       | 商洛市                         |\n| 611002       | 商州区                         |\n| 611021       | 洛南县                         |\n| 611022       | 丹凤县                         |\n| 611023       | 商南县                         |\n| 611024       | 山阳县                         |\n| 611025       | 镇安县                         |\n| 611026       | 柞水县                         |\n| 620000       | 甘肃省                         |\n| 620100       | 兰州市                         |\n| 620102       | 城关区                         |\n| 620103       | 七里河区                       |\n| 620104       | 西固区                         |\n| 620105       | 安宁区                         |\n| 620111       | 红古区                         |\n| 620121       | 永登县                         |\n| 620122       | 皋兰县                         |\n| 620123       | 榆中县                         |\n| 620200       | 嘉峪关市                       |\n| 620300       | 金昌市                         |\n| 620302       | 金川区                         |\n| 620321       | 永昌县                         |\n| 620400       | 白银市                         |\n| 620402       | 白银区                         |\n| 620403       | 平川区                         |\n| 620421       | 靖远县                         |\n| 620422       | 会宁县                         |\n| 620423       | 景泰县                         |\n| 620500       | 天水市                         |\n| 620502       | 秦州区                         |\n| 620503       | 麦积区                         |\n| 620521       | 清水县                         |\n| 620522       | 秦安县                         |\n| 620523       | 甘谷县                         |\n| 620524       | 武山县                         |\n| 620525       | 张家川回族自治县               |\n| 620600       | 武威市                         |\n| 620602       | 凉州区                         |\n| 620621       | 民勤县                         |\n| 620622       | 古浪县                         |\n| 620623       | 天祝藏族自治县                 |\n| 620700       | 张掖市                         |\n| 620702       | 甘州区                         |\n| 620721       | 肃南裕固族自治县               |\n| 620722       | 民乐县                         |\n| 620723       | 临泽县                         |\n| 620724       | 高台县                         |\n| 620725       | 山丹县                         |\n| 620800       | 平凉市                         |\n| 620802       | 崆峒区                         |\n| 620821       | 泾川县                         |\n| 620822       | 灵台县                         |\n| 620823       | 崇信县                         |\n| 620825       | 庄浪县                         |\n| 620826       | 静宁县                         |\n| 620881       | 华亭市                         |\n| 620900       | 酒泉市                         |\n| 620902       | 肃州区                         |\n| 620921       | 金塔县                         |\n| 620922       | 瓜州县                         |\n| 620923       | 肃北蒙古族自治县               |\n| 620924       | 阿克塞哈萨克族自治县           |\n| 620981       | 玉门市                         |\n| 620982       | 敦煌市                         |\n| 621000       | 庆阳市                         |\n| 621002       | 西峰区                         |\n| 621021       | 庆城县                         |\n| 621022       | 环县                           |\n| 621023       | 华池县                         |\n| 621024       | 合水县                         |\n| 621025       | 正宁县                         |\n| 621026       | 宁县                           |\n| 621027       | 镇原县                         |\n| 621100       | 定西市                         |\n| 621102       | 安定区                         |\n| 621121       | 通渭县                         |\n| 621122       | 陇西县                         |\n| 621123       | 渭源县                         |\n| 621124       | 临洮县                         |\n| 621125       | 漳县                           |\n| 621126       | 岷县                           |\n| 621200       | 陇南市                         |\n| 621202       | 武都区                         |\n| 621221       | 成县                           |\n| 621222       | 文县                           |\n| 621223       | 宕昌县                         |\n| 621224       | 康县                           |\n| 621225       | 西和县                         |\n| 621226       | 礼县                           |\n| 621227       | 徽县                           |\n| 621228       | 两当县                         |\n| 622900       | 临夏回族自治州                 |\n| 622901       | 临夏市                         |\n| 622921       | 临夏县                         |\n| 622922       | 康乐县                         |\n| 622923       | 永靖县                         |\n| 622924       | 广河县                         |\n| 622925       | 和政县                         |\n| 622926       | 东乡族自治县                   |\n| 622927       | 积石山保安族东乡族撒拉族自治县 |\n| 623000       | 甘南藏族自治州                 |\n| 623001       | 合作市                         |\n| 623021       | 临潭县                         |\n| 623022       | 卓尼县                         |\n| 623023       | 舟曲县                         |\n| 623024       | 迭部县                         |\n| 623025       | 玛曲县                         |\n| 623026       | 碌曲县                         |\n| 623027       | 夏河县                         |\n| 630000       | 青海省                         |\n| 630100       | 西宁市                         |\n| 630102       | 城东区                         |\n| 630103       | 城中区                         |\n| 630104       | 城西区                         |\n| 630105       | 城北区                         |\n| 630106       | 湟中区                         |\n| 630121       | 大通回族土族自治县             |\n| 630123       | 湟源县                         |\n| 630200       | 海东市                         |\n| 630202       | 乐都区                         |\n| 630203       | 平安区                         |\n| 630222       | 民和回族土族自治县             |\n| 630223       | 互助土族自治县                 |\n| 630224       | 化隆回族自治县                 |\n| 630225       | 循化撒拉族自治县               |\n| 632200       | 海北藏族自治州                 |\n| 632221       | 门源回族自治县                 |\n| 632222       | 祁连县                         |\n| 632223       | 海晏县                         |\n| 632224       | 刚察县                         |\n| 632300       | 黄南藏族自治州                 |\n| 632321       | 同仁县                         |\n| 632322       | 尖扎县                         |\n| 632323       | 泽库县                         |\n| 632324       | 河南蒙古族自治县               |\n| 632500       | 海南藏族自治州                 |\n| 632521       | 共和县                         |\n| 632522       | 同德县                         |\n| 632523       | 贵德县                         |\n| 632524       | 兴海县                         |\n| 632525       | 贵南县                         |\n| 632600       | 果洛藏族自治州                 |\n| 632621       | 玛沁县                         |\n| 632622       | 班玛县                         |\n| 632623       | 甘德县                         |\n| 632624       | 达日县                         |\n| 632625       | 久治县                         |\n| 632626       | 玛多县                         |\n| 632700       | 玉树藏族自治州                 |\n| 632701       | 玉树市                         |\n| 632722       | 杂多县                         |\n| 632723       | 称多县                         |\n| 632724       | 治多县                         |\n| 632725       | 囊谦县                         |\n| 632726       | 曲麻莱县                       |\n| 632800       | 海西蒙古族藏族自治州           |\n| 632801       | 格尔木市                       |\n| 632802       | 德令哈市                       |\n| 632803       | 茫崖市                         |\n| 632821       | 乌兰县                         |\n| 632822       | 都兰县                         |\n| 632823       | 天峻县                         |\n| 640000       | 宁夏回族自治区                 |\n| 640100       | 银川市                         |\n| 640104       | 兴庆区                         |\n| 640105       | 西夏区                         |\n| 640106       | 金凤区                         |\n| 640121       | 永宁县                         |\n| 640122       | 贺兰县                         |\n| 640181       | 灵武市                         |\n| 640200       | 石嘴山市                       |\n| 640202       | 大武口区                       |\n| 640205       | 惠农区                         |\n| 640221       | 平罗县                         |\n| 640300       | 吴忠市                         |\n| 640302       | 利通区                         |\n| 640303       | 红寺堡区                       |\n| 640323       | 盐池县                         |\n| 640324       | 同心县                         |\n| 640381       | 青铜峡市                       |\n| 640400       | 固原市                         |\n| 640402       | 原州区                         |\n| 640422       | 西吉县                         |\n| 640423       | 隆德县                         |\n| 640424       | 泾源县                         |\n| 640425       | 彭阳县                         |\n| 640500       | 中卫市                         |\n| 640502       | 沙坡头区                       |\n| 640521       | 中宁县                         |\n| 640522       | 海原县                         |\n| 650000       | 新疆维吾尔自治区               |\n| 650100       | 乌鲁木齐市                     |\n| 650102       | 天山区                         |\n| 650103       | 沙依巴克区                     |\n| 650104       | 新市区                         |\n| 650105       | 水磨沟区                       |\n| 650106       | 头屯河区                       |\n| 650107       | 达坂城区                       |\n| 650109       | 米东区                         |\n| 650121       | 乌鲁木齐县                     |\n| 650200       | 克拉玛依市                     |\n| 650202       | 独山子区                       |\n| 650203       | 克拉玛依区                     |\n| 650204       | 白碱滩区                       |\n| 650205       | 乌尔禾区                       |\n| 650400       | 吐鲁番市                       |\n| 650402       | 高昌区                         |\n| 650421       | 鄯善县                         |\n| 650422       | 托克逊县                       |\n| 650500       | 哈密市                         |\n| 650502       | 伊州区                         |\n| 650521       | 巴里坤哈萨克自治县             |\n| 650522       | 伊吾县                         |\n| 652300       | 昌吉回族自治州                 |\n| 652301       | 昌吉市                         |\n| 652302       | 阜康市                         |\n| 652323       | 呼图壁县                       |\n| 652324       | 玛纳斯县                       |\n| 652325       | 奇台县                         |\n| 652327       | 吉木萨尔县                     |\n| 652328       | 木垒哈萨克自治县               |\n| 652700       | 博尔塔拉蒙古自治州             |\n| 652701       | 博乐市                         |\n| 652702       | 阿拉山口市                     |\n| 652722       | 精河县                         |\n| 652723       | 温泉县                         |\n| 652800       | 巴音郭楞蒙古自治州             |\n| 652801       | 库尔勒市                       |\n| 652822       | 轮台县                         |\n| 652823       | 尉犁县                         |\n| 652824       | 若羌县                         |\n| 652825       | 且末县                         |\n| 652826       | 焉耆回族自治县                 |\n| 652827       | 和静县                         |\n| 652828       | 和硕县                         |\n| 652829       | 博湖县                         |\n| 652900       | 阿克苏地区                     |\n| 652901       | 阿克苏市                       |\n| 652902       | 库车市                         |\n| 652922       | 温宿县                         |\n| 652924       | 沙雅县                         |\n| 652925       | 新和县                         |\n| 652926       | 拜城县                         |\n| 652927       | 乌什县                         |\n| 652928       | 阿瓦提县                       |\n| 652929       | 柯坪县                         |\n| 653000       | 克孜勒苏柯尔克孜自治州         |\n| 653001       | 阿图什市                       |\n| 653022       | 阿克陶县                       |\n| 653023       | 阿合奇县                       |\n| 653024       | 乌恰县                         |\n| 653100       | 喀什地区                       |\n| 653101       | 喀什市                         |\n| 653121       | 疏附县                         |\n| 653122       | 疏勒县                         |\n| 653123       | 英吉沙县                       |\n| 653124       | 泽普县                         |\n| 653125       | 莎车县                         |\n| 653126       | 叶城县                         |\n| 653127       | 麦盖提县                       |\n| 653128       | 岳普湖县                       |\n| 653129       | 伽师县                         |\n| 653130       | 巴楚县                         |\n| 653131       | 塔什库尔干塔吉克自治县         |\n| 653200       | 和田地区                       |\n| 653201       | 和田市                         |\n| 653221       | 和田县                         |\n| 653222       | 墨玉县                         |\n| 653223       | 皮山县                         |\n| 653224       | 洛浦县                         |\n| 653225       | 策勒县                         |\n| 653226       | 于田县                         |\n| 653227       | 民丰县                         |\n| 654000       | 伊犁哈萨克自治州               |\n| 654002       | 伊宁市                         |\n| 654003       | 奎屯市                         |\n| 654004       | 霍尔果斯市                     |\n| 654021       | 伊宁县                         |\n| 654022       | 察布查尔锡伯自治县             |\n| 654023       | 霍城县                         |\n| 654024       | 巩留县                         |\n| 654025       | 新源县                         |\n| 654026       | 昭苏县                         |\n| 654027       | 特克斯县                       |\n| 654028       | 尼勒克县                       |\n| 654200       | 塔城地区                       |\n| 654201       | 塔城市                         |\n| 654202       | 乌苏市                         |\n| 654221       | 额敏县                         |\n| 654223       | 沙湾县                         |\n| 654224       | 托里县                         |\n| 654225       | 裕民县                         |\n| 654226       | 和布克赛尔蒙古自治县           |\n| 654300       | 阿勒泰地区                     |\n| 654301       | 阿勒泰市                       |\n| 654321       | 布尔津县                       |\n| 654322       | 富蕴县                         |\n| 654323       | 福海县                         |\n| 654324       | 哈巴河县                       |\n| 654325       | 青河县                         |\n| 654326       | 吉木乃县                       |\n| 659001       | 石河子市                       |\n| 659002       | 阿拉尔市                       |\n| 659003       | 图木舒克市                     |\n| 659004       | 五家渠市                       |\n| 659005       | 北屯市                         |\n| 659006       | 铁门关市                       |\n| 659007       | 双河市                         |\n| 659008       | 可克达拉市                     |\n| 659009       | 昆玉市                         |\n| 659010       | 胡杨河市                       |\n| 710000       | 台湾省                         |\n| 810000       | 香港特别行政区                 |\n| 820000       | 澳门特别行政区                 |\n注：1、台湾省、香港特别行政区和澳门特别行政区暂缺地市和区县信息。\t\t\t\t\n   2.本表由统计人员每月根据民政统计信息管理系统中上报单位名称变动情况搜集相关文件编制，略滞后于区划调整文件发布时间。\n   3.为保证上下年度统计工作有效衔接，各级民政统计人员将在当年12月底与区划部门核对并调整统计系统中所有上报单位名称，同时编制发布本表。\n","content":"<p><a href=\"https://www.mca.gov.cn/article/sj/xzqh/2020/2020/202003061536.html\">https://www.mca.gov.cn/article/sj/xzqh/2020/2020/202003061536.html</a> </p>\n<p>2020年1月中华人民共和国县以上行政区划代码\t\t</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">行政区划代码</th>\n<th align=\"left\">单位名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">110000</td>\n<td align=\"left\">北京市</td>\n</tr>\n<tr>\n<td align=\"left\">110101</td>\n<td align=\"left\">东城区</td>\n</tr>\n<tr>\n<td align=\"left\">110102</td>\n<td align=\"left\">西城区</td>\n</tr>\n<tr>\n<td align=\"left\">110105</td>\n<td align=\"left\">朝阳区</td>\n</tr>\n<tr>\n<td align=\"left\">110106</td>\n<td align=\"left\">丰台区</td>\n</tr>\n<tr>\n<td align=\"left\">110107</td>\n<td align=\"left\">石景山区</td>\n</tr>\n<tr>\n<td align=\"left\">110108</td>\n<td align=\"left\">海淀区</td>\n</tr>\n<tr>\n<td align=\"left\">110109</td>\n<td align=\"left\">门头沟区</td>\n</tr>\n<tr>\n<td align=\"left\">110111</td>\n<td align=\"left\">房山区</td>\n</tr>\n<tr>\n<td align=\"left\">110112</td>\n<td align=\"left\">通州区</td>\n</tr>\n<tr>\n<td align=\"left\">110113</td>\n<td align=\"left\">顺义区</td>\n</tr>\n<tr>\n<td align=\"left\">110114</td>\n<td align=\"left\">昌平区</td>\n</tr>\n<tr>\n<td align=\"left\">110115</td>\n<td align=\"left\">大兴区</td>\n</tr>\n<tr>\n<td align=\"left\">110116</td>\n<td align=\"left\">怀柔区</td>\n</tr>\n<tr>\n<td align=\"left\">110117</td>\n<td align=\"left\">平谷区</td>\n</tr>\n<tr>\n<td align=\"left\">110118</td>\n<td align=\"left\">密云区</td>\n</tr>\n<tr>\n<td align=\"left\">110119</td>\n<td align=\"left\">延庆区</td>\n</tr>\n<tr>\n<td align=\"left\">120000</td>\n<td align=\"left\">天津市</td>\n</tr>\n<tr>\n<td align=\"left\">120101</td>\n<td align=\"left\">和平区</td>\n</tr>\n<tr>\n<td align=\"left\">120102</td>\n<td align=\"left\">河东区</td>\n</tr>\n<tr>\n<td align=\"left\">120103</td>\n<td align=\"left\">河西区</td>\n</tr>\n<tr>\n<td align=\"left\">120104</td>\n<td align=\"left\">南开区</td>\n</tr>\n<tr>\n<td align=\"left\">120105</td>\n<td align=\"left\">河北区</td>\n</tr>\n<tr>\n<td align=\"left\">120106</td>\n<td align=\"left\">红桥区</td>\n</tr>\n<tr>\n<td align=\"left\">120110</td>\n<td align=\"left\">东丽区</td>\n</tr>\n<tr>\n<td align=\"left\">120111</td>\n<td align=\"left\">西青区</td>\n</tr>\n<tr>\n<td align=\"left\">120112</td>\n<td align=\"left\">津南区</td>\n</tr>\n<tr>\n<td align=\"left\">120113</td>\n<td align=\"left\">北辰区</td>\n</tr>\n<tr>\n<td align=\"left\">120114</td>\n<td align=\"left\">武清区</td>\n</tr>\n<tr>\n<td align=\"left\">120115</td>\n<td align=\"left\">宝坻区</td>\n</tr>\n<tr>\n<td align=\"left\">120116</td>\n<td align=\"left\">滨海新区</td>\n</tr>\n<tr>\n<td align=\"left\">120117</td>\n<td align=\"left\">宁河区</td>\n</tr>\n<tr>\n<td align=\"left\">120118</td>\n<td align=\"left\">静海区</td>\n</tr>\n<tr>\n<td align=\"left\">120119</td>\n<td align=\"left\">蓟州区</td>\n</tr>\n<tr>\n<td align=\"left\">130000</td>\n<td align=\"left\">河北省</td>\n</tr>\n<tr>\n<td align=\"left\">130100</td>\n<td align=\"left\">石家庄市</td>\n</tr>\n<tr>\n<td align=\"left\">130102</td>\n<td align=\"left\">长安区</td>\n</tr>\n<tr>\n<td align=\"left\">130104</td>\n<td align=\"left\">桥西区</td>\n</tr>\n<tr>\n<td align=\"left\">130105</td>\n<td align=\"left\">新华区</td>\n</tr>\n<tr>\n<td align=\"left\">130107</td>\n<td align=\"left\">井陉矿区</td>\n</tr>\n<tr>\n<td align=\"left\">130108</td>\n<td align=\"left\">裕华区</td>\n</tr>\n<tr>\n<td align=\"left\">130109</td>\n<td align=\"left\">藁城区</td>\n</tr>\n<tr>\n<td align=\"left\">130110</td>\n<td align=\"left\">鹿泉区</td>\n</tr>\n<tr>\n<td align=\"left\">130111</td>\n<td align=\"left\">栾城区</td>\n</tr>\n<tr>\n<td align=\"left\">130121</td>\n<td align=\"left\">井陉县</td>\n</tr>\n<tr>\n<td align=\"left\">130123</td>\n<td align=\"left\">正定县</td>\n</tr>\n<tr>\n<td align=\"left\">130125</td>\n<td align=\"left\">行唐县</td>\n</tr>\n<tr>\n<td align=\"left\">130126</td>\n<td align=\"left\">灵寿县</td>\n</tr>\n<tr>\n<td align=\"left\">130127</td>\n<td align=\"left\">高邑县</td>\n</tr>\n<tr>\n<td align=\"left\">130128</td>\n<td align=\"left\">深泽县</td>\n</tr>\n<tr>\n<td align=\"left\">130129</td>\n<td align=\"left\">赞皇县</td>\n</tr>\n<tr>\n<td align=\"left\">130130</td>\n<td align=\"left\">无极县</td>\n</tr>\n<tr>\n<td align=\"left\">130131</td>\n<td align=\"left\">平山县</td>\n</tr>\n<tr>\n<td align=\"left\">130132</td>\n<td align=\"left\">元氏县</td>\n</tr>\n<tr>\n<td align=\"left\">130133</td>\n<td align=\"left\">赵县</td>\n</tr>\n<tr>\n<td align=\"left\">130181</td>\n<td align=\"left\">辛集市</td>\n</tr>\n<tr>\n<td align=\"left\">130183</td>\n<td align=\"left\">晋州市</td>\n</tr>\n<tr>\n<td align=\"left\">130184</td>\n<td align=\"left\">新乐市</td>\n</tr>\n<tr>\n<td align=\"left\">130200</td>\n<td align=\"left\">唐山市</td>\n</tr>\n<tr>\n<td align=\"left\">130202</td>\n<td align=\"left\">路南区</td>\n</tr>\n<tr>\n<td align=\"left\">130203</td>\n<td align=\"left\">路北区</td>\n</tr>\n<tr>\n<td align=\"left\">130204</td>\n<td align=\"left\">古冶区</td>\n</tr>\n<tr>\n<td align=\"left\">130205</td>\n<td align=\"left\">开平区</td>\n</tr>\n<tr>\n<td align=\"left\">130207</td>\n<td align=\"left\">丰南区</td>\n</tr>\n<tr>\n<td align=\"left\">130208</td>\n<td align=\"left\">丰润区</td>\n</tr>\n<tr>\n<td align=\"left\">130209</td>\n<td align=\"left\">曹妃甸区</td>\n</tr>\n<tr>\n<td align=\"left\">130224</td>\n<td align=\"left\">滦南县</td>\n</tr>\n<tr>\n<td align=\"left\">130225</td>\n<td align=\"left\">乐亭县</td>\n</tr>\n<tr>\n<td align=\"left\">130227</td>\n<td align=\"left\">迁西县</td>\n</tr>\n<tr>\n<td align=\"left\">130229</td>\n<td align=\"left\">玉田县</td>\n</tr>\n<tr>\n<td align=\"left\">130281</td>\n<td align=\"left\">遵化市</td>\n</tr>\n<tr>\n<td align=\"left\">130283</td>\n<td align=\"left\">迁安市</td>\n</tr>\n<tr>\n<td align=\"left\">130284</td>\n<td align=\"left\">滦州市</td>\n</tr>\n<tr>\n<td align=\"left\">130300</td>\n<td align=\"left\">秦皇岛市</td>\n</tr>\n<tr>\n<td align=\"left\">130302</td>\n<td align=\"left\">海港区</td>\n</tr>\n<tr>\n<td align=\"left\">130303</td>\n<td align=\"left\">山海关区</td>\n</tr>\n<tr>\n<td align=\"left\">130304</td>\n<td align=\"left\">北戴河区</td>\n</tr>\n<tr>\n<td align=\"left\">130306</td>\n<td align=\"left\">抚宁区</td>\n</tr>\n<tr>\n<td align=\"left\">130321</td>\n<td align=\"left\">青龙满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">130322</td>\n<td align=\"left\">昌黎县</td>\n</tr>\n<tr>\n<td align=\"left\">130324</td>\n<td align=\"left\">卢龙县</td>\n</tr>\n<tr>\n<td align=\"left\">130400</td>\n<td align=\"left\">邯郸市</td>\n</tr>\n<tr>\n<td align=\"left\">130402</td>\n<td align=\"left\">邯山区</td>\n</tr>\n<tr>\n<td align=\"left\">130403</td>\n<td align=\"left\">丛台区</td>\n</tr>\n<tr>\n<td align=\"left\">130404</td>\n<td align=\"left\">复兴区</td>\n</tr>\n<tr>\n<td align=\"left\">130406</td>\n<td align=\"left\">峰峰矿区</td>\n</tr>\n<tr>\n<td align=\"left\">130407</td>\n<td align=\"left\">肥乡区</td>\n</tr>\n<tr>\n<td align=\"left\">130408</td>\n<td align=\"left\">永年区</td>\n</tr>\n<tr>\n<td align=\"left\">130423</td>\n<td align=\"left\">临漳县</td>\n</tr>\n<tr>\n<td align=\"left\">130424</td>\n<td align=\"left\">成安县</td>\n</tr>\n<tr>\n<td align=\"left\">130425</td>\n<td align=\"left\">大名县</td>\n</tr>\n<tr>\n<td align=\"left\">130426</td>\n<td align=\"left\">涉县</td>\n</tr>\n<tr>\n<td align=\"left\">130427</td>\n<td align=\"left\">磁县</td>\n</tr>\n<tr>\n<td align=\"left\">130430</td>\n<td align=\"left\">邱县</td>\n</tr>\n<tr>\n<td align=\"left\">130431</td>\n<td align=\"left\">鸡泽县</td>\n</tr>\n<tr>\n<td align=\"left\">130432</td>\n<td align=\"left\">广平县</td>\n</tr>\n<tr>\n<td align=\"left\">130433</td>\n<td align=\"left\">馆陶县</td>\n</tr>\n<tr>\n<td align=\"left\">130434</td>\n<td align=\"left\">魏县</td>\n</tr>\n<tr>\n<td align=\"left\">130435</td>\n<td align=\"left\">曲周县</td>\n</tr>\n<tr>\n<td align=\"left\">130481</td>\n<td align=\"left\">武安市</td>\n</tr>\n<tr>\n<td align=\"left\">130500</td>\n<td align=\"left\">邢台市</td>\n</tr>\n<tr>\n<td align=\"left\">130502</td>\n<td align=\"left\">桥东区</td>\n</tr>\n<tr>\n<td align=\"left\">130503</td>\n<td align=\"left\">桥西区</td>\n</tr>\n<tr>\n<td align=\"left\">130521</td>\n<td align=\"left\">邢台县</td>\n</tr>\n<tr>\n<td align=\"left\">130522</td>\n<td align=\"left\">临城县</td>\n</tr>\n<tr>\n<td align=\"left\">130523</td>\n<td align=\"left\">内丘县</td>\n</tr>\n<tr>\n<td align=\"left\">130524</td>\n<td align=\"left\">柏乡县</td>\n</tr>\n<tr>\n<td align=\"left\">130525</td>\n<td align=\"left\">隆尧县</td>\n</tr>\n<tr>\n<td align=\"left\">130526</td>\n<td align=\"left\">任县</td>\n</tr>\n<tr>\n<td align=\"left\">130527</td>\n<td align=\"left\">南和县</td>\n</tr>\n<tr>\n<td align=\"left\">130528</td>\n<td align=\"left\">宁晋县</td>\n</tr>\n<tr>\n<td align=\"left\">130529</td>\n<td align=\"left\">巨鹿县</td>\n</tr>\n<tr>\n<td align=\"left\">130530</td>\n<td align=\"left\">新河县</td>\n</tr>\n<tr>\n<td align=\"left\">130531</td>\n<td align=\"left\">广宗县</td>\n</tr>\n<tr>\n<td align=\"left\">130532</td>\n<td align=\"left\">平乡县</td>\n</tr>\n<tr>\n<td align=\"left\">130533</td>\n<td align=\"left\">威县</td>\n</tr>\n<tr>\n<td align=\"left\">130534</td>\n<td align=\"left\">清河县</td>\n</tr>\n<tr>\n<td align=\"left\">130535</td>\n<td align=\"left\">临西县</td>\n</tr>\n<tr>\n<td align=\"left\">130581</td>\n<td align=\"left\">南宫市</td>\n</tr>\n<tr>\n<td align=\"left\">130582</td>\n<td align=\"left\">沙河市</td>\n</tr>\n<tr>\n<td align=\"left\">130600</td>\n<td align=\"left\">保定市</td>\n</tr>\n<tr>\n<td align=\"left\">130602</td>\n<td align=\"left\">竞秀区</td>\n</tr>\n<tr>\n<td align=\"left\">130606</td>\n<td align=\"left\">莲池区</td>\n</tr>\n<tr>\n<td align=\"left\">130607</td>\n<td align=\"left\">满城区</td>\n</tr>\n<tr>\n<td align=\"left\">130608</td>\n<td align=\"left\">清苑区</td>\n</tr>\n<tr>\n<td align=\"left\">130609</td>\n<td align=\"left\">徐水区</td>\n</tr>\n<tr>\n<td align=\"left\">130623</td>\n<td align=\"left\">涞水县</td>\n</tr>\n<tr>\n<td align=\"left\">130624</td>\n<td align=\"left\">阜平县</td>\n</tr>\n<tr>\n<td align=\"left\">130626</td>\n<td align=\"left\">定兴县</td>\n</tr>\n<tr>\n<td align=\"left\">130627</td>\n<td align=\"left\">唐县</td>\n</tr>\n<tr>\n<td align=\"left\">130628</td>\n<td align=\"left\">高阳县</td>\n</tr>\n<tr>\n<td align=\"left\">130629</td>\n<td align=\"left\">容城县</td>\n</tr>\n<tr>\n<td align=\"left\">130630</td>\n<td align=\"left\">涞源县</td>\n</tr>\n<tr>\n<td align=\"left\">130631</td>\n<td align=\"left\">望都县</td>\n</tr>\n<tr>\n<td align=\"left\">130632</td>\n<td align=\"left\">安新县</td>\n</tr>\n<tr>\n<td align=\"left\">130633</td>\n<td align=\"left\">易县</td>\n</tr>\n<tr>\n<td align=\"left\">130634</td>\n<td align=\"left\">曲阳县</td>\n</tr>\n<tr>\n<td align=\"left\">130635</td>\n<td align=\"left\">蠡县</td>\n</tr>\n<tr>\n<td align=\"left\">130636</td>\n<td align=\"left\">顺平县</td>\n</tr>\n<tr>\n<td align=\"left\">130637</td>\n<td align=\"left\">博野县</td>\n</tr>\n<tr>\n<td align=\"left\">130638</td>\n<td align=\"left\">雄县</td>\n</tr>\n<tr>\n<td align=\"left\">130681</td>\n<td align=\"left\">涿州市</td>\n</tr>\n<tr>\n<td align=\"left\">130682</td>\n<td align=\"left\">定州市</td>\n</tr>\n<tr>\n<td align=\"left\">130683</td>\n<td align=\"left\">安国市</td>\n</tr>\n<tr>\n<td align=\"left\">130684</td>\n<td align=\"left\">高碑店市</td>\n</tr>\n<tr>\n<td align=\"left\">130700</td>\n<td align=\"left\">张家口市</td>\n</tr>\n<tr>\n<td align=\"left\">130702</td>\n<td align=\"left\">桥东区</td>\n</tr>\n<tr>\n<td align=\"left\">130703</td>\n<td align=\"left\">桥西区</td>\n</tr>\n<tr>\n<td align=\"left\">130705</td>\n<td align=\"left\">宣化区</td>\n</tr>\n<tr>\n<td align=\"left\">130706</td>\n<td align=\"left\">下花园区</td>\n</tr>\n<tr>\n<td align=\"left\">130708</td>\n<td align=\"left\">万全区</td>\n</tr>\n<tr>\n<td align=\"left\">130709</td>\n<td align=\"left\">崇礼区</td>\n</tr>\n<tr>\n<td align=\"left\">130722</td>\n<td align=\"left\">张北县</td>\n</tr>\n<tr>\n<td align=\"left\">130723</td>\n<td align=\"left\">康保县</td>\n</tr>\n<tr>\n<td align=\"left\">130724</td>\n<td align=\"left\">沽源县</td>\n</tr>\n<tr>\n<td align=\"left\">130725</td>\n<td align=\"left\">尚义县</td>\n</tr>\n<tr>\n<td align=\"left\">130726</td>\n<td align=\"left\">蔚县</td>\n</tr>\n<tr>\n<td align=\"left\">130727</td>\n<td align=\"left\">阳原县</td>\n</tr>\n<tr>\n<td align=\"left\">130728</td>\n<td align=\"left\">怀安县</td>\n</tr>\n<tr>\n<td align=\"left\">130730</td>\n<td align=\"left\">怀来县</td>\n</tr>\n<tr>\n<td align=\"left\">130731</td>\n<td align=\"left\">涿鹿县</td>\n</tr>\n<tr>\n<td align=\"left\">130732</td>\n<td align=\"left\">赤城县</td>\n</tr>\n<tr>\n<td align=\"left\">130800</td>\n<td align=\"left\">承德市</td>\n</tr>\n<tr>\n<td align=\"left\">130802</td>\n<td align=\"left\">双桥区</td>\n</tr>\n<tr>\n<td align=\"left\">130803</td>\n<td align=\"left\">双滦区</td>\n</tr>\n<tr>\n<td align=\"left\">130804</td>\n<td align=\"left\">鹰手营子矿区</td>\n</tr>\n<tr>\n<td align=\"left\">130821</td>\n<td align=\"left\">承德县</td>\n</tr>\n<tr>\n<td align=\"left\">130822</td>\n<td align=\"left\">兴隆县</td>\n</tr>\n<tr>\n<td align=\"left\">130824</td>\n<td align=\"left\">滦平县</td>\n</tr>\n<tr>\n<td align=\"left\">130825</td>\n<td align=\"left\">隆化县</td>\n</tr>\n<tr>\n<td align=\"left\">130826</td>\n<td align=\"left\">丰宁满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">130827</td>\n<td align=\"left\">宽城满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">130828</td>\n<td align=\"left\">围场满族蒙古族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">130881</td>\n<td align=\"left\">平泉市</td>\n</tr>\n<tr>\n<td align=\"left\">130900</td>\n<td align=\"left\">沧州市</td>\n</tr>\n<tr>\n<td align=\"left\">130902</td>\n<td align=\"left\">新华区</td>\n</tr>\n<tr>\n<td align=\"left\">130903</td>\n<td align=\"left\">运河区</td>\n</tr>\n<tr>\n<td align=\"left\">130921</td>\n<td align=\"left\">沧县</td>\n</tr>\n<tr>\n<td align=\"left\">130922</td>\n<td align=\"left\">青县</td>\n</tr>\n<tr>\n<td align=\"left\">130923</td>\n<td align=\"left\">东光县</td>\n</tr>\n<tr>\n<td align=\"left\">130924</td>\n<td align=\"left\">海兴县</td>\n</tr>\n<tr>\n<td align=\"left\">130925</td>\n<td align=\"left\">盐山县</td>\n</tr>\n<tr>\n<td align=\"left\">130926</td>\n<td align=\"left\">肃宁县</td>\n</tr>\n<tr>\n<td align=\"left\">130927</td>\n<td align=\"left\">南皮县</td>\n</tr>\n<tr>\n<td align=\"left\">130928</td>\n<td align=\"left\">吴桥县</td>\n</tr>\n<tr>\n<td align=\"left\">130929</td>\n<td align=\"left\">献县</td>\n</tr>\n<tr>\n<td align=\"left\">130930</td>\n<td align=\"left\">孟村回族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">130981</td>\n<td align=\"left\">泊头市</td>\n</tr>\n<tr>\n<td align=\"left\">130982</td>\n<td align=\"left\">任丘市</td>\n</tr>\n<tr>\n<td align=\"left\">130983</td>\n<td align=\"left\">黄骅市</td>\n</tr>\n<tr>\n<td align=\"left\">130984</td>\n<td align=\"left\">河间市</td>\n</tr>\n<tr>\n<td align=\"left\">131000</td>\n<td align=\"left\">廊坊市</td>\n</tr>\n<tr>\n<td align=\"left\">131002</td>\n<td align=\"left\">安次区</td>\n</tr>\n<tr>\n<td align=\"left\">131003</td>\n<td align=\"left\">广阳区</td>\n</tr>\n<tr>\n<td align=\"left\">131022</td>\n<td align=\"left\">固安县</td>\n</tr>\n<tr>\n<td align=\"left\">131023</td>\n<td align=\"left\">永清县</td>\n</tr>\n<tr>\n<td align=\"left\">131024</td>\n<td align=\"left\">香河县</td>\n</tr>\n<tr>\n<td align=\"left\">131025</td>\n<td align=\"left\">大城县</td>\n</tr>\n<tr>\n<td align=\"left\">131026</td>\n<td align=\"left\">文安县</td>\n</tr>\n<tr>\n<td align=\"left\">131028</td>\n<td align=\"left\">大厂回族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">131081</td>\n<td align=\"left\">霸州市</td>\n</tr>\n<tr>\n<td align=\"left\">131082</td>\n<td align=\"left\">三河市</td>\n</tr>\n<tr>\n<td align=\"left\">131100</td>\n<td align=\"left\">衡水市</td>\n</tr>\n<tr>\n<td align=\"left\">131102</td>\n<td align=\"left\">桃城区</td>\n</tr>\n<tr>\n<td align=\"left\">131103</td>\n<td align=\"left\">冀州区</td>\n</tr>\n<tr>\n<td align=\"left\">131121</td>\n<td align=\"left\">枣强县</td>\n</tr>\n<tr>\n<td align=\"left\">131122</td>\n<td align=\"left\">武邑县</td>\n</tr>\n<tr>\n<td align=\"left\">131123</td>\n<td align=\"left\">武强县</td>\n</tr>\n<tr>\n<td align=\"left\">131124</td>\n<td align=\"left\">饶阳县</td>\n</tr>\n<tr>\n<td align=\"left\">131125</td>\n<td align=\"left\">安平县</td>\n</tr>\n<tr>\n<td align=\"left\">131126</td>\n<td align=\"left\">故城县</td>\n</tr>\n<tr>\n<td align=\"left\">131127</td>\n<td align=\"left\">景县</td>\n</tr>\n<tr>\n<td align=\"left\">131128</td>\n<td align=\"left\">阜城县</td>\n</tr>\n<tr>\n<td align=\"left\">131182</td>\n<td align=\"left\">深州市</td>\n</tr>\n<tr>\n<td align=\"left\">140000</td>\n<td align=\"left\">山西省</td>\n</tr>\n<tr>\n<td align=\"left\">140100</td>\n<td align=\"left\">太原市</td>\n</tr>\n<tr>\n<td align=\"left\">140105</td>\n<td align=\"left\">小店区</td>\n</tr>\n<tr>\n<td align=\"left\">140106</td>\n<td align=\"left\">迎泽区</td>\n</tr>\n<tr>\n<td align=\"left\">140107</td>\n<td align=\"left\">杏花岭区</td>\n</tr>\n<tr>\n<td align=\"left\">140108</td>\n<td align=\"left\">尖草坪区</td>\n</tr>\n<tr>\n<td align=\"left\">140109</td>\n<td align=\"left\">万柏林区</td>\n</tr>\n<tr>\n<td align=\"left\">140110</td>\n<td align=\"left\">晋源区</td>\n</tr>\n<tr>\n<td align=\"left\">140121</td>\n<td align=\"left\">清徐县</td>\n</tr>\n<tr>\n<td align=\"left\">140122</td>\n<td align=\"left\">阳曲县</td>\n</tr>\n<tr>\n<td align=\"left\">140123</td>\n<td align=\"left\">娄烦县</td>\n</tr>\n<tr>\n<td align=\"left\">140181</td>\n<td align=\"left\">古交市</td>\n</tr>\n<tr>\n<td align=\"left\">140200</td>\n<td align=\"left\">大同市</td>\n</tr>\n<tr>\n<td align=\"left\">140212</td>\n<td align=\"left\">新荣区</td>\n</tr>\n<tr>\n<td align=\"left\">140213</td>\n<td align=\"left\">平城区</td>\n</tr>\n<tr>\n<td align=\"left\">140214</td>\n<td align=\"left\">云冈区</td>\n</tr>\n<tr>\n<td align=\"left\">140215</td>\n<td align=\"left\">云州区</td>\n</tr>\n<tr>\n<td align=\"left\">140221</td>\n<td align=\"left\">阳高县</td>\n</tr>\n<tr>\n<td align=\"left\">140222</td>\n<td align=\"left\">天镇县</td>\n</tr>\n<tr>\n<td align=\"left\">140223</td>\n<td align=\"left\">广灵县</td>\n</tr>\n<tr>\n<td align=\"left\">140224</td>\n<td align=\"left\">灵丘县</td>\n</tr>\n<tr>\n<td align=\"left\">140225</td>\n<td align=\"left\">浑源县</td>\n</tr>\n<tr>\n<td align=\"left\">140226</td>\n<td align=\"left\">左云县</td>\n</tr>\n<tr>\n<td align=\"left\">140300</td>\n<td align=\"left\">阳泉市</td>\n</tr>\n<tr>\n<td align=\"left\">140302</td>\n<td align=\"left\">城区</td>\n</tr>\n<tr>\n<td align=\"left\">140303</td>\n<td align=\"left\">矿区</td>\n</tr>\n<tr>\n<td align=\"left\">140311</td>\n<td align=\"left\">郊区</td>\n</tr>\n<tr>\n<td align=\"left\">140321</td>\n<td align=\"left\">平定县</td>\n</tr>\n<tr>\n<td align=\"left\">140322</td>\n<td align=\"left\">盂县</td>\n</tr>\n<tr>\n<td align=\"left\">140400</td>\n<td align=\"left\">长治市</td>\n</tr>\n<tr>\n<td align=\"left\">140403</td>\n<td align=\"left\">潞州区</td>\n</tr>\n<tr>\n<td align=\"left\">140404</td>\n<td align=\"left\">上党区</td>\n</tr>\n<tr>\n<td align=\"left\">140405</td>\n<td align=\"left\">屯留区</td>\n</tr>\n<tr>\n<td align=\"left\">140406</td>\n<td align=\"left\">潞城区</td>\n</tr>\n<tr>\n<td align=\"left\">140423</td>\n<td align=\"left\">襄垣县</td>\n</tr>\n<tr>\n<td align=\"left\">140425</td>\n<td align=\"left\">平顺县</td>\n</tr>\n<tr>\n<td align=\"left\">140426</td>\n<td align=\"left\">黎城县</td>\n</tr>\n<tr>\n<td align=\"left\">140427</td>\n<td align=\"left\">壶关县</td>\n</tr>\n<tr>\n<td align=\"left\">140428</td>\n<td align=\"left\">长子县</td>\n</tr>\n<tr>\n<td align=\"left\">140429</td>\n<td align=\"left\">武乡县</td>\n</tr>\n<tr>\n<td align=\"left\">140430</td>\n<td align=\"left\">沁县</td>\n</tr>\n<tr>\n<td align=\"left\">140431</td>\n<td align=\"left\">沁源县</td>\n</tr>\n<tr>\n<td align=\"left\">140500</td>\n<td align=\"left\">晋城市</td>\n</tr>\n<tr>\n<td align=\"left\">140502</td>\n<td align=\"left\">城区</td>\n</tr>\n<tr>\n<td align=\"left\">140521</td>\n<td align=\"left\">沁水县</td>\n</tr>\n<tr>\n<td align=\"left\">140522</td>\n<td align=\"left\">阳城县</td>\n</tr>\n<tr>\n<td align=\"left\">140524</td>\n<td align=\"left\">陵川县</td>\n</tr>\n<tr>\n<td align=\"left\">140525</td>\n<td align=\"left\">泽州县</td>\n</tr>\n<tr>\n<td align=\"left\">140581</td>\n<td align=\"left\">高平市</td>\n</tr>\n<tr>\n<td align=\"left\">140600</td>\n<td align=\"left\">朔州市</td>\n</tr>\n<tr>\n<td align=\"left\">140602</td>\n<td align=\"left\">朔城区</td>\n</tr>\n<tr>\n<td align=\"left\">140603</td>\n<td align=\"left\">平鲁区</td>\n</tr>\n<tr>\n<td align=\"left\">140621</td>\n<td align=\"left\">山阴县</td>\n</tr>\n<tr>\n<td align=\"left\">140622</td>\n<td align=\"left\">应县</td>\n</tr>\n<tr>\n<td align=\"left\">140623</td>\n<td align=\"left\">右玉县</td>\n</tr>\n<tr>\n<td align=\"left\">140681</td>\n<td align=\"left\">怀仁市</td>\n</tr>\n<tr>\n<td align=\"left\">140700</td>\n<td align=\"left\">晋中市</td>\n</tr>\n<tr>\n<td align=\"left\">140702</td>\n<td align=\"left\">榆次区</td>\n</tr>\n<tr>\n<td align=\"left\">140703</td>\n<td align=\"left\">太谷区</td>\n</tr>\n<tr>\n<td align=\"left\">140721</td>\n<td align=\"left\">榆社县</td>\n</tr>\n<tr>\n<td align=\"left\">140722</td>\n<td align=\"left\">左权县</td>\n</tr>\n<tr>\n<td align=\"left\">140723</td>\n<td align=\"left\">和顺县</td>\n</tr>\n<tr>\n<td align=\"left\">140724</td>\n<td align=\"left\">昔阳县</td>\n</tr>\n<tr>\n<td align=\"left\">140725</td>\n<td align=\"left\">寿阳县</td>\n</tr>\n<tr>\n<td align=\"left\">140727</td>\n<td align=\"left\">祁县</td>\n</tr>\n<tr>\n<td align=\"left\">140728</td>\n<td align=\"left\">平遥县</td>\n</tr>\n<tr>\n<td align=\"left\">140729</td>\n<td align=\"left\">灵石县</td>\n</tr>\n<tr>\n<td align=\"left\">140781</td>\n<td align=\"left\">介休市</td>\n</tr>\n<tr>\n<td align=\"left\">140800</td>\n<td align=\"left\">运城市</td>\n</tr>\n<tr>\n<td align=\"left\">140802</td>\n<td align=\"left\">盐湖区</td>\n</tr>\n<tr>\n<td align=\"left\">140821</td>\n<td align=\"left\">临猗县</td>\n</tr>\n<tr>\n<td align=\"left\">140822</td>\n<td align=\"left\">万荣县</td>\n</tr>\n<tr>\n<td align=\"left\">140823</td>\n<td align=\"left\">闻喜县</td>\n</tr>\n<tr>\n<td align=\"left\">140824</td>\n<td align=\"left\">稷山县</td>\n</tr>\n<tr>\n<td align=\"left\">140825</td>\n<td align=\"left\">新绛县</td>\n</tr>\n<tr>\n<td align=\"left\">140826</td>\n<td align=\"left\">绛县</td>\n</tr>\n<tr>\n<td align=\"left\">140827</td>\n<td align=\"left\">垣曲县</td>\n</tr>\n<tr>\n<td align=\"left\">140828</td>\n<td align=\"left\">夏县</td>\n</tr>\n<tr>\n<td align=\"left\">140829</td>\n<td align=\"left\">平陆县</td>\n</tr>\n<tr>\n<td align=\"left\">140830</td>\n<td align=\"left\">芮城县</td>\n</tr>\n<tr>\n<td align=\"left\">140881</td>\n<td align=\"left\">永济市</td>\n</tr>\n<tr>\n<td align=\"left\">140882</td>\n<td align=\"left\">河津市</td>\n</tr>\n<tr>\n<td align=\"left\">140900</td>\n<td align=\"left\">忻州市</td>\n</tr>\n<tr>\n<td align=\"left\">140902</td>\n<td align=\"left\">忻府区</td>\n</tr>\n<tr>\n<td align=\"left\">140921</td>\n<td align=\"left\">定襄县</td>\n</tr>\n<tr>\n<td align=\"left\">140922</td>\n<td align=\"left\">五台县</td>\n</tr>\n<tr>\n<td align=\"left\">140923</td>\n<td align=\"left\">代县</td>\n</tr>\n<tr>\n<td align=\"left\">140924</td>\n<td align=\"left\">繁峙县</td>\n</tr>\n<tr>\n<td align=\"left\">140925</td>\n<td align=\"left\">宁武县</td>\n</tr>\n<tr>\n<td align=\"left\">140926</td>\n<td align=\"left\">静乐县</td>\n</tr>\n<tr>\n<td align=\"left\">140927</td>\n<td align=\"left\">神池县</td>\n</tr>\n<tr>\n<td align=\"left\">140928</td>\n<td align=\"left\">五寨县</td>\n</tr>\n<tr>\n<td align=\"left\">140929</td>\n<td align=\"left\">岢岚县</td>\n</tr>\n<tr>\n<td align=\"left\">140930</td>\n<td align=\"left\">河曲县</td>\n</tr>\n<tr>\n<td align=\"left\">140931</td>\n<td align=\"left\">保德县</td>\n</tr>\n<tr>\n<td align=\"left\">140932</td>\n<td align=\"left\">偏关县</td>\n</tr>\n<tr>\n<td align=\"left\">140981</td>\n<td align=\"left\">原平市</td>\n</tr>\n<tr>\n<td align=\"left\">141000</td>\n<td align=\"left\">临汾市</td>\n</tr>\n<tr>\n<td align=\"left\">141002</td>\n<td align=\"left\">尧都区</td>\n</tr>\n<tr>\n<td align=\"left\">141021</td>\n<td align=\"left\">曲沃县</td>\n</tr>\n<tr>\n<td align=\"left\">141022</td>\n<td align=\"left\">翼城县</td>\n</tr>\n<tr>\n<td align=\"left\">141023</td>\n<td align=\"left\">襄汾县</td>\n</tr>\n<tr>\n<td align=\"left\">141024</td>\n<td align=\"left\">洪洞县</td>\n</tr>\n<tr>\n<td align=\"left\">141025</td>\n<td align=\"left\">古县</td>\n</tr>\n<tr>\n<td align=\"left\">141026</td>\n<td align=\"left\">安泽县</td>\n</tr>\n<tr>\n<td align=\"left\">141027</td>\n<td align=\"left\">浮山县</td>\n</tr>\n<tr>\n<td align=\"left\">141028</td>\n<td align=\"left\">吉县</td>\n</tr>\n<tr>\n<td align=\"left\">141029</td>\n<td align=\"left\">乡宁县</td>\n</tr>\n<tr>\n<td align=\"left\">141030</td>\n<td align=\"left\">大宁县</td>\n</tr>\n<tr>\n<td align=\"left\">141031</td>\n<td align=\"left\">隰县</td>\n</tr>\n<tr>\n<td align=\"left\">141032</td>\n<td align=\"left\">永和县</td>\n</tr>\n<tr>\n<td align=\"left\">141033</td>\n<td align=\"left\">蒲县</td>\n</tr>\n<tr>\n<td align=\"left\">141034</td>\n<td align=\"left\">汾西县</td>\n</tr>\n<tr>\n<td align=\"left\">141081</td>\n<td align=\"left\">侯马市</td>\n</tr>\n<tr>\n<td align=\"left\">141082</td>\n<td align=\"left\">霍州市</td>\n</tr>\n<tr>\n<td align=\"left\">141100</td>\n<td align=\"left\">吕梁市</td>\n</tr>\n<tr>\n<td align=\"left\">141102</td>\n<td align=\"left\">离石区</td>\n</tr>\n<tr>\n<td align=\"left\">141121</td>\n<td align=\"left\">文水县</td>\n</tr>\n<tr>\n<td align=\"left\">141122</td>\n<td align=\"left\">交城县</td>\n</tr>\n<tr>\n<td align=\"left\">141123</td>\n<td align=\"left\">兴县</td>\n</tr>\n<tr>\n<td align=\"left\">141124</td>\n<td align=\"left\">临县</td>\n</tr>\n<tr>\n<td align=\"left\">141125</td>\n<td align=\"left\">柳林县</td>\n</tr>\n<tr>\n<td align=\"left\">141126</td>\n<td align=\"left\">石楼县</td>\n</tr>\n<tr>\n<td align=\"left\">141127</td>\n<td align=\"left\">岚县</td>\n</tr>\n<tr>\n<td align=\"left\">141128</td>\n<td align=\"left\">方山县</td>\n</tr>\n<tr>\n<td align=\"left\">141129</td>\n<td align=\"left\">中阳县</td>\n</tr>\n<tr>\n<td align=\"left\">141130</td>\n<td align=\"left\">交口县</td>\n</tr>\n<tr>\n<td align=\"left\">141181</td>\n<td align=\"left\">孝义市</td>\n</tr>\n<tr>\n<td align=\"left\">141182</td>\n<td align=\"left\">汾阳市</td>\n</tr>\n<tr>\n<td align=\"left\">150000</td>\n<td align=\"left\">内蒙古自治区</td>\n</tr>\n<tr>\n<td align=\"left\">150100</td>\n<td align=\"left\">呼和浩特市</td>\n</tr>\n<tr>\n<td align=\"left\">150102</td>\n<td align=\"left\">新城区</td>\n</tr>\n<tr>\n<td align=\"left\">150103</td>\n<td align=\"left\">回民区</td>\n</tr>\n<tr>\n<td align=\"left\">150104</td>\n<td align=\"left\">玉泉区</td>\n</tr>\n<tr>\n<td align=\"left\">150105</td>\n<td align=\"left\">赛罕区</td>\n</tr>\n<tr>\n<td align=\"left\">150121</td>\n<td align=\"left\">土默特左旗</td>\n</tr>\n<tr>\n<td align=\"left\">150122</td>\n<td align=\"left\">托克托县</td>\n</tr>\n<tr>\n<td align=\"left\">150123</td>\n<td align=\"left\">和林格尔县</td>\n</tr>\n<tr>\n<td align=\"left\">150124</td>\n<td align=\"left\">清水河县</td>\n</tr>\n<tr>\n<td align=\"left\">150125</td>\n<td align=\"left\">武川县</td>\n</tr>\n<tr>\n<td align=\"left\">150200</td>\n<td align=\"left\">包头市</td>\n</tr>\n<tr>\n<td align=\"left\">150202</td>\n<td align=\"left\">东河区</td>\n</tr>\n<tr>\n<td align=\"left\">150203</td>\n<td align=\"left\">昆都仑区</td>\n</tr>\n<tr>\n<td align=\"left\">150204</td>\n<td align=\"left\">青山区</td>\n</tr>\n<tr>\n<td align=\"left\">150205</td>\n<td align=\"left\">石拐区</td>\n</tr>\n<tr>\n<td align=\"left\">150206</td>\n<td align=\"left\">白云鄂博矿区</td>\n</tr>\n<tr>\n<td align=\"left\">150207</td>\n<td align=\"left\">九原区</td>\n</tr>\n<tr>\n<td align=\"left\">150221</td>\n<td align=\"left\">土默特右旗</td>\n</tr>\n<tr>\n<td align=\"left\">150222</td>\n<td align=\"left\">固阳县</td>\n</tr>\n<tr>\n<td align=\"left\">150223</td>\n<td align=\"left\">达尔罕茂明安联合旗</td>\n</tr>\n<tr>\n<td align=\"left\">150300</td>\n<td align=\"left\">乌海市</td>\n</tr>\n<tr>\n<td align=\"left\">150302</td>\n<td align=\"left\">海勃湾区</td>\n</tr>\n<tr>\n<td align=\"left\">150303</td>\n<td align=\"left\">海南区</td>\n</tr>\n<tr>\n<td align=\"left\">150304</td>\n<td align=\"left\">乌达区</td>\n</tr>\n<tr>\n<td align=\"left\">150400</td>\n<td align=\"left\">赤峰市</td>\n</tr>\n<tr>\n<td align=\"left\">150402</td>\n<td align=\"left\">红山区</td>\n</tr>\n<tr>\n<td align=\"left\">150403</td>\n<td align=\"left\">元宝山区</td>\n</tr>\n<tr>\n<td align=\"left\">150404</td>\n<td align=\"left\">松山区</td>\n</tr>\n<tr>\n<td align=\"left\">150421</td>\n<td align=\"left\">阿鲁科尔沁旗</td>\n</tr>\n<tr>\n<td align=\"left\">150422</td>\n<td align=\"left\">巴林左旗</td>\n</tr>\n<tr>\n<td align=\"left\">150423</td>\n<td align=\"left\">巴林右旗</td>\n</tr>\n<tr>\n<td align=\"left\">150424</td>\n<td align=\"left\">林西县</td>\n</tr>\n<tr>\n<td align=\"left\">150425</td>\n<td align=\"left\">克什克腾旗</td>\n</tr>\n<tr>\n<td align=\"left\">150426</td>\n<td align=\"left\">翁牛特旗</td>\n</tr>\n<tr>\n<td align=\"left\">150428</td>\n<td align=\"left\">喀喇沁旗</td>\n</tr>\n<tr>\n<td align=\"left\">150429</td>\n<td align=\"left\">宁城县</td>\n</tr>\n<tr>\n<td align=\"left\">150430</td>\n<td align=\"left\">敖汉旗</td>\n</tr>\n<tr>\n<td align=\"left\">150500</td>\n<td align=\"left\">通辽市</td>\n</tr>\n<tr>\n<td align=\"left\">150502</td>\n<td align=\"left\">科尔沁区</td>\n</tr>\n<tr>\n<td align=\"left\">150521</td>\n<td align=\"left\">科尔沁左翼中旗</td>\n</tr>\n<tr>\n<td align=\"left\">150522</td>\n<td align=\"left\">科尔沁左翼后旗</td>\n</tr>\n<tr>\n<td align=\"left\">150523</td>\n<td align=\"left\">开鲁县</td>\n</tr>\n<tr>\n<td align=\"left\">150524</td>\n<td align=\"left\">库伦旗</td>\n</tr>\n<tr>\n<td align=\"left\">150525</td>\n<td align=\"left\">奈曼旗</td>\n</tr>\n<tr>\n<td align=\"left\">150526</td>\n<td align=\"left\">扎鲁特旗</td>\n</tr>\n<tr>\n<td align=\"left\">150581</td>\n<td align=\"left\">霍林郭勒市</td>\n</tr>\n<tr>\n<td align=\"left\">150600</td>\n<td align=\"left\">鄂尔多斯市</td>\n</tr>\n<tr>\n<td align=\"left\">150602</td>\n<td align=\"left\">东胜区</td>\n</tr>\n<tr>\n<td align=\"left\">150603</td>\n<td align=\"left\">康巴什区</td>\n</tr>\n<tr>\n<td align=\"left\">150621</td>\n<td align=\"left\">达拉特旗</td>\n</tr>\n<tr>\n<td align=\"left\">150622</td>\n<td align=\"left\">准格尔旗</td>\n</tr>\n<tr>\n<td align=\"left\">150623</td>\n<td align=\"left\">鄂托克前旗</td>\n</tr>\n<tr>\n<td align=\"left\">150624</td>\n<td align=\"left\">鄂托克旗</td>\n</tr>\n<tr>\n<td align=\"left\">150625</td>\n<td align=\"left\">杭锦旗</td>\n</tr>\n<tr>\n<td align=\"left\">150626</td>\n<td align=\"left\">乌审旗</td>\n</tr>\n<tr>\n<td align=\"left\">150627</td>\n<td align=\"left\">伊金霍洛旗</td>\n</tr>\n<tr>\n<td align=\"left\">150700</td>\n<td align=\"left\">呼伦贝尔市</td>\n</tr>\n<tr>\n<td align=\"left\">150702</td>\n<td align=\"left\">海拉尔区</td>\n</tr>\n<tr>\n<td align=\"left\">150703</td>\n<td align=\"left\">扎赉诺尔区</td>\n</tr>\n<tr>\n<td align=\"left\">150721</td>\n<td align=\"left\">阿荣旗</td>\n</tr>\n<tr>\n<td align=\"left\">150722</td>\n<td align=\"left\">莫力达瓦达斡尔族自治旗</td>\n</tr>\n<tr>\n<td align=\"left\">150723</td>\n<td align=\"left\">鄂伦春自治旗</td>\n</tr>\n<tr>\n<td align=\"left\">150724</td>\n<td align=\"left\">鄂温克族自治旗</td>\n</tr>\n<tr>\n<td align=\"left\">150725</td>\n<td align=\"left\">陈巴尔虎旗</td>\n</tr>\n<tr>\n<td align=\"left\">150726</td>\n<td align=\"left\">新巴尔虎左旗</td>\n</tr>\n<tr>\n<td align=\"left\">150727</td>\n<td align=\"left\">新巴尔虎右旗</td>\n</tr>\n<tr>\n<td align=\"left\">150781</td>\n<td align=\"left\">满洲里市</td>\n</tr>\n<tr>\n<td align=\"left\">150782</td>\n<td align=\"left\">牙克石市</td>\n</tr>\n<tr>\n<td align=\"left\">150783</td>\n<td align=\"left\">扎兰屯市</td>\n</tr>\n<tr>\n<td align=\"left\">150784</td>\n<td align=\"left\">额尔古纳市</td>\n</tr>\n<tr>\n<td align=\"left\">150785</td>\n<td align=\"left\">根河市</td>\n</tr>\n<tr>\n<td align=\"left\">150800</td>\n<td align=\"left\">巴彦淖尔市</td>\n</tr>\n<tr>\n<td align=\"left\">150802</td>\n<td align=\"left\">临河区</td>\n</tr>\n<tr>\n<td align=\"left\">150821</td>\n<td align=\"left\">五原县</td>\n</tr>\n<tr>\n<td align=\"left\">150822</td>\n<td align=\"left\">磴口县</td>\n</tr>\n<tr>\n<td align=\"left\">150823</td>\n<td align=\"left\">乌拉特前旗</td>\n</tr>\n<tr>\n<td align=\"left\">150824</td>\n<td align=\"left\">乌拉特中旗</td>\n</tr>\n<tr>\n<td align=\"left\">150825</td>\n<td align=\"left\">乌拉特后旗</td>\n</tr>\n<tr>\n<td align=\"left\">150826</td>\n<td align=\"left\">杭锦后旗</td>\n</tr>\n<tr>\n<td align=\"left\">150900</td>\n<td align=\"left\">乌兰察布市</td>\n</tr>\n<tr>\n<td align=\"left\">150902</td>\n<td align=\"left\">集宁区</td>\n</tr>\n<tr>\n<td align=\"left\">150921</td>\n<td align=\"left\">卓资县</td>\n</tr>\n<tr>\n<td align=\"left\">150922</td>\n<td align=\"left\">化德县</td>\n</tr>\n<tr>\n<td align=\"left\">150923</td>\n<td align=\"left\">商都县</td>\n</tr>\n<tr>\n<td align=\"left\">150924</td>\n<td align=\"left\">兴和县</td>\n</tr>\n<tr>\n<td align=\"left\">150925</td>\n<td align=\"left\">凉城县</td>\n</tr>\n<tr>\n<td align=\"left\">150926</td>\n<td align=\"left\">察哈尔右翼前旗</td>\n</tr>\n<tr>\n<td align=\"left\">150927</td>\n<td align=\"left\">察哈尔右翼中旗</td>\n</tr>\n<tr>\n<td align=\"left\">150928</td>\n<td align=\"left\">察哈尔右翼后旗</td>\n</tr>\n<tr>\n<td align=\"left\">150929</td>\n<td align=\"left\">四子王旗</td>\n</tr>\n<tr>\n<td align=\"left\">150981</td>\n<td align=\"left\">丰镇市</td>\n</tr>\n<tr>\n<td align=\"left\">152200</td>\n<td align=\"left\">兴安盟</td>\n</tr>\n<tr>\n<td align=\"left\">152201</td>\n<td align=\"left\">乌兰浩特市</td>\n</tr>\n<tr>\n<td align=\"left\">152202</td>\n<td align=\"left\">阿尔山市</td>\n</tr>\n<tr>\n<td align=\"left\">152221</td>\n<td align=\"left\">科尔沁右翼前旗</td>\n</tr>\n<tr>\n<td align=\"left\">152222</td>\n<td align=\"left\">科尔沁右翼中旗</td>\n</tr>\n<tr>\n<td align=\"left\">152223</td>\n<td align=\"left\">扎赉特旗</td>\n</tr>\n<tr>\n<td align=\"left\">152224</td>\n<td align=\"left\">突泉县</td>\n</tr>\n<tr>\n<td align=\"left\">152500</td>\n<td align=\"left\">锡林郭勒盟</td>\n</tr>\n<tr>\n<td align=\"left\">152501</td>\n<td align=\"left\">二连浩特市</td>\n</tr>\n<tr>\n<td align=\"left\">152502</td>\n<td align=\"left\">锡林浩特市</td>\n</tr>\n<tr>\n<td align=\"left\">152522</td>\n<td align=\"left\">阿巴嘎旗</td>\n</tr>\n<tr>\n<td align=\"left\">152523</td>\n<td align=\"left\">苏尼特左旗</td>\n</tr>\n<tr>\n<td align=\"left\">152524</td>\n<td align=\"left\">苏尼特右旗</td>\n</tr>\n<tr>\n<td align=\"left\">152525</td>\n<td align=\"left\">东乌珠穆沁旗</td>\n</tr>\n<tr>\n<td align=\"left\">152526</td>\n<td align=\"left\">西乌珠穆沁旗</td>\n</tr>\n<tr>\n<td align=\"left\">152527</td>\n<td align=\"left\">太仆寺旗</td>\n</tr>\n<tr>\n<td align=\"left\">152528</td>\n<td align=\"left\">镶黄旗</td>\n</tr>\n<tr>\n<td align=\"left\">152529</td>\n<td align=\"left\">正镶白旗</td>\n</tr>\n<tr>\n<td align=\"left\">152530</td>\n<td align=\"left\">正蓝旗</td>\n</tr>\n<tr>\n<td align=\"left\">152531</td>\n<td align=\"left\">多伦县</td>\n</tr>\n<tr>\n<td align=\"left\">152900</td>\n<td align=\"left\">阿拉善盟</td>\n</tr>\n<tr>\n<td align=\"left\">152921</td>\n<td align=\"left\">阿拉善左旗</td>\n</tr>\n<tr>\n<td align=\"left\">152922</td>\n<td align=\"left\">阿拉善右旗</td>\n</tr>\n<tr>\n<td align=\"left\">152923</td>\n<td align=\"left\">额济纳旗</td>\n</tr>\n<tr>\n<td align=\"left\">210000</td>\n<td align=\"left\">辽宁省</td>\n</tr>\n<tr>\n<td align=\"left\">210100</td>\n<td align=\"left\">沈阳市</td>\n</tr>\n<tr>\n<td align=\"left\">210102</td>\n<td align=\"left\">和平区</td>\n</tr>\n<tr>\n<td align=\"left\">210103</td>\n<td align=\"left\">沈河区</td>\n</tr>\n<tr>\n<td align=\"left\">210104</td>\n<td align=\"left\">大东区</td>\n</tr>\n<tr>\n<td align=\"left\">210105</td>\n<td align=\"left\">皇姑区</td>\n</tr>\n<tr>\n<td align=\"left\">210106</td>\n<td align=\"left\">铁西区</td>\n</tr>\n<tr>\n<td align=\"left\">210111</td>\n<td align=\"left\">苏家屯区</td>\n</tr>\n<tr>\n<td align=\"left\">210112</td>\n<td align=\"left\">浑南区</td>\n</tr>\n<tr>\n<td align=\"left\">210113</td>\n<td align=\"left\">沈北新区</td>\n</tr>\n<tr>\n<td align=\"left\">210114</td>\n<td align=\"left\">于洪区</td>\n</tr>\n<tr>\n<td align=\"left\">210115</td>\n<td align=\"left\">辽中区</td>\n</tr>\n<tr>\n<td align=\"left\">210123</td>\n<td align=\"left\">康平县</td>\n</tr>\n<tr>\n<td align=\"left\">210124</td>\n<td align=\"left\">法库县</td>\n</tr>\n<tr>\n<td align=\"left\">210181</td>\n<td align=\"left\">新民市</td>\n</tr>\n<tr>\n<td align=\"left\">210200</td>\n<td align=\"left\">大连市</td>\n</tr>\n<tr>\n<td align=\"left\">210202</td>\n<td align=\"left\">中山区</td>\n</tr>\n<tr>\n<td align=\"left\">210203</td>\n<td align=\"left\">西岗区</td>\n</tr>\n<tr>\n<td align=\"left\">210204</td>\n<td align=\"left\">沙河口区</td>\n</tr>\n<tr>\n<td align=\"left\">210211</td>\n<td align=\"left\">甘井子区</td>\n</tr>\n<tr>\n<td align=\"left\">210212</td>\n<td align=\"left\">旅顺口区</td>\n</tr>\n<tr>\n<td align=\"left\">210213</td>\n<td align=\"left\">金州区</td>\n</tr>\n<tr>\n<td align=\"left\">210214</td>\n<td align=\"left\">普兰店区</td>\n</tr>\n<tr>\n<td align=\"left\">210224</td>\n<td align=\"left\">长海县</td>\n</tr>\n<tr>\n<td align=\"left\">210281</td>\n<td align=\"left\">瓦房店市</td>\n</tr>\n<tr>\n<td align=\"left\">210283</td>\n<td align=\"left\">庄河市</td>\n</tr>\n<tr>\n<td align=\"left\">210300</td>\n<td align=\"left\">鞍山市</td>\n</tr>\n<tr>\n<td align=\"left\">210302</td>\n<td align=\"left\">铁东区</td>\n</tr>\n<tr>\n<td align=\"left\">210303</td>\n<td align=\"left\">铁西区</td>\n</tr>\n<tr>\n<td align=\"left\">210304</td>\n<td align=\"left\">立山区</td>\n</tr>\n<tr>\n<td align=\"left\">210311</td>\n<td align=\"left\">千山区</td>\n</tr>\n<tr>\n<td align=\"left\">210321</td>\n<td align=\"left\">台安县</td>\n</tr>\n<tr>\n<td align=\"left\">210323</td>\n<td align=\"left\">岫岩满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">210381</td>\n<td align=\"left\">海城市</td>\n</tr>\n<tr>\n<td align=\"left\">210400</td>\n<td align=\"left\">抚顺市</td>\n</tr>\n<tr>\n<td align=\"left\">210402</td>\n<td align=\"left\">新抚区</td>\n</tr>\n<tr>\n<td align=\"left\">210403</td>\n<td align=\"left\">东洲区</td>\n</tr>\n<tr>\n<td align=\"left\">210404</td>\n<td align=\"left\">望花区</td>\n</tr>\n<tr>\n<td align=\"left\">210411</td>\n<td align=\"left\">顺城区</td>\n</tr>\n<tr>\n<td align=\"left\">210421</td>\n<td align=\"left\">抚顺县</td>\n</tr>\n<tr>\n<td align=\"left\">210422</td>\n<td align=\"left\">新宾满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">210423</td>\n<td align=\"left\">清原满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">210500</td>\n<td align=\"left\">本溪市</td>\n</tr>\n<tr>\n<td align=\"left\">210502</td>\n<td align=\"left\">平山区</td>\n</tr>\n<tr>\n<td align=\"left\">210503</td>\n<td align=\"left\">溪湖区</td>\n</tr>\n<tr>\n<td align=\"left\">210504</td>\n<td align=\"left\">明山区</td>\n</tr>\n<tr>\n<td align=\"left\">210505</td>\n<td align=\"left\">南芬区</td>\n</tr>\n<tr>\n<td align=\"left\">210521</td>\n<td align=\"left\">本溪满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">210522</td>\n<td align=\"left\">桓仁满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">210600</td>\n<td align=\"left\">丹东市</td>\n</tr>\n<tr>\n<td align=\"left\">210602</td>\n<td align=\"left\">元宝区</td>\n</tr>\n<tr>\n<td align=\"left\">210603</td>\n<td align=\"left\">振兴区</td>\n</tr>\n<tr>\n<td align=\"left\">210604</td>\n<td align=\"left\">振安区</td>\n</tr>\n<tr>\n<td align=\"left\">210624</td>\n<td align=\"left\">宽甸满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">210681</td>\n<td align=\"left\">东港市</td>\n</tr>\n<tr>\n<td align=\"left\">210682</td>\n<td align=\"left\">凤城市</td>\n</tr>\n<tr>\n<td align=\"left\">210700</td>\n<td align=\"left\">锦州市</td>\n</tr>\n<tr>\n<td align=\"left\">210702</td>\n<td align=\"left\">古塔区</td>\n</tr>\n<tr>\n<td align=\"left\">210703</td>\n<td align=\"left\">凌河区</td>\n</tr>\n<tr>\n<td align=\"left\">210711</td>\n<td align=\"left\">太和区</td>\n</tr>\n<tr>\n<td align=\"left\">210726</td>\n<td align=\"left\">黑山县</td>\n</tr>\n<tr>\n<td align=\"left\">210727</td>\n<td align=\"left\">义县</td>\n</tr>\n<tr>\n<td align=\"left\">210781</td>\n<td align=\"left\">凌海市</td>\n</tr>\n<tr>\n<td align=\"left\">210782</td>\n<td align=\"left\">北镇市</td>\n</tr>\n<tr>\n<td align=\"left\">210800</td>\n<td align=\"left\">营口市</td>\n</tr>\n<tr>\n<td align=\"left\">210802</td>\n<td align=\"left\">站前区</td>\n</tr>\n<tr>\n<td align=\"left\">210803</td>\n<td align=\"left\">西市区</td>\n</tr>\n<tr>\n<td align=\"left\">210804</td>\n<td align=\"left\">鲅鱼圈区</td>\n</tr>\n<tr>\n<td align=\"left\">210811</td>\n<td align=\"left\">老边区</td>\n</tr>\n<tr>\n<td align=\"left\">210881</td>\n<td align=\"left\">盖州市</td>\n</tr>\n<tr>\n<td align=\"left\">210882</td>\n<td align=\"left\">大石桥市</td>\n</tr>\n<tr>\n<td align=\"left\">210900</td>\n<td align=\"left\">阜新市</td>\n</tr>\n<tr>\n<td align=\"left\">210902</td>\n<td align=\"left\">海州区</td>\n</tr>\n<tr>\n<td align=\"left\">210903</td>\n<td align=\"left\">新邱区</td>\n</tr>\n<tr>\n<td align=\"left\">210904</td>\n<td align=\"left\">太平区</td>\n</tr>\n<tr>\n<td align=\"left\">210905</td>\n<td align=\"left\">清河门区</td>\n</tr>\n<tr>\n<td align=\"left\">210911</td>\n<td align=\"left\">细河区</td>\n</tr>\n<tr>\n<td align=\"left\">210921</td>\n<td align=\"left\">阜新蒙古族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">210922</td>\n<td align=\"left\">彰武县</td>\n</tr>\n<tr>\n<td align=\"left\">211000</td>\n<td align=\"left\">辽阳市</td>\n</tr>\n<tr>\n<td align=\"left\">211002</td>\n<td align=\"left\">白塔区</td>\n</tr>\n<tr>\n<td align=\"left\">211003</td>\n<td align=\"left\">文圣区</td>\n</tr>\n<tr>\n<td align=\"left\">211004</td>\n<td align=\"left\">宏伟区</td>\n</tr>\n<tr>\n<td align=\"left\">211005</td>\n<td align=\"left\">弓长岭区</td>\n</tr>\n<tr>\n<td align=\"left\">211011</td>\n<td align=\"left\">太子河区</td>\n</tr>\n<tr>\n<td align=\"left\">211021</td>\n<td align=\"left\">辽阳县</td>\n</tr>\n<tr>\n<td align=\"left\">211081</td>\n<td align=\"left\">灯塔市</td>\n</tr>\n<tr>\n<td align=\"left\">211100</td>\n<td align=\"left\">盘锦市</td>\n</tr>\n<tr>\n<td align=\"left\">211102</td>\n<td align=\"left\">双台子区</td>\n</tr>\n<tr>\n<td align=\"left\">211103</td>\n<td align=\"left\">兴隆台区</td>\n</tr>\n<tr>\n<td align=\"left\">211104</td>\n<td align=\"left\">大洼区</td>\n</tr>\n<tr>\n<td align=\"left\">211122</td>\n<td align=\"left\">盘山县</td>\n</tr>\n<tr>\n<td align=\"left\">211200</td>\n<td align=\"left\">铁岭市</td>\n</tr>\n<tr>\n<td align=\"left\">211202</td>\n<td align=\"left\">银州区</td>\n</tr>\n<tr>\n<td align=\"left\">211204</td>\n<td align=\"left\">清河区</td>\n</tr>\n<tr>\n<td align=\"left\">211221</td>\n<td align=\"left\">铁岭县</td>\n</tr>\n<tr>\n<td align=\"left\">211223</td>\n<td align=\"left\">西丰县</td>\n</tr>\n<tr>\n<td align=\"left\">211224</td>\n<td align=\"left\">昌图县</td>\n</tr>\n<tr>\n<td align=\"left\">211281</td>\n<td align=\"left\">调兵山市</td>\n</tr>\n<tr>\n<td align=\"left\">211282</td>\n<td align=\"left\">开原市</td>\n</tr>\n<tr>\n<td align=\"left\">211300</td>\n<td align=\"left\">朝阳市</td>\n</tr>\n<tr>\n<td align=\"left\">211302</td>\n<td align=\"left\">双塔区</td>\n</tr>\n<tr>\n<td align=\"left\">211303</td>\n<td align=\"left\">龙城区</td>\n</tr>\n<tr>\n<td align=\"left\">211321</td>\n<td align=\"left\">朝阳县</td>\n</tr>\n<tr>\n<td align=\"left\">211322</td>\n<td align=\"left\">建平县</td>\n</tr>\n<tr>\n<td align=\"left\">211324</td>\n<td align=\"left\">喀喇沁左翼蒙古族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">211381</td>\n<td align=\"left\">北票市</td>\n</tr>\n<tr>\n<td align=\"left\">211382</td>\n<td align=\"left\">凌源市</td>\n</tr>\n<tr>\n<td align=\"left\">211400</td>\n<td align=\"left\">葫芦岛市</td>\n</tr>\n<tr>\n<td align=\"left\">211402</td>\n<td align=\"left\">连山区</td>\n</tr>\n<tr>\n<td align=\"left\">211403</td>\n<td align=\"left\">龙港区</td>\n</tr>\n<tr>\n<td align=\"left\">211404</td>\n<td align=\"left\">南票区</td>\n</tr>\n<tr>\n<td align=\"left\">211421</td>\n<td align=\"left\">绥中县</td>\n</tr>\n<tr>\n<td align=\"left\">211422</td>\n<td align=\"left\">建昌县</td>\n</tr>\n<tr>\n<td align=\"left\">211481</td>\n<td align=\"left\">兴城市</td>\n</tr>\n<tr>\n<td align=\"left\">220000</td>\n<td align=\"left\">吉林省</td>\n</tr>\n<tr>\n<td align=\"left\">220100</td>\n<td align=\"left\">长春市</td>\n</tr>\n<tr>\n<td align=\"left\">220102</td>\n<td align=\"left\">南关区</td>\n</tr>\n<tr>\n<td align=\"left\">220103</td>\n<td align=\"left\">宽城区</td>\n</tr>\n<tr>\n<td align=\"left\">220104</td>\n<td align=\"left\">朝阳区</td>\n</tr>\n<tr>\n<td align=\"left\">220105</td>\n<td align=\"left\">二道区</td>\n</tr>\n<tr>\n<td align=\"left\">220106</td>\n<td align=\"left\">绿园区</td>\n</tr>\n<tr>\n<td align=\"left\">220112</td>\n<td align=\"left\">双阳区</td>\n</tr>\n<tr>\n<td align=\"left\">220113</td>\n<td align=\"left\">九台区</td>\n</tr>\n<tr>\n<td align=\"left\">220122</td>\n<td align=\"left\">农安县</td>\n</tr>\n<tr>\n<td align=\"left\">220182</td>\n<td align=\"left\">榆树市</td>\n</tr>\n<tr>\n<td align=\"left\">220183</td>\n<td align=\"left\">德惠市</td>\n</tr>\n<tr>\n<td align=\"left\">220200</td>\n<td align=\"left\">吉林市</td>\n</tr>\n<tr>\n<td align=\"left\">220202</td>\n<td align=\"left\">昌邑区</td>\n</tr>\n<tr>\n<td align=\"left\">220203</td>\n<td align=\"left\">龙潭区</td>\n</tr>\n<tr>\n<td align=\"left\">220204</td>\n<td align=\"left\">船营区</td>\n</tr>\n<tr>\n<td align=\"left\">220211</td>\n<td align=\"left\">丰满区</td>\n</tr>\n<tr>\n<td align=\"left\">220221</td>\n<td align=\"left\">永吉县</td>\n</tr>\n<tr>\n<td align=\"left\">220281</td>\n<td align=\"left\">蛟河市</td>\n</tr>\n<tr>\n<td align=\"left\">220282</td>\n<td align=\"left\">桦甸市</td>\n</tr>\n<tr>\n<td align=\"left\">220283</td>\n<td align=\"left\">舒兰市</td>\n</tr>\n<tr>\n<td align=\"left\">220284</td>\n<td align=\"left\">磐石市</td>\n</tr>\n<tr>\n<td align=\"left\">220300</td>\n<td align=\"left\">四平市</td>\n</tr>\n<tr>\n<td align=\"left\">220302</td>\n<td align=\"left\">铁西区</td>\n</tr>\n<tr>\n<td align=\"left\">220303</td>\n<td align=\"left\">铁东区</td>\n</tr>\n<tr>\n<td align=\"left\">220322</td>\n<td align=\"left\">梨树县</td>\n</tr>\n<tr>\n<td align=\"left\">220323</td>\n<td align=\"left\">伊通满族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">220381</td>\n<td align=\"left\">公主岭市</td>\n</tr>\n<tr>\n<td align=\"left\">220382</td>\n<td align=\"left\">双辽市</td>\n</tr>\n<tr>\n<td align=\"left\">220400</td>\n<td align=\"left\">辽源市</td>\n</tr>\n<tr>\n<td align=\"left\">220402</td>\n<td align=\"left\">龙山区</td>\n</tr>\n<tr>\n<td align=\"left\">220403</td>\n<td align=\"left\">西安区</td>\n</tr>\n<tr>\n<td align=\"left\">220421</td>\n<td align=\"left\">东丰县</td>\n</tr>\n<tr>\n<td align=\"left\">220422</td>\n<td align=\"left\">东辽县</td>\n</tr>\n<tr>\n<td align=\"left\">220500</td>\n<td align=\"left\">通化市</td>\n</tr>\n<tr>\n<td align=\"left\">220502</td>\n<td align=\"left\">东昌区</td>\n</tr>\n<tr>\n<td align=\"left\">220503</td>\n<td align=\"left\">二道江区</td>\n</tr>\n<tr>\n<td align=\"left\">220521</td>\n<td align=\"left\">通化县</td>\n</tr>\n<tr>\n<td align=\"left\">220523</td>\n<td align=\"left\">辉南县</td>\n</tr>\n<tr>\n<td align=\"left\">220524</td>\n<td align=\"left\">柳河县</td>\n</tr>\n<tr>\n<td align=\"left\">220581</td>\n<td align=\"left\">梅河口市</td>\n</tr>\n<tr>\n<td align=\"left\">220582</td>\n<td align=\"left\">集安市</td>\n</tr>\n<tr>\n<td align=\"left\">220600</td>\n<td align=\"left\">白山市</td>\n</tr>\n<tr>\n<td align=\"left\">220602</td>\n<td align=\"left\">浑江区</td>\n</tr>\n<tr>\n<td align=\"left\">220605</td>\n<td align=\"left\">江源区</td>\n</tr>\n<tr>\n<td align=\"left\">220621</td>\n<td align=\"left\">抚松县</td>\n</tr>\n<tr>\n<td align=\"left\">220622</td>\n<td align=\"left\">靖宇县</td>\n</tr>\n<tr>\n<td align=\"left\">220623</td>\n<td align=\"left\">长白朝鲜族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">220681</td>\n<td align=\"left\">临江市</td>\n</tr>\n<tr>\n<td align=\"left\">220700</td>\n<td align=\"left\">松原市</td>\n</tr>\n<tr>\n<td align=\"left\">220702</td>\n<td align=\"left\">宁江区</td>\n</tr>\n<tr>\n<td align=\"left\">220721</td>\n<td align=\"left\">前郭尔罗斯蒙古族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">220722</td>\n<td align=\"left\">长岭县</td>\n</tr>\n<tr>\n<td align=\"left\">220723</td>\n<td align=\"left\">乾安县</td>\n</tr>\n<tr>\n<td align=\"left\">220781</td>\n<td align=\"left\">扶余市</td>\n</tr>\n<tr>\n<td align=\"left\">220800</td>\n<td align=\"left\">白城市</td>\n</tr>\n<tr>\n<td align=\"left\">220802</td>\n<td align=\"left\">洮北区</td>\n</tr>\n<tr>\n<td align=\"left\">220821</td>\n<td align=\"left\">镇赉县</td>\n</tr>\n<tr>\n<td align=\"left\">220822</td>\n<td align=\"left\">通榆县</td>\n</tr>\n<tr>\n<td align=\"left\">220881</td>\n<td align=\"left\">洮南市</td>\n</tr>\n<tr>\n<td align=\"left\">220882</td>\n<td align=\"left\">大安市</td>\n</tr>\n<tr>\n<td align=\"left\">222400</td>\n<td align=\"left\">延边朝鲜族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">222401</td>\n<td align=\"left\">延吉市</td>\n</tr>\n<tr>\n<td align=\"left\">222402</td>\n<td align=\"left\">图们市</td>\n</tr>\n<tr>\n<td align=\"left\">222403</td>\n<td align=\"left\">敦化市</td>\n</tr>\n<tr>\n<td align=\"left\">222404</td>\n<td align=\"left\">珲春市</td>\n</tr>\n<tr>\n<td align=\"left\">222405</td>\n<td align=\"left\">龙井市</td>\n</tr>\n<tr>\n<td align=\"left\">222406</td>\n<td align=\"left\">和龙市</td>\n</tr>\n<tr>\n<td align=\"left\">222424</td>\n<td align=\"left\">汪清县</td>\n</tr>\n<tr>\n<td align=\"left\">222426</td>\n<td align=\"left\">安图县</td>\n</tr>\n<tr>\n<td align=\"left\">230000</td>\n<td align=\"left\">黑龙江省</td>\n</tr>\n<tr>\n<td align=\"left\">230100</td>\n<td align=\"left\">哈尔滨市</td>\n</tr>\n<tr>\n<td align=\"left\">230102</td>\n<td align=\"left\">道里区</td>\n</tr>\n<tr>\n<td align=\"left\">230103</td>\n<td align=\"left\">南岗区</td>\n</tr>\n<tr>\n<td align=\"left\">230104</td>\n<td align=\"left\">道外区</td>\n</tr>\n<tr>\n<td align=\"left\">230108</td>\n<td align=\"left\">平房区</td>\n</tr>\n<tr>\n<td align=\"left\">230109</td>\n<td align=\"left\">松北区</td>\n</tr>\n<tr>\n<td align=\"left\">230110</td>\n<td align=\"left\">香坊区</td>\n</tr>\n<tr>\n<td align=\"left\">230111</td>\n<td align=\"left\">呼兰区</td>\n</tr>\n<tr>\n<td align=\"left\">230112</td>\n<td align=\"left\">阿城区</td>\n</tr>\n<tr>\n<td align=\"left\">230113</td>\n<td align=\"left\">双城区</td>\n</tr>\n<tr>\n<td align=\"left\">230123</td>\n<td align=\"left\">依兰县</td>\n</tr>\n<tr>\n<td align=\"left\">230124</td>\n<td align=\"left\">方正县</td>\n</tr>\n<tr>\n<td align=\"left\">230125</td>\n<td align=\"left\">宾县</td>\n</tr>\n<tr>\n<td align=\"left\">230126</td>\n<td align=\"left\">巴彦县</td>\n</tr>\n<tr>\n<td align=\"left\">230127</td>\n<td align=\"left\">木兰县</td>\n</tr>\n<tr>\n<td align=\"left\">230128</td>\n<td align=\"left\">通河县</td>\n</tr>\n<tr>\n<td align=\"left\">230129</td>\n<td align=\"left\">延寿县</td>\n</tr>\n<tr>\n<td align=\"left\">230183</td>\n<td align=\"left\">尚志市</td>\n</tr>\n<tr>\n<td align=\"left\">230184</td>\n<td align=\"left\">五常市</td>\n</tr>\n<tr>\n<td align=\"left\">230200</td>\n<td align=\"left\">齐齐哈尔市</td>\n</tr>\n<tr>\n<td align=\"left\">230202</td>\n<td align=\"left\">龙沙区</td>\n</tr>\n<tr>\n<td align=\"left\">230203</td>\n<td align=\"left\">建华区</td>\n</tr>\n<tr>\n<td align=\"left\">230204</td>\n<td align=\"left\">铁锋区</td>\n</tr>\n<tr>\n<td align=\"left\">230205</td>\n<td align=\"left\">昂昂溪区</td>\n</tr>\n<tr>\n<td align=\"left\">230206</td>\n<td align=\"left\">富拉尔基区</td>\n</tr>\n<tr>\n<td align=\"left\">230207</td>\n<td align=\"left\">碾子山区</td>\n</tr>\n<tr>\n<td align=\"left\">230208</td>\n<td align=\"left\">梅里斯达斡尔族区</td>\n</tr>\n<tr>\n<td align=\"left\">230221</td>\n<td align=\"left\">龙江县</td>\n</tr>\n<tr>\n<td align=\"left\">230223</td>\n<td align=\"left\">依安县</td>\n</tr>\n<tr>\n<td align=\"left\">230224</td>\n<td align=\"left\">泰来县</td>\n</tr>\n<tr>\n<td align=\"left\">230225</td>\n<td align=\"left\">甘南县</td>\n</tr>\n<tr>\n<td align=\"left\">230227</td>\n<td align=\"left\">富裕县</td>\n</tr>\n<tr>\n<td align=\"left\">230229</td>\n<td align=\"left\">克山县</td>\n</tr>\n<tr>\n<td align=\"left\">230230</td>\n<td align=\"left\">克东县</td>\n</tr>\n<tr>\n<td align=\"left\">230231</td>\n<td align=\"left\">拜泉县</td>\n</tr>\n<tr>\n<td align=\"left\">230281</td>\n<td align=\"left\">讷河市</td>\n</tr>\n<tr>\n<td align=\"left\">230300</td>\n<td align=\"left\">鸡西市</td>\n</tr>\n<tr>\n<td align=\"left\">230302</td>\n<td align=\"left\">鸡冠区</td>\n</tr>\n<tr>\n<td align=\"left\">230303</td>\n<td align=\"left\">恒山区</td>\n</tr>\n<tr>\n<td align=\"left\">230304</td>\n<td align=\"left\">滴道区</td>\n</tr>\n<tr>\n<td align=\"left\">230305</td>\n<td align=\"left\">梨树区</td>\n</tr>\n<tr>\n<td align=\"left\">230306</td>\n<td align=\"left\">城子河区</td>\n</tr>\n<tr>\n<td align=\"left\">230307</td>\n<td align=\"left\">麻山区</td>\n</tr>\n<tr>\n<td align=\"left\">230321</td>\n<td align=\"left\">鸡东县</td>\n</tr>\n<tr>\n<td align=\"left\">230381</td>\n<td align=\"left\">虎林市</td>\n</tr>\n<tr>\n<td align=\"left\">230382</td>\n<td align=\"left\">密山市</td>\n</tr>\n<tr>\n<td align=\"left\">230400</td>\n<td align=\"left\">鹤岗市</td>\n</tr>\n<tr>\n<td align=\"left\">230402</td>\n<td align=\"left\">向阳区</td>\n</tr>\n<tr>\n<td align=\"left\">230403</td>\n<td align=\"left\">工农区</td>\n</tr>\n<tr>\n<td align=\"left\">230404</td>\n<td align=\"left\">南山区</td>\n</tr>\n<tr>\n<td align=\"left\">230405</td>\n<td align=\"left\">兴安区</td>\n</tr>\n<tr>\n<td align=\"left\">230406</td>\n<td align=\"left\">东山区</td>\n</tr>\n<tr>\n<td align=\"left\">230407</td>\n<td align=\"left\">兴山区</td>\n</tr>\n<tr>\n<td align=\"left\">230421</td>\n<td align=\"left\">萝北县</td>\n</tr>\n<tr>\n<td align=\"left\">230422</td>\n<td align=\"left\">绥滨县</td>\n</tr>\n<tr>\n<td align=\"left\">230500</td>\n<td align=\"left\">双鸭山市</td>\n</tr>\n<tr>\n<td align=\"left\">230502</td>\n<td align=\"left\">尖山区</td>\n</tr>\n<tr>\n<td align=\"left\">230503</td>\n<td align=\"left\">岭东区</td>\n</tr>\n<tr>\n<td align=\"left\">230505</td>\n<td align=\"left\">四方台区</td>\n</tr>\n<tr>\n<td align=\"left\">230506</td>\n<td align=\"left\">宝山区</td>\n</tr>\n<tr>\n<td align=\"left\">230521</td>\n<td align=\"left\">集贤县</td>\n</tr>\n<tr>\n<td align=\"left\">230522</td>\n<td align=\"left\">友谊县</td>\n</tr>\n<tr>\n<td align=\"left\">230523</td>\n<td align=\"left\">宝清县</td>\n</tr>\n<tr>\n<td align=\"left\">230524</td>\n<td align=\"left\">饶河县</td>\n</tr>\n<tr>\n<td align=\"left\">230600</td>\n<td align=\"left\">大庆市</td>\n</tr>\n<tr>\n<td align=\"left\">230602</td>\n<td align=\"left\">萨尔图区</td>\n</tr>\n<tr>\n<td align=\"left\">230603</td>\n<td align=\"left\">龙凤区</td>\n</tr>\n<tr>\n<td align=\"left\">230604</td>\n<td align=\"left\">让胡路区</td>\n</tr>\n<tr>\n<td align=\"left\">230605</td>\n<td align=\"left\">红岗区</td>\n</tr>\n<tr>\n<td align=\"left\">230606</td>\n<td align=\"left\">大同区</td>\n</tr>\n<tr>\n<td align=\"left\">230621</td>\n<td align=\"left\">肇州县</td>\n</tr>\n<tr>\n<td align=\"left\">230622</td>\n<td align=\"left\">肇源县</td>\n</tr>\n<tr>\n<td align=\"left\">230623</td>\n<td align=\"left\">林甸县</td>\n</tr>\n<tr>\n<td align=\"left\">230624</td>\n<td align=\"left\">杜尔伯特蒙古族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">230700</td>\n<td align=\"left\">伊春市</td>\n</tr>\n<tr>\n<td align=\"left\">230717</td>\n<td align=\"left\">伊美区</td>\n</tr>\n<tr>\n<td align=\"left\">230718</td>\n<td align=\"left\">乌翠区</td>\n</tr>\n<tr>\n<td align=\"left\">230719</td>\n<td align=\"left\">友好区</td>\n</tr>\n<tr>\n<td align=\"left\">230722</td>\n<td align=\"left\">嘉荫县</td>\n</tr>\n<tr>\n<td align=\"left\">230723</td>\n<td align=\"left\">汤旺县</td>\n</tr>\n<tr>\n<td align=\"left\">230724</td>\n<td align=\"left\">丰林县</td>\n</tr>\n<tr>\n<td align=\"left\">230725</td>\n<td align=\"left\">大箐山县</td>\n</tr>\n<tr>\n<td align=\"left\">230726</td>\n<td align=\"left\">南岔县</td>\n</tr>\n<tr>\n<td align=\"left\">230751</td>\n<td align=\"left\">金林区</td>\n</tr>\n<tr>\n<td align=\"left\">230781</td>\n<td align=\"left\">铁力市</td>\n</tr>\n<tr>\n<td align=\"left\">230800</td>\n<td align=\"left\">佳木斯市</td>\n</tr>\n<tr>\n<td align=\"left\">230803</td>\n<td align=\"left\">向阳区</td>\n</tr>\n<tr>\n<td align=\"left\">230804</td>\n<td align=\"left\">前进区</td>\n</tr>\n<tr>\n<td align=\"left\">230805</td>\n<td align=\"left\">东风区</td>\n</tr>\n<tr>\n<td align=\"left\">230811</td>\n<td align=\"left\">郊区</td>\n</tr>\n<tr>\n<td align=\"left\">230822</td>\n<td align=\"left\">桦南县</td>\n</tr>\n<tr>\n<td align=\"left\">230826</td>\n<td align=\"left\">桦川县</td>\n</tr>\n<tr>\n<td align=\"left\">230828</td>\n<td align=\"left\">汤原县</td>\n</tr>\n<tr>\n<td align=\"left\">230881</td>\n<td align=\"left\">同江市</td>\n</tr>\n<tr>\n<td align=\"left\">230882</td>\n<td align=\"left\">富锦市</td>\n</tr>\n<tr>\n<td align=\"left\">230883</td>\n<td align=\"left\">抚远市</td>\n</tr>\n<tr>\n<td align=\"left\">230900</td>\n<td align=\"left\">七台河市</td>\n</tr>\n<tr>\n<td align=\"left\">230902</td>\n<td align=\"left\">新兴区</td>\n</tr>\n<tr>\n<td align=\"left\">230903</td>\n<td align=\"left\">桃山区</td>\n</tr>\n<tr>\n<td align=\"left\">230904</td>\n<td align=\"left\">茄子河区</td>\n</tr>\n<tr>\n<td align=\"left\">230921</td>\n<td align=\"left\">勃利县</td>\n</tr>\n<tr>\n<td align=\"left\">231000</td>\n<td align=\"left\">牡丹江市</td>\n</tr>\n<tr>\n<td align=\"left\">231002</td>\n<td align=\"left\">东安区</td>\n</tr>\n<tr>\n<td align=\"left\">231003</td>\n<td align=\"left\">阳明区</td>\n</tr>\n<tr>\n<td align=\"left\">231004</td>\n<td align=\"left\">爱民区</td>\n</tr>\n<tr>\n<td align=\"left\">231005</td>\n<td align=\"left\">西安区</td>\n</tr>\n<tr>\n<td align=\"left\">231025</td>\n<td align=\"left\">林口县</td>\n</tr>\n<tr>\n<td align=\"left\">231081</td>\n<td align=\"left\">绥芬河市</td>\n</tr>\n<tr>\n<td align=\"left\">231083</td>\n<td align=\"left\">海林市</td>\n</tr>\n<tr>\n<td align=\"left\">231084</td>\n<td align=\"left\">宁安市</td>\n</tr>\n<tr>\n<td align=\"left\">231085</td>\n<td align=\"left\">穆棱市</td>\n</tr>\n<tr>\n<td align=\"left\">231086</td>\n<td align=\"left\">东宁市</td>\n</tr>\n<tr>\n<td align=\"left\">231100</td>\n<td align=\"left\">黑河市</td>\n</tr>\n<tr>\n<td align=\"left\">231102</td>\n<td align=\"left\">爱辉区</td>\n</tr>\n<tr>\n<td align=\"left\">231123</td>\n<td align=\"left\">逊克县</td>\n</tr>\n<tr>\n<td align=\"left\">231124</td>\n<td align=\"left\">孙吴县</td>\n</tr>\n<tr>\n<td align=\"left\">231181</td>\n<td align=\"left\">北安市</td>\n</tr>\n<tr>\n<td align=\"left\">231182</td>\n<td align=\"left\">五大连池市</td>\n</tr>\n<tr>\n<td align=\"left\">231183</td>\n<td align=\"left\">嫩江市</td>\n</tr>\n<tr>\n<td align=\"left\">231200</td>\n<td align=\"left\">绥化市</td>\n</tr>\n<tr>\n<td align=\"left\">231202</td>\n<td align=\"left\">北林区</td>\n</tr>\n<tr>\n<td align=\"left\">231221</td>\n<td align=\"left\">望奎县</td>\n</tr>\n<tr>\n<td align=\"left\">231222</td>\n<td align=\"left\">兰西县</td>\n</tr>\n<tr>\n<td align=\"left\">231223</td>\n<td align=\"left\">青冈县</td>\n</tr>\n<tr>\n<td align=\"left\">231224</td>\n<td align=\"left\">庆安县</td>\n</tr>\n<tr>\n<td align=\"left\">231225</td>\n<td align=\"left\">明水县</td>\n</tr>\n<tr>\n<td align=\"left\">231226</td>\n<td align=\"left\">绥棱县</td>\n</tr>\n<tr>\n<td align=\"left\">231281</td>\n<td align=\"left\">安达市</td>\n</tr>\n<tr>\n<td align=\"left\">231282</td>\n<td align=\"left\">肇东市</td>\n</tr>\n<tr>\n<td align=\"left\">231283</td>\n<td align=\"left\">海伦市</td>\n</tr>\n<tr>\n<td align=\"left\">232700</td>\n<td align=\"left\">大兴安岭地区</td>\n</tr>\n<tr>\n<td align=\"left\">232701</td>\n<td align=\"left\">漠河市</td>\n</tr>\n<tr>\n<td align=\"left\">232721</td>\n<td align=\"left\">呼玛县</td>\n</tr>\n<tr>\n<td align=\"left\">232722</td>\n<td align=\"left\">塔河县</td>\n</tr>\n<tr>\n<td align=\"left\">310000</td>\n<td align=\"left\">上海市</td>\n</tr>\n<tr>\n<td align=\"left\">310101</td>\n<td align=\"left\">黄浦区</td>\n</tr>\n<tr>\n<td align=\"left\">310104</td>\n<td align=\"left\">徐汇区</td>\n</tr>\n<tr>\n<td align=\"left\">310105</td>\n<td align=\"left\">长宁区</td>\n</tr>\n<tr>\n<td align=\"left\">310106</td>\n<td align=\"left\">静安区</td>\n</tr>\n<tr>\n<td align=\"left\">310107</td>\n<td align=\"left\">普陀区</td>\n</tr>\n<tr>\n<td align=\"left\">310109</td>\n<td align=\"left\">虹口区</td>\n</tr>\n<tr>\n<td align=\"left\">310110</td>\n<td align=\"left\">杨浦区</td>\n</tr>\n<tr>\n<td align=\"left\">310112</td>\n<td align=\"left\">闵行区</td>\n</tr>\n<tr>\n<td align=\"left\">310113</td>\n<td align=\"left\">宝山区</td>\n</tr>\n<tr>\n<td align=\"left\">310114</td>\n<td align=\"left\">嘉定区</td>\n</tr>\n<tr>\n<td align=\"left\">310115</td>\n<td align=\"left\">浦东新区</td>\n</tr>\n<tr>\n<td align=\"left\">310116</td>\n<td align=\"left\">金山区</td>\n</tr>\n<tr>\n<td align=\"left\">310117</td>\n<td align=\"left\">松江区</td>\n</tr>\n<tr>\n<td align=\"left\">310118</td>\n<td align=\"left\">青浦区</td>\n</tr>\n<tr>\n<td align=\"left\">310120</td>\n<td align=\"left\">奉贤区</td>\n</tr>\n<tr>\n<td align=\"left\">310151</td>\n<td align=\"left\">崇明区</td>\n</tr>\n<tr>\n<td align=\"left\">320000</td>\n<td align=\"left\">江苏省</td>\n</tr>\n<tr>\n<td align=\"left\">320100</td>\n<td align=\"left\">南京市</td>\n</tr>\n<tr>\n<td align=\"left\">320102</td>\n<td align=\"left\">玄武区</td>\n</tr>\n<tr>\n<td align=\"left\">320104</td>\n<td align=\"left\">秦淮区</td>\n</tr>\n<tr>\n<td align=\"left\">320105</td>\n<td align=\"left\">建邺区</td>\n</tr>\n<tr>\n<td align=\"left\">320106</td>\n<td align=\"left\">鼓楼区</td>\n</tr>\n<tr>\n<td align=\"left\">320111</td>\n<td align=\"left\">浦口区</td>\n</tr>\n<tr>\n<td align=\"left\">320113</td>\n<td align=\"left\">栖霞区</td>\n</tr>\n<tr>\n<td align=\"left\">320114</td>\n<td align=\"left\">雨花台区</td>\n</tr>\n<tr>\n<td align=\"left\">320115</td>\n<td align=\"left\">江宁区</td>\n</tr>\n<tr>\n<td align=\"left\">320116</td>\n<td align=\"left\">六合区</td>\n</tr>\n<tr>\n<td align=\"left\">320117</td>\n<td align=\"left\">溧水区</td>\n</tr>\n<tr>\n<td align=\"left\">320118</td>\n<td align=\"left\">高淳区</td>\n</tr>\n<tr>\n<td align=\"left\">320200</td>\n<td align=\"left\">无锡市</td>\n</tr>\n<tr>\n<td align=\"left\">320205</td>\n<td align=\"left\">锡山区</td>\n</tr>\n<tr>\n<td align=\"left\">320206</td>\n<td align=\"left\">惠山区</td>\n</tr>\n<tr>\n<td align=\"left\">320211</td>\n<td align=\"left\">滨湖区</td>\n</tr>\n<tr>\n<td align=\"left\">320213</td>\n<td align=\"left\">梁溪区</td>\n</tr>\n<tr>\n<td align=\"left\">320214</td>\n<td align=\"left\">新吴区</td>\n</tr>\n<tr>\n<td align=\"left\">320281</td>\n<td align=\"left\">江阴市</td>\n</tr>\n<tr>\n<td align=\"left\">320282</td>\n<td align=\"left\">宜兴市</td>\n</tr>\n<tr>\n<td align=\"left\">320300</td>\n<td align=\"left\">徐州市</td>\n</tr>\n<tr>\n<td align=\"left\">320302</td>\n<td align=\"left\">鼓楼区</td>\n</tr>\n<tr>\n<td align=\"left\">320303</td>\n<td align=\"left\">云龙区</td>\n</tr>\n<tr>\n<td align=\"left\">320305</td>\n<td align=\"left\">贾汪区</td>\n</tr>\n<tr>\n<td align=\"left\">320311</td>\n<td align=\"left\">泉山区</td>\n</tr>\n<tr>\n<td align=\"left\">320312</td>\n<td align=\"left\">铜山区</td>\n</tr>\n<tr>\n<td align=\"left\">320321</td>\n<td align=\"left\">丰县</td>\n</tr>\n<tr>\n<td align=\"left\">320322</td>\n<td align=\"left\">沛县</td>\n</tr>\n<tr>\n<td align=\"left\">320324</td>\n<td align=\"left\">睢宁县</td>\n</tr>\n<tr>\n<td align=\"left\">320381</td>\n<td align=\"left\">新沂市</td>\n</tr>\n<tr>\n<td align=\"left\">320382</td>\n<td align=\"left\">邳州市</td>\n</tr>\n<tr>\n<td align=\"left\">320400</td>\n<td align=\"left\">常州市</td>\n</tr>\n<tr>\n<td align=\"left\">320402</td>\n<td align=\"left\">天宁区</td>\n</tr>\n<tr>\n<td align=\"left\">320404</td>\n<td align=\"left\">钟楼区</td>\n</tr>\n<tr>\n<td align=\"left\">320411</td>\n<td align=\"left\">新北区</td>\n</tr>\n<tr>\n<td align=\"left\">320412</td>\n<td align=\"left\">武进区</td>\n</tr>\n<tr>\n<td align=\"left\">320413</td>\n<td align=\"left\">金坛区</td>\n</tr>\n<tr>\n<td align=\"left\">320481</td>\n<td align=\"left\">溧阳市</td>\n</tr>\n<tr>\n<td align=\"left\">320500</td>\n<td align=\"left\">苏州市</td>\n</tr>\n<tr>\n<td align=\"left\">320505</td>\n<td align=\"left\">虎丘区</td>\n</tr>\n<tr>\n<td align=\"left\">320506</td>\n<td align=\"left\">吴中区</td>\n</tr>\n<tr>\n<td align=\"left\">320507</td>\n<td align=\"left\">相城区</td>\n</tr>\n<tr>\n<td align=\"left\">320508</td>\n<td align=\"left\">姑苏区</td>\n</tr>\n<tr>\n<td align=\"left\">320509</td>\n<td align=\"left\">吴江区</td>\n</tr>\n<tr>\n<td align=\"left\">320581</td>\n<td align=\"left\">常熟市</td>\n</tr>\n<tr>\n<td align=\"left\">320582</td>\n<td align=\"left\">张家港市</td>\n</tr>\n<tr>\n<td align=\"left\">320583</td>\n<td align=\"left\">昆山市</td>\n</tr>\n<tr>\n<td align=\"left\">320585</td>\n<td align=\"left\">太仓市</td>\n</tr>\n<tr>\n<td align=\"left\">320600</td>\n<td align=\"left\">南通市</td>\n</tr>\n<tr>\n<td align=\"left\">320602</td>\n<td align=\"left\">崇川区</td>\n</tr>\n<tr>\n<td align=\"left\">320611</td>\n<td align=\"left\">港闸区</td>\n</tr>\n<tr>\n<td align=\"left\">320612</td>\n<td align=\"left\">通州区</td>\n</tr>\n<tr>\n<td align=\"left\">320623</td>\n<td align=\"left\">如东县</td>\n</tr>\n<tr>\n<td align=\"left\">320681</td>\n<td align=\"left\">启东市</td>\n</tr>\n<tr>\n<td align=\"left\">320682</td>\n<td align=\"left\">如皋市</td>\n</tr>\n<tr>\n<td align=\"left\">320684</td>\n<td align=\"left\">海门市</td>\n</tr>\n<tr>\n<td align=\"left\">320685</td>\n<td align=\"left\">海安市</td>\n</tr>\n<tr>\n<td align=\"left\">320700</td>\n<td align=\"left\">连云港市</td>\n</tr>\n<tr>\n<td align=\"left\">320703</td>\n<td align=\"left\">连云区</td>\n</tr>\n<tr>\n<td align=\"left\">320706</td>\n<td align=\"left\">海州区</td>\n</tr>\n<tr>\n<td align=\"left\">320707</td>\n<td align=\"left\">赣榆区</td>\n</tr>\n<tr>\n<td align=\"left\">320722</td>\n<td align=\"left\">东海县</td>\n</tr>\n<tr>\n<td align=\"left\">320723</td>\n<td align=\"left\">灌云县</td>\n</tr>\n<tr>\n<td align=\"left\">320724</td>\n<td align=\"left\">灌南县</td>\n</tr>\n<tr>\n<td align=\"left\">320800</td>\n<td align=\"left\">淮安市</td>\n</tr>\n<tr>\n<td align=\"left\">320803</td>\n<td align=\"left\">淮安区</td>\n</tr>\n<tr>\n<td align=\"left\">320804</td>\n<td align=\"left\">淮阴区</td>\n</tr>\n<tr>\n<td align=\"left\">320812</td>\n<td align=\"left\">清江浦区</td>\n</tr>\n<tr>\n<td align=\"left\">320813</td>\n<td align=\"left\">洪泽区</td>\n</tr>\n<tr>\n<td align=\"left\">320826</td>\n<td align=\"left\">涟水县</td>\n</tr>\n<tr>\n<td align=\"left\">320830</td>\n<td align=\"left\">盱眙县</td>\n</tr>\n<tr>\n<td align=\"left\">320831</td>\n<td align=\"left\">金湖县</td>\n</tr>\n<tr>\n<td align=\"left\">320900</td>\n<td align=\"left\">盐城市</td>\n</tr>\n<tr>\n<td align=\"left\">320902</td>\n<td align=\"left\">亭湖区</td>\n</tr>\n<tr>\n<td align=\"left\">320903</td>\n<td align=\"left\">盐都区</td>\n</tr>\n<tr>\n<td align=\"left\">320904</td>\n<td align=\"left\">大丰区</td>\n</tr>\n<tr>\n<td align=\"left\">320921</td>\n<td align=\"left\">响水县</td>\n</tr>\n<tr>\n<td align=\"left\">320922</td>\n<td align=\"left\">滨海县</td>\n</tr>\n<tr>\n<td align=\"left\">320923</td>\n<td align=\"left\">阜宁县</td>\n</tr>\n<tr>\n<td align=\"left\">320924</td>\n<td align=\"left\">射阳县</td>\n</tr>\n<tr>\n<td align=\"left\">320925</td>\n<td align=\"left\">建湖县</td>\n</tr>\n<tr>\n<td align=\"left\">320981</td>\n<td align=\"left\">东台市</td>\n</tr>\n<tr>\n<td align=\"left\">321000</td>\n<td align=\"left\">扬州市</td>\n</tr>\n<tr>\n<td align=\"left\">321002</td>\n<td align=\"left\">广陵区</td>\n</tr>\n<tr>\n<td align=\"left\">321003</td>\n<td align=\"left\">邗江区</td>\n</tr>\n<tr>\n<td align=\"left\">321012</td>\n<td align=\"left\">江都区</td>\n</tr>\n<tr>\n<td align=\"left\">321023</td>\n<td align=\"left\">宝应县</td>\n</tr>\n<tr>\n<td align=\"left\">321081</td>\n<td align=\"left\">仪征市</td>\n</tr>\n<tr>\n<td align=\"left\">321084</td>\n<td align=\"left\">高邮市</td>\n</tr>\n<tr>\n<td align=\"left\">321100</td>\n<td align=\"left\">镇江市</td>\n</tr>\n<tr>\n<td align=\"left\">321102</td>\n<td align=\"left\">京口区</td>\n</tr>\n<tr>\n<td align=\"left\">321111</td>\n<td align=\"left\">润州区</td>\n</tr>\n<tr>\n<td align=\"left\">321112</td>\n<td align=\"left\">丹徒区</td>\n</tr>\n<tr>\n<td align=\"left\">321181</td>\n<td align=\"left\">丹阳市</td>\n</tr>\n<tr>\n<td align=\"left\">321182</td>\n<td align=\"left\">扬中市</td>\n</tr>\n<tr>\n<td align=\"left\">321183</td>\n<td align=\"left\">句容市</td>\n</tr>\n<tr>\n<td align=\"left\">321200</td>\n<td align=\"left\">泰州市</td>\n</tr>\n<tr>\n<td align=\"left\">321202</td>\n<td align=\"left\">海陵区</td>\n</tr>\n<tr>\n<td align=\"left\">321203</td>\n<td align=\"left\">高港区</td>\n</tr>\n<tr>\n<td align=\"left\">321204</td>\n<td align=\"left\">姜堰区</td>\n</tr>\n<tr>\n<td align=\"left\">321281</td>\n<td align=\"left\">兴化市</td>\n</tr>\n<tr>\n<td align=\"left\">321282</td>\n<td align=\"left\">靖江市</td>\n</tr>\n<tr>\n<td align=\"left\">321283</td>\n<td align=\"left\">泰兴市</td>\n</tr>\n<tr>\n<td align=\"left\">321300</td>\n<td align=\"left\">宿迁市</td>\n</tr>\n<tr>\n<td align=\"left\">321302</td>\n<td align=\"left\">宿城区</td>\n</tr>\n<tr>\n<td align=\"left\">321311</td>\n<td align=\"left\">宿豫区</td>\n</tr>\n<tr>\n<td align=\"left\">321322</td>\n<td align=\"left\">沭阳县</td>\n</tr>\n<tr>\n<td align=\"left\">321323</td>\n<td align=\"left\">泗阳县</td>\n</tr>\n<tr>\n<td align=\"left\">321324</td>\n<td align=\"left\">泗洪县</td>\n</tr>\n<tr>\n<td align=\"left\">330000</td>\n<td align=\"left\">浙江省</td>\n</tr>\n<tr>\n<td align=\"left\">330100</td>\n<td align=\"left\">杭州市</td>\n</tr>\n<tr>\n<td align=\"left\">330102</td>\n<td align=\"left\">上城区</td>\n</tr>\n<tr>\n<td align=\"left\">330103</td>\n<td align=\"left\">下城区</td>\n</tr>\n<tr>\n<td align=\"left\">330104</td>\n<td align=\"left\">江干区</td>\n</tr>\n<tr>\n<td align=\"left\">330105</td>\n<td align=\"left\">拱墅区</td>\n</tr>\n<tr>\n<td align=\"left\">330106</td>\n<td align=\"left\">西湖区</td>\n</tr>\n<tr>\n<td align=\"left\">330108</td>\n<td align=\"left\">滨江区</td>\n</tr>\n<tr>\n<td align=\"left\">330109</td>\n<td align=\"left\">萧山区</td>\n</tr>\n<tr>\n<td align=\"left\">330110</td>\n<td align=\"left\">余杭区</td>\n</tr>\n<tr>\n<td align=\"left\">330111</td>\n<td align=\"left\">富阳区</td>\n</tr>\n<tr>\n<td align=\"left\">330112</td>\n<td align=\"left\">临安区</td>\n</tr>\n<tr>\n<td align=\"left\">330122</td>\n<td align=\"left\">桐庐县</td>\n</tr>\n<tr>\n<td align=\"left\">330127</td>\n<td align=\"left\">淳安县</td>\n</tr>\n<tr>\n<td align=\"left\">330182</td>\n<td align=\"left\">建德市</td>\n</tr>\n<tr>\n<td align=\"left\">330200</td>\n<td align=\"left\">宁波市</td>\n</tr>\n<tr>\n<td align=\"left\">330203</td>\n<td align=\"left\">海曙区</td>\n</tr>\n<tr>\n<td align=\"left\">330205</td>\n<td align=\"left\">江北区</td>\n</tr>\n<tr>\n<td align=\"left\">330206</td>\n<td align=\"left\">北仑区</td>\n</tr>\n<tr>\n<td align=\"left\">330211</td>\n<td align=\"left\">镇海区</td>\n</tr>\n<tr>\n<td align=\"left\">330212</td>\n<td align=\"left\">鄞州区</td>\n</tr>\n<tr>\n<td align=\"left\">330213</td>\n<td align=\"left\">奉化区</td>\n</tr>\n<tr>\n<td align=\"left\">330225</td>\n<td align=\"left\">象山县</td>\n</tr>\n<tr>\n<td align=\"left\">330226</td>\n<td align=\"left\">宁海县</td>\n</tr>\n<tr>\n<td align=\"left\">330281</td>\n<td align=\"left\">余姚市</td>\n</tr>\n<tr>\n<td align=\"left\">330282</td>\n<td align=\"left\">慈溪市</td>\n</tr>\n<tr>\n<td align=\"left\">330300</td>\n<td align=\"left\">温州市</td>\n</tr>\n<tr>\n<td align=\"left\">330302</td>\n<td align=\"left\">鹿城区</td>\n</tr>\n<tr>\n<td align=\"left\">330303</td>\n<td align=\"left\">龙湾区</td>\n</tr>\n<tr>\n<td align=\"left\">330304</td>\n<td align=\"left\">瓯海区</td>\n</tr>\n<tr>\n<td align=\"left\">330305</td>\n<td align=\"left\">洞头区</td>\n</tr>\n<tr>\n<td align=\"left\">330324</td>\n<td align=\"left\">永嘉县</td>\n</tr>\n<tr>\n<td align=\"left\">330326</td>\n<td align=\"left\">平阳县</td>\n</tr>\n<tr>\n<td align=\"left\">330327</td>\n<td align=\"left\">苍南县</td>\n</tr>\n<tr>\n<td align=\"left\">330328</td>\n<td align=\"left\">文成县</td>\n</tr>\n<tr>\n<td align=\"left\">330329</td>\n<td align=\"left\">泰顺县</td>\n</tr>\n<tr>\n<td align=\"left\">330381</td>\n<td align=\"left\">瑞安市</td>\n</tr>\n<tr>\n<td align=\"left\">330382</td>\n<td align=\"left\">乐清市</td>\n</tr>\n<tr>\n<td align=\"left\">330383</td>\n<td align=\"left\">龙港市</td>\n</tr>\n<tr>\n<td align=\"left\">330400</td>\n<td align=\"left\">嘉兴市</td>\n</tr>\n<tr>\n<td align=\"left\">330402</td>\n<td align=\"left\">南湖区</td>\n</tr>\n<tr>\n<td align=\"left\">330411</td>\n<td align=\"left\">秀洲区</td>\n</tr>\n<tr>\n<td align=\"left\">330421</td>\n<td align=\"left\">嘉善县</td>\n</tr>\n<tr>\n<td align=\"left\">330424</td>\n<td align=\"left\">海盐县</td>\n</tr>\n<tr>\n<td align=\"left\">330481</td>\n<td align=\"left\">海宁市</td>\n</tr>\n<tr>\n<td align=\"left\">330482</td>\n<td align=\"left\">平湖市</td>\n</tr>\n<tr>\n<td align=\"left\">330483</td>\n<td align=\"left\">桐乡市</td>\n</tr>\n<tr>\n<td align=\"left\">330500</td>\n<td align=\"left\">湖州市</td>\n</tr>\n<tr>\n<td align=\"left\">330502</td>\n<td align=\"left\">吴兴区</td>\n</tr>\n<tr>\n<td align=\"left\">330503</td>\n<td align=\"left\">南浔区</td>\n</tr>\n<tr>\n<td align=\"left\">330521</td>\n<td align=\"left\">德清县</td>\n</tr>\n<tr>\n<td align=\"left\">330522</td>\n<td align=\"left\">长兴县</td>\n</tr>\n<tr>\n<td align=\"left\">330523</td>\n<td align=\"left\">安吉县</td>\n</tr>\n<tr>\n<td align=\"left\">330600</td>\n<td align=\"left\">绍兴市</td>\n</tr>\n<tr>\n<td align=\"left\">330602</td>\n<td align=\"left\">越城区</td>\n</tr>\n<tr>\n<td align=\"left\">330603</td>\n<td align=\"left\">柯桥区</td>\n</tr>\n<tr>\n<td align=\"left\">330604</td>\n<td align=\"left\">上虞区</td>\n</tr>\n<tr>\n<td align=\"left\">330624</td>\n<td align=\"left\">新昌县</td>\n</tr>\n<tr>\n<td align=\"left\">330681</td>\n<td align=\"left\">诸暨市</td>\n</tr>\n<tr>\n<td align=\"left\">330683</td>\n<td align=\"left\">嵊州市</td>\n</tr>\n<tr>\n<td align=\"left\">330700</td>\n<td align=\"left\">金华市</td>\n</tr>\n<tr>\n<td align=\"left\">330702</td>\n<td align=\"left\">婺城区</td>\n</tr>\n<tr>\n<td align=\"left\">330703</td>\n<td align=\"left\">金东区</td>\n</tr>\n<tr>\n<td align=\"left\">330723</td>\n<td align=\"left\">武义县</td>\n</tr>\n<tr>\n<td align=\"left\">330726</td>\n<td align=\"left\">浦江县</td>\n</tr>\n<tr>\n<td align=\"left\">330727</td>\n<td align=\"left\">磐安县</td>\n</tr>\n<tr>\n<td align=\"left\">330781</td>\n<td align=\"left\">兰溪市</td>\n</tr>\n<tr>\n<td align=\"left\">330782</td>\n<td align=\"left\">义乌市</td>\n</tr>\n<tr>\n<td align=\"left\">330783</td>\n<td align=\"left\">东阳市</td>\n</tr>\n<tr>\n<td align=\"left\">330784</td>\n<td align=\"left\">永康市</td>\n</tr>\n<tr>\n<td align=\"left\">330800</td>\n<td align=\"left\">衢州市</td>\n</tr>\n<tr>\n<td align=\"left\">330802</td>\n<td align=\"left\">柯城区</td>\n</tr>\n<tr>\n<td align=\"left\">330803</td>\n<td align=\"left\">衢江区</td>\n</tr>\n<tr>\n<td align=\"left\">330822</td>\n<td align=\"left\">常山县</td>\n</tr>\n<tr>\n<td align=\"left\">330824</td>\n<td align=\"left\">开化县</td>\n</tr>\n<tr>\n<td align=\"left\">330825</td>\n<td align=\"left\">龙游县</td>\n</tr>\n<tr>\n<td align=\"left\">330881</td>\n<td align=\"left\">江山市</td>\n</tr>\n<tr>\n<td align=\"left\">330900</td>\n<td align=\"left\">舟山市</td>\n</tr>\n<tr>\n<td align=\"left\">330902</td>\n<td align=\"left\">定海区</td>\n</tr>\n<tr>\n<td align=\"left\">330903</td>\n<td align=\"left\">普陀区</td>\n</tr>\n<tr>\n<td align=\"left\">330921</td>\n<td align=\"left\">岱山县</td>\n</tr>\n<tr>\n<td align=\"left\">330922</td>\n<td align=\"left\">嵊泗县</td>\n</tr>\n<tr>\n<td align=\"left\">331000</td>\n<td align=\"left\">台州市</td>\n</tr>\n<tr>\n<td align=\"left\">331002</td>\n<td align=\"left\">椒江区</td>\n</tr>\n<tr>\n<td align=\"left\">331003</td>\n<td align=\"left\">黄岩区</td>\n</tr>\n<tr>\n<td align=\"left\">331004</td>\n<td align=\"left\">路桥区</td>\n</tr>\n<tr>\n<td align=\"left\">331022</td>\n<td align=\"left\">三门县</td>\n</tr>\n<tr>\n<td align=\"left\">331023</td>\n<td align=\"left\">天台县</td>\n</tr>\n<tr>\n<td align=\"left\">331024</td>\n<td align=\"left\">仙居县</td>\n</tr>\n<tr>\n<td align=\"left\">331081</td>\n<td align=\"left\">温岭市</td>\n</tr>\n<tr>\n<td align=\"left\">331082</td>\n<td align=\"left\">临海市</td>\n</tr>\n<tr>\n<td align=\"left\">331083</td>\n<td align=\"left\">玉环市</td>\n</tr>\n<tr>\n<td align=\"left\">331100</td>\n<td align=\"left\">丽水市</td>\n</tr>\n<tr>\n<td align=\"left\">331102</td>\n<td align=\"left\">莲都区</td>\n</tr>\n<tr>\n<td align=\"left\">331121</td>\n<td align=\"left\">青田县</td>\n</tr>\n<tr>\n<td align=\"left\">331122</td>\n<td align=\"left\">缙云县</td>\n</tr>\n<tr>\n<td align=\"left\">331123</td>\n<td align=\"left\">遂昌县</td>\n</tr>\n<tr>\n<td align=\"left\">331124</td>\n<td align=\"left\">松阳县</td>\n</tr>\n<tr>\n<td align=\"left\">331125</td>\n<td align=\"left\">云和县</td>\n</tr>\n<tr>\n<td align=\"left\">331126</td>\n<td align=\"left\">庆元县</td>\n</tr>\n<tr>\n<td align=\"left\">331127</td>\n<td align=\"left\">景宁畲族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">331181</td>\n<td align=\"left\">龙泉市</td>\n</tr>\n<tr>\n<td align=\"left\">340000</td>\n<td align=\"left\">安徽省</td>\n</tr>\n<tr>\n<td align=\"left\">340100</td>\n<td align=\"left\">合肥市</td>\n</tr>\n<tr>\n<td align=\"left\">340102</td>\n<td align=\"left\">瑶海区</td>\n</tr>\n<tr>\n<td align=\"left\">340103</td>\n<td align=\"left\">庐阳区</td>\n</tr>\n<tr>\n<td align=\"left\">340104</td>\n<td align=\"left\">蜀山区</td>\n</tr>\n<tr>\n<td align=\"left\">340111</td>\n<td align=\"left\">包河区</td>\n</tr>\n<tr>\n<td align=\"left\">340121</td>\n<td align=\"left\">长丰县</td>\n</tr>\n<tr>\n<td align=\"left\">340122</td>\n<td align=\"left\">肥东县</td>\n</tr>\n<tr>\n<td align=\"left\">340123</td>\n<td align=\"left\">肥西县</td>\n</tr>\n<tr>\n<td align=\"left\">340124</td>\n<td align=\"left\">庐江县</td>\n</tr>\n<tr>\n<td align=\"left\">340181</td>\n<td align=\"left\">巢湖市</td>\n</tr>\n<tr>\n<td align=\"left\">340200</td>\n<td align=\"left\">芜湖市</td>\n</tr>\n<tr>\n<td align=\"left\">340202</td>\n<td align=\"left\">镜湖区</td>\n</tr>\n<tr>\n<td align=\"left\">340203</td>\n<td align=\"left\">弋江区</td>\n</tr>\n<tr>\n<td align=\"left\">340207</td>\n<td align=\"left\">鸠江区</td>\n</tr>\n<tr>\n<td align=\"left\">340208</td>\n<td align=\"left\">三山区</td>\n</tr>\n<tr>\n<td align=\"left\">340221</td>\n<td align=\"left\">芜湖县</td>\n</tr>\n<tr>\n<td align=\"left\">340222</td>\n<td align=\"left\">繁昌县</td>\n</tr>\n<tr>\n<td align=\"left\">340223</td>\n<td align=\"left\">南陵县</td>\n</tr>\n<tr>\n<td align=\"left\">340281</td>\n<td align=\"left\">无为市</td>\n</tr>\n<tr>\n<td align=\"left\">340300</td>\n<td align=\"left\">蚌埠市</td>\n</tr>\n<tr>\n<td align=\"left\">340302</td>\n<td align=\"left\">龙子湖区</td>\n</tr>\n<tr>\n<td align=\"left\">340303</td>\n<td align=\"left\">蚌山区</td>\n</tr>\n<tr>\n<td align=\"left\">340304</td>\n<td align=\"left\">禹会区</td>\n</tr>\n<tr>\n<td align=\"left\">340311</td>\n<td align=\"left\">淮上区</td>\n</tr>\n<tr>\n<td align=\"left\">340321</td>\n<td align=\"left\">怀远县</td>\n</tr>\n<tr>\n<td align=\"left\">340322</td>\n<td align=\"left\">五河县</td>\n</tr>\n<tr>\n<td align=\"left\">340323</td>\n<td align=\"left\">固镇县</td>\n</tr>\n<tr>\n<td align=\"left\">340400</td>\n<td align=\"left\">淮南市</td>\n</tr>\n<tr>\n<td align=\"left\">340402</td>\n<td align=\"left\">大通区</td>\n</tr>\n<tr>\n<td align=\"left\">340403</td>\n<td align=\"left\">田家庵区</td>\n</tr>\n<tr>\n<td align=\"left\">340404</td>\n<td align=\"left\">谢家集区</td>\n</tr>\n<tr>\n<td align=\"left\">340405</td>\n<td align=\"left\">八公山区</td>\n</tr>\n<tr>\n<td align=\"left\">340406</td>\n<td align=\"left\">潘集区</td>\n</tr>\n<tr>\n<td align=\"left\">340421</td>\n<td align=\"left\">凤台县</td>\n</tr>\n<tr>\n<td align=\"left\">340422</td>\n<td align=\"left\">寿县</td>\n</tr>\n<tr>\n<td align=\"left\">340500</td>\n<td align=\"left\">马鞍山市</td>\n</tr>\n<tr>\n<td align=\"left\">340503</td>\n<td align=\"left\">花山区</td>\n</tr>\n<tr>\n<td align=\"left\">340504</td>\n<td align=\"left\">雨山区</td>\n</tr>\n<tr>\n<td align=\"left\">340506</td>\n<td align=\"left\">博望区</td>\n</tr>\n<tr>\n<td align=\"left\">340521</td>\n<td align=\"left\">当涂县</td>\n</tr>\n<tr>\n<td align=\"left\">340522</td>\n<td align=\"left\">含山县</td>\n</tr>\n<tr>\n<td align=\"left\">340523</td>\n<td align=\"left\">和县</td>\n</tr>\n<tr>\n<td align=\"left\">340600</td>\n<td align=\"left\">淮北市</td>\n</tr>\n<tr>\n<td align=\"left\">340602</td>\n<td align=\"left\">杜集区</td>\n</tr>\n<tr>\n<td align=\"left\">340603</td>\n<td align=\"left\">相山区</td>\n</tr>\n<tr>\n<td align=\"left\">340604</td>\n<td align=\"left\">烈山区</td>\n</tr>\n<tr>\n<td align=\"left\">340621</td>\n<td align=\"left\">濉溪县</td>\n</tr>\n<tr>\n<td align=\"left\">340700</td>\n<td align=\"left\">铜陵市</td>\n</tr>\n<tr>\n<td align=\"left\">340705</td>\n<td align=\"left\">铜官区</td>\n</tr>\n<tr>\n<td align=\"left\">340706</td>\n<td align=\"left\">义安区</td>\n</tr>\n<tr>\n<td align=\"left\">340711</td>\n<td align=\"left\">郊区</td>\n</tr>\n<tr>\n<td align=\"left\">340722</td>\n<td align=\"left\">枞阳县</td>\n</tr>\n<tr>\n<td align=\"left\">340800</td>\n<td align=\"left\">安庆市</td>\n</tr>\n<tr>\n<td align=\"left\">340802</td>\n<td align=\"left\">迎江区</td>\n</tr>\n<tr>\n<td align=\"left\">340803</td>\n<td align=\"left\">大观区</td>\n</tr>\n<tr>\n<td align=\"left\">340811</td>\n<td align=\"left\">宜秀区</td>\n</tr>\n<tr>\n<td align=\"left\">340822</td>\n<td align=\"left\">怀宁县</td>\n</tr>\n<tr>\n<td align=\"left\">340825</td>\n<td align=\"left\">太湖县</td>\n</tr>\n<tr>\n<td align=\"left\">340826</td>\n<td align=\"left\">宿松县</td>\n</tr>\n<tr>\n<td align=\"left\">340827</td>\n<td align=\"left\">望江县</td>\n</tr>\n<tr>\n<td align=\"left\">340828</td>\n<td align=\"left\">岳西县</td>\n</tr>\n<tr>\n<td align=\"left\">340881</td>\n<td align=\"left\">桐城市</td>\n</tr>\n<tr>\n<td align=\"left\">340882</td>\n<td align=\"left\">潜山市</td>\n</tr>\n<tr>\n<td align=\"left\">341000</td>\n<td align=\"left\">黄山市</td>\n</tr>\n<tr>\n<td align=\"left\">341002</td>\n<td align=\"left\">屯溪区</td>\n</tr>\n<tr>\n<td align=\"left\">341003</td>\n<td align=\"left\">黄山区</td>\n</tr>\n<tr>\n<td align=\"left\">341004</td>\n<td align=\"left\">徽州区</td>\n</tr>\n<tr>\n<td align=\"left\">341021</td>\n<td align=\"left\">歙县</td>\n</tr>\n<tr>\n<td align=\"left\">341022</td>\n<td align=\"left\">休宁县</td>\n</tr>\n<tr>\n<td align=\"left\">341023</td>\n<td align=\"left\">黟县</td>\n</tr>\n<tr>\n<td align=\"left\">341024</td>\n<td align=\"left\">祁门县</td>\n</tr>\n<tr>\n<td align=\"left\">341100</td>\n<td align=\"left\">滁州市</td>\n</tr>\n<tr>\n<td align=\"left\">341102</td>\n<td align=\"left\">琅琊区</td>\n</tr>\n<tr>\n<td align=\"left\">341103</td>\n<td align=\"left\">南谯区</td>\n</tr>\n<tr>\n<td align=\"left\">341122</td>\n<td align=\"left\">来安县</td>\n</tr>\n<tr>\n<td align=\"left\">341124</td>\n<td align=\"left\">全椒县</td>\n</tr>\n<tr>\n<td align=\"left\">341125</td>\n<td align=\"left\">定远县</td>\n</tr>\n<tr>\n<td align=\"left\">341126</td>\n<td align=\"left\">凤阳县</td>\n</tr>\n<tr>\n<td align=\"left\">341181</td>\n<td align=\"left\">天长市</td>\n</tr>\n<tr>\n<td align=\"left\">341182</td>\n<td align=\"left\">明光市</td>\n</tr>\n<tr>\n<td align=\"left\">341200</td>\n<td align=\"left\">阜阳市</td>\n</tr>\n<tr>\n<td align=\"left\">341202</td>\n<td align=\"left\">颍州区</td>\n</tr>\n<tr>\n<td align=\"left\">341203</td>\n<td align=\"left\">颍东区</td>\n</tr>\n<tr>\n<td align=\"left\">341204</td>\n<td align=\"left\">颍泉区</td>\n</tr>\n<tr>\n<td align=\"left\">341221</td>\n<td align=\"left\">临泉县</td>\n</tr>\n<tr>\n<td align=\"left\">341222</td>\n<td align=\"left\">太和县</td>\n</tr>\n<tr>\n<td align=\"left\">341225</td>\n<td align=\"left\">阜南县</td>\n</tr>\n<tr>\n<td align=\"left\">341226</td>\n<td align=\"left\">颍上县</td>\n</tr>\n<tr>\n<td align=\"left\">341282</td>\n<td align=\"left\">界首市</td>\n</tr>\n<tr>\n<td align=\"left\">341300</td>\n<td align=\"left\">宿州市</td>\n</tr>\n<tr>\n<td align=\"left\">341302</td>\n<td align=\"left\">埇桥区</td>\n</tr>\n<tr>\n<td align=\"left\">341321</td>\n<td align=\"left\">砀山县</td>\n</tr>\n<tr>\n<td align=\"left\">341322</td>\n<td align=\"left\">萧县</td>\n</tr>\n<tr>\n<td align=\"left\">341323</td>\n<td align=\"left\">灵璧县</td>\n</tr>\n<tr>\n<td align=\"left\">341324</td>\n<td align=\"left\">泗县</td>\n</tr>\n<tr>\n<td align=\"left\">341500</td>\n<td align=\"left\">六安市</td>\n</tr>\n<tr>\n<td align=\"left\">341502</td>\n<td align=\"left\">金安区</td>\n</tr>\n<tr>\n<td align=\"left\">341503</td>\n<td align=\"left\">裕安区</td>\n</tr>\n<tr>\n<td align=\"left\">341504</td>\n<td align=\"left\">叶集区</td>\n</tr>\n<tr>\n<td align=\"left\">341522</td>\n<td align=\"left\">霍邱县</td>\n</tr>\n<tr>\n<td align=\"left\">341523</td>\n<td align=\"left\">舒城县</td>\n</tr>\n<tr>\n<td align=\"left\">341524</td>\n<td align=\"left\">金寨县</td>\n</tr>\n<tr>\n<td align=\"left\">341525</td>\n<td align=\"left\">霍山县</td>\n</tr>\n<tr>\n<td align=\"left\">341600</td>\n<td align=\"left\">亳州市</td>\n</tr>\n<tr>\n<td align=\"left\">341602</td>\n<td align=\"left\">谯城区</td>\n</tr>\n<tr>\n<td align=\"left\">341621</td>\n<td align=\"left\">涡阳县</td>\n</tr>\n<tr>\n<td align=\"left\">341622</td>\n<td align=\"left\">蒙城县</td>\n</tr>\n<tr>\n<td align=\"left\">341623</td>\n<td align=\"left\">利辛县</td>\n</tr>\n<tr>\n<td align=\"left\">341700</td>\n<td align=\"left\">池州市</td>\n</tr>\n<tr>\n<td align=\"left\">341702</td>\n<td align=\"left\">贵池区</td>\n</tr>\n<tr>\n<td align=\"left\">341721</td>\n<td align=\"left\">东至县</td>\n</tr>\n<tr>\n<td align=\"left\">341722</td>\n<td align=\"left\">石台县</td>\n</tr>\n<tr>\n<td align=\"left\">341723</td>\n<td align=\"left\">青阳县</td>\n</tr>\n<tr>\n<td align=\"left\">341800</td>\n<td align=\"left\">宣城市</td>\n</tr>\n<tr>\n<td align=\"left\">341802</td>\n<td align=\"left\">宣州区</td>\n</tr>\n<tr>\n<td align=\"left\">341821</td>\n<td align=\"left\">郎溪县</td>\n</tr>\n<tr>\n<td align=\"left\">341823</td>\n<td align=\"left\">泾县</td>\n</tr>\n<tr>\n<td align=\"left\">341824</td>\n<td align=\"left\">绩溪县</td>\n</tr>\n<tr>\n<td align=\"left\">341825</td>\n<td align=\"left\">旌德县</td>\n</tr>\n<tr>\n<td align=\"left\">341881</td>\n<td align=\"left\">宁国市</td>\n</tr>\n<tr>\n<td align=\"left\">341882</td>\n<td align=\"left\">广德市</td>\n</tr>\n<tr>\n<td align=\"left\">350000</td>\n<td align=\"left\">福建省</td>\n</tr>\n<tr>\n<td align=\"left\">350100</td>\n<td align=\"left\">福州市</td>\n</tr>\n<tr>\n<td align=\"left\">350102</td>\n<td align=\"left\">鼓楼区</td>\n</tr>\n<tr>\n<td align=\"left\">350103</td>\n<td align=\"left\">台江区</td>\n</tr>\n<tr>\n<td align=\"left\">350104</td>\n<td align=\"left\">仓山区</td>\n</tr>\n<tr>\n<td align=\"left\">350105</td>\n<td align=\"left\">马尾区</td>\n</tr>\n<tr>\n<td align=\"left\">350111</td>\n<td align=\"left\">晋安区</td>\n</tr>\n<tr>\n<td align=\"left\">350112</td>\n<td align=\"left\">长乐区</td>\n</tr>\n<tr>\n<td align=\"left\">350121</td>\n<td align=\"left\">闽侯县</td>\n</tr>\n<tr>\n<td align=\"left\">350122</td>\n<td align=\"left\">连江县</td>\n</tr>\n<tr>\n<td align=\"left\">350123</td>\n<td align=\"left\">罗源县</td>\n</tr>\n<tr>\n<td align=\"left\">350124</td>\n<td align=\"left\">闽清县</td>\n</tr>\n<tr>\n<td align=\"left\">350125</td>\n<td align=\"left\">永泰县</td>\n</tr>\n<tr>\n<td align=\"left\">350128</td>\n<td align=\"left\">平潭县</td>\n</tr>\n<tr>\n<td align=\"left\">350181</td>\n<td align=\"left\">福清市</td>\n</tr>\n<tr>\n<td align=\"left\">350200</td>\n<td align=\"left\">厦门市</td>\n</tr>\n<tr>\n<td align=\"left\">350203</td>\n<td align=\"left\">思明区</td>\n</tr>\n<tr>\n<td align=\"left\">350205</td>\n<td align=\"left\">海沧区</td>\n</tr>\n<tr>\n<td align=\"left\">350206</td>\n<td align=\"left\">湖里区</td>\n</tr>\n<tr>\n<td align=\"left\">350211</td>\n<td align=\"left\">集美区</td>\n</tr>\n<tr>\n<td align=\"left\">350212</td>\n<td align=\"left\">同安区</td>\n</tr>\n<tr>\n<td align=\"left\">350213</td>\n<td align=\"left\">翔安区</td>\n</tr>\n<tr>\n<td align=\"left\">350300</td>\n<td align=\"left\">莆田市</td>\n</tr>\n<tr>\n<td align=\"left\">350302</td>\n<td align=\"left\">城厢区</td>\n</tr>\n<tr>\n<td align=\"left\">350303</td>\n<td align=\"left\">涵江区</td>\n</tr>\n<tr>\n<td align=\"left\">350304</td>\n<td align=\"left\">荔城区</td>\n</tr>\n<tr>\n<td align=\"left\">350305</td>\n<td align=\"left\">秀屿区</td>\n</tr>\n<tr>\n<td align=\"left\">350322</td>\n<td align=\"left\">仙游县</td>\n</tr>\n<tr>\n<td align=\"left\">350400</td>\n<td align=\"left\">三明市</td>\n</tr>\n<tr>\n<td align=\"left\">350402</td>\n<td align=\"left\">梅列区</td>\n</tr>\n<tr>\n<td align=\"left\">350403</td>\n<td align=\"left\">三元区</td>\n</tr>\n<tr>\n<td align=\"left\">350421</td>\n<td align=\"left\">明溪县</td>\n</tr>\n<tr>\n<td align=\"left\">350423</td>\n<td align=\"left\">清流县</td>\n</tr>\n<tr>\n<td align=\"left\">350424</td>\n<td align=\"left\">宁化县</td>\n</tr>\n<tr>\n<td align=\"left\">350425</td>\n<td align=\"left\">大田县</td>\n</tr>\n<tr>\n<td align=\"left\">350426</td>\n<td align=\"left\">尤溪县</td>\n</tr>\n<tr>\n<td align=\"left\">350427</td>\n<td align=\"left\">沙县</td>\n</tr>\n<tr>\n<td align=\"left\">350428</td>\n<td align=\"left\">将乐县</td>\n</tr>\n<tr>\n<td align=\"left\">350429</td>\n<td align=\"left\">泰宁县</td>\n</tr>\n<tr>\n<td align=\"left\">350430</td>\n<td align=\"left\">建宁县</td>\n</tr>\n<tr>\n<td align=\"left\">350481</td>\n<td align=\"left\">永安市</td>\n</tr>\n<tr>\n<td align=\"left\">350500</td>\n<td align=\"left\">泉州市</td>\n</tr>\n<tr>\n<td align=\"left\">350502</td>\n<td align=\"left\">鲤城区</td>\n</tr>\n<tr>\n<td align=\"left\">350503</td>\n<td align=\"left\">丰泽区</td>\n</tr>\n<tr>\n<td align=\"left\">350504</td>\n<td align=\"left\">洛江区</td>\n</tr>\n<tr>\n<td align=\"left\">350505</td>\n<td align=\"left\">泉港区</td>\n</tr>\n<tr>\n<td align=\"left\">350521</td>\n<td align=\"left\">惠安县</td>\n</tr>\n<tr>\n<td align=\"left\">350524</td>\n<td align=\"left\">安溪县</td>\n</tr>\n<tr>\n<td align=\"left\">350525</td>\n<td align=\"left\">永春县</td>\n</tr>\n<tr>\n<td align=\"left\">350526</td>\n<td align=\"left\">德化县</td>\n</tr>\n<tr>\n<td align=\"left\">350527</td>\n<td align=\"left\">金门县</td>\n</tr>\n<tr>\n<td align=\"left\">350581</td>\n<td align=\"left\">石狮市</td>\n</tr>\n<tr>\n<td align=\"left\">350582</td>\n<td align=\"left\">晋江市</td>\n</tr>\n<tr>\n<td align=\"left\">350583</td>\n<td align=\"left\">南安市</td>\n</tr>\n<tr>\n<td align=\"left\">350600</td>\n<td align=\"left\">漳州市</td>\n</tr>\n<tr>\n<td align=\"left\">350602</td>\n<td align=\"left\">芗城区</td>\n</tr>\n<tr>\n<td align=\"left\">350603</td>\n<td align=\"left\">龙文区</td>\n</tr>\n<tr>\n<td align=\"left\">350622</td>\n<td align=\"left\">云霄县</td>\n</tr>\n<tr>\n<td align=\"left\">350623</td>\n<td align=\"left\">漳浦县</td>\n</tr>\n<tr>\n<td align=\"left\">350624</td>\n<td align=\"left\">诏安县</td>\n</tr>\n<tr>\n<td align=\"left\">350625</td>\n<td align=\"left\">长泰县</td>\n</tr>\n<tr>\n<td align=\"left\">350626</td>\n<td align=\"left\">东山县</td>\n</tr>\n<tr>\n<td align=\"left\">350627</td>\n<td align=\"left\">南靖县</td>\n</tr>\n<tr>\n<td align=\"left\">350628</td>\n<td align=\"left\">平和县</td>\n</tr>\n<tr>\n<td align=\"left\">350629</td>\n<td align=\"left\">华安县</td>\n</tr>\n<tr>\n<td align=\"left\">350681</td>\n<td align=\"left\">龙海市</td>\n</tr>\n<tr>\n<td align=\"left\">350700</td>\n<td align=\"left\">南平市</td>\n</tr>\n<tr>\n<td align=\"left\">350702</td>\n<td align=\"left\">延平区</td>\n</tr>\n<tr>\n<td align=\"left\">350703</td>\n<td align=\"left\">建阳区</td>\n</tr>\n<tr>\n<td align=\"left\">350721</td>\n<td align=\"left\">顺昌县</td>\n</tr>\n<tr>\n<td align=\"left\">350722</td>\n<td align=\"left\">浦城县</td>\n</tr>\n<tr>\n<td align=\"left\">350723</td>\n<td align=\"left\">光泽县</td>\n</tr>\n<tr>\n<td align=\"left\">350724</td>\n<td align=\"left\">松溪县</td>\n</tr>\n<tr>\n<td align=\"left\">350725</td>\n<td align=\"left\">政和县</td>\n</tr>\n<tr>\n<td align=\"left\">350781</td>\n<td align=\"left\">邵武市</td>\n</tr>\n<tr>\n<td align=\"left\">350782</td>\n<td align=\"left\">武夷山市</td>\n</tr>\n<tr>\n<td align=\"left\">350783</td>\n<td align=\"left\">建瓯市</td>\n</tr>\n<tr>\n<td align=\"left\">350800</td>\n<td align=\"left\">龙岩市</td>\n</tr>\n<tr>\n<td align=\"left\">350802</td>\n<td align=\"left\">新罗区</td>\n</tr>\n<tr>\n<td align=\"left\">350803</td>\n<td align=\"left\">永定区</td>\n</tr>\n<tr>\n<td align=\"left\">350821</td>\n<td align=\"left\">长汀县</td>\n</tr>\n<tr>\n<td align=\"left\">350823</td>\n<td align=\"left\">上杭县</td>\n</tr>\n<tr>\n<td align=\"left\">350824</td>\n<td align=\"left\">武平县</td>\n</tr>\n<tr>\n<td align=\"left\">350825</td>\n<td align=\"left\">连城县</td>\n</tr>\n<tr>\n<td align=\"left\">350881</td>\n<td align=\"left\">漳平市</td>\n</tr>\n<tr>\n<td align=\"left\">350900</td>\n<td align=\"left\">宁德市</td>\n</tr>\n<tr>\n<td align=\"left\">350902</td>\n<td align=\"left\">蕉城区</td>\n</tr>\n<tr>\n<td align=\"left\">350921</td>\n<td align=\"left\">霞浦县</td>\n</tr>\n<tr>\n<td align=\"left\">350922</td>\n<td align=\"left\">古田县</td>\n</tr>\n<tr>\n<td align=\"left\">350923</td>\n<td align=\"left\">屏南县</td>\n</tr>\n<tr>\n<td align=\"left\">350924</td>\n<td align=\"left\">寿宁县</td>\n</tr>\n<tr>\n<td align=\"left\">350925</td>\n<td align=\"left\">周宁县</td>\n</tr>\n<tr>\n<td align=\"left\">350926</td>\n<td align=\"left\">柘荣县</td>\n</tr>\n<tr>\n<td align=\"left\">350981</td>\n<td align=\"left\">福安市</td>\n</tr>\n<tr>\n<td align=\"left\">350982</td>\n<td align=\"left\">福鼎市</td>\n</tr>\n<tr>\n<td align=\"left\">360000</td>\n<td align=\"left\">江西省</td>\n</tr>\n<tr>\n<td align=\"left\">360100</td>\n<td align=\"left\">南昌市</td>\n</tr>\n<tr>\n<td align=\"left\">360102</td>\n<td align=\"left\">东湖区</td>\n</tr>\n<tr>\n<td align=\"left\">360103</td>\n<td align=\"left\">西湖区</td>\n</tr>\n<tr>\n<td align=\"left\">360104</td>\n<td align=\"left\">青云谱区</td>\n</tr>\n<tr>\n<td align=\"left\">360111</td>\n<td align=\"left\">青山湖区</td>\n</tr>\n<tr>\n<td align=\"left\">360112</td>\n<td align=\"left\">新建区</td>\n</tr>\n<tr>\n<td align=\"left\">360113</td>\n<td align=\"left\">红谷滩区</td>\n</tr>\n<tr>\n<td align=\"left\">360121</td>\n<td align=\"left\">南昌县</td>\n</tr>\n<tr>\n<td align=\"left\">360123</td>\n<td align=\"left\">安义县</td>\n</tr>\n<tr>\n<td align=\"left\">360124</td>\n<td align=\"left\">进贤县</td>\n</tr>\n<tr>\n<td align=\"left\">360200</td>\n<td align=\"left\">景德镇市</td>\n</tr>\n<tr>\n<td align=\"left\">360202</td>\n<td align=\"left\">昌江区</td>\n</tr>\n<tr>\n<td align=\"left\">360203</td>\n<td align=\"left\">珠山区</td>\n</tr>\n<tr>\n<td align=\"left\">360222</td>\n<td align=\"left\">浮梁县</td>\n</tr>\n<tr>\n<td align=\"left\">360281</td>\n<td align=\"left\">乐平市</td>\n</tr>\n<tr>\n<td align=\"left\">360300</td>\n<td align=\"left\">萍乡市</td>\n</tr>\n<tr>\n<td align=\"left\">360302</td>\n<td align=\"left\">安源区</td>\n</tr>\n<tr>\n<td align=\"left\">360313</td>\n<td align=\"left\">湘东区</td>\n</tr>\n<tr>\n<td align=\"left\">360321</td>\n<td align=\"left\">莲花县</td>\n</tr>\n<tr>\n<td align=\"left\">360322</td>\n<td align=\"left\">上栗县</td>\n</tr>\n<tr>\n<td align=\"left\">360323</td>\n<td align=\"left\">芦溪县</td>\n</tr>\n<tr>\n<td align=\"left\">360400</td>\n<td align=\"left\">九江市</td>\n</tr>\n<tr>\n<td align=\"left\">360402</td>\n<td align=\"left\">濂溪区</td>\n</tr>\n<tr>\n<td align=\"left\">360403</td>\n<td align=\"left\">浔阳区</td>\n</tr>\n<tr>\n<td align=\"left\">360404</td>\n<td align=\"left\">柴桑区</td>\n</tr>\n<tr>\n<td align=\"left\">360423</td>\n<td align=\"left\">武宁县</td>\n</tr>\n<tr>\n<td align=\"left\">360424</td>\n<td align=\"left\">修水县</td>\n</tr>\n<tr>\n<td align=\"left\">360425</td>\n<td align=\"left\">永修县</td>\n</tr>\n<tr>\n<td align=\"left\">360426</td>\n<td align=\"left\">德安县</td>\n</tr>\n<tr>\n<td align=\"left\">360428</td>\n<td align=\"left\">都昌县</td>\n</tr>\n<tr>\n<td align=\"left\">360429</td>\n<td align=\"left\">湖口县</td>\n</tr>\n<tr>\n<td align=\"left\">360430</td>\n<td align=\"left\">彭泽县</td>\n</tr>\n<tr>\n<td align=\"left\">360481</td>\n<td align=\"left\">瑞昌市</td>\n</tr>\n<tr>\n<td align=\"left\">360482</td>\n<td align=\"left\">共青城市</td>\n</tr>\n<tr>\n<td align=\"left\">360483</td>\n<td align=\"left\">庐山市</td>\n</tr>\n<tr>\n<td align=\"left\">360500</td>\n<td align=\"left\">新余市</td>\n</tr>\n<tr>\n<td align=\"left\">360502</td>\n<td align=\"left\">渝水区</td>\n</tr>\n<tr>\n<td align=\"left\">360521</td>\n<td align=\"left\">分宜县</td>\n</tr>\n<tr>\n<td align=\"left\">360600</td>\n<td align=\"left\">鹰潭市</td>\n</tr>\n<tr>\n<td align=\"left\">360602</td>\n<td align=\"left\">月湖区</td>\n</tr>\n<tr>\n<td align=\"left\">360603</td>\n<td align=\"left\">余江区</td>\n</tr>\n<tr>\n<td align=\"left\">360681</td>\n<td align=\"left\">贵溪市</td>\n</tr>\n<tr>\n<td align=\"left\">360700</td>\n<td align=\"left\">赣州市</td>\n</tr>\n<tr>\n<td align=\"left\">360702</td>\n<td align=\"left\">章贡区</td>\n</tr>\n<tr>\n<td align=\"left\">360703</td>\n<td align=\"left\">南康区</td>\n</tr>\n<tr>\n<td align=\"left\">360704</td>\n<td align=\"left\">赣县区</td>\n</tr>\n<tr>\n<td align=\"left\">360722</td>\n<td align=\"left\">信丰县</td>\n</tr>\n<tr>\n<td align=\"left\">360723</td>\n<td align=\"left\">大余县</td>\n</tr>\n<tr>\n<td align=\"left\">360724</td>\n<td align=\"left\">上犹县</td>\n</tr>\n<tr>\n<td align=\"left\">360725</td>\n<td align=\"left\">崇义县</td>\n</tr>\n<tr>\n<td align=\"left\">360726</td>\n<td align=\"left\">安远县</td>\n</tr>\n<tr>\n<td align=\"left\">360727</td>\n<td align=\"left\">龙南县</td>\n</tr>\n<tr>\n<td align=\"left\">360728</td>\n<td align=\"left\">定南县</td>\n</tr>\n<tr>\n<td align=\"left\">360729</td>\n<td align=\"left\">全南县</td>\n</tr>\n<tr>\n<td align=\"left\">360730</td>\n<td align=\"left\">宁都县</td>\n</tr>\n<tr>\n<td align=\"left\">360731</td>\n<td align=\"left\">于都县</td>\n</tr>\n<tr>\n<td align=\"left\">360732</td>\n<td align=\"left\">兴国县</td>\n</tr>\n<tr>\n<td align=\"left\">360733</td>\n<td align=\"left\">会昌县</td>\n</tr>\n<tr>\n<td align=\"left\">360734</td>\n<td align=\"left\">寻乌县</td>\n</tr>\n<tr>\n<td align=\"left\">360735</td>\n<td align=\"left\">石城县</td>\n</tr>\n<tr>\n<td align=\"left\">360781</td>\n<td align=\"left\">瑞金市</td>\n</tr>\n<tr>\n<td align=\"left\">360800</td>\n<td align=\"left\">吉安市</td>\n</tr>\n<tr>\n<td align=\"left\">360802</td>\n<td align=\"left\">吉州区</td>\n</tr>\n<tr>\n<td align=\"left\">360803</td>\n<td align=\"left\">青原区</td>\n</tr>\n<tr>\n<td align=\"left\">360821</td>\n<td align=\"left\">吉安县</td>\n</tr>\n<tr>\n<td align=\"left\">360822</td>\n<td align=\"left\">吉水县</td>\n</tr>\n<tr>\n<td align=\"left\">360823</td>\n<td align=\"left\">峡江县</td>\n</tr>\n<tr>\n<td align=\"left\">360824</td>\n<td align=\"left\">新干县</td>\n</tr>\n<tr>\n<td align=\"left\">360825</td>\n<td align=\"left\">永丰县</td>\n</tr>\n<tr>\n<td align=\"left\">360826</td>\n<td align=\"left\">泰和县</td>\n</tr>\n<tr>\n<td align=\"left\">360827</td>\n<td align=\"left\">遂川县</td>\n</tr>\n<tr>\n<td align=\"left\">360828</td>\n<td align=\"left\">万安县</td>\n</tr>\n<tr>\n<td align=\"left\">360829</td>\n<td align=\"left\">安福县</td>\n</tr>\n<tr>\n<td align=\"left\">360830</td>\n<td align=\"left\">永新县</td>\n</tr>\n<tr>\n<td align=\"left\">360881</td>\n<td align=\"left\">井冈山市</td>\n</tr>\n<tr>\n<td align=\"left\">360900</td>\n<td align=\"left\">宜春市</td>\n</tr>\n<tr>\n<td align=\"left\">360902</td>\n<td align=\"left\">袁州区</td>\n</tr>\n<tr>\n<td align=\"left\">360921</td>\n<td align=\"left\">奉新县</td>\n</tr>\n<tr>\n<td align=\"left\">360922</td>\n<td align=\"left\">万载县</td>\n</tr>\n<tr>\n<td align=\"left\">360923</td>\n<td align=\"left\">上高县</td>\n</tr>\n<tr>\n<td align=\"left\">360924</td>\n<td align=\"left\">宜丰县</td>\n</tr>\n<tr>\n<td align=\"left\">360925</td>\n<td align=\"left\">靖安县</td>\n</tr>\n<tr>\n<td align=\"left\">360926</td>\n<td align=\"left\">铜鼓县</td>\n</tr>\n<tr>\n<td align=\"left\">360981</td>\n<td align=\"left\">丰城市</td>\n</tr>\n<tr>\n<td align=\"left\">360982</td>\n<td align=\"left\">樟树市</td>\n</tr>\n<tr>\n<td align=\"left\">360983</td>\n<td align=\"left\">高安市</td>\n</tr>\n<tr>\n<td align=\"left\">361000</td>\n<td align=\"left\">抚州市</td>\n</tr>\n<tr>\n<td align=\"left\">361002</td>\n<td align=\"left\">临川区</td>\n</tr>\n<tr>\n<td align=\"left\">361003</td>\n<td align=\"left\">东乡区</td>\n</tr>\n<tr>\n<td align=\"left\">361021</td>\n<td align=\"left\">南城县</td>\n</tr>\n<tr>\n<td align=\"left\">361022</td>\n<td align=\"left\">黎川县</td>\n</tr>\n<tr>\n<td align=\"left\">361023</td>\n<td align=\"left\">南丰县</td>\n</tr>\n<tr>\n<td align=\"left\">361024</td>\n<td align=\"left\">崇仁县</td>\n</tr>\n<tr>\n<td align=\"left\">361025</td>\n<td align=\"left\">乐安县</td>\n</tr>\n<tr>\n<td align=\"left\">361026</td>\n<td align=\"left\">宜黄县</td>\n</tr>\n<tr>\n<td align=\"left\">361027</td>\n<td align=\"left\">金溪县</td>\n</tr>\n<tr>\n<td align=\"left\">361028</td>\n<td align=\"left\">资溪县</td>\n</tr>\n<tr>\n<td align=\"left\">361030</td>\n<td align=\"left\">广昌县</td>\n</tr>\n<tr>\n<td align=\"left\">361100</td>\n<td align=\"left\">上饶市</td>\n</tr>\n<tr>\n<td align=\"left\">361102</td>\n<td align=\"left\">信州区</td>\n</tr>\n<tr>\n<td align=\"left\">361103</td>\n<td align=\"left\">广丰区</td>\n</tr>\n<tr>\n<td align=\"left\">361104</td>\n<td align=\"left\">广信区</td>\n</tr>\n<tr>\n<td align=\"left\">361123</td>\n<td align=\"left\">玉山县</td>\n</tr>\n<tr>\n<td align=\"left\">361124</td>\n<td align=\"left\">铅山县</td>\n</tr>\n<tr>\n<td align=\"left\">361125</td>\n<td align=\"left\">横峰县</td>\n</tr>\n<tr>\n<td align=\"left\">361126</td>\n<td align=\"left\">弋阳县</td>\n</tr>\n<tr>\n<td align=\"left\">361127</td>\n<td align=\"left\">余干县</td>\n</tr>\n<tr>\n<td align=\"left\">361128</td>\n<td align=\"left\">鄱阳县</td>\n</tr>\n<tr>\n<td align=\"left\">361129</td>\n<td align=\"left\">万年县</td>\n</tr>\n<tr>\n<td align=\"left\">361130</td>\n<td align=\"left\">婺源县</td>\n</tr>\n<tr>\n<td align=\"left\">361181</td>\n<td align=\"left\">德兴市</td>\n</tr>\n<tr>\n<td align=\"left\">370000</td>\n<td align=\"left\">山东省</td>\n</tr>\n<tr>\n<td align=\"left\">370100</td>\n<td align=\"left\">济南市</td>\n</tr>\n<tr>\n<td align=\"left\">370102</td>\n<td align=\"left\">历下区</td>\n</tr>\n<tr>\n<td align=\"left\">370103</td>\n<td align=\"left\">市中区</td>\n</tr>\n<tr>\n<td align=\"left\">370104</td>\n<td align=\"left\">槐荫区</td>\n</tr>\n<tr>\n<td align=\"left\">370105</td>\n<td align=\"left\">天桥区</td>\n</tr>\n<tr>\n<td align=\"left\">370112</td>\n<td align=\"left\">历城区</td>\n</tr>\n<tr>\n<td align=\"left\">370113</td>\n<td align=\"left\">长清区</td>\n</tr>\n<tr>\n<td align=\"left\">370114</td>\n<td align=\"left\">章丘区</td>\n</tr>\n<tr>\n<td align=\"left\">370115</td>\n<td align=\"left\">济阳区</td>\n</tr>\n<tr>\n<td align=\"left\">370116</td>\n<td align=\"left\">莱芜区</td>\n</tr>\n<tr>\n<td align=\"left\">370117</td>\n<td align=\"left\">钢城区</td>\n</tr>\n<tr>\n<td align=\"left\">370124</td>\n<td align=\"left\">平阴县</td>\n</tr>\n<tr>\n<td align=\"left\">370126</td>\n<td align=\"left\">商河县</td>\n</tr>\n<tr>\n<td align=\"left\">370200</td>\n<td align=\"left\">青岛市</td>\n</tr>\n<tr>\n<td align=\"left\">370202</td>\n<td align=\"left\">市南区</td>\n</tr>\n<tr>\n<td align=\"left\">370203</td>\n<td align=\"left\">市北区</td>\n</tr>\n<tr>\n<td align=\"left\">370211</td>\n<td align=\"left\">黄岛区</td>\n</tr>\n<tr>\n<td align=\"left\">370212</td>\n<td align=\"left\">崂山区</td>\n</tr>\n<tr>\n<td align=\"left\">370213</td>\n<td align=\"left\">李沧区</td>\n</tr>\n<tr>\n<td align=\"left\">370214</td>\n<td align=\"left\">城阳区</td>\n</tr>\n<tr>\n<td align=\"left\">370215</td>\n<td align=\"left\">即墨区</td>\n</tr>\n<tr>\n<td align=\"left\">370281</td>\n<td align=\"left\">胶州市</td>\n</tr>\n<tr>\n<td align=\"left\">370283</td>\n<td align=\"left\">平度市</td>\n</tr>\n<tr>\n<td align=\"left\">370285</td>\n<td align=\"left\">莱西市</td>\n</tr>\n<tr>\n<td align=\"left\">370300</td>\n<td align=\"left\">淄博市</td>\n</tr>\n<tr>\n<td align=\"left\">370302</td>\n<td align=\"left\">淄川区</td>\n</tr>\n<tr>\n<td align=\"left\">370303</td>\n<td align=\"left\">张店区</td>\n</tr>\n<tr>\n<td align=\"left\">370304</td>\n<td align=\"left\">博山区</td>\n</tr>\n<tr>\n<td align=\"left\">370305</td>\n<td align=\"left\">临淄区</td>\n</tr>\n<tr>\n<td align=\"left\">370306</td>\n<td align=\"left\">周村区</td>\n</tr>\n<tr>\n<td align=\"left\">370321</td>\n<td align=\"left\">桓台县</td>\n</tr>\n<tr>\n<td align=\"left\">370322</td>\n<td align=\"left\">高青县</td>\n</tr>\n<tr>\n<td align=\"left\">370323</td>\n<td align=\"left\">沂源县</td>\n</tr>\n<tr>\n<td align=\"left\">370400</td>\n<td align=\"left\">枣庄市</td>\n</tr>\n<tr>\n<td align=\"left\">370402</td>\n<td align=\"left\">市中区</td>\n</tr>\n<tr>\n<td align=\"left\">370403</td>\n<td align=\"left\">薛城区</td>\n</tr>\n<tr>\n<td align=\"left\">370404</td>\n<td align=\"left\">峄城区</td>\n</tr>\n<tr>\n<td align=\"left\">370405</td>\n<td align=\"left\">台儿庄区</td>\n</tr>\n<tr>\n<td align=\"left\">370406</td>\n<td align=\"left\">山亭区</td>\n</tr>\n<tr>\n<td align=\"left\">370481</td>\n<td align=\"left\">滕州市</td>\n</tr>\n<tr>\n<td align=\"left\">370500</td>\n<td align=\"left\">东营市</td>\n</tr>\n<tr>\n<td align=\"left\">370502</td>\n<td align=\"left\">东营区</td>\n</tr>\n<tr>\n<td align=\"left\">370503</td>\n<td align=\"left\">河口区</td>\n</tr>\n<tr>\n<td align=\"left\">370505</td>\n<td align=\"left\">垦利区</td>\n</tr>\n<tr>\n<td align=\"left\">370522</td>\n<td align=\"left\">利津县</td>\n</tr>\n<tr>\n<td align=\"left\">370523</td>\n<td align=\"left\">广饶县</td>\n</tr>\n<tr>\n<td align=\"left\">370600</td>\n<td align=\"left\">烟台市</td>\n</tr>\n<tr>\n<td align=\"left\">370602</td>\n<td align=\"left\">芝罘区</td>\n</tr>\n<tr>\n<td align=\"left\">370611</td>\n<td align=\"left\">福山区</td>\n</tr>\n<tr>\n<td align=\"left\">370612</td>\n<td align=\"left\">牟平区</td>\n</tr>\n<tr>\n<td align=\"left\">370613</td>\n<td align=\"left\">莱山区</td>\n</tr>\n<tr>\n<td align=\"left\">370634</td>\n<td align=\"left\">长岛县</td>\n</tr>\n<tr>\n<td align=\"left\">370681</td>\n<td align=\"left\">龙口市</td>\n</tr>\n<tr>\n<td align=\"left\">370682</td>\n<td align=\"left\">莱阳市</td>\n</tr>\n<tr>\n<td align=\"left\">370683</td>\n<td align=\"left\">莱州市</td>\n</tr>\n<tr>\n<td align=\"left\">370684</td>\n<td align=\"left\">蓬莱市</td>\n</tr>\n<tr>\n<td align=\"left\">370685</td>\n<td align=\"left\">招远市</td>\n</tr>\n<tr>\n<td align=\"left\">370686</td>\n<td align=\"left\">栖霞市</td>\n</tr>\n<tr>\n<td align=\"left\">370687</td>\n<td align=\"left\">海阳市</td>\n</tr>\n<tr>\n<td align=\"left\">370700</td>\n<td align=\"left\">潍坊市</td>\n</tr>\n<tr>\n<td align=\"left\">370702</td>\n<td align=\"left\">潍城区</td>\n</tr>\n<tr>\n<td align=\"left\">370703</td>\n<td align=\"left\">寒亭区</td>\n</tr>\n<tr>\n<td align=\"left\">370704</td>\n<td align=\"left\">坊子区</td>\n</tr>\n<tr>\n<td align=\"left\">370705</td>\n<td align=\"left\">奎文区</td>\n</tr>\n<tr>\n<td align=\"left\">370724</td>\n<td align=\"left\">临朐县</td>\n</tr>\n<tr>\n<td align=\"left\">370725</td>\n<td align=\"left\">昌乐县</td>\n</tr>\n<tr>\n<td align=\"left\">370781</td>\n<td align=\"left\">青州市</td>\n</tr>\n<tr>\n<td align=\"left\">370782</td>\n<td align=\"left\">诸城市</td>\n</tr>\n<tr>\n<td align=\"left\">370783</td>\n<td align=\"left\">寿光市</td>\n</tr>\n<tr>\n<td align=\"left\">370784</td>\n<td align=\"left\">安丘市</td>\n</tr>\n<tr>\n<td align=\"left\">370785</td>\n<td align=\"left\">高密市</td>\n</tr>\n<tr>\n<td align=\"left\">370786</td>\n<td align=\"left\">昌邑市</td>\n</tr>\n<tr>\n<td align=\"left\">370800</td>\n<td align=\"left\">济宁市</td>\n</tr>\n<tr>\n<td align=\"left\">370811</td>\n<td align=\"left\">任城区</td>\n</tr>\n<tr>\n<td align=\"left\">370812</td>\n<td align=\"left\">兖州区</td>\n</tr>\n<tr>\n<td align=\"left\">370826</td>\n<td align=\"left\">微山县</td>\n</tr>\n<tr>\n<td align=\"left\">370827</td>\n<td align=\"left\">鱼台县</td>\n</tr>\n<tr>\n<td align=\"left\">370828</td>\n<td align=\"left\">金乡县</td>\n</tr>\n<tr>\n<td align=\"left\">370829</td>\n<td align=\"left\">嘉祥县</td>\n</tr>\n<tr>\n<td align=\"left\">370830</td>\n<td align=\"left\">汶上县</td>\n</tr>\n<tr>\n<td align=\"left\">370831</td>\n<td align=\"left\">泗水县</td>\n</tr>\n<tr>\n<td align=\"left\">370832</td>\n<td align=\"left\">梁山县</td>\n</tr>\n<tr>\n<td align=\"left\">370881</td>\n<td align=\"left\">曲阜市</td>\n</tr>\n<tr>\n<td align=\"left\">370883</td>\n<td align=\"left\">邹城市</td>\n</tr>\n<tr>\n<td align=\"left\">370900</td>\n<td align=\"left\">泰安市</td>\n</tr>\n<tr>\n<td align=\"left\">370902</td>\n<td align=\"left\">泰山区</td>\n</tr>\n<tr>\n<td align=\"left\">370911</td>\n<td align=\"left\">岱岳区</td>\n</tr>\n<tr>\n<td align=\"left\">370921</td>\n<td align=\"left\">宁阳县</td>\n</tr>\n<tr>\n<td align=\"left\">370923</td>\n<td align=\"left\">东平县</td>\n</tr>\n<tr>\n<td align=\"left\">370982</td>\n<td align=\"left\">新泰市</td>\n</tr>\n<tr>\n<td align=\"left\">370983</td>\n<td align=\"left\">肥城市</td>\n</tr>\n<tr>\n<td align=\"left\">371000</td>\n<td align=\"left\">威海市</td>\n</tr>\n<tr>\n<td align=\"left\">371002</td>\n<td align=\"left\">环翠区</td>\n</tr>\n<tr>\n<td align=\"left\">371003</td>\n<td align=\"left\">文登区</td>\n</tr>\n<tr>\n<td align=\"left\">371082</td>\n<td align=\"left\">荣成市</td>\n</tr>\n<tr>\n<td align=\"left\">371083</td>\n<td align=\"left\">乳山市</td>\n</tr>\n<tr>\n<td align=\"left\">371100</td>\n<td align=\"left\">日照市</td>\n</tr>\n<tr>\n<td align=\"left\">371102</td>\n<td align=\"left\">东港区</td>\n</tr>\n<tr>\n<td align=\"left\">371103</td>\n<td align=\"left\">岚山区</td>\n</tr>\n<tr>\n<td align=\"left\">371121</td>\n<td align=\"left\">五莲县</td>\n</tr>\n<tr>\n<td align=\"left\">371122</td>\n<td align=\"left\">莒县</td>\n</tr>\n<tr>\n<td align=\"left\">371300</td>\n<td align=\"left\">临沂市</td>\n</tr>\n<tr>\n<td align=\"left\">371302</td>\n<td align=\"left\">兰山区</td>\n</tr>\n<tr>\n<td align=\"left\">371311</td>\n<td align=\"left\">罗庄区</td>\n</tr>\n<tr>\n<td align=\"left\">371312</td>\n<td align=\"left\">河东区</td>\n</tr>\n<tr>\n<td align=\"left\">371321</td>\n<td align=\"left\">沂南县</td>\n</tr>\n<tr>\n<td align=\"left\">371322</td>\n<td align=\"left\">郯城县</td>\n</tr>\n<tr>\n<td align=\"left\">371323</td>\n<td align=\"left\">沂水县</td>\n</tr>\n<tr>\n<td align=\"left\">371324</td>\n<td align=\"left\">兰陵县</td>\n</tr>\n<tr>\n<td align=\"left\">371325</td>\n<td align=\"left\">费县</td>\n</tr>\n<tr>\n<td align=\"left\">371326</td>\n<td align=\"left\">平邑县</td>\n</tr>\n<tr>\n<td align=\"left\">371327</td>\n<td align=\"left\">莒南县</td>\n</tr>\n<tr>\n<td align=\"left\">371328</td>\n<td align=\"left\">蒙阴县</td>\n</tr>\n<tr>\n<td align=\"left\">371329</td>\n<td align=\"left\">临沭县</td>\n</tr>\n<tr>\n<td align=\"left\">371400</td>\n<td align=\"left\">德州市</td>\n</tr>\n<tr>\n<td align=\"left\">371402</td>\n<td align=\"left\">德城区</td>\n</tr>\n<tr>\n<td align=\"left\">371403</td>\n<td align=\"left\">陵城区</td>\n</tr>\n<tr>\n<td align=\"left\">371422</td>\n<td align=\"left\">宁津县</td>\n</tr>\n<tr>\n<td align=\"left\">371423</td>\n<td align=\"left\">庆云县</td>\n</tr>\n<tr>\n<td align=\"left\">371424</td>\n<td align=\"left\">临邑县</td>\n</tr>\n<tr>\n<td align=\"left\">371425</td>\n<td align=\"left\">齐河县</td>\n</tr>\n<tr>\n<td align=\"left\">371426</td>\n<td align=\"left\">平原县</td>\n</tr>\n<tr>\n<td align=\"left\">371427</td>\n<td align=\"left\">夏津县</td>\n</tr>\n<tr>\n<td align=\"left\">371428</td>\n<td align=\"left\">武城县</td>\n</tr>\n<tr>\n<td align=\"left\">371481</td>\n<td align=\"left\">乐陵市</td>\n</tr>\n<tr>\n<td align=\"left\">371482</td>\n<td align=\"left\">禹城市</td>\n</tr>\n<tr>\n<td align=\"left\">371500</td>\n<td align=\"left\">聊城市</td>\n</tr>\n<tr>\n<td align=\"left\">371502</td>\n<td align=\"left\">东昌府区</td>\n</tr>\n<tr>\n<td align=\"left\">371503</td>\n<td align=\"left\">茌平区</td>\n</tr>\n<tr>\n<td align=\"left\">371521</td>\n<td align=\"left\">阳谷县</td>\n</tr>\n<tr>\n<td align=\"left\">371522</td>\n<td align=\"left\">莘县</td>\n</tr>\n<tr>\n<td align=\"left\">371524</td>\n<td align=\"left\">东阿县</td>\n</tr>\n<tr>\n<td align=\"left\">371525</td>\n<td align=\"left\">冠县</td>\n</tr>\n<tr>\n<td align=\"left\">371526</td>\n<td align=\"left\">高唐县</td>\n</tr>\n<tr>\n<td align=\"left\">371581</td>\n<td align=\"left\">临清市</td>\n</tr>\n<tr>\n<td align=\"left\">371600</td>\n<td align=\"left\">滨州市</td>\n</tr>\n<tr>\n<td align=\"left\">371602</td>\n<td align=\"left\">滨城区</td>\n</tr>\n<tr>\n<td align=\"left\">371603</td>\n<td align=\"left\">沾化区</td>\n</tr>\n<tr>\n<td align=\"left\">371621</td>\n<td align=\"left\">惠民县</td>\n</tr>\n<tr>\n<td align=\"left\">371622</td>\n<td align=\"left\">阳信县</td>\n</tr>\n<tr>\n<td align=\"left\">371623</td>\n<td align=\"left\">无棣县</td>\n</tr>\n<tr>\n<td align=\"left\">371625</td>\n<td align=\"left\">博兴县</td>\n</tr>\n<tr>\n<td align=\"left\">371681</td>\n<td align=\"left\">邹平市</td>\n</tr>\n<tr>\n<td align=\"left\">371700</td>\n<td align=\"left\">菏泽市</td>\n</tr>\n<tr>\n<td align=\"left\">371702</td>\n<td align=\"left\">牡丹区</td>\n</tr>\n<tr>\n<td align=\"left\">371703</td>\n<td align=\"left\">定陶区</td>\n</tr>\n<tr>\n<td align=\"left\">371721</td>\n<td align=\"left\">曹县</td>\n</tr>\n<tr>\n<td align=\"left\">371722</td>\n<td align=\"left\">单县</td>\n</tr>\n<tr>\n<td align=\"left\">371723</td>\n<td align=\"left\">成武县</td>\n</tr>\n<tr>\n<td align=\"left\">371724</td>\n<td align=\"left\">巨野县</td>\n</tr>\n<tr>\n<td align=\"left\">371725</td>\n<td align=\"left\">郓城县</td>\n</tr>\n<tr>\n<td align=\"left\">371726</td>\n<td align=\"left\">鄄城县</td>\n</tr>\n<tr>\n<td align=\"left\">371728</td>\n<td align=\"left\">东明县</td>\n</tr>\n<tr>\n<td align=\"left\">410000</td>\n<td align=\"left\">河南省</td>\n</tr>\n<tr>\n<td align=\"left\">410100</td>\n<td align=\"left\">郑州市</td>\n</tr>\n<tr>\n<td align=\"left\">410102</td>\n<td align=\"left\">中原区</td>\n</tr>\n<tr>\n<td align=\"left\">410103</td>\n<td align=\"left\">二七区</td>\n</tr>\n<tr>\n<td align=\"left\">410104</td>\n<td align=\"left\">管城回族区</td>\n</tr>\n<tr>\n<td align=\"left\">410105</td>\n<td align=\"left\">金水区</td>\n</tr>\n<tr>\n<td align=\"left\">410106</td>\n<td align=\"left\">上街区</td>\n</tr>\n<tr>\n<td align=\"left\">410108</td>\n<td align=\"left\">惠济区</td>\n</tr>\n<tr>\n<td align=\"left\">410122</td>\n<td align=\"left\">中牟县</td>\n</tr>\n<tr>\n<td align=\"left\">410181</td>\n<td align=\"left\">巩义市</td>\n</tr>\n<tr>\n<td align=\"left\">410182</td>\n<td align=\"left\">荥阳市</td>\n</tr>\n<tr>\n<td align=\"left\">410183</td>\n<td align=\"left\">新密市</td>\n</tr>\n<tr>\n<td align=\"left\">410184</td>\n<td align=\"left\">新郑市</td>\n</tr>\n<tr>\n<td align=\"left\">410185</td>\n<td align=\"left\">登封市</td>\n</tr>\n<tr>\n<td align=\"left\">410200</td>\n<td align=\"left\">开封市</td>\n</tr>\n<tr>\n<td align=\"left\">410202</td>\n<td align=\"left\">龙亭区</td>\n</tr>\n<tr>\n<td align=\"left\">410203</td>\n<td align=\"left\">顺河回族区</td>\n</tr>\n<tr>\n<td align=\"left\">410204</td>\n<td align=\"left\">鼓楼区</td>\n</tr>\n<tr>\n<td align=\"left\">410205</td>\n<td align=\"left\">禹王台区</td>\n</tr>\n<tr>\n<td align=\"left\">410212</td>\n<td align=\"left\">祥符区</td>\n</tr>\n<tr>\n<td align=\"left\">410221</td>\n<td align=\"left\">杞县</td>\n</tr>\n<tr>\n<td align=\"left\">410222</td>\n<td align=\"left\">通许县</td>\n</tr>\n<tr>\n<td align=\"left\">410223</td>\n<td align=\"left\">尉氏县</td>\n</tr>\n<tr>\n<td align=\"left\">410225</td>\n<td align=\"left\">兰考县</td>\n</tr>\n<tr>\n<td align=\"left\">410300</td>\n<td align=\"left\">洛阳市</td>\n</tr>\n<tr>\n<td align=\"left\">410302</td>\n<td align=\"left\">老城区</td>\n</tr>\n<tr>\n<td align=\"left\">410303</td>\n<td align=\"left\">西工区</td>\n</tr>\n<tr>\n<td align=\"left\">410304</td>\n<td align=\"left\">瀍河回族区</td>\n</tr>\n<tr>\n<td align=\"left\">410305</td>\n<td align=\"left\">涧西区</td>\n</tr>\n<tr>\n<td align=\"left\">410306</td>\n<td align=\"left\">吉利区</td>\n</tr>\n<tr>\n<td align=\"left\">410311</td>\n<td align=\"left\">洛龙区</td>\n</tr>\n<tr>\n<td align=\"left\">410322</td>\n<td align=\"left\">孟津县</td>\n</tr>\n<tr>\n<td align=\"left\">410323</td>\n<td align=\"left\">新安县</td>\n</tr>\n<tr>\n<td align=\"left\">410324</td>\n<td align=\"left\">栾川县</td>\n</tr>\n<tr>\n<td align=\"left\">410325</td>\n<td align=\"left\">嵩县</td>\n</tr>\n<tr>\n<td align=\"left\">410326</td>\n<td align=\"left\">汝阳县</td>\n</tr>\n<tr>\n<td align=\"left\">410327</td>\n<td align=\"left\">宜阳县</td>\n</tr>\n<tr>\n<td align=\"left\">410328</td>\n<td align=\"left\">洛宁县</td>\n</tr>\n<tr>\n<td align=\"left\">410329</td>\n<td align=\"left\">伊川县</td>\n</tr>\n<tr>\n<td align=\"left\">410381</td>\n<td align=\"left\">偃师市</td>\n</tr>\n<tr>\n<td align=\"left\">410400</td>\n<td align=\"left\">平顶山市</td>\n</tr>\n<tr>\n<td align=\"left\">410402</td>\n<td align=\"left\">新华区</td>\n</tr>\n<tr>\n<td align=\"left\">410403</td>\n<td align=\"left\">卫东区</td>\n</tr>\n<tr>\n<td align=\"left\">410404</td>\n<td align=\"left\">石龙区</td>\n</tr>\n<tr>\n<td align=\"left\">410411</td>\n<td align=\"left\">湛河区</td>\n</tr>\n<tr>\n<td align=\"left\">410421</td>\n<td align=\"left\">宝丰县</td>\n</tr>\n<tr>\n<td align=\"left\">410422</td>\n<td align=\"left\">叶县</td>\n</tr>\n<tr>\n<td align=\"left\">410423</td>\n<td align=\"left\">鲁山县</td>\n</tr>\n<tr>\n<td align=\"left\">410425</td>\n<td align=\"left\">郏县</td>\n</tr>\n<tr>\n<td align=\"left\">410481</td>\n<td align=\"left\">舞钢市</td>\n</tr>\n<tr>\n<td align=\"left\">410482</td>\n<td align=\"left\">汝州市</td>\n</tr>\n<tr>\n<td align=\"left\">410500</td>\n<td align=\"left\">安阳市</td>\n</tr>\n<tr>\n<td align=\"left\">410502</td>\n<td align=\"left\">文峰区</td>\n</tr>\n<tr>\n<td align=\"left\">410503</td>\n<td align=\"left\">北关区</td>\n</tr>\n<tr>\n<td align=\"left\">410505</td>\n<td align=\"left\">殷都区</td>\n</tr>\n<tr>\n<td align=\"left\">410506</td>\n<td align=\"left\">龙安区</td>\n</tr>\n<tr>\n<td align=\"left\">410522</td>\n<td align=\"left\">安阳县</td>\n</tr>\n<tr>\n<td align=\"left\">410523</td>\n<td align=\"left\">汤阴县</td>\n</tr>\n<tr>\n<td align=\"left\">410526</td>\n<td align=\"left\">滑县</td>\n</tr>\n<tr>\n<td align=\"left\">410527</td>\n<td align=\"left\">内黄县</td>\n</tr>\n<tr>\n<td align=\"left\">410581</td>\n<td align=\"left\">林州市</td>\n</tr>\n<tr>\n<td align=\"left\">410600</td>\n<td align=\"left\">鹤壁市</td>\n</tr>\n<tr>\n<td align=\"left\">410602</td>\n<td align=\"left\">鹤山区</td>\n</tr>\n<tr>\n<td align=\"left\">410603</td>\n<td align=\"left\">山城区</td>\n</tr>\n<tr>\n<td align=\"left\">410611</td>\n<td align=\"left\">淇滨区</td>\n</tr>\n<tr>\n<td align=\"left\">410621</td>\n<td align=\"left\">浚县</td>\n</tr>\n<tr>\n<td align=\"left\">410622</td>\n<td align=\"left\">淇县</td>\n</tr>\n<tr>\n<td align=\"left\">410700</td>\n<td align=\"left\">新乡市</td>\n</tr>\n<tr>\n<td align=\"left\">410702</td>\n<td align=\"left\">红旗区</td>\n</tr>\n<tr>\n<td align=\"left\">410703</td>\n<td align=\"left\">卫滨区</td>\n</tr>\n<tr>\n<td align=\"left\">410704</td>\n<td align=\"left\">凤泉区</td>\n</tr>\n<tr>\n<td align=\"left\">410711</td>\n<td align=\"left\">牧野区</td>\n</tr>\n<tr>\n<td align=\"left\">410721</td>\n<td align=\"left\">新乡县</td>\n</tr>\n<tr>\n<td align=\"left\">410724</td>\n<td align=\"left\">获嘉县</td>\n</tr>\n<tr>\n<td align=\"left\">410725</td>\n<td align=\"left\">原阳县</td>\n</tr>\n<tr>\n<td align=\"left\">410726</td>\n<td align=\"left\">延津县</td>\n</tr>\n<tr>\n<td align=\"left\">410727</td>\n<td align=\"left\">封丘县</td>\n</tr>\n<tr>\n<td align=\"left\">410781</td>\n<td align=\"left\">卫辉市</td>\n</tr>\n<tr>\n<td align=\"left\">410782</td>\n<td align=\"left\">辉县市</td>\n</tr>\n<tr>\n<td align=\"left\">410783</td>\n<td align=\"left\">长垣市</td>\n</tr>\n<tr>\n<td align=\"left\">410800</td>\n<td align=\"left\">焦作市</td>\n</tr>\n<tr>\n<td align=\"left\">410802</td>\n<td align=\"left\">解放区</td>\n</tr>\n<tr>\n<td align=\"left\">410803</td>\n<td align=\"left\">中站区</td>\n</tr>\n<tr>\n<td align=\"left\">410804</td>\n<td align=\"left\">马村区</td>\n</tr>\n<tr>\n<td align=\"left\">410811</td>\n<td align=\"left\">山阳区</td>\n</tr>\n<tr>\n<td align=\"left\">410821</td>\n<td align=\"left\">修武县</td>\n</tr>\n<tr>\n<td align=\"left\">410822</td>\n<td align=\"left\">博爱县</td>\n</tr>\n<tr>\n<td align=\"left\">410823</td>\n<td align=\"left\">武陟县</td>\n</tr>\n<tr>\n<td align=\"left\">410825</td>\n<td align=\"left\">温县</td>\n</tr>\n<tr>\n<td align=\"left\">410882</td>\n<td align=\"left\">沁阳市</td>\n</tr>\n<tr>\n<td align=\"left\">410883</td>\n<td align=\"left\">孟州市</td>\n</tr>\n<tr>\n<td align=\"left\">410900</td>\n<td align=\"left\">濮阳市</td>\n</tr>\n<tr>\n<td align=\"left\">410902</td>\n<td align=\"left\">华龙区</td>\n</tr>\n<tr>\n<td align=\"left\">410922</td>\n<td align=\"left\">清丰县</td>\n</tr>\n<tr>\n<td align=\"left\">410923</td>\n<td align=\"left\">南乐县</td>\n</tr>\n<tr>\n<td align=\"left\">410926</td>\n<td align=\"left\">范县</td>\n</tr>\n<tr>\n<td align=\"left\">410927</td>\n<td align=\"left\">台前县</td>\n</tr>\n<tr>\n<td align=\"left\">410928</td>\n<td align=\"left\">濮阳县</td>\n</tr>\n<tr>\n<td align=\"left\">411000</td>\n<td align=\"left\">许昌市</td>\n</tr>\n<tr>\n<td align=\"left\">411002</td>\n<td align=\"left\">魏都区</td>\n</tr>\n<tr>\n<td align=\"left\">411003</td>\n<td align=\"left\">建安区</td>\n</tr>\n<tr>\n<td align=\"left\">411024</td>\n<td align=\"left\">鄢陵县</td>\n</tr>\n<tr>\n<td align=\"left\">411025</td>\n<td align=\"left\">襄城县</td>\n</tr>\n<tr>\n<td align=\"left\">411081</td>\n<td align=\"left\">禹州市</td>\n</tr>\n<tr>\n<td align=\"left\">411082</td>\n<td align=\"left\">长葛市</td>\n</tr>\n<tr>\n<td align=\"left\">411100</td>\n<td align=\"left\">漯河市</td>\n</tr>\n<tr>\n<td align=\"left\">411102</td>\n<td align=\"left\">源汇区</td>\n</tr>\n<tr>\n<td align=\"left\">411103</td>\n<td align=\"left\">郾城区</td>\n</tr>\n<tr>\n<td align=\"left\">411104</td>\n<td align=\"left\">召陵区</td>\n</tr>\n<tr>\n<td align=\"left\">411121</td>\n<td align=\"left\">舞阳县</td>\n</tr>\n<tr>\n<td align=\"left\">411122</td>\n<td align=\"left\">临颍县</td>\n</tr>\n<tr>\n<td align=\"left\">411200</td>\n<td align=\"left\">三门峡市</td>\n</tr>\n<tr>\n<td align=\"left\">411202</td>\n<td align=\"left\">湖滨区</td>\n</tr>\n<tr>\n<td align=\"left\">411203</td>\n<td align=\"left\">陕州区</td>\n</tr>\n<tr>\n<td align=\"left\">411221</td>\n<td align=\"left\">渑池县</td>\n</tr>\n<tr>\n<td align=\"left\">411224</td>\n<td align=\"left\">卢氏县</td>\n</tr>\n<tr>\n<td align=\"left\">411281</td>\n<td align=\"left\">义马市</td>\n</tr>\n<tr>\n<td align=\"left\">411282</td>\n<td align=\"left\">灵宝市</td>\n</tr>\n<tr>\n<td align=\"left\">411300</td>\n<td align=\"left\">南阳市</td>\n</tr>\n<tr>\n<td align=\"left\">411302</td>\n<td align=\"left\">宛城区</td>\n</tr>\n<tr>\n<td align=\"left\">411303</td>\n<td align=\"left\">卧龙区</td>\n</tr>\n<tr>\n<td align=\"left\">411321</td>\n<td align=\"left\">南召县</td>\n</tr>\n<tr>\n<td align=\"left\">411322</td>\n<td align=\"left\">方城县</td>\n</tr>\n<tr>\n<td align=\"left\">411323</td>\n<td align=\"left\">西峡县</td>\n</tr>\n<tr>\n<td align=\"left\">411324</td>\n<td align=\"left\">镇平县</td>\n</tr>\n<tr>\n<td align=\"left\">411325</td>\n<td align=\"left\">内乡县</td>\n</tr>\n<tr>\n<td align=\"left\">411326</td>\n<td align=\"left\">淅川县</td>\n</tr>\n<tr>\n<td align=\"left\">411327</td>\n<td align=\"left\">社旗县</td>\n</tr>\n<tr>\n<td align=\"left\">411328</td>\n<td align=\"left\">唐河县</td>\n</tr>\n<tr>\n<td align=\"left\">411329</td>\n<td align=\"left\">新野县</td>\n</tr>\n<tr>\n<td align=\"left\">411330</td>\n<td align=\"left\">桐柏县</td>\n</tr>\n<tr>\n<td align=\"left\">411381</td>\n<td align=\"left\">邓州市</td>\n</tr>\n<tr>\n<td align=\"left\">411400</td>\n<td align=\"left\">商丘市</td>\n</tr>\n<tr>\n<td align=\"left\">411402</td>\n<td align=\"left\">梁园区</td>\n</tr>\n<tr>\n<td align=\"left\">411403</td>\n<td align=\"left\">睢阳区</td>\n</tr>\n<tr>\n<td align=\"left\">411421</td>\n<td align=\"left\">民权县</td>\n</tr>\n<tr>\n<td align=\"left\">411422</td>\n<td align=\"left\">睢县</td>\n</tr>\n<tr>\n<td align=\"left\">411423</td>\n<td align=\"left\">宁陵县</td>\n</tr>\n<tr>\n<td align=\"left\">411424</td>\n<td align=\"left\">柘城县</td>\n</tr>\n<tr>\n<td align=\"left\">411425</td>\n<td align=\"left\">虞城县</td>\n</tr>\n<tr>\n<td align=\"left\">411426</td>\n<td align=\"left\">夏邑县</td>\n</tr>\n<tr>\n<td align=\"left\">411481</td>\n<td align=\"left\">永城市</td>\n</tr>\n<tr>\n<td align=\"left\">411500</td>\n<td align=\"left\">信阳市</td>\n</tr>\n<tr>\n<td align=\"left\">411502</td>\n<td align=\"left\">浉河区</td>\n</tr>\n<tr>\n<td align=\"left\">411503</td>\n<td align=\"left\">平桥区</td>\n</tr>\n<tr>\n<td align=\"left\">411521</td>\n<td align=\"left\">罗山县</td>\n</tr>\n<tr>\n<td align=\"left\">411522</td>\n<td align=\"left\">光山县</td>\n</tr>\n<tr>\n<td align=\"left\">411523</td>\n<td align=\"left\">新县</td>\n</tr>\n<tr>\n<td align=\"left\">411524</td>\n<td align=\"left\">商城县</td>\n</tr>\n<tr>\n<td align=\"left\">411525</td>\n<td align=\"left\">固始县</td>\n</tr>\n<tr>\n<td align=\"left\">411526</td>\n<td align=\"left\">潢川县</td>\n</tr>\n<tr>\n<td align=\"left\">411527</td>\n<td align=\"left\">淮滨县</td>\n</tr>\n<tr>\n<td align=\"left\">411528</td>\n<td align=\"left\">息县</td>\n</tr>\n<tr>\n<td align=\"left\">411600</td>\n<td align=\"left\">周口市</td>\n</tr>\n<tr>\n<td align=\"left\">411602</td>\n<td align=\"left\">川汇区</td>\n</tr>\n<tr>\n<td align=\"left\">411603</td>\n<td align=\"left\">淮阳区</td>\n</tr>\n<tr>\n<td align=\"left\">411621</td>\n<td align=\"left\">扶沟县</td>\n</tr>\n<tr>\n<td align=\"left\">411622</td>\n<td align=\"left\">西华县</td>\n</tr>\n<tr>\n<td align=\"left\">411623</td>\n<td align=\"left\">商水县</td>\n</tr>\n<tr>\n<td align=\"left\">411624</td>\n<td align=\"left\">沈丘县</td>\n</tr>\n<tr>\n<td align=\"left\">411625</td>\n<td align=\"left\">郸城县</td>\n</tr>\n<tr>\n<td align=\"left\">411627</td>\n<td align=\"left\">太康县</td>\n</tr>\n<tr>\n<td align=\"left\">411628</td>\n<td align=\"left\">鹿邑县</td>\n</tr>\n<tr>\n<td align=\"left\">411681</td>\n<td align=\"left\">项城市</td>\n</tr>\n<tr>\n<td align=\"left\">411700</td>\n<td align=\"left\">驻马店市</td>\n</tr>\n<tr>\n<td align=\"left\">411702</td>\n<td align=\"left\">驿城区</td>\n</tr>\n<tr>\n<td align=\"left\">411721</td>\n<td align=\"left\">西平县</td>\n</tr>\n<tr>\n<td align=\"left\">411722</td>\n<td align=\"left\">上蔡县</td>\n</tr>\n<tr>\n<td align=\"left\">411723</td>\n<td align=\"left\">平舆县</td>\n</tr>\n<tr>\n<td align=\"left\">411724</td>\n<td align=\"left\">正阳县</td>\n</tr>\n<tr>\n<td align=\"left\">411725</td>\n<td align=\"left\">确山县</td>\n</tr>\n<tr>\n<td align=\"left\">411726</td>\n<td align=\"left\">泌阳县</td>\n</tr>\n<tr>\n<td align=\"left\">411727</td>\n<td align=\"left\">汝南县</td>\n</tr>\n<tr>\n<td align=\"left\">411728</td>\n<td align=\"left\">遂平县</td>\n</tr>\n<tr>\n<td align=\"left\">411729</td>\n<td align=\"left\">新蔡县</td>\n</tr>\n<tr>\n<td align=\"left\">419001</td>\n<td align=\"left\">济源市</td>\n</tr>\n<tr>\n<td align=\"left\">420000</td>\n<td align=\"left\">湖北省</td>\n</tr>\n<tr>\n<td align=\"left\">420100</td>\n<td align=\"left\">武汉市</td>\n</tr>\n<tr>\n<td align=\"left\">420102</td>\n<td align=\"left\">江岸区</td>\n</tr>\n<tr>\n<td align=\"left\">420103</td>\n<td align=\"left\">江汉区</td>\n</tr>\n<tr>\n<td align=\"left\">420104</td>\n<td align=\"left\">硚口区</td>\n</tr>\n<tr>\n<td align=\"left\">420105</td>\n<td align=\"left\">汉阳区</td>\n</tr>\n<tr>\n<td align=\"left\">420106</td>\n<td align=\"left\">武昌区</td>\n</tr>\n<tr>\n<td align=\"left\">420107</td>\n<td align=\"left\">青山区</td>\n</tr>\n<tr>\n<td align=\"left\">420111</td>\n<td align=\"left\">洪山区</td>\n</tr>\n<tr>\n<td align=\"left\">420112</td>\n<td align=\"left\">东西湖区</td>\n</tr>\n<tr>\n<td align=\"left\">420113</td>\n<td align=\"left\">汉南区</td>\n</tr>\n<tr>\n<td align=\"left\">420114</td>\n<td align=\"left\">蔡甸区</td>\n</tr>\n<tr>\n<td align=\"left\">420115</td>\n<td align=\"left\">江夏区</td>\n</tr>\n<tr>\n<td align=\"left\">420116</td>\n<td align=\"left\">黄陂区</td>\n</tr>\n<tr>\n<td align=\"left\">420117</td>\n<td align=\"left\">新洲区</td>\n</tr>\n<tr>\n<td align=\"left\">420200</td>\n<td align=\"left\">黄石市</td>\n</tr>\n<tr>\n<td align=\"left\">420202</td>\n<td align=\"left\">黄石港区</td>\n</tr>\n<tr>\n<td align=\"left\">420203</td>\n<td align=\"left\">西塞山区</td>\n</tr>\n<tr>\n<td align=\"left\">420204</td>\n<td align=\"left\">下陆区</td>\n</tr>\n<tr>\n<td align=\"left\">420205</td>\n<td align=\"left\">铁山区</td>\n</tr>\n<tr>\n<td align=\"left\">420222</td>\n<td align=\"left\">阳新县</td>\n</tr>\n<tr>\n<td align=\"left\">420281</td>\n<td align=\"left\">大冶市</td>\n</tr>\n<tr>\n<td align=\"left\">420300</td>\n<td align=\"left\">十堰市</td>\n</tr>\n<tr>\n<td align=\"left\">420302</td>\n<td align=\"left\">茅箭区</td>\n</tr>\n<tr>\n<td align=\"left\">420303</td>\n<td align=\"left\">张湾区</td>\n</tr>\n<tr>\n<td align=\"left\">420304</td>\n<td align=\"left\">郧阳区</td>\n</tr>\n<tr>\n<td align=\"left\">420322</td>\n<td align=\"left\">郧西县</td>\n</tr>\n<tr>\n<td align=\"left\">420323</td>\n<td align=\"left\">竹山县</td>\n</tr>\n<tr>\n<td align=\"left\">420324</td>\n<td align=\"left\">竹溪县</td>\n</tr>\n<tr>\n<td align=\"left\">420325</td>\n<td align=\"left\">房县</td>\n</tr>\n<tr>\n<td align=\"left\">420381</td>\n<td align=\"left\">丹江口市</td>\n</tr>\n<tr>\n<td align=\"left\">420500</td>\n<td align=\"left\">宜昌市</td>\n</tr>\n<tr>\n<td align=\"left\">420502</td>\n<td align=\"left\">西陵区</td>\n</tr>\n<tr>\n<td align=\"left\">420503</td>\n<td align=\"left\">伍家岗区</td>\n</tr>\n<tr>\n<td align=\"left\">420504</td>\n<td align=\"left\">点军区</td>\n</tr>\n<tr>\n<td align=\"left\">420505</td>\n<td align=\"left\">猇亭区</td>\n</tr>\n<tr>\n<td align=\"left\">420506</td>\n<td align=\"left\">夷陵区</td>\n</tr>\n<tr>\n<td align=\"left\">420525</td>\n<td align=\"left\">远安县</td>\n</tr>\n<tr>\n<td align=\"left\">420526</td>\n<td align=\"left\">兴山县</td>\n</tr>\n<tr>\n<td align=\"left\">420527</td>\n<td align=\"left\">秭归县</td>\n</tr>\n<tr>\n<td align=\"left\">420528</td>\n<td align=\"left\">长阳土家族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">420529</td>\n<td align=\"left\">五峰土家族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">420581</td>\n<td align=\"left\">宜都市</td>\n</tr>\n<tr>\n<td align=\"left\">420582</td>\n<td align=\"left\">当阳市</td>\n</tr>\n<tr>\n<td align=\"left\">420583</td>\n<td align=\"left\">枝江市</td>\n</tr>\n<tr>\n<td align=\"left\">420600</td>\n<td align=\"left\">襄阳市</td>\n</tr>\n<tr>\n<td align=\"left\">420602</td>\n<td align=\"left\">襄城区</td>\n</tr>\n<tr>\n<td align=\"left\">420606</td>\n<td align=\"left\">樊城区</td>\n</tr>\n<tr>\n<td align=\"left\">420607</td>\n<td align=\"left\">襄州区</td>\n</tr>\n<tr>\n<td align=\"left\">420624</td>\n<td align=\"left\">南漳县</td>\n</tr>\n<tr>\n<td align=\"left\">420625</td>\n<td align=\"left\">谷城县</td>\n</tr>\n<tr>\n<td align=\"left\">420626</td>\n<td align=\"left\">保康县</td>\n</tr>\n<tr>\n<td align=\"left\">420682</td>\n<td align=\"left\">老河口市</td>\n</tr>\n<tr>\n<td align=\"left\">420683</td>\n<td align=\"left\">枣阳市</td>\n</tr>\n<tr>\n<td align=\"left\">420684</td>\n<td align=\"left\">宜城市</td>\n</tr>\n<tr>\n<td align=\"left\">420700</td>\n<td align=\"left\">鄂州市</td>\n</tr>\n<tr>\n<td align=\"left\">420702</td>\n<td align=\"left\">梁子湖区</td>\n</tr>\n<tr>\n<td align=\"left\">420703</td>\n<td align=\"left\">华容区</td>\n</tr>\n<tr>\n<td align=\"left\">420704</td>\n<td align=\"left\">鄂城区</td>\n</tr>\n<tr>\n<td align=\"left\">420800</td>\n<td align=\"left\">荆门市</td>\n</tr>\n<tr>\n<td align=\"left\">420802</td>\n<td align=\"left\">东宝区</td>\n</tr>\n<tr>\n<td align=\"left\">420804</td>\n<td align=\"left\">掇刀区</td>\n</tr>\n<tr>\n<td align=\"left\">420822</td>\n<td align=\"left\">沙洋县</td>\n</tr>\n<tr>\n<td align=\"left\">420881</td>\n<td align=\"left\">钟祥市</td>\n</tr>\n<tr>\n<td align=\"left\">420882</td>\n<td align=\"left\">京山市</td>\n</tr>\n<tr>\n<td align=\"left\">420900</td>\n<td align=\"left\">孝感市</td>\n</tr>\n<tr>\n<td align=\"left\">420902</td>\n<td align=\"left\">孝南区</td>\n</tr>\n<tr>\n<td align=\"left\">420921</td>\n<td align=\"left\">孝昌县</td>\n</tr>\n<tr>\n<td align=\"left\">420922</td>\n<td align=\"left\">大悟县</td>\n</tr>\n<tr>\n<td align=\"left\">420923</td>\n<td align=\"left\">云梦县</td>\n</tr>\n<tr>\n<td align=\"left\">420981</td>\n<td align=\"left\">应城市</td>\n</tr>\n<tr>\n<td align=\"left\">420982</td>\n<td align=\"left\">安陆市</td>\n</tr>\n<tr>\n<td align=\"left\">420984</td>\n<td align=\"left\">汉川市</td>\n</tr>\n<tr>\n<td align=\"left\">421000</td>\n<td align=\"left\">荆州市</td>\n</tr>\n<tr>\n<td align=\"left\">421002</td>\n<td align=\"left\">沙市区</td>\n</tr>\n<tr>\n<td align=\"left\">421003</td>\n<td align=\"left\">荆州区</td>\n</tr>\n<tr>\n<td align=\"left\">421022</td>\n<td align=\"left\">公安县</td>\n</tr>\n<tr>\n<td align=\"left\">421023</td>\n<td align=\"left\">监利县</td>\n</tr>\n<tr>\n<td align=\"left\">421024</td>\n<td align=\"left\">江陵县</td>\n</tr>\n<tr>\n<td align=\"left\">421081</td>\n<td align=\"left\">石首市</td>\n</tr>\n<tr>\n<td align=\"left\">421083</td>\n<td align=\"left\">洪湖市</td>\n</tr>\n<tr>\n<td align=\"left\">421087</td>\n<td align=\"left\">松滋市</td>\n</tr>\n<tr>\n<td align=\"left\">421100</td>\n<td align=\"left\">黄冈市</td>\n</tr>\n<tr>\n<td align=\"left\">421102</td>\n<td align=\"left\">黄州区</td>\n</tr>\n<tr>\n<td align=\"left\">421121</td>\n<td align=\"left\">团风县</td>\n</tr>\n<tr>\n<td align=\"left\">421122</td>\n<td align=\"left\">红安县</td>\n</tr>\n<tr>\n<td align=\"left\">421123</td>\n<td align=\"left\">罗田县</td>\n</tr>\n<tr>\n<td align=\"left\">421124</td>\n<td align=\"left\">英山县</td>\n</tr>\n<tr>\n<td align=\"left\">421125</td>\n<td align=\"left\">浠水县</td>\n</tr>\n<tr>\n<td align=\"left\">421126</td>\n<td align=\"left\">蕲春县</td>\n</tr>\n<tr>\n<td align=\"left\">421127</td>\n<td align=\"left\">黄梅县</td>\n</tr>\n<tr>\n<td align=\"left\">421181</td>\n<td align=\"left\">麻城市</td>\n</tr>\n<tr>\n<td align=\"left\">421182</td>\n<td align=\"left\">武穴市</td>\n</tr>\n<tr>\n<td align=\"left\">421200</td>\n<td align=\"left\">咸宁市</td>\n</tr>\n<tr>\n<td align=\"left\">421202</td>\n<td align=\"left\">咸安区</td>\n</tr>\n<tr>\n<td align=\"left\">421221</td>\n<td align=\"left\">嘉鱼县</td>\n</tr>\n<tr>\n<td align=\"left\">421222</td>\n<td align=\"left\">通城县</td>\n</tr>\n<tr>\n<td align=\"left\">421223</td>\n<td align=\"left\">崇阳县</td>\n</tr>\n<tr>\n<td align=\"left\">421224</td>\n<td align=\"left\">通山县</td>\n</tr>\n<tr>\n<td align=\"left\">421281</td>\n<td align=\"left\">赤壁市</td>\n</tr>\n<tr>\n<td align=\"left\">421300</td>\n<td align=\"left\">随州市</td>\n</tr>\n<tr>\n<td align=\"left\">421303</td>\n<td align=\"left\">曾都区</td>\n</tr>\n<tr>\n<td align=\"left\">421321</td>\n<td align=\"left\">随县</td>\n</tr>\n<tr>\n<td align=\"left\">421381</td>\n<td align=\"left\">广水市</td>\n</tr>\n<tr>\n<td align=\"left\">422800</td>\n<td align=\"left\">恩施土家族苗族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">422801</td>\n<td align=\"left\">恩施市</td>\n</tr>\n<tr>\n<td align=\"left\">422802</td>\n<td align=\"left\">利川市</td>\n</tr>\n<tr>\n<td align=\"left\">422822</td>\n<td align=\"left\">建始县</td>\n</tr>\n<tr>\n<td align=\"left\">422823</td>\n<td align=\"left\">巴东县</td>\n</tr>\n<tr>\n<td align=\"left\">422825</td>\n<td align=\"left\">宣恩县</td>\n</tr>\n<tr>\n<td align=\"left\">422826</td>\n<td align=\"left\">咸丰县</td>\n</tr>\n<tr>\n<td align=\"left\">422827</td>\n<td align=\"left\">来凤县</td>\n</tr>\n<tr>\n<td align=\"left\">422828</td>\n<td align=\"left\">鹤峰县</td>\n</tr>\n<tr>\n<td align=\"left\">429004</td>\n<td align=\"left\">仙桃市</td>\n</tr>\n<tr>\n<td align=\"left\">429005</td>\n<td align=\"left\">潜江市</td>\n</tr>\n<tr>\n<td align=\"left\">429006</td>\n<td align=\"left\">天门市</td>\n</tr>\n<tr>\n<td align=\"left\">429021</td>\n<td align=\"left\">神农架林区</td>\n</tr>\n<tr>\n<td align=\"left\">430000</td>\n<td align=\"left\">湖南省</td>\n</tr>\n<tr>\n<td align=\"left\">430100</td>\n<td align=\"left\">长沙市</td>\n</tr>\n<tr>\n<td align=\"left\">430102</td>\n<td align=\"left\">芙蓉区</td>\n</tr>\n<tr>\n<td align=\"left\">430103</td>\n<td align=\"left\">天心区</td>\n</tr>\n<tr>\n<td align=\"left\">430104</td>\n<td align=\"left\">岳麓区</td>\n</tr>\n<tr>\n<td align=\"left\">430105</td>\n<td align=\"left\">开福区</td>\n</tr>\n<tr>\n<td align=\"left\">430111</td>\n<td align=\"left\">雨花区</td>\n</tr>\n<tr>\n<td align=\"left\">430112</td>\n<td align=\"left\">望城区</td>\n</tr>\n<tr>\n<td align=\"left\">430121</td>\n<td align=\"left\">长沙县</td>\n</tr>\n<tr>\n<td align=\"left\">430181</td>\n<td align=\"left\">浏阳市</td>\n</tr>\n<tr>\n<td align=\"left\">430182</td>\n<td align=\"left\">宁乡市</td>\n</tr>\n<tr>\n<td align=\"left\">430200</td>\n<td align=\"left\">株洲市</td>\n</tr>\n<tr>\n<td align=\"left\">430202</td>\n<td align=\"left\">荷塘区</td>\n</tr>\n<tr>\n<td align=\"left\">430203</td>\n<td align=\"left\">芦淞区</td>\n</tr>\n<tr>\n<td align=\"left\">430204</td>\n<td align=\"left\">石峰区</td>\n</tr>\n<tr>\n<td align=\"left\">430211</td>\n<td align=\"left\">天元区</td>\n</tr>\n<tr>\n<td align=\"left\">430212</td>\n<td align=\"left\">渌口区</td>\n</tr>\n<tr>\n<td align=\"left\">430223</td>\n<td align=\"left\">攸县</td>\n</tr>\n<tr>\n<td align=\"left\">430224</td>\n<td align=\"left\">茶陵县</td>\n</tr>\n<tr>\n<td align=\"left\">430225</td>\n<td align=\"left\">炎陵县</td>\n</tr>\n<tr>\n<td align=\"left\">430281</td>\n<td align=\"left\">醴陵市</td>\n</tr>\n<tr>\n<td align=\"left\">430300</td>\n<td align=\"left\">湘潭市</td>\n</tr>\n<tr>\n<td align=\"left\">430302</td>\n<td align=\"left\">雨湖区</td>\n</tr>\n<tr>\n<td align=\"left\">430304</td>\n<td align=\"left\">岳塘区</td>\n</tr>\n<tr>\n<td align=\"left\">430321</td>\n<td align=\"left\">湘潭县</td>\n</tr>\n<tr>\n<td align=\"left\">430381</td>\n<td align=\"left\">湘乡市</td>\n</tr>\n<tr>\n<td align=\"left\">430382</td>\n<td align=\"left\">韶山市</td>\n</tr>\n<tr>\n<td align=\"left\">430400</td>\n<td align=\"left\">衡阳市</td>\n</tr>\n<tr>\n<td align=\"left\">430405</td>\n<td align=\"left\">珠晖区</td>\n</tr>\n<tr>\n<td align=\"left\">430406</td>\n<td align=\"left\">雁峰区</td>\n</tr>\n<tr>\n<td align=\"left\">430407</td>\n<td align=\"left\">石鼓区</td>\n</tr>\n<tr>\n<td align=\"left\">430408</td>\n<td align=\"left\">蒸湘区</td>\n</tr>\n<tr>\n<td align=\"left\">430412</td>\n<td align=\"left\">南岳区</td>\n</tr>\n<tr>\n<td align=\"left\">430421</td>\n<td align=\"left\">衡阳县</td>\n</tr>\n<tr>\n<td align=\"left\">430422</td>\n<td align=\"left\">衡南县</td>\n</tr>\n<tr>\n<td align=\"left\">430423</td>\n<td align=\"left\">衡山县</td>\n</tr>\n<tr>\n<td align=\"left\">430424</td>\n<td align=\"left\">衡东县</td>\n</tr>\n<tr>\n<td align=\"left\">430426</td>\n<td align=\"left\">祁东县</td>\n</tr>\n<tr>\n<td align=\"left\">430481</td>\n<td align=\"left\">耒阳市</td>\n</tr>\n<tr>\n<td align=\"left\">430482</td>\n<td align=\"left\">常宁市</td>\n</tr>\n<tr>\n<td align=\"left\">430500</td>\n<td align=\"left\">邵阳市</td>\n</tr>\n<tr>\n<td align=\"left\">430502</td>\n<td align=\"left\">双清区</td>\n</tr>\n<tr>\n<td align=\"left\">430503</td>\n<td align=\"left\">大祥区</td>\n</tr>\n<tr>\n<td align=\"left\">430511</td>\n<td align=\"left\">北塔区</td>\n</tr>\n<tr>\n<td align=\"left\">430522</td>\n<td align=\"left\">新邵县</td>\n</tr>\n<tr>\n<td align=\"left\">430523</td>\n<td align=\"left\">邵阳县</td>\n</tr>\n<tr>\n<td align=\"left\">430524</td>\n<td align=\"left\">隆回县</td>\n</tr>\n<tr>\n<td align=\"left\">430525</td>\n<td align=\"left\">洞口县</td>\n</tr>\n<tr>\n<td align=\"left\">430527</td>\n<td align=\"left\">绥宁县</td>\n</tr>\n<tr>\n<td align=\"left\">430528</td>\n<td align=\"left\">新宁县</td>\n</tr>\n<tr>\n<td align=\"left\">430529</td>\n<td align=\"left\">城步苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">430581</td>\n<td align=\"left\">武冈市</td>\n</tr>\n<tr>\n<td align=\"left\">430582</td>\n<td align=\"left\">邵东市</td>\n</tr>\n<tr>\n<td align=\"left\">430600</td>\n<td align=\"left\">岳阳市</td>\n</tr>\n<tr>\n<td align=\"left\">430602</td>\n<td align=\"left\">岳阳楼区</td>\n</tr>\n<tr>\n<td align=\"left\">430603</td>\n<td align=\"left\">云溪区</td>\n</tr>\n<tr>\n<td align=\"left\">430611</td>\n<td align=\"left\">君山区</td>\n</tr>\n<tr>\n<td align=\"left\">430621</td>\n<td align=\"left\">岳阳县</td>\n</tr>\n<tr>\n<td align=\"left\">430623</td>\n<td align=\"left\">华容县</td>\n</tr>\n<tr>\n<td align=\"left\">430624</td>\n<td align=\"left\">湘阴县</td>\n</tr>\n<tr>\n<td align=\"left\">430626</td>\n<td align=\"left\">平江县</td>\n</tr>\n<tr>\n<td align=\"left\">430681</td>\n<td align=\"left\">汨罗市</td>\n</tr>\n<tr>\n<td align=\"left\">430682</td>\n<td align=\"left\">临湘市</td>\n</tr>\n<tr>\n<td align=\"left\">430700</td>\n<td align=\"left\">常德市</td>\n</tr>\n<tr>\n<td align=\"left\">430702</td>\n<td align=\"left\">武陵区</td>\n</tr>\n<tr>\n<td align=\"left\">430703</td>\n<td align=\"left\">鼎城区</td>\n</tr>\n<tr>\n<td align=\"left\">430721</td>\n<td align=\"left\">安乡县</td>\n</tr>\n<tr>\n<td align=\"left\">430722</td>\n<td align=\"left\">汉寿县</td>\n</tr>\n<tr>\n<td align=\"left\">430723</td>\n<td align=\"left\">澧县</td>\n</tr>\n<tr>\n<td align=\"left\">430724</td>\n<td align=\"left\">临澧县</td>\n</tr>\n<tr>\n<td align=\"left\">430725</td>\n<td align=\"left\">桃源县</td>\n</tr>\n<tr>\n<td align=\"left\">430726</td>\n<td align=\"left\">石门县</td>\n</tr>\n<tr>\n<td align=\"left\">430781</td>\n<td align=\"left\">津市市</td>\n</tr>\n<tr>\n<td align=\"left\">430800</td>\n<td align=\"left\">张家界市</td>\n</tr>\n<tr>\n<td align=\"left\">430802</td>\n<td align=\"left\">永定区</td>\n</tr>\n<tr>\n<td align=\"left\">430811</td>\n<td align=\"left\">武陵源区</td>\n</tr>\n<tr>\n<td align=\"left\">430821</td>\n<td align=\"left\">慈利县</td>\n</tr>\n<tr>\n<td align=\"left\">430822</td>\n<td align=\"left\">桑植县</td>\n</tr>\n<tr>\n<td align=\"left\">430900</td>\n<td align=\"left\">益阳市</td>\n</tr>\n<tr>\n<td align=\"left\">430902</td>\n<td align=\"left\">资阳区</td>\n</tr>\n<tr>\n<td align=\"left\">430903</td>\n<td align=\"left\">赫山区</td>\n</tr>\n<tr>\n<td align=\"left\">430921</td>\n<td align=\"left\">南县</td>\n</tr>\n<tr>\n<td align=\"left\">430922</td>\n<td align=\"left\">桃江县</td>\n</tr>\n<tr>\n<td align=\"left\">430923</td>\n<td align=\"left\">安化县</td>\n</tr>\n<tr>\n<td align=\"left\">430981</td>\n<td align=\"left\">沅江市</td>\n</tr>\n<tr>\n<td align=\"left\">431000</td>\n<td align=\"left\">郴州市</td>\n</tr>\n<tr>\n<td align=\"left\">431002</td>\n<td align=\"left\">北湖区</td>\n</tr>\n<tr>\n<td align=\"left\">431003</td>\n<td align=\"left\">苏仙区</td>\n</tr>\n<tr>\n<td align=\"left\">431021</td>\n<td align=\"left\">桂阳县</td>\n</tr>\n<tr>\n<td align=\"left\">431022</td>\n<td align=\"left\">宜章县</td>\n</tr>\n<tr>\n<td align=\"left\">431023</td>\n<td align=\"left\">永兴县</td>\n</tr>\n<tr>\n<td align=\"left\">431024</td>\n<td align=\"left\">嘉禾县</td>\n</tr>\n<tr>\n<td align=\"left\">431025</td>\n<td align=\"left\">临武县</td>\n</tr>\n<tr>\n<td align=\"left\">431026</td>\n<td align=\"left\">汝城县</td>\n</tr>\n<tr>\n<td align=\"left\">431027</td>\n<td align=\"left\">桂东县</td>\n</tr>\n<tr>\n<td align=\"left\">431028</td>\n<td align=\"left\">安仁县</td>\n</tr>\n<tr>\n<td align=\"left\">431081</td>\n<td align=\"left\">资兴市</td>\n</tr>\n<tr>\n<td align=\"left\">431100</td>\n<td align=\"left\">永州市</td>\n</tr>\n<tr>\n<td align=\"left\">431102</td>\n<td align=\"left\">零陵区</td>\n</tr>\n<tr>\n<td align=\"left\">431103</td>\n<td align=\"left\">冷水滩区</td>\n</tr>\n<tr>\n<td align=\"left\">431121</td>\n<td align=\"left\">祁阳县</td>\n</tr>\n<tr>\n<td align=\"left\">431122</td>\n<td align=\"left\">东安县</td>\n</tr>\n<tr>\n<td align=\"left\">431123</td>\n<td align=\"left\">双牌县</td>\n</tr>\n<tr>\n<td align=\"left\">431124</td>\n<td align=\"left\">道县</td>\n</tr>\n<tr>\n<td align=\"left\">431125</td>\n<td align=\"left\">江永县</td>\n</tr>\n<tr>\n<td align=\"left\">431126</td>\n<td align=\"left\">宁远县</td>\n</tr>\n<tr>\n<td align=\"left\">431127</td>\n<td align=\"left\">蓝山县</td>\n</tr>\n<tr>\n<td align=\"left\">431128</td>\n<td align=\"left\">新田县</td>\n</tr>\n<tr>\n<td align=\"left\">431129</td>\n<td align=\"left\">江华瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">431200</td>\n<td align=\"left\">怀化市</td>\n</tr>\n<tr>\n<td align=\"left\">431202</td>\n<td align=\"left\">鹤城区</td>\n</tr>\n<tr>\n<td align=\"left\">431221</td>\n<td align=\"left\">中方县</td>\n</tr>\n<tr>\n<td align=\"left\">431222</td>\n<td align=\"left\">沅陵县</td>\n</tr>\n<tr>\n<td align=\"left\">431223</td>\n<td align=\"left\">辰溪县</td>\n</tr>\n<tr>\n<td align=\"left\">431224</td>\n<td align=\"left\">溆浦县</td>\n</tr>\n<tr>\n<td align=\"left\">431225</td>\n<td align=\"left\">会同县</td>\n</tr>\n<tr>\n<td align=\"left\">431226</td>\n<td align=\"left\">麻阳苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">431227</td>\n<td align=\"left\">新晃侗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">431228</td>\n<td align=\"left\">芷江侗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">431229</td>\n<td align=\"left\">靖州苗族侗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">431230</td>\n<td align=\"left\">通道侗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">431281</td>\n<td align=\"left\">洪江市</td>\n</tr>\n<tr>\n<td align=\"left\">431300</td>\n<td align=\"left\">娄底市</td>\n</tr>\n<tr>\n<td align=\"left\">431302</td>\n<td align=\"left\">娄星区</td>\n</tr>\n<tr>\n<td align=\"left\">431321</td>\n<td align=\"left\">双峰县</td>\n</tr>\n<tr>\n<td align=\"left\">431322</td>\n<td align=\"left\">新化县</td>\n</tr>\n<tr>\n<td align=\"left\">431381</td>\n<td align=\"left\">冷水江市</td>\n</tr>\n<tr>\n<td align=\"left\">431382</td>\n<td align=\"left\">涟源市</td>\n</tr>\n<tr>\n<td align=\"left\">433100</td>\n<td align=\"left\">湘西土家族苗族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">433101</td>\n<td align=\"left\">吉首市</td>\n</tr>\n<tr>\n<td align=\"left\">433122</td>\n<td align=\"left\">泸溪县</td>\n</tr>\n<tr>\n<td align=\"left\">433123</td>\n<td align=\"left\">凤凰县</td>\n</tr>\n<tr>\n<td align=\"left\">433124</td>\n<td align=\"left\">花垣县</td>\n</tr>\n<tr>\n<td align=\"left\">433125</td>\n<td align=\"left\">保靖县</td>\n</tr>\n<tr>\n<td align=\"left\">433126</td>\n<td align=\"left\">古丈县</td>\n</tr>\n<tr>\n<td align=\"left\">433127</td>\n<td align=\"left\">永顺县</td>\n</tr>\n<tr>\n<td align=\"left\">433130</td>\n<td align=\"left\">龙山县</td>\n</tr>\n<tr>\n<td align=\"left\">440000</td>\n<td align=\"left\">广东省</td>\n</tr>\n<tr>\n<td align=\"left\">440100</td>\n<td align=\"left\">广州市</td>\n</tr>\n<tr>\n<td align=\"left\">440103</td>\n<td align=\"left\">荔湾区</td>\n</tr>\n<tr>\n<td align=\"left\">440104</td>\n<td align=\"left\">越秀区</td>\n</tr>\n<tr>\n<td align=\"left\">440105</td>\n<td align=\"left\">海珠区</td>\n</tr>\n<tr>\n<td align=\"left\">440106</td>\n<td align=\"left\">天河区</td>\n</tr>\n<tr>\n<td align=\"left\">440111</td>\n<td align=\"left\">白云区</td>\n</tr>\n<tr>\n<td align=\"left\">440112</td>\n<td align=\"left\">黄埔区</td>\n</tr>\n<tr>\n<td align=\"left\">440113</td>\n<td align=\"left\">番禺区</td>\n</tr>\n<tr>\n<td align=\"left\">440114</td>\n<td align=\"left\">花都区</td>\n</tr>\n<tr>\n<td align=\"left\">440115</td>\n<td align=\"left\">南沙区</td>\n</tr>\n<tr>\n<td align=\"left\">440117</td>\n<td align=\"left\">从化区</td>\n</tr>\n<tr>\n<td align=\"left\">440118</td>\n<td align=\"left\">增城区</td>\n</tr>\n<tr>\n<td align=\"left\">440200</td>\n<td align=\"left\">韶关市</td>\n</tr>\n<tr>\n<td align=\"left\">440203</td>\n<td align=\"left\">武江区</td>\n</tr>\n<tr>\n<td align=\"left\">440204</td>\n<td align=\"left\">浈江区</td>\n</tr>\n<tr>\n<td align=\"left\">440205</td>\n<td align=\"left\">曲江区</td>\n</tr>\n<tr>\n<td align=\"left\">440222</td>\n<td align=\"left\">始兴县</td>\n</tr>\n<tr>\n<td align=\"left\">440224</td>\n<td align=\"left\">仁化县</td>\n</tr>\n<tr>\n<td align=\"left\">440229</td>\n<td align=\"left\">翁源县</td>\n</tr>\n<tr>\n<td align=\"left\">440232</td>\n<td align=\"left\">乳源瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">440233</td>\n<td align=\"left\">新丰县</td>\n</tr>\n<tr>\n<td align=\"left\">440281</td>\n<td align=\"left\">乐昌市</td>\n</tr>\n<tr>\n<td align=\"left\">440282</td>\n<td align=\"left\">南雄市</td>\n</tr>\n<tr>\n<td align=\"left\">440300</td>\n<td align=\"left\">深圳市</td>\n</tr>\n<tr>\n<td align=\"left\">440303</td>\n<td align=\"left\">罗湖区</td>\n</tr>\n<tr>\n<td align=\"left\">440304</td>\n<td align=\"left\">福田区</td>\n</tr>\n<tr>\n<td align=\"left\">440305</td>\n<td align=\"left\">南山区</td>\n</tr>\n<tr>\n<td align=\"left\">440306</td>\n<td align=\"left\">宝安区</td>\n</tr>\n<tr>\n<td align=\"left\">440307</td>\n<td align=\"left\">龙岗区</td>\n</tr>\n<tr>\n<td align=\"left\">440308</td>\n<td align=\"left\">盐田区</td>\n</tr>\n<tr>\n<td align=\"left\">440309</td>\n<td align=\"left\">龙华区</td>\n</tr>\n<tr>\n<td align=\"left\">440310</td>\n<td align=\"left\">坪山区</td>\n</tr>\n<tr>\n<td align=\"left\">440311</td>\n<td align=\"left\">光明区</td>\n</tr>\n<tr>\n<td align=\"left\">440400</td>\n<td align=\"left\">珠海市</td>\n</tr>\n<tr>\n<td align=\"left\">440402</td>\n<td align=\"left\">香洲区</td>\n</tr>\n<tr>\n<td align=\"left\">440403</td>\n<td align=\"left\">斗门区</td>\n</tr>\n<tr>\n<td align=\"left\">440404</td>\n<td align=\"left\">金湾区</td>\n</tr>\n<tr>\n<td align=\"left\">440500</td>\n<td align=\"left\">汕头市</td>\n</tr>\n<tr>\n<td align=\"left\">440507</td>\n<td align=\"left\">龙湖区</td>\n</tr>\n<tr>\n<td align=\"left\">440511</td>\n<td align=\"left\">金平区</td>\n</tr>\n<tr>\n<td align=\"left\">440512</td>\n<td align=\"left\">濠江区</td>\n</tr>\n<tr>\n<td align=\"left\">440513</td>\n<td align=\"left\">潮阳区</td>\n</tr>\n<tr>\n<td align=\"left\">440514</td>\n<td align=\"left\">潮南区</td>\n</tr>\n<tr>\n<td align=\"left\">440515</td>\n<td align=\"left\">澄海区</td>\n</tr>\n<tr>\n<td align=\"left\">440523</td>\n<td align=\"left\">南澳县</td>\n</tr>\n<tr>\n<td align=\"left\">440600</td>\n<td align=\"left\">佛山市</td>\n</tr>\n<tr>\n<td align=\"left\">440604</td>\n<td align=\"left\">禅城区</td>\n</tr>\n<tr>\n<td align=\"left\">440605</td>\n<td align=\"left\">南海区</td>\n</tr>\n<tr>\n<td align=\"left\">440606</td>\n<td align=\"left\">顺德区</td>\n</tr>\n<tr>\n<td align=\"left\">440607</td>\n<td align=\"left\">三水区</td>\n</tr>\n<tr>\n<td align=\"left\">440608</td>\n<td align=\"left\">高明区</td>\n</tr>\n<tr>\n<td align=\"left\">440700</td>\n<td align=\"left\">江门市</td>\n</tr>\n<tr>\n<td align=\"left\">440703</td>\n<td align=\"left\">蓬江区</td>\n</tr>\n<tr>\n<td align=\"left\">440704</td>\n<td align=\"left\">江海区</td>\n</tr>\n<tr>\n<td align=\"left\">440705</td>\n<td align=\"left\">新会区</td>\n</tr>\n<tr>\n<td align=\"left\">440781</td>\n<td align=\"left\">台山市</td>\n</tr>\n<tr>\n<td align=\"left\">440783</td>\n<td align=\"left\">开平市</td>\n</tr>\n<tr>\n<td align=\"left\">440784</td>\n<td align=\"left\">鹤山市</td>\n</tr>\n<tr>\n<td align=\"left\">440785</td>\n<td align=\"left\">恩平市</td>\n</tr>\n<tr>\n<td align=\"left\">440800</td>\n<td align=\"left\">湛江市</td>\n</tr>\n<tr>\n<td align=\"left\">440802</td>\n<td align=\"left\">赤坎区</td>\n</tr>\n<tr>\n<td align=\"left\">440803</td>\n<td align=\"left\">霞山区</td>\n</tr>\n<tr>\n<td align=\"left\">440804</td>\n<td align=\"left\">坡头区</td>\n</tr>\n<tr>\n<td align=\"left\">440811</td>\n<td align=\"left\">麻章区</td>\n</tr>\n<tr>\n<td align=\"left\">440823</td>\n<td align=\"left\">遂溪县</td>\n</tr>\n<tr>\n<td align=\"left\">440825</td>\n<td align=\"left\">徐闻县</td>\n</tr>\n<tr>\n<td align=\"left\">440881</td>\n<td align=\"left\">廉江市</td>\n</tr>\n<tr>\n<td align=\"left\">440882</td>\n<td align=\"left\">雷州市</td>\n</tr>\n<tr>\n<td align=\"left\">440883</td>\n<td align=\"left\">吴川市</td>\n</tr>\n<tr>\n<td align=\"left\">440900</td>\n<td align=\"left\">茂名市</td>\n</tr>\n<tr>\n<td align=\"left\">440902</td>\n<td align=\"left\">茂南区</td>\n</tr>\n<tr>\n<td align=\"left\">440904</td>\n<td align=\"left\">电白区</td>\n</tr>\n<tr>\n<td align=\"left\">440981</td>\n<td align=\"left\">高州市</td>\n</tr>\n<tr>\n<td align=\"left\">440982</td>\n<td align=\"left\">化州市</td>\n</tr>\n<tr>\n<td align=\"left\">440983</td>\n<td align=\"left\">信宜市</td>\n</tr>\n<tr>\n<td align=\"left\">441200</td>\n<td align=\"left\">肇庆市</td>\n</tr>\n<tr>\n<td align=\"left\">441202</td>\n<td align=\"left\">端州区</td>\n</tr>\n<tr>\n<td align=\"left\">441203</td>\n<td align=\"left\">鼎湖区</td>\n</tr>\n<tr>\n<td align=\"left\">441204</td>\n<td align=\"left\">高要区</td>\n</tr>\n<tr>\n<td align=\"left\">441223</td>\n<td align=\"left\">广宁县</td>\n</tr>\n<tr>\n<td align=\"left\">441224</td>\n<td align=\"left\">怀集县</td>\n</tr>\n<tr>\n<td align=\"left\">441225</td>\n<td align=\"left\">封开县</td>\n</tr>\n<tr>\n<td align=\"left\">441226</td>\n<td align=\"left\">德庆县</td>\n</tr>\n<tr>\n<td align=\"left\">441284</td>\n<td align=\"left\">四会市</td>\n</tr>\n<tr>\n<td align=\"left\">441300</td>\n<td align=\"left\">惠州市</td>\n</tr>\n<tr>\n<td align=\"left\">441302</td>\n<td align=\"left\">惠城区</td>\n</tr>\n<tr>\n<td align=\"left\">441303</td>\n<td align=\"left\">惠阳区</td>\n</tr>\n<tr>\n<td align=\"left\">441322</td>\n<td align=\"left\">博罗县</td>\n</tr>\n<tr>\n<td align=\"left\">441323</td>\n<td align=\"left\">惠东县</td>\n</tr>\n<tr>\n<td align=\"left\">441324</td>\n<td align=\"left\">龙门县</td>\n</tr>\n<tr>\n<td align=\"left\">441400</td>\n<td align=\"left\">梅州市</td>\n</tr>\n<tr>\n<td align=\"left\">441402</td>\n<td align=\"left\">梅江区</td>\n</tr>\n<tr>\n<td align=\"left\">441403</td>\n<td align=\"left\">梅县区</td>\n</tr>\n<tr>\n<td align=\"left\">441422</td>\n<td align=\"left\">大埔县</td>\n</tr>\n<tr>\n<td align=\"left\">441423</td>\n<td align=\"left\">丰顺县</td>\n</tr>\n<tr>\n<td align=\"left\">441424</td>\n<td align=\"left\">五华县</td>\n</tr>\n<tr>\n<td align=\"left\">441426</td>\n<td align=\"left\">平远县</td>\n</tr>\n<tr>\n<td align=\"left\">441427</td>\n<td align=\"left\">蕉岭县</td>\n</tr>\n<tr>\n<td align=\"left\">441481</td>\n<td align=\"left\">兴宁市</td>\n</tr>\n<tr>\n<td align=\"left\">441500</td>\n<td align=\"left\">汕尾市</td>\n</tr>\n<tr>\n<td align=\"left\">441502</td>\n<td align=\"left\">城区</td>\n</tr>\n<tr>\n<td align=\"left\">441521</td>\n<td align=\"left\">海丰县</td>\n</tr>\n<tr>\n<td align=\"left\">441523</td>\n<td align=\"left\">陆河县</td>\n</tr>\n<tr>\n<td align=\"left\">441581</td>\n<td align=\"left\">陆丰市</td>\n</tr>\n<tr>\n<td align=\"left\">441600</td>\n<td align=\"left\">河源市</td>\n</tr>\n<tr>\n<td align=\"left\">441602</td>\n<td align=\"left\">源城区</td>\n</tr>\n<tr>\n<td align=\"left\">441621</td>\n<td align=\"left\">紫金县</td>\n</tr>\n<tr>\n<td align=\"left\">441622</td>\n<td align=\"left\">龙川县</td>\n</tr>\n<tr>\n<td align=\"left\">441623</td>\n<td align=\"left\">连平县</td>\n</tr>\n<tr>\n<td align=\"left\">441624</td>\n<td align=\"left\">和平县</td>\n</tr>\n<tr>\n<td align=\"left\">441625</td>\n<td align=\"left\">东源县</td>\n</tr>\n<tr>\n<td align=\"left\">441700</td>\n<td align=\"left\">阳江市</td>\n</tr>\n<tr>\n<td align=\"left\">441702</td>\n<td align=\"left\">江城区</td>\n</tr>\n<tr>\n<td align=\"left\">441704</td>\n<td align=\"left\">阳东区</td>\n</tr>\n<tr>\n<td align=\"left\">441721</td>\n<td align=\"left\">阳西县</td>\n</tr>\n<tr>\n<td align=\"left\">441781</td>\n<td align=\"left\">阳春市</td>\n</tr>\n<tr>\n<td align=\"left\">441800</td>\n<td align=\"left\">清远市</td>\n</tr>\n<tr>\n<td align=\"left\">441802</td>\n<td align=\"left\">清城区</td>\n</tr>\n<tr>\n<td align=\"left\">441803</td>\n<td align=\"left\">清新区</td>\n</tr>\n<tr>\n<td align=\"left\">441821</td>\n<td align=\"left\">佛冈县</td>\n</tr>\n<tr>\n<td align=\"left\">441823</td>\n<td align=\"left\">阳山县</td>\n</tr>\n<tr>\n<td align=\"left\">441825</td>\n<td align=\"left\">连山壮族瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">441826</td>\n<td align=\"left\">连南瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">441881</td>\n<td align=\"left\">英德市</td>\n</tr>\n<tr>\n<td align=\"left\">441882</td>\n<td align=\"left\">连州市</td>\n</tr>\n<tr>\n<td align=\"left\">441900</td>\n<td align=\"left\">东莞市</td>\n</tr>\n<tr>\n<td align=\"left\">442000</td>\n<td align=\"left\">中山市</td>\n</tr>\n<tr>\n<td align=\"left\">445100</td>\n<td align=\"left\">潮州市</td>\n</tr>\n<tr>\n<td align=\"left\">445102</td>\n<td align=\"left\">湘桥区</td>\n</tr>\n<tr>\n<td align=\"left\">445103</td>\n<td align=\"left\">潮安区</td>\n</tr>\n<tr>\n<td align=\"left\">445122</td>\n<td align=\"left\">饶平县</td>\n</tr>\n<tr>\n<td align=\"left\">445200</td>\n<td align=\"left\">揭阳市</td>\n</tr>\n<tr>\n<td align=\"left\">445202</td>\n<td align=\"left\">榕城区</td>\n</tr>\n<tr>\n<td align=\"left\">445203</td>\n<td align=\"left\">揭东区</td>\n</tr>\n<tr>\n<td align=\"left\">445222</td>\n<td align=\"left\">揭西县</td>\n</tr>\n<tr>\n<td align=\"left\">445224</td>\n<td align=\"left\">惠来县</td>\n</tr>\n<tr>\n<td align=\"left\">445281</td>\n<td align=\"left\">普宁市</td>\n</tr>\n<tr>\n<td align=\"left\">445300</td>\n<td align=\"left\">云浮市</td>\n</tr>\n<tr>\n<td align=\"left\">445302</td>\n<td align=\"left\">云城区</td>\n</tr>\n<tr>\n<td align=\"left\">445303</td>\n<td align=\"left\">云安区</td>\n</tr>\n<tr>\n<td align=\"left\">445321</td>\n<td align=\"left\">新兴县</td>\n</tr>\n<tr>\n<td align=\"left\">445322</td>\n<td align=\"left\">郁南县</td>\n</tr>\n<tr>\n<td align=\"left\">445381</td>\n<td align=\"left\">罗定市</td>\n</tr>\n<tr>\n<td align=\"left\">450000</td>\n<td align=\"left\">广西壮族自治区</td>\n</tr>\n<tr>\n<td align=\"left\">450100</td>\n<td align=\"left\">南宁市</td>\n</tr>\n<tr>\n<td align=\"left\">450102</td>\n<td align=\"left\">兴宁区</td>\n</tr>\n<tr>\n<td align=\"left\">450103</td>\n<td align=\"left\">青秀区</td>\n</tr>\n<tr>\n<td align=\"left\">450105</td>\n<td align=\"left\">江南区</td>\n</tr>\n<tr>\n<td align=\"left\">450107</td>\n<td align=\"left\">西乡塘区</td>\n</tr>\n<tr>\n<td align=\"left\">450108</td>\n<td align=\"left\">良庆区</td>\n</tr>\n<tr>\n<td align=\"left\">450109</td>\n<td align=\"left\">邕宁区</td>\n</tr>\n<tr>\n<td align=\"left\">450110</td>\n<td align=\"left\">武鸣区</td>\n</tr>\n<tr>\n<td align=\"left\">450123</td>\n<td align=\"left\">隆安县</td>\n</tr>\n<tr>\n<td align=\"left\">450124</td>\n<td align=\"left\">马山县</td>\n</tr>\n<tr>\n<td align=\"left\">450125</td>\n<td align=\"left\">上林县</td>\n</tr>\n<tr>\n<td align=\"left\">450126</td>\n<td align=\"left\">宾阳县</td>\n</tr>\n<tr>\n<td align=\"left\">450127</td>\n<td align=\"left\">横县</td>\n</tr>\n<tr>\n<td align=\"left\">450200</td>\n<td align=\"left\">柳州市</td>\n</tr>\n<tr>\n<td align=\"left\">450202</td>\n<td align=\"left\">城中区</td>\n</tr>\n<tr>\n<td align=\"left\">450203</td>\n<td align=\"left\">鱼峰区</td>\n</tr>\n<tr>\n<td align=\"left\">450204</td>\n<td align=\"left\">柳南区</td>\n</tr>\n<tr>\n<td align=\"left\">450205</td>\n<td align=\"left\">柳北区</td>\n</tr>\n<tr>\n<td align=\"left\">450206</td>\n<td align=\"left\">柳江区</td>\n</tr>\n<tr>\n<td align=\"left\">450222</td>\n<td align=\"left\">柳城县</td>\n</tr>\n<tr>\n<td align=\"left\">450223</td>\n<td align=\"left\">鹿寨县</td>\n</tr>\n<tr>\n<td align=\"left\">450224</td>\n<td align=\"left\">融安县</td>\n</tr>\n<tr>\n<td align=\"left\">450225</td>\n<td align=\"left\">融水苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">450226</td>\n<td align=\"left\">三江侗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">450300</td>\n<td align=\"left\">桂林市</td>\n</tr>\n<tr>\n<td align=\"left\">450302</td>\n<td align=\"left\">秀峰区</td>\n</tr>\n<tr>\n<td align=\"left\">450303</td>\n<td align=\"left\">叠彩区</td>\n</tr>\n<tr>\n<td align=\"left\">450304</td>\n<td align=\"left\">象山区</td>\n</tr>\n<tr>\n<td align=\"left\">450305</td>\n<td align=\"left\">七星区</td>\n</tr>\n<tr>\n<td align=\"left\">450311</td>\n<td align=\"left\">雁山区</td>\n</tr>\n<tr>\n<td align=\"left\">450312</td>\n<td align=\"left\">临桂区</td>\n</tr>\n<tr>\n<td align=\"left\">450321</td>\n<td align=\"left\">阳朔县</td>\n</tr>\n<tr>\n<td align=\"left\">450323</td>\n<td align=\"left\">灵川县</td>\n</tr>\n<tr>\n<td align=\"left\">450324</td>\n<td align=\"left\">全州县</td>\n</tr>\n<tr>\n<td align=\"left\">450325</td>\n<td align=\"left\">兴安县</td>\n</tr>\n<tr>\n<td align=\"left\">450326</td>\n<td align=\"left\">永福县</td>\n</tr>\n<tr>\n<td align=\"left\">450327</td>\n<td align=\"left\">灌阳县</td>\n</tr>\n<tr>\n<td align=\"left\">450328</td>\n<td align=\"left\">龙胜各族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">450329</td>\n<td align=\"left\">资源县</td>\n</tr>\n<tr>\n<td align=\"left\">450330</td>\n<td align=\"left\">平乐县</td>\n</tr>\n<tr>\n<td align=\"left\">450381</td>\n<td align=\"left\">荔浦市</td>\n</tr>\n<tr>\n<td align=\"left\">450332</td>\n<td align=\"left\">恭城瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">450400</td>\n<td align=\"left\">梧州市</td>\n</tr>\n<tr>\n<td align=\"left\">450403</td>\n<td align=\"left\">万秀区</td>\n</tr>\n<tr>\n<td align=\"left\">450405</td>\n<td align=\"left\">长洲区</td>\n</tr>\n<tr>\n<td align=\"left\">450406</td>\n<td align=\"left\">龙圩区</td>\n</tr>\n<tr>\n<td align=\"left\">450421</td>\n<td align=\"left\">苍梧县</td>\n</tr>\n<tr>\n<td align=\"left\">450422</td>\n<td align=\"left\">藤县</td>\n</tr>\n<tr>\n<td align=\"left\">450423</td>\n<td align=\"left\">蒙山县</td>\n</tr>\n<tr>\n<td align=\"left\">450481</td>\n<td align=\"left\">岑溪市</td>\n</tr>\n<tr>\n<td align=\"left\">450500</td>\n<td align=\"left\">北海市</td>\n</tr>\n<tr>\n<td align=\"left\">450502</td>\n<td align=\"left\">海城区</td>\n</tr>\n<tr>\n<td align=\"left\">450503</td>\n<td align=\"left\">银海区</td>\n</tr>\n<tr>\n<td align=\"left\">450512</td>\n<td align=\"left\">铁山港区</td>\n</tr>\n<tr>\n<td align=\"left\">450521</td>\n<td align=\"left\">合浦县</td>\n</tr>\n<tr>\n<td align=\"left\">450600</td>\n<td align=\"left\">防城港市</td>\n</tr>\n<tr>\n<td align=\"left\">450602</td>\n<td align=\"left\">港口区</td>\n</tr>\n<tr>\n<td align=\"left\">450603</td>\n<td align=\"left\">防城区</td>\n</tr>\n<tr>\n<td align=\"left\">450621</td>\n<td align=\"left\">上思县</td>\n</tr>\n<tr>\n<td align=\"left\">450681</td>\n<td align=\"left\">东兴市</td>\n</tr>\n<tr>\n<td align=\"left\">450700</td>\n<td align=\"left\">钦州市</td>\n</tr>\n<tr>\n<td align=\"left\">450702</td>\n<td align=\"left\">钦南区</td>\n</tr>\n<tr>\n<td align=\"left\">450703</td>\n<td align=\"left\">钦北区</td>\n</tr>\n<tr>\n<td align=\"left\">450721</td>\n<td align=\"left\">灵山县</td>\n</tr>\n<tr>\n<td align=\"left\">450722</td>\n<td align=\"left\">浦北县</td>\n</tr>\n<tr>\n<td align=\"left\">450800</td>\n<td align=\"left\">贵港市</td>\n</tr>\n<tr>\n<td align=\"left\">450802</td>\n<td align=\"left\">港北区</td>\n</tr>\n<tr>\n<td align=\"left\">450803</td>\n<td align=\"left\">港南区</td>\n</tr>\n<tr>\n<td align=\"left\">450804</td>\n<td align=\"left\">覃塘区</td>\n</tr>\n<tr>\n<td align=\"left\">450821</td>\n<td align=\"left\">平南县</td>\n</tr>\n<tr>\n<td align=\"left\">450881</td>\n<td align=\"left\">桂平市</td>\n</tr>\n<tr>\n<td align=\"left\">450900</td>\n<td align=\"left\">玉林市</td>\n</tr>\n<tr>\n<td align=\"left\">450902</td>\n<td align=\"left\">玉州区</td>\n</tr>\n<tr>\n<td align=\"left\">450903</td>\n<td align=\"left\">福绵区</td>\n</tr>\n<tr>\n<td align=\"left\">450921</td>\n<td align=\"left\">容县</td>\n</tr>\n<tr>\n<td align=\"left\">450922</td>\n<td align=\"left\">陆川县</td>\n</tr>\n<tr>\n<td align=\"left\">450923</td>\n<td align=\"left\">博白县</td>\n</tr>\n<tr>\n<td align=\"left\">450924</td>\n<td align=\"left\">兴业县</td>\n</tr>\n<tr>\n<td align=\"left\">450981</td>\n<td align=\"left\">北流市</td>\n</tr>\n<tr>\n<td align=\"left\">451000</td>\n<td align=\"left\">百色市</td>\n</tr>\n<tr>\n<td align=\"left\">451002</td>\n<td align=\"left\">右江区</td>\n</tr>\n<tr>\n<td align=\"left\">451003</td>\n<td align=\"left\">田阳区</td>\n</tr>\n<tr>\n<td align=\"left\">451022</td>\n<td align=\"left\">田东县</td>\n</tr>\n<tr>\n<td align=\"left\">451024</td>\n<td align=\"left\">德保县</td>\n</tr>\n<tr>\n<td align=\"left\">451026</td>\n<td align=\"left\">那坡县</td>\n</tr>\n<tr>\n<td align=\"left\">451027</td>\n<td align=\"left\">凌云县</td>\n</tr>\n<tr>\n<td align=\"left\">451028</td>\n<td align=\"left\">乐业县</td>\n</tr>\n<tr>\n<td align=\"left\">451029</td>\n<td align=\"left\">田林县</td>\n</tr>\n<tr>\n<td align=\"left\">451030</td>\n<td align=\"left\">西林县</td>\n</tr>\n<tr>\n<td align=\"left\">451031</td>\n<td align=\"left\">隆林各族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451081</td>\n<td align=\"left\">靖西市</td>\n</tr>\n<tr>\n<td align=\"left\">451082</td>\n<td align=\"left\">平果市</td>\n</tr>\n<tr>\n<td align=\"left\">451100</td>\n<td align=\"left\">贺州市</td>\n</tr>\n<tr>\n<td align=\"left\">451102</td>\n<td align=\"left\">八步区</td>\n</tr>\n<tr>\n<td align=\"left\">451103</td>\n<td align=\"left\">平桂区</td>\n</tr>\n<tr>\n<td align=\"left\">451121</td>\n<td align=\"left\">昭平县</td>\n</tr>\n<tr>\n<td align=\"left\">451122</td>\n<td align=\"left\">钟山县</td>\n</tr>\n<tr>\n<td align=\"left\">451123</td>\n<td align=\"left\">富川瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451200</td>\n<td align=\"left\">河池市</td>\n</tr>\n<tr>\n<td align=\"left\">451202</td>\n<td align=\"left\">金城江区</td>\n</tr>\n<tr>\n<td align=\"left\">451203</td>\n<td align=\"left\">宜州区</td>\n</tr>\n<tr>\n<td align=\"left\">451221</td>\n<td align=\"left\">南丹县</td>\n</tr>\n<tr>\n<td align=\"left\">451222</td>\n<td align=\"left\">天峨县</td>\n</tr>\n<tr>\n<td align=\"left\">451223</td>\n<td align=\"left\">凤山县</td>\n</tr>\n<tr>\n<td align=\"left\">451224</td>\n<td align=\"left\">东兰县</td>\n</tr>\n<tr>\n<td align=\"left\">451225</td>\n<td align=\"left\">罗城仫佬族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451226</td>\n<td align=\"left\">环江毛南族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451227</td>\n<td align=\"left\">巴马瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451228</td>\n<td align=\"left\">都安瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451229</td>\n<td align=\"left\">大化瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451300</td>\n<td align=\"left\">来宾市</td>\n</tr>\n<tr>\n<td align=\"left\">451302</td>\n<td align=\"left\">兴宾区</td>\n</tr>\n<tr>\n<td align=\"left\">451321</td>\n<td align=\"left\">忻城县</td>\n</tr>\n<tr>\n<td align=\"left\">451322</td>\n<td align=\"left\">象州县</td>\n</tr>\n<tr>\n<td align=\"left\">451323</td>\n<td align=\"left\">武宣县</td>\n</tr>\n<tr>\n<td align=\"left\">451324</td>\n<td align=\"left\">金秀瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">451381</td>\n<td align=\"left\">合山市</td>\n</tr>\n<tr>\n<td align=\"left\">451400</td>\n<td align=\"left\">崇左市</td>\n</tr>\n<tr>\n<td align=\"left\">451402</td>\n<td align=\"left\">江州区</td>\n</tr>\n<tr>\n<td align=\"left\">451421</td>\n<td align=\"left\">扶绥县</td>\n</tr>\n<tr>\n<td align=\"left\">451422</td>\n<td align=\"left\">宁明县</td>\n</tr>\n<tr>\n<td align=\"left\">451423</td>\n<td align=\"left\">龙州县</td>\n</tr>\n<tr>\n<td align=\"left\">451424</td>\n<td align=\"left\">大新县</td>\n</tr>\n<tr>\n<td align=\"left\">451425</td>\n<td align=\"left\">天等县</td>\n</tr>\n<tr>\n<td align=\"left\">451481</td>\n<td align=\"left\">凭祥市</td>\n</tr>\n<tr>\n<td align=\"left\">460000</td>\n<td align=\"left\">海南省</td>\n</tr>\n<tr>\n<td align=\"left\">460100</td>\n<td align=\"left\">海口市</td>\n</tr>\n<tr>\n<td align=\"left\">460105</td>\n<td align=\"left\">秀英区</td>\n</tr>\n<tr>\n<td align=\"left\">460106</td>\n<td align=\"left\">龙华区</td>\n</tr>\n<tr>\n<td align=\"left\">460107</td>\n<td align=\"left\">琼山区</td>\n</tr>\n<tr>\n<td align=\"left\">460108</td>\n<td align=\"left\">美兰区</td>\n</tr>\n<tr>\n<td align=\"left\">460200</td>\n<td align=\"left\">三亚市</td>\n</tr>\n<tr>\n<td align=\"left\">460202</td>\n<td align=\"left\">海棠区</td>\n</tr>\n<tr>\n<td align=\"left\">460203</td>\n<td align=\"left\">吉阳区</td>\n</tr>\n<tr>\n<td align=\"left\">460204</td>\n<td align=\"left\">天涯区</td>\n</tr>\n<tr>\n<td align=\"left\">460205</td>\n<td align=\"left\">崖州区</td>\n</tr>\n<tr>\n<td align=\"left\">460300</td>\n<td align=\"left\">三沙市</td>\n</tr>\n<tr>\n<td align=\"left\">460400</td>\n<td align=\"left\">儋州市</td>\n</tr>\n<tr>\n<td align=\"left\">469001</td>\n<td align=\"left\">五指山市</td>\n</tr>\n<tr>\n<td align=\"left\">469002</td>\n<td align=\"left\">琼海市</td>\n</tr>\n<tr>\n<td align=\"left\">469005</td>\n<td align=\"left\">文昌市</td>\n</tr>\n<tr>\n<td align=\"left\">469006</td>\n<td align=\"left\">万宁市</td>\n</tr>\n<tr>\n<td align=\"left\">469007</td>\n<td align=\"left\">东方市</td>\n</tr>\n<tr>\n<td align=\"left\">469021</td>\n<td align=\"left\">定安县</td>\n</tr>\n<tr>\n<td align=\"left\">469022</td>\n<td align=\"left\">屯昌县</td>\n</tr>\n<tr>\n<td align=\"left\">469023</td>\n<td align=\"left\">澄迈县</td>\n</tr>\n<tr>\n<td align=\"left\">469024</td>\n<td align=\"left\">临高县</td>\n</tr>\n<tr>\n<td align=\"left\">469025</td>\n<td align=\"left\">白沙黎族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">469026</td>\n<td align=\"left\">昌江黎族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">469027</td>\n<td align=\"left\">乐东黎族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">469028</td>\n<td align=\"left\">陵水黎族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">469029</td>\n<td align=\"left\">保亭黎族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">469030</td>\n<td align=\"left\">琼中黎族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">500000</td>\n<td align=\"left\">重庆市</td>\n</tr>\n<tr>\n<td align=\"left\">500101</td>\n<td align=\"left\">万州区</td>\n</tr>\n<tr>\n<td align=\"left\">500102</td>\n<td align=\"left\">涪陵区</td>\n</tr>\n<tr>\n<td align=\"left\">500103</td>\n<td align=\"left\">渝中区</td>\n</tr>\n<tr>\n<td align=\"left\">500104</td>\n<td align=\"left\">大渡口区</td>\n</tr>\n<tr>\n<td align=\"left\">500105</td>\n<td align=\"left\">江北区</td>\n</tr>\n<tr>\n<td align=\"left\">500106</td>\n<td align=\"left\">沙坪坝区</td>\n</tr>\n<tr>\n<td align=\"left\">500107</td>\n<td align=\"left\">九龙坡区</td>\n</tr>\n<tr>\n<td align=\"left\">500108</td>\n<td align=\"left\">南岸区</td>\n</tr>\n<tr>\n<td align=\"left\">500109</td>\n<td align=\"left\">北碚区</td>\n</tr>\n<tr>\n<td align=\"left\">500110</td>\n<td align=\"left\">綦江区</td>\n</tr>\n<tr>\n<td align=\"left\">500111</td>\n<td align=\"left\">大足区</td>\n</tr>\n<tr>\n<td align=\"left\">500112</td>\n<td align=\"left\">渝北区</td>\n</tr>\n<tr>\n<td align=\"left\">500113</td>\n<td align=\"left\">巴南区</td>\n</tr>\n<tr>\n<td align=\"left\">500114</td>\n<td align=\"left\">黔江区</td>\n</tr>\n<tr>\n<td align=\"left\">500115</td>\n<td align=\"left\">长寿区</td>\n</tr>\n<tr>\n<td align=\"left\">500116</td>\n<td align=\"left\">江津区</td>\n</tr>\n<tr>\n<td align=\"left\">500117</td>\n<td align=\"left\">合川区</td>\n</tr>\n<tr>\n<td align=\"left\">500118</td>\n<td align=\"left\">永川区</td>\n</tr>\n<tr>\n<td align=\"left\">500119</td>\n<td align=\"left\">南川区</td>\n</tr>\n<tr>\n<td align=\"left\">500120</td>\n<td align=\"left\">璧山区</td>\n</tr>\n<tr>\n<td align=\"left\">500151</td>\n<td align=\"left\">铜梁区</td>\n</tr>\n<tr>\n<td align=\"left\">500152</td>\n<td align=\"left\">潼南区</td>\n</tr>\n<tr>\n<td align=\"left\">500153</td>\n<td align=\"left\">荣昌区</td>\n</tr>\n<tr>\n<td align=\"left\">500154</td>\n<td align=\"left\">开州区</td>\n</tr>\n<tr>\n<td align=\"left\">500155</td>\n<td align=\"left\">梁平区</td>\n</tr>\n<tr>\n<td align=\"left\">500156</td>\n<td align=\"left\">武隆区</td>\n</tr>\n<tr>\n<td align=\"left\">500229</td>\n<td align=\"left\">城口县</td>\n</tr>\n<tr>\n<td align=\"left\">500230</td>\n<td align=\"left\">丰都县</td>\n</tr>\n<tr>\n<td align=\"left\">500231</td>\n<td align=\"left\">垫江县</td>\n</tr>\n<tr>\n<td align=\"left\">500233</td>\n<td align=\"left\">忠县</td>\n</tr>\n<tr>\n<td align=\"left\">500235</td>\n<td align=\"left\">云阳县</td>\n</tr>\n<tr>\n<td align=\"left\">500236</td>\n<td align=\"left\">奉节县</td>\n</tr>\n<tr>\n<td align=\"left\">500237</td>\n<td align=\"left\">巫山县</td>\n</tr>\n<tr>\n<td align=\"left\">500238</td>\n<td align=\"left\">巫溪县</td>\n</tr>\n<tr>\n<td align=\"left\">500240</td>\n<td align=\"left\">石柱土家族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">500241</td>\n<td align=\"left\">秀山土家族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">500242</td>\n<td align=\"left\">酉阳土家族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">500243</td>\n<td align=\"left\">彭水苗族土家族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">510000</td>\n<td align=\"left\">四川省</td>\n</tr>\n<tr>\n<td align=\"left\">510100</td>\n<td align=\"left\">成都市</td>\n</tr>\n<tr>\n<td align=\"left\">510104</td>\n<td align=\"left\">锦江区</td>\n</tr>\n<tr>\n<td align=\"left\">510105</td>\n<td align=\"left\">青羊区</td>\n</tr>\n<tr>\n<td align=\"left\">510106</td>\n<td align=\"left\">金牛区</td>\n</tr>\n<tr>\n<td align=\"left\">510107</td>\n<td align=\"left\">武侯区</td>\n</tr>\n<tr>\n<td align=\"left\">510108</td>\n<td align=\"left\">成华区</td>\n</tr>\n<tr>\n<td align=\"left\">510112</td>\n<td align=\"left\">龙泉驿区</td>\n</tr>\n<tr>\n<td align=\"left\">510113</td>\n<td align=\"left\">青白江区</td>\n</tr>\n<tr>\n<td align=\"left\">510114</td>\n<td align=\"left\">新都区</td>\n</tr>\n<tr>\n<td align=\"left\">510115</td>\n<td align=\"left\">温江区</td>\n</tr>\n<tr>\n<td align=\"left\">510116</td>\n<td align=\"left\">双流区</td>\n</tr>\n<tr>\n<td align=\"left\">510117</td>\n<td align=\"left\">郫都区</td>\n</tr>\n<tr>\n<td align=\"left\">510121</td>\n<td align=\"left\">金堂县</td>\n</tr>\n<tr>\n<td align=\"left\">510129</td>\n<td align=\"left\">大邑县</td>\n</tr>\n<tr>\n<td align=\"left\">510131</td>\n<td align=\"left\">蒲江县</td>\n</tr>\n<tr>\n<td align=\"left\">510132</td>\n<td align=\"left\">新津县</td>\n</tr>\n<tr>\n<td align=\"left\">510181</td>\n<td align=\"left\">都江堰市</td>\n</tr>\n<tr>\n<td align=\"left\">510182</td>\n<td align=\"left\">彭州市</td>\n</tr>\n<tr>\n<td align=\"left\">510183</td>\n<td align=\"left\">邛崃市</td>\n</tr>\n<tr>\n<td align=\"left\">510184</td>\n<td align=\"left\">崇州市</td>\n</tr>\n<tr>\n<td align=\"left\">510185</td>\n<td align=\"left\">简阳市</td>\n</tr>\n<tr>\n<td align=\"left\">510300</td>\n<td align=\"left\">自贡市</td>\n</tr>\n<tr>\n<td align=\"left\">510302</td>\n<td align=\"left\">自流井区</td>\n</tr>\n<tr>\n<td align=\"left\">510303</td>\n<td align=\"left\">贡井区</td>\n</tr>\n<tr>\n<td align=\"left\">510304</td>\n<td align=\"left\">大安区</td>\n</tr>\n<tr>\n<td align=\"left\">510311</td>\n<td align=\"left\">沿滩区</td>\n</tr>\n<tr>\n<td align=\"left\">510321</td>\n<td align=\"left\">荣县</td>\n</tr>\n<tr>\n<td align=\"left\">510322</td>\n<td align=\"left\">富顺县</td>\n</tr>\n<tr>\n<td align=\"left\">510400</td>\n<td align=\"left\">攀枝花市</td>\n</tr>\n<tr>\n<td align=\"left\">510402</td>\n<td align=\"left\">东区</td>\n</tr>\n<tr>\n<td align=\"left\">510403</td>\n<td align=\"left\">西区</td>\n</tr>\n<tr>\n<td align=\"left\">510411</td>\n<td align=\"left\">仁和区</td>\n</tr>\n<tr>\n<td align=\"left\">510421</td>\n<td align=\"left\">米易县</td>\n</tr>\n<tr>\n<td align=\"left\">510422</td>\n<td align=\"left\">盐边县</td>\n</tr>\n<tr>\n<td align=\"left\">510500</td>\n<td align=\"left\">泸州市</td>\n</tr>\n<tr>\n<td align=\"left\">510502</td>\n<td align=\"left\">江阳区</td>\n</tr>\n<tr>\n<td align=\"left\">510503</td>\n<td align=\"left\">纳溪区</td>\n</tr>\n<tr>\n<td align=\"left\">510504</td>\n<td align=\"left\">龙马潭区</td>\n</tr>\n<tr>\n<td align=\"left\">510521</td>\n<td align=\"left\">泸县</td>\n</tr>\n<tr>\n<td align=\"left\">510522</td>\n<td align=\"left\">合江县</td>\n</tr>\n<tr>\n<td align=\"left\">510524</td>\n<td align=\"left\">叙永县</td>\n</tr>\n<tr>\n<td align=\"left\">510525</td>\n<td align=\"left\">古蔺县</td>\n</tr>\n<tr>\n<td align=\"left\">510600</td>\n<td align=\"left\">德阳市</td>\n</tr>\n<tr>\n<td align=\"left\">510603</td>\n<td align=\"left\">旌阳区</td>\n</tr>\n<tr>\n<td align=\"left\">510604</td>\n<td align=\"left\">罗江区</td>\n</tr>\n<tr>\n<td align=\"left\">510623</td>\n<td align=\"left\">中江县</td>\n</tr>\n<tr>\n<td align=\"left\">510681</td>\n<td align=\"left\">广汉市</td>\n</tr>\n<tr>\n<td align=\"left\">510682</td>\n<td align=\"left\">什邡市</td>\n</tr>\n<tr>\n<td align=\"left\">510683</td>\n<td align=\"left\">绵竹市</td>\n</tr>\n<tr>\n<td align=\"left\">510700</td>\n<td align=\"left\">绵阳市</td>\n</tr>\n<tr>\n<td align=\"left\">510703</td>\n<td align=\"left\">涪城区</td>\n</tr>\n<tr>\n<td align=\"left\">510704</td>\n<td align=\"left\">游仙区</td>\n</tr>\n<tr>\n<td align=\"left\">510705</td>\n<td align=\"left\">安州区</td>\n</tr>\n<tr>\n<td align=\"left\">510722</td>\n<td align=\"left\">三台县</td>\n</tr>\n<tr>\n<td align=\"left\">510723</td>\n<td align=\"left\">盐亭县</td>\n</tr>\n<tr>\n<td align=\"left\">510725</td>\n<td align=\"left\">梓潼县</td>\n</tr>\n<tr>\n<td align=\"left\">510726</td>\n<td align=\"left\">北川羌族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">510727</td>\n<td align=\"left\">平武县</td>\n</tr>\n<tr>\n<td align=\"left\">510781</td>\n<td align=\"left\">江油市</td>\n</tr>\n<tr>\n<td align=\"left\">510800</td>\n<td align=\"left\">广元市</td>\n</tr>\n<tr>\n<td align=\"left\">510802</td>\n<td align=\"left\">利州区</td>\n</tr>\n<tr>\n<td align=\"left\">510811</td>\n<td align=\"left\">昭化区</td>\n</tr>\n<tr>\n<td align=\"left\">510812</td>\n<td align=\"left\">朝天区</td>\n</tr>\n<tr>\n<td align=\"left\">510821</td>\n<td align=\"left\">旺苍县</td>\n</tr>\n<tr>\n<td align=\"left\">510822</td>\n<td align=\"left\">青川县</td>\n</tr>\n<tr>\n<td align=\"left\">510823</td>\n<td align=\"left\">剑阁县</td>\n</tr>\n<tr>\n<td align=\"left\">510824</td>\n<td align=\"left\">苍溪县</td>\n</tr>\n<tr>\n<td align=\"left\">510900</td>\n<td align=\"left\">遂宁市</td>\n</tr>\n<tr>\n<td align=\"left\">510903</td>\n<td align=\"left\">船山区</td>\n</tr>\n<tr>\n<td align=\"left\">510904</td>\n<td align=\"left\">安居区</td>\n</tr>\n<tr>\n<td align=\"left\">510921</td>\n<td align=\"left\">蓬溪县</td>\n</tr>\n<tr>\n<td align=\"left\">510923</td>\n<td align=\"left\">大英县</td>\n</tr>\n<tr>\n<td align=\"left\">510981</td>\n<td align=\"left\">射洪市</td>\n</tr>\n<tr>\n<td align=\"left\">511000</td>\n<td align=\"left\">内江市</td>\n</tr>\n<tr>\n<td align=\"left\">511002</td>\n<td align=\"left\">市中区</td>\n</tr>\n<tr>\n<td align=\"left\">511011</td>\n<td align=\"left\">东兴区</td>\n</tr>\n<tr>\n<td align=\"left\">511024</td>\n<td align=\"left\">威远县</td>\n</tr>\n<tr>\n<td align=\"left\">511025</td>\n<td align=\"left\">资中县</td>\n</tr>\n<tr>\n<td align=\"left\">511083</td>\n<td align=\"left\">隆昌市</td>\n</tr>\n<tr>\n<td align=\"left\">511100</td>\n<td align=\"left\">乐山市</td>\n</tr>\n<tr>\n<td align=\"left\">511102</td>\n<td align=\"left\">市中区</td>\n</tr>\n<tr>\n<td align=\"left\">511111</td>\n<td align=\"left\">沙湾区</td>\n</tr>\n<tr>\n<td align=\"left\">511112</td>\n<td align=\"left\">五通桥区</td>\n</tr>\n<tr>\n<td align=\"left\">511113</td>\n<td align=\"left\">金口河区</td>\n</tr>\n<tr>\n<td align=\"left\">511123</td>\n<td align=\"left\">犍为县</td>\n</tr>\n<tr>\n<td align=\"left\">511124</td>\n<td align=\"left\">井研县</td>\n</tr>\n<tr>\n<td align=\"left\">511126</td>\n<td align=\"left\">夹江县</td>\n</tr>\n<tr>\n<td align=\"left\">511129</td>\n<td align=\"left\">沐川县</td>\n</tr>\n<tr>\n<td align=\"left\">511132</td>\n<td align=\"left\">峨边彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">511133</td>\n<td align=\"left\">马边彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">511181</td>\n<td align=\"left\">峨眉山市</td>\n</tr>\n<tr>\n<td align=\"left\">511300</td>\n<td align=\"left\">南充市</td>\n</tr>\n<tr>\n<td align=\"left\">511302</td>\n<td align=\"left\">顺庆区</td>\n</tr>\n<tr>\n<td align=\"left\">511303</td>\n<td align=\"left\">高坪区</td>\n</tr>\n<tr>\n<td align=\"left\">511304</td>\n<td align=\"left\">嘉陵区</td>\n</tr>\n<tr>\n<td align=\"left\">511321</td>\n<td align=\"left\">南部县</td>\n</tr>\n<tr>\n<td align=\"left\">511322</td>\n<td align=\"left\">营山县</td>\n</tr>\n<tr>\n<td align=\"left\">511323</td>\n<td align=\"left\">蓬安县</td>\n</tr>\n<tr>\n<td align=\"left\">511324</td>\n<td align=\"left\">仪陇县</td>\n</tr>\n<tr>\n<td align=\"left\">511325</td>\n<td align=\"left\">西充县</td>\n</tr>\n<tr>\n<td align=\"left\">511381</td>\n<td align=\"left\">阆中市</td>\n</tr>\n<tr>\n<td align=\"left\">511400</td>\n<td align=\"left\">眉山市</td>\n</tr>\n<tr>\n<td align=\"left\">511402</td>\n<td align=\"left\">东坡区</td>\n</tr>\n<tr>\n<td align=\"left\">511403</td>\n<td align=\"left\">彭山区</td>\n</tr>\n<tr>\n<td align=\"left\">511421</td>\n<td align=\"left\">仁寿县</td>\n</tr>\n<tr>\n<td align=\"left\">511423</td>\n<td align=\"left\">洪雅县</td>\n</tr>\n<tr>\n<td align=\"left\">511424</td>\n<td align=\"left\">丹棱县</td>\n</tr>\n<tr>\n<td align=\"left\">511425</td>\n<td align=\"left\">青神县</td>\n</tr>\n<tr>\n<td align=\"left\">511500</td>\n<td align=\"left\">宜宾市</td>\n</tr>\n<tr>\n<td align=\"left\">511502</td>\n<td align=\"left\">翠屏区</td>\n</tr>\n<tr>\n<td align=\"left\">511503</td>\n<td align=\"left\">南溪区</td>\n</tr>\n<tr>\n<td align=\"left\">511504</td>\n<td align=\"left\">叙州区</td>\n</tr>\n<tr>\n<td align=\"left\">511523</td>\n<td align=\"left\">江安县</td>\n</tr>\n<tr>\n<td align=\"left\">511524</td>\n<td align=\"left\">长宁县</td>\n</tr>\n<tr>\n<td align=\"left\">511525</td>\n<td align=\"left\">高县</td>\n</tr>\n<tr>\n<td align=\"left\">511526</td>\n<td align=\"left\">珙县</td>\n</tr>\n<tr>\n<td align=\"left\">511527</td>\n<td align=\"left\">筠连县</td>\n</tr>\n<tr>\n<td align=\"left\">511528</td>\n<td align=\"left\">兴文县</td>\n</tr>\n<tr>\n<td align=\"left\">511529</td>\n<td align=\"left\">屏山县</td>\n</tr>\n<tr>\n<td align=\"left\">511600</td>\n<td align=\"left\">广安市</td>\n</tr>\n<tr>\n<td align=\"left\">511602</td>\n<td align=\"left\">广安区</td>\n</tr>\n<tr>\n<td align=\"left\">511603</td>\n<td align=\"left\">前锋区</td>\n</tr>\n<tr>\n<td align=\"left\">511621</td>\n<td align=\"left\">岳池县</td>\n</tr>\n<tr>\n<td align=\"left\">511622</td>\n<td align=\"left\">武胜县</td>\n</tr>\n<tr>\n<td align=\"left\">511623</td>\n<td align=\"left\">邻水县</td>\n</tr>\n<tr>\n<td align=\"left\">511681</td>\n<td align=\"left\">华蓥市</td>\n</tr>\n<tr>\n<td align=\"left\">511700</td>\n<td align=\"left\">达州市</td>\n</tr>\n<tr>\n<td align=\"left\">511702</td>\n<td align=\"left\">通川区</td>\n</tr>\n<tr>\n<td align=\"left\">511703</td>\n<td align=\"left\">达川区</td>\n</tr>\n<tr>\n<td align=\"left\">511722</td>\n<td align=\"left\">宣汉县</td>\n</tr>\n<tr>\n<td align=\"left\">511723</td>\n<td align=\"left\">开江县</td>\n</tr>\n<tr>\n<td align=\"left\">511724</td>\n<td align=\"left\">大竹县</td>\n</tr>\n<tr>\n<td align=\"left\">511725</td>\n<td align=\"left\">渠县</td>\n</tr>\n<tr>\n<td align=\"left\">511781</td>\n<td align=\"left\">万源市</td>\n</tr>\n<tr>\n<td align=\"left\">511800</td>\n<td align=\"left\">雅安市</td>\n</tr>\n<tr>\n<td align=\"left\">511802</td>\n<td align=\"left\">雨城区</td>\n</tr>\n<tr>\n<td align=\"left\">511803</td>\n<td align=\"left\">名山区</td>\n</tr>\n<tr>\n<td align=\"left\">511822</td>\n<td align=\"left\">荥经县</td>\n</tr>\n<tr>\n<td align=\"left\">511823</td>\n<td align=\"left\">汉源县</td>\n</tr>\n<tr>\n<td align=\"left\">511824</td>\n<td align=\"left\">石棉县</td>\n</tr>\n<tr>\n<td align=\"left\">511825</td>\n<td align=\"left\">天全县</td>\n</tr>\n<tr>\n<td align=\"left\">511826</td>\n<td align=\"left\">芦山县</td>\n</tr>\n<tr>\n<td align=\"left\">511827</td>\n<td align=\"left\">宝兴县</td>\n</tr>\n<tr>\n<td align=\"left\">511900</td>\n<td align=\"left\">巴中市</td>\n</tr>\n<tr>\n<td align=\"left\">511902</td>\n<td align=\"left\">巴州区</td>\n</tr>\n<tr>\n<td align=\"left\">511903</td>\n<td align=\"left\">恩阳区</td>\n</tr>\n<tr>\n<td align=\"left\">511921</td>\n<td align=\"left\">通江县</td>\n</tr>\n<tr>\n<td align=\"left\">511922</td>\n<td align=\"left\">南江县</td>\n</tr>\n<tr>\n<td align=\"left\">511923</td>\n<td align=\"left\">平昌县</td>\n</tr>\n<tr>\n<td align=\"left\">512000</td>\n<td align=\"left\">资阳市</td>\n</tr>\n<tr>\n<td align=\"left\">512002</td>\n<td align=\"left\">雁江区</td>\n</tr>\n<tr>\n<td align=\"left\">512021</td>\n<td align=\"left\">安岳县</td>\n</tr>\n<tr>\n<td align=\"left\">512022</td>\n<td align=\"left\">乐至县</td>\n</tr>\n<tr>\n<td align=\"left\">513200</td>\n<td align=\"left\">阿坝藏族羌族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">513201</td>\n<td align=\"left\">马尔康市</td>\n</tr>\n<tr>\n<td align=\"left\">513221</td>\n<td align=\"left\">汶川县</td>\n</tr>\n<tr>\n<td align=\"left\">513222</td>\n<td align=\"left\">理县</td>\n</tr>\n<tr>\n<td align=\"left\">513223</td>\n<td align=\"left\">茂县</td>\n</tr>\n<tr>\n<td align=\"left\">513224</td>\n<td align=\"left\">松潘县</td>\n</tr>\n<tr>\n<td align=\"left\">513225</td>\n<td align=\"left\">九寨沟县</td>\n</tr>\n<tr>\n<td align=\"left\">513226</td>\n<td align=\"left\">金川县</td>\n</tr>\n<tr>\n<td align=\"left\">513227</td>\n<td align=\"left\">小金县</td>\n</tr>\n<tr>\n<td align=\"left\">513228</td>\n<td align=\"left\">黑水县</td>\n</tr>\n<tr>\n<td align=\"left\">513230</td>\n<td align=\"left\">壤塘县</td>\n</tr>\n<tr>\n<td align=\"left\">513231</td>\n<td align=\"left\">阿坝县</td>\n</tr>\n<tr>\n<td align=\"left\">513232</td>\n<td align=\"left\">若尔盖县</td>\n</tr>\n<tr>\n<td align=\"left\">513233</td>\n<td align=\"left\">红原县</td>\n</tr>\n<tr>\n<td align=\"left\">513300</td>\n<td align=\"left\">甘孜藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">513301</td>\n<td align=\"left\">康定市</td>\n</tr>\n<tr>\n<td align=\"left\">513322</td>\n<td align=\"left\">泸定县</td>\n</tr>\n<tr>\n<td align=\"left\">513323</td>\n<td align=\"left\">丹巴县</td>\n</tr>\n<tr>\n<td align=\"left\">513324</td>\n<td align=\"left\">九龙县</td>\n</tr>\n<tr>\n<td align=\"left\">513325</td>\n<td align=\"left\">雅江县</td>\n</tr>\n<tr>\n<td align=\"left\">513326</td>\n<td align=\"left\">道孚县</td>\n</tr>\n<tr>\n<td align=\"left\">513327</td>\n<td align=\"left\">炉霍县</td>\n</tr>\n<tr>\n<td align=\"left\">513328</td>\n<td align=\"left\">甘孜县</td>\n</tr>\n<tr>\n<td align=\"left\">513329</td>\n<td align=\"left\">新龙县</td>\n</tr>\n<tr>\n<td align=\"left\">513330</td>\n<td align=\"left\">德格县</td>\n</tr>\n<tr>\n<td align=\"left\">513331</td>\n<td align=\"left\">白玉县</td>\n</tr>\n<tr>\n<td align=\"left\">513332</td>\n<td align=\"left\">石渠县</td>\n</tr>\n<tr>\n<td align=\"left\">513333</td>\n<td align=\"left\">色达县</td>\n</tr>\n<tr>\n<td align=\"left\">513334</td>\n<td align=\"left\">理塘县</td>\n</tr>\n<tr>\n<td align=\"left\">513335</td>\n<td align=\"left\">巴塘县</td>\n</tr>\n<tr>\n<td align=\"left\">513336</td>\n<td align=\"left\">乡城县</td>\n</tr>\n<tr>\n<td align=\"left\">513337</td>\n<td align=\"left\">稻城县</td>\n</tr>\n<tr>\n<td align=\"left\">513338</td>\n<td align=\"left\">得荣县</td>\n</tr>\n<tr>\n<td align=\"left\">513400</td>\n<td align=\"left\">凉山彝族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">513401</td>\n<td align=\"left\">西昌市</td>\n</tr>\n<tr>\n<td align=\"left\">513422</td>\n<td align=\"left\">木里藏族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">513423</td>\n<td align=\"left\">盐源县</td>\n</tr>\n<tr>\n<td align=\"left\">513424</td>\n<td align=\"left\">德昌县</td>\n</tr>\n<tr>\n<td align=\"left\">513425</td>\n<td align=\"left\">会理县</td>\n</tr>\n<tr>\n<td align=\"left\">513426</td>\n<td align=\"left\">会东县</td>\n</tr>\n<tr>\n<td align=\"left\">513427</td>\n<td align=\"left\">宁南县</td>\n</tr>\n<tr>\n<td align=\"left\">513428</td>\n<td align=\"left\">普格县</td>\n</tr>\n<tr>\n<td align=\"left\">513429</td>\n<td align=\"left\">布拖县</td>\n</tr>\n<tr>\n<td align=\"left\">513430</td>\n<td align=\"left\">金阳县</td>\n</tr>\n<tr>\n<td align=\"left\">513431</td>\n<td align=\"left\">昭觉县</td>\n</tr>\n<tr>\n<td align=\"left\">513432</td>\n<td align=\"left\">喜德县</td>\n</tr>\n<tr>\n<td align=\"left\">513433</td>\n<td align=\"left\">冕宁县</td>\n</tr>\n<tr>\n<td align=\"left\">513434</td>\n<td align=\"left\">越西县</td>\n</tr>\n<tr>\n<td align=\"left\">513435</td>\n<td align=\"left\">甘洛县</td>\n</tr>\n<tr>\n<td align=\"left\">513436</td>\n<td align=\"left\">美姑县</td>\n</tr>\n<tr>\n<td align=\"left\">513437</td>\n<td align=\"left\">雷波县</td>\n</tr>\n<tr>\n<td align=\"left\">520000</td>\n<td align=\"left\">贵州省</td>\n</tr>\n<tr>\n<td align=\"left\">520100</td>\n<td align=\"left\">贵阳市</td>\n</tr>\n<tr>\n<td align=\"left\">520102</td>\n<td align=\"left\">南明区</td>\n</tr>\n<tr>\n<td align=\"left\">520103</td>\n<td align=\"left\">云岩区</td>\n</tr>\n<tr>\n<td align=\"left\">520111</td>\n<td align=\"left\">花溪区</td>\n</tr>\n<tr>\n<td align=\"left\">520112</td>\n<td align=\"left\">乌当区</td>\n</tr>\n<tr>\n<td align=\"left\">520113</td>\n<td align=\"left\">白云区</td>\n</tr>\n<tr>\n<td align=\"left\">520115</td>\n<td align=\"left\">观山湖区</td>\n</tr>\n<tr>\n<td align=\"left\">520121</td>\n<td align=\"left\">开阳县</td>\n</tr>\n<tr>\n<td align=\"left\">520122</td>\n<td align=\"left\">息烽县</td>\n</tr>\n<tr>\n<td align=\"left\">520123</td>\n<td align=\"left\">修文县</td>\n</tr>\n<tr>\n<td align=\"left\">520181</td>\n<td align=\"left\">清镇市</td>\n</tr>\n<tr>\n<td align=\"left\">520200</td>\n<td align=\"left\">六盘水市</td>\n</tr>\n<tr>\n<td align=\"left\">520201</td>\n<td align=\"left\">钟山区</td>\n</tr>\n<tr>\n<td align=\"left\">520203</td>\n<td align=\"left\">六枝特区</td>\n</tr>\n<tr>\n<td align=\"left\">520221</td>\n<td align=\"left\">水城县</td>\n</tr>\n<tr>\n<td align=\"left\">520281</td>\n<td align=\"left\">盘州市</td>\n</tr>\n<tr>\n<td align=\"left\">520300</td>\n<td align=\"left\">遵义市</td>\n</tr>\n<tr>\n<td align=\"left\">520302</td>\n<td align=\"left\">红花岗区</td>\n</tr>\n<tr>\n<td align=\"left\">520303</td>\n<td align=\"left\">汇川区</td>\n</tr>\n<tr>\n<td align=\"left\">520304</td>\n<td align=\"left\">播州区</td>\n</tr>\n<tr>\n<td align=\"left\">520322</td>\n<td align=\"left\">桐梓县</td>\n</tr>\n<tr>\n<td align=\"left\">520323</td>\n<td align=\"left\">绥阳县</td>\n</tr>\n<tr>\n<td align=\"left\">520324</td>\n<td align=\"left\">正安县</td>\n</tr>\n<tr>\n<td align=\"left\">520325</td>\n<td align=\"left\">道真仡佬族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520326</td>\n<td align=\"left\">务川仡佬族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520327</td>\n<td align=\"left\">凤冈县</td>\n</tr>\n<tr>\n<td align=\"left\">520328</td>\n<td align=\"left\">湄潭县</td>\n</tr>\n<tr>\n<td align=\"left\">520329</td>\n<td align=\"left\">余庆县</td>\n</tr>\n<tr>\n<td align=\"left\">520330</td>\n<td align=\"left\">习水县</td>\n</tr>\n<tr>\n<td align=\"left\">520381</td>\n<td align=\"left\">赤水市</td>\n</tr>\n<tr>\n<td align=\"left\">520382</td>\n<td align=\"left\">仁怀市</td>\n</tr>\n<tr>\n<td align=\"left\">520400</td>\n<td align=\"left\">安顺市</td>\n</tr>\n<tr>\n<td align=\"left\">520402</td>\n<td align=\"left\">西秀区</td>\n</tr>\n<tr>\n<td align=\"left\">520403</td>\n<td align=\"left\">平坝区</td>\n</tr>\n<tr>\n<td align=\"left\">520422</td>\n<td align=\"left\">普定县</td>\n</tr>\n<tr>\n<td align=\"left\">520423</td>\n<td align=\"left\">镇宁布依族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520424</td>\n<td align=\"left\">关岭布依族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520425</td>\n<td align=\"left\">紫云苗族布依族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520500</td>\n<td align=\"left\">毕节市</td>\n</tr>\n<tr>\n<td align=\"left\">520502</td>\n<td align=\"left\">七星关区</td>\n</tr>\n<tr>\n<td align=\"left\">520521</td>\n<td align=\"left\">大方县</td>\n</tr>\n<tr>\n<td align=\"left\">520522</td>\n<td align=\"left\">黔西县</td>\n</tr>\n<tr>\n<td align=\"left\">520523</td>\n<td align=\"left\">金沙县</td>\n</tr>\n<tr>\n<td align=\"left\">520524</td>\n<td align=\"left\">织金县</td>\n</tr>\n<tr>\n<td align=\"left\">520525</td>\n<td align=\"left\">纳雍县</td>\n</tr>\n<tr>\n<td align=\"left\">520526</td>\n<td align=\"left\">威宁彝族回族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520527</td>\n<td align=\"left\">赫章县</td>\n</tr>\n<tr>\n<td align=\"left\">520600</td>\n<td align=\"left\">铜仁市</td>\n</tr>\n<tr>\n<td align=\"left\">520602</td>\n<td align=\"left\">碧江区</td>\n</tr>\n<tr>\n<td align=\"left\">520603</td>\n<td align=\"left\">万山区</td>\n</tr>\n<tr>\n<td align=\"left\">520621</td>\n<td align=\"left\">江口县</td>\n</tr>\n<tr>\n<td align=\"left\">520622</td>\n<td align=\"left\">玉屏侗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520623</td>\n<td align=\"left\">石阡县</td>\n</tr>\n<tr>\n<td align=\"left\">520624</td>\n<td align=\"left\">思南县</td>\n</tr>\n<tr>\n<td align=\"left\">520625</td>\n<td align=\"left\">印江土家族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520626</td>\n<td align=\"left\">德江县</td>\n</tr>\n<tr>\n<td align=\"left\">520627</td>\n<td align=\"left\">沿河土家族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">520628</td>\n<td align=\"left\">松桃苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">522300</td>\n<td align=\"left\">黔西南布依族苗族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">522301</td>\n<td align=\"left\">兴义市</td>\n</tr>\n<tr>\n<td align=\"left\">522302</td>\n<td align=\"left\">兴仁市</td>\n</tr>\n<tr>\n<td align=\"left\">522323</td>\n<td align=\"left\">普安县</td>\n</tr>\n<tr>\n<td align=\"left\">522324</td>\n<td align=\"left\">晴隆县</td>\n</tr>\n<tr>\n<td align=\"left\">522325</td>\n<td align=\"left\">贞丰县</td>\n</tr>\n<tr>\n<td align=\"left\">522326</td>\n<td align=\"left\">望谟县</td>\n</tr>\n<tr>\n<td align=\"left\">522327</td>\n<td align=\"left\">册亨县</td>\n</tr>\n<tr>\n<td align=\"left\">522328</td>\n<td align=\"left\">安龙县</td>\n</tr>\n<tr>\n<td align=\"left\">522600</td>\n<td align=\"left\">黔东南苗族侗族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">522601</td>\n<td align=\"left\">凯里市</td>\n</tr>\n<tr>\n<td align=\"left\">522622</td>\n<td align=\"left\">黄平县</td>\n</tr>\n<tr>\n<td align=\"left\">522623</td>\n<td align=\"left\">施秉县</td>\n</tr>\n<tr>\n<td align=\"left\">522624</td>\n<td align=\"left\">三穗县</td>\n</tr>\n<tr>\n<td align=\"left\">522625</td>\n<td align=\"left\">镇远县</td>\n</tr>\n<tr>\n<td align=\"left\">522626</td>\n<td align=\"left\">岑巩县</td>\n</tr>\n<tr>\n<td align=\"left\">522627</td>\n<td align=\"left\">天柱县</td>\n</tr>\n<tr>\n<td align=\"left\">522628</td>\n<td align=\"left\">锦屏县</td>\n</tr>\n<tr>\n<td align=\"left\">522629</td>\n<td align=\"left\">剑河县</td>\n</tr>\n<tr>\n<td align=\"left\">522630</td>\n<td align=\"left\">台江县</td>\n</tr>\n<tr>\n<td align=\"left\">522631</td>\n<td align=\"left\">黎平县</td>\n</tr>\n<tr>\n<td align=\"left\">522632</td>\n<td align=\"left\">榕江县</td>\n</tr>\n<tr>\n<td align=\"left\">522633</td>\n<td align=\"left\">从江县</td>\n</tr>\n<tr>\n<td align=\"left\">522634</td>\n<td align=\"left\">雷山县</td>\n</tr>\n<tr>\n<td align=\"left\">522635</td>\n<td align=\"left\">麻江县</td>\n</tr>\n<tr>\n<td align=\"left\">522636</td>\n<td align=\"left\">丹寨县</td>\n</tr>\n<tr>\n<td align=\"left\">522700</td>\n<td align=\"left\">黔南布依族苗族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">522701</td>\n<td align=\"left\">都匀市</td>\n</tr>\n<tr>\n<td align=\"left\">522702</td>\n<td align=\"left\">福泉市</td>\n</tr>\n<tr>\n<td align=\"left\">522722</td>\n<td align=\"left\">荔波县</td>\n</tr>\n<tr>\n<td align=\"left\">522723</td>\n<td align=\"left\">贵定县</td>\n</tr>\n<tr>\n<td align=\"left\">522725</td>\n<td align=\"left\">瓮安县</td>\n</tr>\n<tr>\n<td align=\"left\">522726</td>\n<td align=\"left\">独山县</td>\n</tr>\n<tr>\n<td align=\"left\">522727</td>\n<td align=\"left\">平塘县</td>\n</tr>\n<tr>\n<td align=\"left\">522728</td>\n<td align=\"left\">罗甸县</td>\n</tr>\n<tr>\n<td align=\"left\">522729</td>\n<td align=\"left\">长顺县</td>\n</tr>\n<tr>\n<td align=\"left\">522730</td>\n<td align=\"left\">龙里县</td>\n</tr>\n<tr>\n<td align=\"left\">522731</td>\n<td align=\"left\">惠水县</td>\n</tr>\n<tr>\n<td align=\"left\">522732</td>\n<td align=\"left\">三都水族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530000</td>\n<td align=\"left\">云南省</td>\n</tr>\n<tr>\n<td align=\"left\">530100</td>\n<td align=\"left\">昆明市</td>\n</tr>\n<tr>\n<td align=\"left\">530102</td>\n<td align=\"left\">五华区</td>\n</tr>\n<tr>\n<td align=\"left\">530103</td>\n<td align=\"left\">盘龙区</td>\n</tr>\n<tr>\n<td align=\"left\">530111</td>\n<td align=\"left\">官渡区</td>\n</tr>\n<tr>\n<td align=\"left\">530112</td>\n<td align=\"left\">西山区</td>\n</tr>\n<tr>\n<td align=\"left\">530113</td>\n<td align=\"left\">东川区</td>\n</tr>\n<tr>\n<td align=\"left\">530114</td>\n<td align=\"left\">呈贡区</td>\n</tr>\n<tr>\n<td align=\"left\">530115</td>\n<td align=\"left\">晋宁区</td>\n</tr>\n<tr>\n<td align=\"left\">530124</td>\n<td align=\"left\">富民县</td>\n</tr>\n<tr>\n<td align=\"left\">530125</td>\n<td align=\"left\">宜良县</td>\n</tr>\n<tr>\n<td align=\"left\">530126</td>\n<td align=\"left\">石林彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530127</td>\n<td align=\"left\">嵩明县</td>\n</tr>\n<tr>\n<td align=\"left\">530128</td>\n<td align=\"left\">禄劝彝族苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530129</td>\n<td align=\"left\">寻甸回族彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530181</td>\n<td align=\"left\">安宁市</td>\n</tr>\n<tr>\n<td align=\"left\">530300</td>\n<td align=\"left\">曲靖市</td>\n</tr>\n<tr>\n<td align=\"left\">530302</td>\n<td align=\"left\">麒麟区</td>\n</tr>\n<tr>\n<td align=\"left\">530303</td>\n<td align=\"left\">沾益区</td>\n</tr>\n<tr>\n<td align=\"left\">530304</td>\n<td align=\"left\">马龙区</td>\n</tr>\n<tr>\n<td align=\"left\">530322</td>\n<td align=\"left\">陆良县</td>\n</tr>\n<tr>\n<td align=\"left\">530323</td>\n<td align=\"left\">师宗县</td>\n</tr>\n<tr>\n<td align=\"left\">530324</td>\n<td align=\"left\">罗平县</td>\n</tr>\n<tr>\n<td align=\"left\">530325</td>\n<td align=\"left\">富源县</td>\n</tr>\n<tr>\n<td align=\"left\">530326</td>\n<td align=\"left\">会泽县</td>\n</tr>\n<tr>\n<td align=\"left\">530381</td>\n<td align=\"left\">宣威市</td>\n</tr>\n<tr>\n<td align=\"left\">530400</td>\n<td align=\"left\">玉溪市</td>\n</tr>\n<tr>\n<td align=\"left\">530402</td>\n<td align=\"left\">红塔区</td>\n</tr>\n<tr>\n<td align=\"left\">530403</td>\n<td align=\"left\">江川区</td>\n</tr>\n<tr>\n<td align=\"left\">530423</td>\n<td align=\"left\">通海县</td>\n</tr>\n<tr>\n<td align=\"left\">530424</td>\n<td align=\"left\">华宁县</td>\n</tr>\n<tr>\n<td align=\"left\">530425</td>\n<td align=\"left\">易门县</td>\n</tr>\n<tr>\n<td align=\"left\">530426</td>\n<td align=\"left\">峨山彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530427</td>\n<td align=\"left\">新平彝族傣族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530428</td>\n<td align=\"left\">元江哈尼族彝族傣族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530481</td>\n<td align=\"left\">澄江市</td>\n</tr>\n<tr>\n<td align=\"left\">530500</td>\n<td align=\"left\">保山市</td>\n</tr>\n<tr>\n<td align=\"left\">530502</td>\n<td align=\"left\">隆阳区</td>\n</tr>\n<tr>\n<td align=\"left\">530521</td>\n<td align=\"left\">施甸县</td>\n</tr>\n<tr>\n<td align=\"left\">530523</td>\n<td align=\"left\">龙陵县</td>\n</tr>\n<tr>\n<td align=\"left\">530524</td>\n<td align=\"left\">昌宁县</td>\n</tr>\n<tr>\n<td align=\"left\">530581</td>\n<td align=\"left\">腾冲市</td>\n</tr>\n<tr>\n<td align=\"left\">530600</td>\n<td align=\"left\">昭通市</td>\n</tr>\n<tr>\n<td align=\"left\">530602</td>\n<td align=\"left\">昭阳区</td>\n</tr>\n<tr>\n<td align=\"left\">530621</td>\n<td align=\"left\">鲁甸县</td>\n</tr>\n<tr>\n<td align=\"left\">530622</td>\n<td align=\"left\">巧家县</td>\n</tr>\n<tr>\n<td align=\"left\">530623</td>\n<td align=\"left\">盐津县</td>\n</tr>\n<tr>\n<td align=\"left\">530624</td>\n<td align=\"left\">大关县</td>\n</tr>\n<tr>\n<td align=\"left\">530625</td>\n<td align=\"left\">永善县</td>\n</tr>\n<tr>\n<td align=\"left\">530626</td>\n<td align=\"left\">绥江县</td>\n</tr>\n<tr>\n<td align=\"left\">530627</td>\n<td align=\"left\">镇雄县</td>\n</tr>\n<tr>\n<td align=\"left\">530628</td>\n<td align=\"left\">彝良县</td>\n</tr>\n<tr>\n<td align=\"left\">530629</td>\n<td align=\"left\">威信县</td>\n</tr>\n<tr>\n<td align=\"left\">530681</td>\n<td align=\"left\">水富市</td>\n</tr>\n<tr>\n<td align=\"left\">530700</td>\n<td align=\"left\">丽江市</td>\n</tr>\n<tr>\n<td align=\"left\">530702</td>\n<td align=\"left\">古城区</td>\n</tr>\n<tr>\n<td align=\"left\">530721</td>\n<td align=\"left\">玉龙纳西族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530722</td>\n<td align=\"left\">永胜县</td>\n</tr>\n<tr>\n<td align=\"left\">530723</td>\n<td align=\"left\">华坪县</td>\n</tr>\n<tr>\n<td align=\"left\">530724</td>\n<td align=\"left\">宁蒗彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530800</td>\n<td align=\"left\">普洱市</td>\n</tr>\n<tr>\n<td align=\"left\">530802</td>\n<td align=\"left\">思茅区</td>\n</tr>\n<tr>\n<td align=\"left\">530821</td>\n<td align=\"left\">宁洱哈尼族彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530822</td>\n<td align=\"left\">墨江哈尼族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530823</td>\n<td align=\"left\">景东彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530824</td>\n<td align=\"left\">景谷傣族彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530825</td>\n<td align=\"left\">镇沅彝族哈尼族拉祜族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530826</td>\n<td align=\"left\">江城哈尼族彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530827</td>\n<td align=\"left\">孟连傣族拉祜族佤族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530828</td>\n<td align=\"left\">澜沧拉祜族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530829</td>\n<td align=\"left\">西盟佤族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530900</td>\n<td align=\"left\">临沧市</td>\n</tr>\n<tr>\n<td align=\"left\">530902</td>\n<td align=\"left\">临翔区</td>\n</tr>\n<tr>\n<td align=\"left\">530921</td>\n<td align=\"left\">凤庆县</td>\n</tr>\n<tr>\n<td align=\"left\">530922</td>\n<td align=\"left\">云县</td>\n</tr>\n<tr>\n<td align=\"left\">530923</td>\n<td align=\"left\">永德县</td>\n</tr>\n<tr>\n<td align=\"left\">530924</td>\n<td align=\"left\">镇康县</td>\n</tr>\n<tr>\n<td align=\"left\">530925</td>\n<td align=\"left\">双江拉祜族佤族布朗族傣族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530926</td>\n<td align=\"left\">耿马傣族佤族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">530927</td>\n<td align=\"left\">沧源佤族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">532300</td>\n<td align=\"left\">楚雄彝族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">532301</td>\n<td align=\"left\">楚雄市</td>\n</tr>\n<tr>\n<td align=\"left\">532322</td>\n<td align=\"left\">双柏县</td>\n</tr>\n<tr>\n<td align=\"left\">532323</td>\n<td align=\"left\">牟定县</td>\n</tr>\n<tr>\n<td align=\"left\">532324</td>\n<td align=\"left\">南华县</td>\n</tr>\n<tr>\n<td align=\"left\">532325</td>\n<td align=\"left\">姚安县</td>\n</tr>\n<tr>\n<td align=\"left\">532326</td>\n<td align=\"left\">大姚县</td>\n</tr>\n<tr>\n<td align=\"left\">532327</td>\n<td align=\"left\">永仁县</td>\n</tr>\n<tr>\n<td align=\"left\">532328</td>\n<td align=\"left\">元谋县</td>\n</tr>\n<tr>\n<td align=\"left\">532329</td>\n<td align=\"left\">武定县</td>\n</tr>\n<tr>\n<td align=\"left\">532331</td>\n<td align=\"left\">禄丰县</td>\n</tr>\n<tr>\n<td align=\"left\">532500</td>\n<td align=\"left\">红河哈尼族彝族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">532501</td>\n<td align=\"left\">个旧市</td>\n</tr>\n<tr>\n<td align=\"left\">532502</td>\n<td align=\"left\">开远市</td>\n</tr>\n<tr>\n<td align=\"left\">532503</td>\n<td align=\"left\">蒙自市</td>\n</tr>\n<tr>\n<td align=\"left\">532504</td>\n<td align=\"left\">弥勒市</td>\n</tr>\n<tr>\n<td align=\"left\">532523</td>\n<td align=\"left\">屏边苗族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">532524</td>\n<td align=\"left\">建水县</td>\n</tr>\n<tr>\n<td align=\"left\">532525</td>\n<td align=\"left\">石屏县</td>\n</tr>\n<tr>\n<td align=\"left\">532527</td>\n<td align=\"left\">泸西县</td>\n</tr>\n<tr>\n<td align=\"left\">532528</td>\n<td align=\"left\">元阳县</td>\n</tr>\n<tr>\n<td align=\"left\">532529</td>\n<td align=\"left\">红河县</td>\n</tr>\n<tr>\n<td align=\"left\">532530</td>\n<td align=\"left\">金平苗族瑶族傣族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">532531</td>\n<td align=\"left\">绿春县</td>\n</tr>\n<tr>\n<td align=\"left\">532532</td>\n<td align=\"left\">河口瑶族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">532600</td>\n<td align=\"left\">文山壮族苗族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">532601</td>\n<td align=\"left\">文山市</td>\n</tr>\n<tr>\n<td align=\"left\">532622</td>\n<td align=\"left\">砚山县</td>\n</tr>\n<tr>\n<td align=\"left\">532623</td>\n<td align=\"left\">西畴县</td>\n</tr>\n<tr>\n<td align=\"left\">532624</td>\n<td align=\"left\">麻栗坡县</td>\n</tr>\n<tr>\n<td align=\"left\">532625</td>\n<td align=\"left\">马关县</td>\n</tr>\n<tr>\n<td align=\"left\">532626</td>\n<td align=\"left\">丘北县</td>\n</tr>\n<tr>\n<td align=\"left\">532627</td>\n<td align=\"left\">广南县</td>\n</tr>\n<tr>\n<td align=\"left\">532628</td>\n<td align=\"left\">富宁县</td>\n</tr>\n<tr>\n<td align=\"left\">532800</td>\n<td align=\"left\">西双版纳傣族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">532801</td>\n<td align=\"left\">景洪市</td>\n</tr>\n<tr>\n<td align=\"left\">532822</td>\n<td align=\"left\">勐海县</td>\n</tr>\n<tr>\n<td align=\"left\">532823</td>\n<td align=\"left\">勐腊县</td>\n</tr>\n<tr>\n<td align=\"left\">532900</td>\n<td align=\"left\">大理白族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">532901</td>\n<td align=\"left\">大理市</td>\n</tr>\n<tr>\n<td align=\"left\">532922</td>\n<td align=\"left\">漾濞彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">532923</td>\n<td align=\"left\">祥云县</td>\n</tr>\n<tr>\n<td align=\"left\">532924</td>\n<td align=\"left\">宾川县</td>\n</tr>\n<tr>\n<td align=\"left\">532925</td>\n<td align=\"left\">弥渡县</td>\n</tr>\n<tr>\n<td align=\"left\">532926</td>\n<td align=\"left\">南涧彝族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">532927</td>\n<td align=\"left\">巍山彝族回族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">532928</td>\n<td align=\"left\">永平县</td>\n</tr>\n<tr>\n<td align=\"left\">532929</td>\n<td align=\"left\">云龙县</td>\n</tr>\n<tr>\n<td align=\"left\">532930</td>\n<td align=\"left\">洱源县</td>\n</tr>\n<tr>\n<td align=\"left\">532931</td>\n<td align=\"left\">剑川县</td>\n</tr>\n<tr>\n<td align=\"left\">532932</td>\n<td align=\"left\">鹤庆县</td>\n</tr>\n<tr>\n<td align=\"left\">533100</td>\n<td align=\"left\">德宏傣族景颇族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">533102</td>\n<td align=\"left\">瑞丽市</td>\n</tr>\n<tr>\n<td align=\"left\">533103</td>\n<td align=\"left\">芒市</td>\n</tr>\n<tr>\n<td align=\"left\">533122</td>\n<td align=\"left\">梁河县</td>\n</tr>\n<tr>\n<td align=\"left\">533123</td>\n<td align=\"left\">盈江县</td>\n</tr>\n<tr>\n<td align=\"left\">533124</td>\n<td align=\"left\">陇川县</td>\n</tr>\n<tr>\n<td align=\"left\">533300</td>\n<td align=\"left\">怒江傈僳族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">533301</td>\n<td align=\"left\">泸水市</td>\n</tr>\n<tr>\n<td align=\"left\">533323</td>\n<td align=\"left\">福贡县</td>\n</tr>\n<tr>\n<td align=\"left\">533324</td>\n<td align=\"left\">贡山独龙族怒族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">533325</td>\n<td align=\"left\">兰坪白族普米族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">533400</td>\n<td align=\"left\">迪庆藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">533401</td>\n<td align=\"left\">香格里拉市</td>\n</tr>\n<tr>\n<td align=\"left\">533422</td>\n<td align=\"left\">德钦县</td>\n</tr>\n<tr>\n<td align=\"left\">533423</td>\n<td align=\"left\">维西傈僳族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">540000</td>\n<td align=\"left\">西藏自治区</td>\n</tr>\n<tr>\n<td align=\"left\">540100</td>\n<td align=\"left\">拉萨市</td>\n</tr>\n<tr>\n<td align=\"left\">540102</td>\n<td align=\"left\">城关区</td>\n</tr>\n<tr>\n<td align=\"left\">540103</td>\n<td align=\"left\">堆龙德庆区</td>\n</tr>\n<tr>\n<td align=\"left\">540104</td>\n<td align=\"left\">达孜区</td>\n</tr>\n<tr>\n<td align=\"left\">540121</td>\n<td align=\"left\">林周县</td>\n</tr>\n<tr>\n<td align=\"left\">540122</td>\n<td align=\"left\">当雄县</td>\n</tr>\n<tr>\n<td align=\"left\">540123</td>\n<td align=\"left\">尼木县</td>\n</tr>\n<tr>\n<td align=\"left\">540124</td>\n<td align=\"left\">曲水县</td>\n</tr>\n<tr>\n<td align=\"left\">540127</td>\n<td align=\"left\">墨竹工卡县</td>\n</tr>\n<tr>\n<td align=\"left\">540200</td>\n<td align=\"left\">日喀则市</td>\n</tr>\n<tr>\n<td align=\"left\">540202</td>\n<td align=\"left\">桑珠孜区</td>\n</tr>\n<tr>\n<td align=\"left\">540221</td>\n<td align=\"left\">南木林县</td>\n</tr>\n<tr>\n<td align=\"left\">540222</td>\n<td align=\"left\">江孜县</td>\n</tr>\n<tr>\n<td align=\"left\">540223</td>\n<td align=\"left\">定日县</td>\n</tr>\n<tr>\n<td align=\"left\">540224</td>\n<td align=\"left\">萨迦县</td>\n</tr>\n<tr>\n<td align=\"left\">540225</td>\n<td align=\"left\">拉孜县</td>\n</tr>\n<tr>\n<td align=\"left\">540226</td>\n<td align=\"left\">昂仁县</td>\n</tr>\n<tr>\n<td align=\"left\">540227</td>\n<td align=\"left\">谢通门县</td>\n</tr>\n<tr>\n<td align=\"left\">540228</td>\n<td align=\"left\">白朗县</td>\n</tr>\n<tr>\n<td align=\"left\">540229</td>\n<td align=\"left\">仁布县</td>\n</tr>\n<tr>\n<td align=\"left\">540230</td>\n<td align=\"left\">康马县</td>\n</tr>\n<tr>\n<td align=\"left\">540231</td>\n<td align=\"left\">定结县</td>\n</tr>\n<tr>\n<td align=\"left\">540232</td>\n<td align=\"left\">仲巴县</td>\n</tr>\n<tr>\n<td align=\"left\">540233</td>\n<td align=\"left\">亚东县</td>\n</tr>\n<tr>\n<td align=\"left\">540234</td>\n<td align=\"left\">吉隆县</td>\n</tr>\n<tr>\n<td align=\"left\">540235</td>\n<td align=\"left\">聂拉木县</td>\n</tr>\n<tr>\n<td align=\"left\">540236</td>\n<td align=\"left\">萨嘎县</td>\n</tr>\n<tr>\n<td align=\"left\">540237</td>\n<td align=\"left\">岗巴县</td>\n</tr>\n<tr>\n<td align=\"left\">540300</td>\n<td align=\"left\">昌都市</td>\n</tr>\n<tr>\n<td align=\"left\">540302</td>\n<td align=\"left\">卡若区</td>\n</tr>\n<tr>\n<td align=\"left\">540321</td>\n<td align=\"left\">江达县</td>\n</tr>\n<tr>\n<td align=\"left\">540322</td>\n<td align=\"left\">贡觉县</td>\n</tr>\n<tr>\n<td align=\"left\">540323</td>\n<td align=\"left\">类乌齐县</td>\n</tr>\n<tr>\n<td align=\"left\">540324</td>\n<td align=\"left\">丁青县</td>\n</tr>\n<tr>\n<td align=\"left\">540325</td>\n<td align=\"left\">察雅县</td>\n</tr>\n<tr>\n<td align=\"left\">540326</td>\n<td align=\"left\">八宿县</td>\n</tr>\n<tr>\n<td align=\"left\">540327</td>\n<td align=\"left\">左贡县</td>\n</tr>\n<tr>\n<td align=\"left\">540328</td>\n<td align=\"left\">芒康县</td>\n</tr>\n<tr>\n<td align=\"left\">540329</td>\n<td align=\"left\">洛隆县</td>\n</tr>\n<tr>\n<td align=\"left\">540330</td>\n<td align=\"left\">边坝县</td>\n</tr>\n<tr>\n<td align=\"left\">540400</td>\n<td align=\"left\">林芝市</td>\n</tr>\n<tr>\n<td align=\"left\">540402</td>\n<td align=\"left\">巴宜区</td>\n</tr>\n<tr>\n<td align=\"left\">540421</td>\n<td align=\"left\">工布江达县</td>\n</tr>\n<tr>\n<td align=\"left\">540422</td>\n<td align=\"left\">米林县</td>\n</tr>\n<tr>\n<td align=\"left\">540423</td>\n<td align=\"left\">墨脱县</td>\n</tr>\n<tr>\n<td align=\"left\">540424</td>\n<td align=\"left\">波密县</td>\n</tr>\n<tr>\n<td align=\"left\">540425</td>\n<td align=\"left\">察隅县</td>\n</tr>\n<tr>\n<td align=\"left\">540426</td>\n<td align=\"left\">朗县</td>\n</tr>\n<tr>\n<td align=\"left\">540500</td>\n<td align=\"left\">山南市</td>\n</tr>\n<tr>\n<td align=\"left\">540502</td>\n<td align=\"left\">乃东区</td>\n</tr>\n<tr>\n<td align=\"left\">540521</td>\n<td align=\"left\">扎囊县</td>\n</tr>\n<tr>\n<td align=\"left\">540522</td>\n<td align=\"left\">贡嘎县</td>\n</tr>\n<tr>\n<td align=\"left\">540523</td>\n<td align=\"left\">桑日县</td>\n</tr>\n<tr>\n<td align=\"left\">540524</td>\n<td align=\"left\">琼结县</td>\n</tr>\n<tr>\n<td align=\"left\">540525</td>\n<td align=\"left\">曲松县</td>\n</tr>\n<tr>\n<td align=\"left\">540526</td>\n<td align=\"left\">措美县</td>\n</tr>\n<tr>\n<td align=\"left\">540527</td>\n<td align=\"left\">洛扎县</td>\n</tr>\n<tr>\n<td align=\"left\">540528</td>\n<td align=\"left\">加查县</td>\n</tr>\n<tr>\n<td align=\"left\">540529</td>\n<td align=\"left\">隆子县</td>\n</tr>\n<tr>\n<td align=\"left\">540530</td>\n<td align=\"left\">错那县</td>\n</tr>\n<tr>\n<td align=\"left\">540531</td>\n<td align=\"left\">浪卡子县</td>\n</tr>\n<tr>\n<td align=\"left\">540600</td>\n<td align=\"left\">那曲市</td>\n</tr>\n<tr>\n<td align=\"left\">540602</td>\n<td align=\"left\">色尼区</td>\n</tr>\n<tr>\n<td align=\"left\">540621</td>\n<td align=\"left\">嘉黎县</td>\n</tr>\n<tr>\n<td align=\"left\">540622</td>\n<td align=\"left\">比如县</td>\n</tr>\n<tr>\n<td align=\"left\">540623</td>\n<td align=\"left\">聂荣县</td>\n</tr>\n<tr>\n<td align=\"left\">540624</td>\n<td align=\"left\">安多县</td>\n</tr>\n<tr>\n<td align=\"left\">540625</td>\n<td align=\"left\">申扎县</td>\n</tr>\n<tr>\n<td align=\"left\">540626</td>\n<td align=\"left\">索县</td>\n</tr>\n<tr>\n<td align=\"left\">540627</td>\n<td align=\"left\">班戈县</td>\n</tr>\n<tr>\n<td align=\"left\">540628</td>\n<td align=\"left\">巴青县</td>\n</tr>\n<tr>\n<td align=\"left\">540629</td>\n<td align=\"left\">尼玛县</td>\n</tr>\n<tr>\n<td align=\"left\">540630</td>\n<td align=\"left\">双湖县</td>\n</tr>\n<tr>\n<td align=\"left\">542500</td>\n<td align=\"left\">阿里地区</td>\n</tr>\n<tr>\n<td align=\"left\">542521</td>\n<td align=\"left\">普兰县</td>\n</tr>\n<tr>\n<td align=\"left\">542522</td>\n<td align=\"left\">札达县</td>\n</tr>\n<tr>\n<td align=\"left\">542523</td>\n<td align=\"left\">噶尔县</td>\n</tr>\n<tr>\n<td align=\"left\">542524</td>\n<td align=\"left\">日土县</td>\n</tr>\n<tr>\n<td align=\"left\">542525</td>\n<td align=\"left\">革吉县</td>\n</tr>\n<tr>\n<td align=\"left\">542526</td>\n<td align=\"left\">改则县</td>\n</tr>\n<tr>\n<td align=\"left\">542527</td>\n<td align=\"left\">措勤县</td>\n</tr>\n<tr>\n<td align=\"left\">610000</td>\n<td align=\"left\">陕西省</td>\n</tr>\n<tr>\n<td align=\"left\">610100</td>\n<td align=\"left\">西安市</td>\n</tr>\n<tr>\n<td align=\"left\">610102</td>\n<td align=\"left\">新城区</td>\n</tr>\n<tr>\n<td align=\"left\">610103</td>\n<td align=\"left\">碑林区</td>\n</tr>\n<tr>\n<td align=\"left\">610104</td>\n<td align=\"left\">莲湖区</td>\n</tr>\n<tr>\n<td align=\"left\">610111</td>\n<td align=\"left\">灞桥区</td>\n</tr>\n<tr>\n<td align=\"left\">610112</td>\n<td align=\"left\">未央区</td>\n</tr>\n<tr>\n<td align=\"left\">610113</td>\n<td align=\"left\">雁塔区</td>\n</tr>\n<tr>\n<td align=\"left\">610114</td>\n<td align=\"left\">阎良区</td>\n</tr>\n<tr>\n<td align=\"left\">610115</td>\n<td align=\"left\">临潼区</td>\n</tr>\n<tr>\n<td align=\"left\">610116</td>\n<td align=\"left\">长安区</td>\n</tr>\n<tr>\n<td align=\"left\">610117</td>\n<td align=\"left\">高陵区</td>\n</tr>\n<tr>\n<td align=\"left\">610118</td>\n<td align=\"left\">鄠邑区</td>\n</tr>\n<tr>\n<td align=\"left\">610122</td>\n<td align=\"left\">蓝田县</td>\n</tr>\n<tr>\n<td align=\"left\">610124</td>\n<td align=\"left\">周至县</td>\n</tr>\n<tr>\n<td align=\"left\">610200</td>\n<td align=\"left\">铜川市</td>\n</tr>\n<tr>\n<td align=\"left\">610202</td>\n<td align=\"left\">王益区</td>\n</tr>\n<tr>\n<td align=\"left\">610203</td>\n<td align=\"left\">印台区</td>\n</tr>\n<tr>\n<td align=\"left\">610204</td>\n<td align=\"left\">耀州区</td>\n</tr>\n<tr>\n<td align=\"left\">610222</td>\n<td align=\"left\">宜君县</td>\n</tr>\n<tr>\n<td align=\"left\">610300</td>\n<td align=\"left\">宝鸡市</td>\n</tr>\n<tr>\n<td align=\"left\">610302</td>\n<td align=\"left\">渭滨区</td>\n</tr>\n<tr>\n<td align=\"left\">610303</td>\n<td align=\"left\">金台区</td>\n</tr>\n<tr>\n<td align=\"left\">610304</td>\n<td align=\"left\">陈仓区</td>\n</tr>\n<tr>\n<td align=\"left\">610322</td>\n<td align=\"left\">凤翔县</td>\n</tr>\n<tr>\n<td align=\"left\">610323</td>\n<td align=\"left\">岐山县</td>\n</tr>\n<tr>\n<td align=\"left\">610324</td>\n<td align=\"left\">扶风县</td>\n</tr>\n<tr>\n<td align=\"left\">610326</td>\n<td align=\"left\">眉县</td>\n</tr>\n<tr>\n<td align=\"left\">610327</td>\n<td align=\"left\">陇县</td>\n</tr>\n<tr>\n<td align=\"left\">610328</td>\n<td align=\"left\">千阳县</td>\n</tr>\n<tr>\n<td align=\"left\">610329</td>\n<td align=\"left\">麟游县</td>\n</tr>\n<tr>\n<td align=\"left\">610330</td>\n<td align=\"left\">凤县</td>\n</tr>\n<tr>\n<td align=\"left\">610331</td>\n<td align=\"left\">太白县</td>\n</tr>\n<tr>\n<td align=\"left\">610400</td>\n<td align=\"left\">咸阳市</td>\n</tr>\n<tr>\n<td align=\"left\">610402</td>\n<td align=\"left\">秦都区</td>\n</tr>\n<tr>\n<td align=\"left\">610403</td>\n<td align=\"left\">杨陵区</td>\n</tr>\n<tr>\n<td align=\"left\">610404</td>\n<td align=\"left\">渭城区</td>\n</tr>\n<tr>\n<td align=\"left\">610422</td>\n<td align=\"left\">三原县</td>\n</tr>\n<tr>\n<td align=\"left\">610423</td>\n<td align=\"left\">泾阳县</td>\n</tr>\n<tr>\n<td align=\"left\">610424</td>\n<td align=\"left\">乾县</td>\n</tr>\n<tr>\n<td align=\"left\">610425</td>\n<td align=\"left\">礼泉县</td>\n</tr>\n<tr>\n<td align=\"left\">610426</td>\n<td align=\"left\">永寿县</td>\n</tr>\n<tr>\n<td align=\"left\">610428</td>\n<td align=\"left\">长武县</td>\n</tr>\n<tr>\n<td align=\"left\">610429</td>\n<td align=\"left\">旬邑县</td>\n</tr>\n<tr>\n<td align=\"left\">610430</td>\n<td align=\"left\">淳化县</td>\n</tr>\n<tr>\n<td align=\"left\">610431</td>\n<td align=\"left\">武功县</td>\n</tr>\n<tr>\n<td align=\"left\">610481</td>\n<td align=\"left\">兴平市</td>\n</tr>\n<tr>\n<td align=\"left\">610482</td>\n<td align=\"left\">彬州市</td>\n</tr>\n<tr>\n<td align=\"left\">610500</td>\n<td align=\"left\">渭南市</td>\n</tr>\n<tr>\n<td align=\"left\">610502</td>\n<td align=\"left\">临渭区</td>\n</tr>\n<tr>\n<td align=\"left\">610503</td>\n<td align=\"left\">华州区</td>\n</tr>\n<tr>\n<td align=\"left\">610522</td>\n<td align=\"left\">潼关县</td>\n</tr>\n<tr>\n<td align=\"left\">610523</td>\n<td align=\"left\">大荔县</td>\n</tr>\n<tr>\n<td align=\"left\">610524</td>\n<td align=\"left\">合阳县</td>\n</tr>\n<tr>\n<td align=\"left\">610525</td>\n<td align=\"left\">澄城县</td>\n</tr>\n<tr>\n<td align=\"left\">610526</td>\n<td align=\"left\">蒲城县</td>\n</tr>\n<tr>\n<td align=\"left\">610527</td>\n<td align=\"left\">白水县</td>\n</tr>\n<tr>\n<td align=\"left\">610528</td>\n<td align=\"left\">富平县</td>\n</tr>\n<tr>\n<td align=\"left\">610581</td>\n<td align=\"left\">韩城市</td>\n</tr>\n<tr>\n<td align=\"left\">610582</td>\n<td align=\"left\">华阴市</td>\n</tr>\n<tr>\n<td align=\"left\">610600</td>\n<td align=\"left\">延安市</td>\n</tr>\n<tr>\n<td align=\"left\">610602</td>\n<td align=\"left\">宝塔区</td>\n</tr>\n<tr>\n<td align=\"left\">610603</td>\n<td align=\"left\">安塞区</td>\n</tr>\n<tr>\n<td align=\"left\">610621</td>\n<td align=\"left\">延长县</td>\n</tr>\n<tr>\n<td align=\"left\">610622</td>\n<td align=\"left\">延川县</td>\n</tr>\n<tr>\n<td align=\"left\">610625</td>\n<td align=\"left\">志丹县</td>\n</tr>\n<tr>\n<td align=\"left\">610626</td>\n<td align=\"left\">吴起县</td>\n</tr>\n<tr>\n<td align=\"left\">610627</td>\n<td align=\"left\">甘泉县</td>\n</tr>\n<tr>\n<td align=\"left\">610628</td>\n<td align=\"left\">富县</td>\n</tr>\n<tr>\n<td align=\"left\">610629</td>\n<td align=\"left\">洛川县</td>\n</tr>\n<tr>\n<td align=\"left\">610630</td>\n<td align=\"left\">宜川县</td>\n</tr>\n<tr>\n<td align=\"left\">610631</td>\n<td align=\"left\">黄龙县</td>\n</tr>\n<tr>\n<td align=\"left\">610632</td>\n<td align=\"left\">黄陵县</td>\n</tr>\n<tr>\n<td align=\"left\">610681</td>\n<td align=\"left\">子长市</td>\n</tr>\n<tr>\n<td align=\"left\">610700</td>\n<td align=\"left\">汉中市</td>\n</tr>\n<tr>\n<td align=\"left\">610702</td>\n<td align=\"left\">汉台区</td>\n</tr>\n<tr>\n<td align=\"left\">610703</td>\n<td align=\"left\">南郑区</td>\n</tr>\n<tr>\n<td align=\"left\">610722</td>\n<td align=\"left\">城固县</td>\n</tr>\n<tr>\n<td align=\"left\">610723</td>\n<td align=\"left\">洋县</td>\n</tr>\n<tr>\n<td align=\"left\">610724</td>\n<td align=\"left\">西乡县</td>\n</tr>\n<tr>\n<td align=\"left\">610725</td>\n<td align=\"left\">勉县</td>\n</tr>\n<tr>\n<td align=\"left\">610726</td>\n<td align=\"left\">宁强县</td>\n</tr>\n<tr>\n<td align=\"left\">610727</td>\n<td align=\"left\">略阳县</td>\n</tr>\n<tr>\n<td align=\"left\">610728</td>\n<td align=\"left\">镇巴县</td>\n</tr>\n<tr>\n<td align=\"left\">610729</td>\n<td align=\"left\">留坝县</td>\n</tr>\n<tr>\n<td align=\"left\">610730</td>\n<td align=\"left\">佛坪县</td>\n</tr>\n<tr>\n<td align=\"left\">610800</td>\n<td align=\"left\">榆林市</td>\n</tr>\n<tr>\n<td align=\"left\">610802</td>\n<td align=\"left\">榆阳区</td>\n</tr>\n<tr>\n<td align=\"left\">610803</td>\n<td align=\"left\">横山区</td>\n</tr>\n<tr>\n<td align=\"left\">610822</td>\n<td align=\"left\">府谷县</td>\n</tr>\n<tr>\n<td align=\"left\">610824</td>\n<td align=\"left\">靖边县</td>\n</tr>\n<tr>\n<td align=\"left\">610825</td>\n<td align=\"left\">定边县</td>\n</tr>\n<tr>\n<td align=\"left\">610826</td>\n<td align=\"left\">绥德县</td>\n</tr>\n<tr>\n<td align=\"left\">610827</td>\n<td align=\"left\">米脂县</td>\n</tr>\n<tr>\n<td align=\"left\">610828</td>\n<td align=\"left\">佳县</td>\n</tr>\n<tr>\n<td align=\"left\">610829</td>\n<td align=\"left\">吴堡县</td>\n</tr>\n<tr>\n<td align=\"left\">610830</td>\n<td align=\"left\">清涧县</td>\n</tr>\n<tr>\n<td align=\"left\">610831</td>\n<td align=\"left\">子洲县</td>\n</tr>\n<tr>\n<td align=\"left\">610881</td>\n<td align=\"left\">神木市</td>\n</tr>\n<tr>\n<td align=\"left\">610900</td>\n<td align=\"left\">安康市</td>\n</tr>\n<tr>\n<td align=\"left\">610902</td>\n<td align=\"left\">汉滨区</td>\n</tr>\n<tr>\n<td align=\"left\">610921</td>\n<td align=\"left\">汉阴县</td>\n</tr>\n<tr>\n<td align=\"left\">610922</td>\n<td align=\"left\">石泉县</td>\n</tr>\n<tr>\n<td align=\"left\">610923</td>\n<td align=\"left\">宁陕县</td>\n</tr>\n<tr>\n<td align=\"left\">610924</td>\n<td align=\"left\">紫阳县</td>\n</tr>\n<tr>\n<td align=\"left\">610925</td>\n<td align=\"left\">岚皋县</td>\n</tr>\n<tr>\n<td align=\"left\">610926</td>\n<td align=\"left\">平利县</td>\n</tr>\n<tr>\n<td align=\"left\">610927</td>\n<td align=\"left\">镇坪县</td>\n</tr>\n<tr>\n<td align=\"left\">610928</td>\n<td align=\"left\">旬阳县</td>\n</tr>\n<tr>\n<td align=\"left\">610929</td>\n<td align=\"left\">白河县</td>\n</tr>\n<tr>\n<td align=\"left\">611000</td>\n<td align=\"left\">商洛市</td>\n</tr>\n<tr>\n<td align=\"left\">611002</td>\n<td align=\"left\">商州区</td>\n</tr>\n<tr>\n<td align=\"left\">611021</td>\n<td align=\"left\">洛南县</td>\n</tr>\n<tr>\n<td align=\"left\">611022</td>\n<td align=\"left\">丹凤县</td>\n</tr>\n<tr>\n<td align=\"left\">611023</td>\n<td align=\"left\">商南县</td>\n</tr>\n<tr>\n<td align=\"left\">611024</td>\n<td align=\"left\">山阳县</td>\n</tr>\n<tr>\n<td align=\"left\">611025</td>\n<td align=\"left\">镇安县</td>\n</tr>\n<tr>\n<td align=\"left\">611026</td>\n<td align=\"left\">柞水县</td>\n</tr>\n<tr>\n<td align=\"left\">620000</td>\n<td align=\"left\">甘肃省</td>\n</tr>\n<tr>\n<td align=\"left\">620100</td>\n<td align=\"left\">兰州市</td>\n</tr>\n<tr>\n<td align=\"left\">620102</td>\n<td align=\"left\">城关区</td>\n</tr>\n<tr>\n<td align=\"left\">620103</td>\n<td align=\"left\">七里河区</td>\n</tr>\n<tr>\n<td align=\"left\">620104</td>\n<td align=\"left\">西固区</td>\n</tr>\n<tr>\n<td align=\"left\">620105</td>\n<td align=\"left\">安宁区</td>\n</tr>\n<tr>\n<td align=\"left\">620111</td>\n<td align=\"left\">红古区</td>\n</tr>\n<tr>\n<td align=\"left\">620121</td>\n<td align=\"left\">永登县</td>\n</tr>\n<tr>\n<td align=\"left\">620122</td>\n<td align=\"left\">皋兰县</td>\n</tr>\n<tr>\n<td align=\"left\">620123</td>\n<td align=\"left\">榆中县</td>\n</tr>\n<tr>\n<td align=\"left\">620200</td>\n<td align=\"left\">嘉峪关市</td>\n</tr>\n<tr>\n<td align=\"left\">620300</td>\n<td align=\"left\">金昌市</td>\n</tr>\n<tr>\n<td align=\"left\">620302</td>\n<td align=\"left\">金川区</td>\n</tr>\n<tr>\n<td align=\"left\">620321</td>\n<td align=\"left\">永昌县</td>\n</tr>\n<tr>\n<td align=\"left\">620400</td>\n<td align=\"left\">白银市</td>\n</tr>\n<tr>\n<td align=\"left\">620402</td>\n<td align=\"left\">白银区</td>\n</tr>\n<tr>\n<td align=\"left\">620403</td>\n<td align=\"left\">平川区</td>\n</tr>\n<tr>\n<td align=\"left\">620421</td>\n<td align=\"left\">靖远县</td>\n</tr>\n<tr>\n<td align=\"left\">620422</td>\n<td align=\"left\">会宁县</td>\n</tr>\n<tr>\n<td align=\"left\">620423</td>\n<td align=\"left\">景泰县</td>\n</tr>\n<tr>\n<td align=\"left\">620500</td>\n<td align=\"left\">天水市</td>\n</tr>\n<tr>\n<td align=\"left\">620502</td>\n<td align=\"left\">秦州区</td>\n</tr>\n<tr>\n<td align=\"left\">620503</td>\n<td align=\"left\">麦积区</td>\n</tr>\n<tr>\n<td align=\"left\">620521</td>\n<td align=\"left\">清水县</td>\n</tr>\n<tr>\n<td align=\"left\">620522</td>\n<td align=\"left\">秦安县</td>\n</tr>\n<tr>\n<td align=\"left\">620523</td>\n<td align=\"left\">甘谷县</td>\n</tr>\n<tr>\n<td align=\"left\">620524</td>\n<td align=\"left\">武山县</td>\n</tr>\n<tr>\n<td align=\"left\">620525</td>\n<td align=\"left\">张家川回族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">620600</td>\n<td align=\"left\">武威市</td>\n</tr>\n<tr>\n<td align=\"left\">620602</td>\n<td align=\"left\">凉州区</td>\n</tr>\n<tr>\n<td align=\"left\">620621</td>\n<td align=\"left\">民勤县</td>\n</tr>\n<tr>\n<td align=\"left\">620622</td>\n<td align=\"left\">古浪县</td>\n</tr>\n<tr>\n<td align=\"left\">620623</td>\n<td align=\"left\">天祝藏族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">620700</td>\n<td align=\"left\">张掖市</td>\n</tr>\n<tr>\n<td align=\"left\">620702</td>\n<td align=\"left\">甘州区</td>\n</tr>\n<tr>\n<td align=\"left\">620721</td>\n<td align=\"left\">肃南裕固族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">620722</td>\n<td align=\"left\">民乐县</td>\n</tr>\n<tr>\n<td align=\"left\">620723</td>\n<td align=\"left\">临泽县</td>\n</tr>\n<tr>\n<td align=\"left\">620724</td>\n<td align=\"left\">高台县</td>\n</tr>\n<tr>\n<td align=\"left\">620725</td>\n<td align=\"left\">山丹县</td>\n</tr>\n<tr>\n<td align=\"left\">620800</td>\n<td align=\"left\">平凉市</td>\n</tr>\n<tr>\n<td align=\"left\">620802</td>\n<td align=\"left\">崆峒区</td>\n</tr>\n<tr>\n<td align=\"left\">620821</td>\n<td align=\"left\">泾川县</td>\n</tr>\n<tr>\n<td align=\"left\">620822</td>\n<td align=\"left\">灵台县</td>\n</tr>\n<tr>\n<td align=\"left\">620823</td>\n<td align=\"left\">崇信县</td>\n</tr>\n<tr>\n<td align=\"left\">620825</td>\n<td align=\"left\">庄浪县</td>\n</tr>\n<tr>\n<td align=\"left\">620826</td>\n<td align=\"left\">静宁县</td>\n</tr>\n<tr>\n<td align=\"left\">620881</td>\n<td align=\"left\">华亭市</td>\n</tr>\n<tr>\n<td align=\"left\">620900</td>\n<td align=\"left\">酒泉市</td>\n</tr>\n<tr>\n<td align=\"left\">620902</td>\n<td align=\"left\">肃州区</td>\n</tr>\n<tr>\n<td align=\"left\">620921</td>\n<td align=\"left\">金塔县</td>\n</tr>\n<tr>\n<td align=\"left\">620922</td>\n<td align=\"left\">瓜州县</td>\n</tr>\n<tr>\n<td align=\"left\">620923</td>\n<td align=\"left\">肃北蒙古族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">620924</td>\n<td align=\"left\">阿克塞哈萨克族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">620981</td>\n<td align=\"left\">玉门市</td>\n</tr>\n<tr>\n<td align=\"left\">620982</td>\n<td align=\"left\">敦煌市</td>\n</tr>\n<tr>\n<td align=\"left\">621000</td>\n<td align=\"left\">庆阳市</td>\n</tr>\n<tr>\n<td align=\"left\">621002</td>\n<td align=\"left\">西峰区</td>\n</tr>\n<tr>\n<td align=\"left\">621021</td>\n<td align=\"left\">庆城县</td>\n</tr>\n<tr>\n<td align=\"left\">621022</td>\n<td align=\"left\">环县</td>\n</tr>\n<tr>\n<td align=\"left\">621023</td>\n<td align=\"left\">华池县</td>\n</tr>\n<tr>\n<td align=\"left\">621024</td>\n<td align=\"left\">合水县</td>\n</tr>\n<tr>\n<td align=\"left\">621025</td>\n<td align=\"left\">正宁县</td>\n</tr>\n<tr>\n<td align=\"left\">621026</td>\n<td align=\"left\">宁县</td>\n</tr>\n<tr>\n<td align=\"left\">621027</td>\n<td align=\"left\">镇原县</td>\n</tr>\n<tr>\n<td align=\"left\">621100</td>\n<td align=\"left\">定西市</td>\n</tr>\n<tr>\n<td align=\"left\">621102</td>\n<td align=\"left\">安定区</td>\n</tr>\n<tr>\n<td align=\"left\">621121</td>\n<td align=\"left\">通渭县</td>\n</tr>\n<tr>\n<td align=\"left\">621122</td>\n<td align=\"left\">陇西县</td>\n</tr>\n<tr>\n<td align=\"left\">621123</td>\n<td align=\"left\">渭源县</td>\n</tr>\n<tr>\n<td align=\"left\">621124</td>\n<td align=\"left\">临洮县</td>\n</tr>\n<tr>\n<td align=\"left\">621125</td>\n<td align=\"left\">漳县</td>\n</tr>\n<tr>\n<td align=\"left\">621126</td>\n<td align=\"left\">岷县</td>\n</tr>\n<tr>\n<td align=\"left\">621200</td>\n<td align=\"left\">陇南市</td>\n</tr>\n<tr>\n<td align=\"left\">621202</td>\n<td align=\"left\">武都区</td>\n</tr>\n<tr>\n<td align=\"left\">621221</td>\n<td align=\"left\">成县</td>\n</tr>\n<tr>\n<td align=\"left\">621222</td>\n<td align=\"left\">文县</td>\n</tr>\n<tr>\n<td align=\"left\">621223</td>\n<td align=\"left\">宕昌县</td>\n</tr>\n<tr>\n<td align=\"left\">621224</td>\n<td align=\"left\">康县</td>\n</tr>\n<tr>\n<td align=\"left\">621225</td>\n<td align=\"left\">西和县</td>\n</tr>\n<tr>\n<td align=\"left\">621226</td>\n<td align=\"left\">礼县</td>\n</tr>\n<tr>\n<td align=\"left\">621227</td>\n<td align=\"left\">徽县</td>\n</tr>\n<tr>\n<td align=\"left\">621228</td>\n<td align=\"left\">两当县</td>\n</tr>\n<tr>\n<td align=\"left\">622900</td>\n<td align=\"left\">临夏回族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">622901</td>\n<td align=\"left\">临夏市</td>\n</tr>\n<tr>\n<td align=\"left\">622921</td>\n<td align=\"left\">临夏县</td>\n</tr>\n<tr>\n<td align=\"left\">622922</td>\n<td align=\"left\">康乐县</td>\n</tr>\n<tr>\n<td align=\"left\">622923</td>\n<td align=\"left\">永靖县</td>\n</tr>\n<tr>\n<td align=\"left\">622924</td>\n<td align=\"left\">广河县</td>\n</tr>\n<tr>\n<td align=\"left\">622925</td>\n<td align=\"left\">和政县</td>\n</tr>\n<tr>\n<td align=\"left\">622926</td>\n<td align=\"left\">东乡族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">622927</td>\n<td align=\"left\">积石山保安族东乡族撒拉族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">623000</td>\n<td align=\"left\">甘南藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">623001</td>\n<td align=\"left\">合作市</td>\n</tr>\n<tr>\n<td align=\"left\">623021</td>\n<td align=\"left\">临潭县</td>\n</tr>\n<tr>\n<td align=\"left\">623022</td>\n<td align=\"left\">卓尼县</td>\n</tr>\n<tr>\n<td align=\"left\">623023</td>\n<td align=\"left\">舟曲县</td>\n</tr>\n<tr>\n<td align=\"left\">623024</td>\n<td align=\"left\">迭部县</td>\n</tr>\n<tr>\n<td align=\"left\">623025</td>\n<td align=\"left\">玛曲县</td>\n</tr>\n<tr>\n<td align=\"left\">623026</td>\n<td align=\"left\">碌曲县</td>\n</tr>\n<tr>\n<td align=\"left\">623027</td>\n<td align=\"left\">夏河县</td>\n</tr>\n<tr>\n<td align=\"left\">630000</td>\n<td align=\"left\">青海省</td>\n</tr>\n<tr>\n<td align=\"left\">630100</td>\n<td align=\"left\">西宁市</td>\n</tr>\n<tr>\n<td align=\"left\">630102</td>\n<td align=\"left\">城东区</td>\n</tr>\n<tr>\n<td align=\"left\">630103</td>\n<td align=\"left\">城中区</td>\n</tr>\n<tr>\n<td align=\"left\">630104</td>\n<td align=\"left\">城西区</td>\n</tr>\n<tr>\n<td align=\"left\">630105</td>\n<td align=\"left\">城北区</td>\n</tr>\n<tr>\n<td align=\"left\">630106</td>\n<td align=\"left\">湟中区</td>\n</tr>\n<tr>\n<td align=\"left\">630121</td>\n<td align=\"left\">大通回族土族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">630123</td>\n<td align=\"left\">湟源县</td>\n</tr>\n<tr>\n<td align=\"left\">630200</td>\n<td align=\"left\">海东市</td>\n</tr>\n<tr>\n<td align=\"left\">630202</td>\n<td align=\"left\">乐都区</td>\n</tr>\n<tr>\n<td align=\"left\">630203</td>\n<td align=\"left\">平安区</td>\n</tr>\n<tr>\n<td align=\"left\">630222</td>\n<td align=\"left\">民和回族土族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">630223</td>\n<td align=\"left\">互助土族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">630224</td>\n<td align=\"left\">化隆回族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">630225</td>\n<td align=\"left\">循化撒拉族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">632200</td>\n<td align=\"left\">海北藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">632221</td>\n<td align=\"left\">门源回族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">632222</td>\n<td align=\"left\">祁连县</td>\n</tr>\n<tr>\n<td align=\"left\">632223</td>\n<td align=\"left\">海晏县</td>\n</tr>\n<tr>\n<td align=\"left\">632224</td>\n<td align=\"left\">刚察县</td>\n</tr>\n<tr>\n<td align=\"left\">632300</td>\n<td align=\"left\">黄南藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">632321</td>\n<td align=\"left\">同仁县</td>\n</tr>\n<tr>\n<td align=\"left\">632322</td>\n<td align=\"left\">尖扎县</td>\n</tr>\n<tr>\n<td align=\"left\">632323</td>\n<td align=\"left\">泽库县</td>\n</tr>\n<tr>\n<td align=\"left\">632324</td>\n<td align=\"left\">河南蒙古族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">632500</td>\n<td align=\"left\">海南藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">632521</td>\n<td align=\"left\">共和县</td>\n</tr>\n<tr>\n<td align=\"left\">632522</td>\n<td align=\"left\">同德县</td>\n</tr>\n<tr>\n<td align=\"left\">632523</td>\n<td align=\"left\">贵德县</td>\n</tr>\n<tr>\n<td align=\"left\">632524</td>\n<td align=\"left\">兴海县</td>\n</tr>\n<tr>\n<td align=\"left\">632525</td>\n<td align=\"left\">贵南县</td>\n</tr>\n<tr>\n<td align=\"left\">632600</td>\n<td align=\"left\">果洛藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">632621</td>\n<td align=\"left\">玛沁县</td>\n</tr>\n<tr>\n<td align=\"left\">632622</td>\n<td align=\"left\">班玛县</td>\n</tr>\n<tr>\n<td align=\"left\">632623</td>\n<td align=\"left\">甘德县</td>\n</tr>\n<tr>\n<td align=\"left\">632624</td>\n<td align=\"left\">达日县</td>\n</tr>\n<tr>\n<td align=\"left\">632625</td>\n<td align=\"left\">久治县</td>\n</tr>\n<tr>\n<td align=\"left\">632626</td>\n<td align=\"left\">玛多县</td>\n</tr>\n<tr>\n<td align=\"left\">632700</td>\n<td align=\"left\">玉树藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">632701</td>\n<td align=\"left\">玉树市</td>\n</tr>\n<tr>\n<td align=\"left\">632722</td>\n<td align=\"left\">杂多县</td>\n</tr>\n<tr>\n<td align=\"left\">632723</td>\n<td align=\"left\">称多县</td>\n</tr>\n<tr>\n<td align=\"left\">632724</td>\n<td align=\"left\">治多县</td>\n</tr>\n<tr>\n<td align=\"left\">632725</td>\n<td align=\"left\">囊谦县</td>\n</tr>\n<tr>\n<td align=\"left\">632726</td>\n<td align=\"left\">曲麻莱县</td>\n</tr>\n<tr>\n<td align=\"left\">632800</td>\n<td align=\"left\">海西蒙古族藏族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">632801</td>\n<td align=\"left\">格尔木市</td>\n</tr>\n<tr>\n<td align=\"left\">632802</td>\n<td align=\"left\">德令哈市</td>\n</tr>\n<tr>\n<td align=\"left\">632803</td>\n<td align=\"left\">茫崖市</td>\n</tr>\n<tr>\n<td align=\"left\">632821</td>\n<td align=\"left\">乌兰县</td>\n</tr>\n<tr>\n<td align=\"left\">632822</td>\n<td align=\"left\">都兰县</td>\n</tr>\n<tr>\n<td align=\"left\">632823</td>\n<td align=\"left\">天峻县</td>\n</tr>\n<tr>\n<td align=\"left\">640000</td>\n<td align=\"left\">宁夏回族自治区</td>\n</tr>\n<tr>\n<td align=\"left\">640100</td>\n<td align=\"left\">银川市</td>\n</tr>\n<tr>\n<td align=\"left\">640104</td>\n<td align=\"left\">兴庆区</td>\n</tr>\n<tr>\n<td align=\"left\">640105</td>\n<td align=\"left\">西夏区</td>\n</tr>\n<tr>\n<td align=\"left\">640106</td>\n<td align=\"left\">金凤区</td>\n</tr>\n<tr>\n<td align=\"left\">640121</td>\n<td align=\"left\">永宁县</td>\n</tr>\n<tr>\n<td align=\"left\">640122</td>\n<td align=\"left\">贺兰县</td>\n</tr>\n<tr>\n<td align=\"left\">640181</td>\n<td align=\"left\">灵武市</td>\n</tr>\n<tr>\n<td align=\"left\">640200</td>\n<td align=\"left\">石嘴山市</td>\n</tr>\n<tr>\n<td align=\"left\">640202</td>\n<td align=\"left\">大武口区</td>\n</tr>\n<tr>\n<td align=\"left\">640205</td>\n<td align=\"left\">惠农区</td>\n</tr>\n<tr>\n<td align=\"left\">640221</td>\n<td align=\"left\">平罗县</td>\n</tr>\n<tr>\n<td align=\"left\">640300</td>\n<td align=\"left\">吴忠市</td>\n</tr>\n<tr>\n<td align=\"left\">640302</td>\n<td align=\"left\">利通区</td>\n</tr>\n<tr>\n<td align=\"left\">640303</td>\n<td align=\"left\">红寺堡区</td>\n</tr>\n<tr>\n<td align=\"left\">640323</td>\n<td align=\"left\">盐池县</td>\n</tr>\n<tr>\n<td align=\"left\">640324</td>\n<td align=\"left\">同心县</td>\n</tr>\n<tr>\n<td align=\"left\">640381</td>\n<td align=\"left\">青铜峡市</td>\n</tr>\n<tr>\n<td align=\"left\">640400</td>\n<td align=\"left\">固原市</td>\n</tr>\n<tr>\n<td align=\"left\">640402</td>\n<td align=\"left\">原州区</td>\n</tr>\n<tr>\n<td align=\"left\">640422</td>\n<td align=\"left\">西吉县</td>\n</tr>\n<tr>\n<td align=\"left\">640423</td>\n<td align=\"left\">隆德县</td>\n</tr>\n<tr>\n<td align=\"left\">640424</td>\n<td align=\"left\">泾源县</td>\n</tr>\n<tr>\n<td align=\"left\">640425</td>\n<td align=\"left\">彭阳县</td>\n</tr>\n<tr>\n<td align=\"left\">640500</td>\n<td align=\"left\">中卫市</td>\n</tr>\n<tr>\n<td align=\"left\">640502</td>\n<td align=\"left\">沙坡头区</td>\n</tr>\n<tr>\n<td align=\"left\">640521</td>\n<td align=\"left\">中宁县</td>\n</tr>\n<tr>\n<td align=\"left\">640522</td>\n<td align=\"left\">海原县</td>\n</tr>\n<tr>\n<td align=\"left\">650000</td>\n<td align=\"left\">新疆维吾尔自治区</td>\n</tr>\n<tr>\n<td align=\"left\">650100</td>\n<td align=\"left\">乌鲁木齐市</td>\n</tr>\n<tr>\n<td align=\"left\">650102</td>\n<td align=\"left\">天山区</td>\n</tr>\n<tr>\n<td align=\"left\">650103</td>\n<td align=\"left\">沙依巴克区</td>\n</tr>\n<tr>\n<td align=\"left\">650104</td>\n<td align=\"left\">新市区</td>\n</tr>\n<tr>\n<td align=\"left\">650105</td>\n<td align=\"left\">水磨沟区</td>\n</tr>\n<tr>\n<td align=\"left\">650106</td>\n<td align=\"left\">头屯河区</td>\n</tr>\n<tr>\n<td align=\"left\">650107</td>\n<td align=\"left\">达坂城区</td>\n</tr>\n<tr>\n<td align=\"left\">650109</td>\n<td align=\"left\">米东区</td>\n</tr>\n<tr>\n<td align=\"left\">650121</td>\n<td align=\"left\">乌鲁木齐县</td>\n</tr>\n<tr>\n<td align=\"left\">650200</td>\n<td align=\"left\">克拉玛依市</td>\n</tr>\n<tr>\n<td align=\"left\">650202</td>\n<td align=\"left\">独山子区</td>\n</tr>\n<tr>\n<td align=\"left\">650203</td>\n<td align=\"left\">克拉玛依区</td>\n</tr>\n<tr>\n<td align=\"left\">650204</td>\n<td align=\"left\">白碱滩区</td>\n</tr>\n<tr>\n<td align=\"left\">650205</td>\n<td align=\"left\">乌尔禾区</td>\n</tr>\n<tr>\n<td align=\"left\">650400</td>\n<td align=\"left\">吐鲁番市</td>\n</tr>\n<tr>\n<td align=\"left\">650402</td>\n<td align=\"left\">高昌区</td>\n</tr>\n<tr>\n<td align=\"left\">650421</td>\n<td align=\"left\">鄯善县</td>\n</tr>\n<tr>\n<td align=\"left\">650422</td>\n<td align=\"left\">托克逊县</td>\n</tr>\n<tr>\n<td align=\"left\">650500</td>\n<td align=\"left\">哈密市</td>\n</tr>\n<tr>\n<td align=\"left\">650502</td>\n<td align=\"left\">伊州区</td>\n</tr>\n<tr>\n<td align=\"left\">650521</td>\n<td align=\"left\">巴里坤哈萨克自治县</td>\n</tr>\n<tr>\n<td align=\"left\">650522</td>\n<td align=\"left\">伊吾县</td>\n</tr>\n<tr>\n<td align=\"left\">652300</td>\n<td align=\"left\">昌吉回族自治州</td>\n</tr>\n<tr>\n<td align=\"left\">652301</td>\n<td align=\"left\">昌吉市</td>\n</tr>\n<tr>\n<td align=\"left\">652302</td>\n<td align=\"left\">阜康市</td>\n</tr>\n<tr>\n<td align=\"left\">652323</td>\n<td align=\"left\">呼图壁县</td>\n</tr>\n<tr>\n<td align=\"left\">652324</td>\n<td align=\"left\">玛纳斯县</td>\n</tr>\n<tr>\n<td align=\"left\">652325</td>\n<td align=\"left\">奇台县</td>\n</tr>\n<tr>\n<td align=\"left\">652327</td>\n<td align=\"left\">吉木萨尔县</td>\n</tr>\n<tr>\n<td align=\"left\">652328</td>\n<td align=\"left\">木垒哈萨克自治县</td>\n</tr>\n<tr>\n<td align=\"left\">652700</td>\n<td align=\"left\">博尔塔拉蒙古自治州</td>\n</tr>\n<tr>\n<td align=\"left\">652701</td>\n<td align=\"left\">博乐市</td>\n</tr>\n<tr>\n<td align=\"left\">652702</td>\n<td align=\"left\">阿拉山口市</td>\n</tr>\n<tr>\n<td align=\"left\">652722</td>\n<td align=\"left\">精河县</td>\n</tr>\n<tr>\n<td align=\"left\">652723</td>\n<td align=\"left\">温泉县</td>\n</tr>\n<tr>\n<td align=\"left\">652800</td>\n<td align=\"left\">巴音郭楞蒙古自治州</td>\n</tr>\n<tr>\n<td align=\"left\">652801</td>\n<td align=\"left\">库尔勒市</td>\n</tr>\n<tr>\n<td align=\"left\">652822</td>\n<td align=\"left\">轮台县</td>\n</tr>\n<tr>\n<td align=\"left\">652823</td>\n<td align=\"left\">尉犁县</td>\n</tr>\n<tr>\n<td align=\"left\">652824</td>\n<td align=\"left\">若羌县</td>\n</tr>\n<tr>\n<td align=\"left\">652825</td>\n<td align=\"left\">且末县</td>\n</tr>\n<tr>\n<td align=\"left\">652826</td>\n<td align=\"left\">焉耆回族自治县</td>\n</tr>\n<tr>\n<td align=\"left\">652827</td>\n<td align=\"left\">和静县</td>\n</tr>\n<tr>\n<td align=\"left\">652828</td>\n<td align=\"left\">和硕县</td>\n</tr>\n<tr>\n<td align=\"left\">652829</td>\n<td align=\"left\">博湖县</td>\n</tr>\n<tr>\n<td align=\"left\">652900</td>\n<td align=\"left\">阿克苏地区</td>\n</tr>\n<tr>\n<td align=\"left\">652901</td>\n<td align=\"left\">阿克苏市</td>\n</tr>\n<tr>\n<td align=\"left\">652902</td>\n<td align=\"left\">库车市</td>\n</tr>\n<tr>\n<td align=\"left\">652922</td>\n<td align=\"left\">温宿县</td>\n</tr>\n<tr>\n<td align=\"left\">652924</td>\n<td align=\"left\">沙雅县</td>\n</tr>\n<tr>\n<td align=\"left\">652925</td>\n<td align=\"left\">新和县</td>\n</tr>\n<tr>\n<td align=\"left\">652926</td>\n<td align=\"left\">拜城县</td>\n</tr>\n<tr>\n<td align=\"left\">652927</td>\n<td align=\"left\">乌什县</td>\n</tr>\n<tr>\n<td align=\"left\">652928</td>\n<td align=\"left\">阿瓦提县</td>\n</tr>\n<tr>\n<td align=\"left\">652929</td>\n<td align=\"left\">柯坪县</td>\n</tr>\n<tr>\n<td align=\"left\">653000</td>\n<td align=\"left\">克孜勒苏柯尔克孜自治州</td>\n</tr>\n<tr>\n<td align=\"left\">653001</td>\n<td align=\"left\">阿图什市</td>\n</tr>\n<tr>\n<td align=\"left\">653022</td>\n<td align=\"left\">阿克陶县</td>\n</tr>\n<tr>\n<td align=\"left\">653023</td>\n<td align=\"left\">阿合奇县</td>\n</tr>\n<tr>\n<td align=\"left\">653024</td>\n<td align=\"left\">乌恰县</td>\n</tr>\n<tr>\n<td align=\"left\">653100</td>\n<td align=\"left\">喀什地区</td>\n</tr>\n<tr>\n<td align=\"left\">653101</td>\n<td align=\"left\">喀什市</td>\n</tr>\n<tr>\n<td align=\"left\">653121</td>\n<td align=\"left\">疏附县</td>\n</tr>\n<tr>\n<td align=\"left\">653122</td>\n<td align=\"left\">疏勒县</td>\n</tr>\n<tr>\n<td align=\"left\">653123</td>\n<td align=\"left\">英吉沙县</td>\n</tr>\n<tr>\n<td align=\"left\">653124</td>\n<td align=\"left\">泽普县</td>\n</tr>\n<tr>\n<td align=\"left\">653125</td>\n<td align=\"left\">莎车县</td>\n</tr>\n<tr>\n<td align=\"left\">653126</td>\n<td align=\"left\">叶城县</td>\n</tr>\n<tr>\n<td align=\"left\">653127</td>\n<td align=\"left\">麦盖提县</td>\n</tr>\n<tr>\n<td align=\"left\">653128</td>\n<td align=\"left\">岳普湖县</td>\n</tr>\n<tr>\n<td align=\"left\">653129</td>\n<td align=\"left\">伽师县</td>\n</tr>\n<tr>\n<td align=\"left\">653130</td>\n<td align=\"left\">巴楚县</td>\n</tr>\n<tr>\n<td align=\"left\">653131</td>\n<td align=\"left\">塔什库尔干塔吉克自治县</td>\n</tr>\n<tr>\n<td align=\"left\">653200</td>\n<td align=\"left\">和田地区</td>\n</tr>\n<tr>\n<td align=\"left\">653201</td>\n<td align=\"left\">和田市</td>\n</tr>\n<tr>\n<td align=\"left\">653221</td>\n<td align=\"left\">和田县</td>\n</tr>\n<tr>\n<td align=\"left\">653222</td>\n<td align=\"left\">墨玉县</td>\n</tr>\n<tr>\n<td align=\"left\">653223</td>\n<td align=\"left\">皮山县</td>\n</tr>\n<tr>\n<td align=\"left\">653224</td>\n<td align=\"left\">洛浦县</td>\n</tr>\n<tr>\n<td align=\"left\">653225</td>\n<td align=\"left\">策勒县</td>\n</tr>\n<tr>\n<td align=\"left\">653226</td>\n<td align=\"left\">于田县</td>\n</tr>\n<tr>\n<td align=\"left\">653227</td>\n<td align=\"left\">民丰县</td>\n</tr>\n<tr>\n<td align=\"left\">654000</td>\n<td align=\"left\">伊犁哈萨克自治州</td>\n</tr>\n<tr>\n<td align=\"left\">654002</td>\n<td align=\"left\">伊宁市</td>\n</tr>\n<tr>\n<td align=\"left\">654003</td>\n<td align=\"left\">奎屯市</td>\n</tr>\n<tr>\n<td align=\"left\">654004</td>\n<td align=\"left\">霍尔果斯市</td>\n</tr>\n<tr>\n<td align=\"left\">654021</td>\n<td align=\"left\">伊宁县</td>\n</tr>\n<tr>\n<td align=\"left\">654022</td>\n<td align=\"left\">察布查尔锡伯自治县</td>\n</tr>\n<tr>\n<td align=\"left\">654023</td>\n<td align=\"left\">霍城县</td>\n</tr>\n<tr>\n<td align=\"left\">654024</td>\n<td align=\"left\">巩留县</td>\n</tr>\n<tr>\n<td align=\"left\">654025</td>\n<td align=\"left\">新源县</td>\n</tr>\n<tr>\n<td align=\"left\">654026</td>\n<td align=\"left\">昭苏县</td>\n</tr>\n<tr>\n<td align=\"left\">654027</td>\n<td align=\"left\">特克斯县</td>\n</tr>\n<tr>\n<td align=\"left\">654028</td>\n<td align=\"left\">尼勒克县</td>\n</tr>\n<tr>\n<td align=\"left\">654200</td>\n<td align=\"left\">塔城地区</td>\n</tr>\n<tr>\n<td align=\"left\">654201</td>\n<td align=\"left\">塔城市</td>\n</tr>\n<tr>\n<td align=\"left\">654202</td>\n<td align=\"left\">乌苏市</td>\n</tr>\n<tr>\n<td align=\"left\">654221</td>\n<td align=\"left\">额敏县</td>\n</tr>\n<tr>\n<td align=\"left\">654223</td>\n<td align=\"left\">沙湾县</td>\n</tr>\n<tr>\n<td align=\"left\">654224</td>\n<td align=\"left\">托里县</td>\n</tr>\n<tr>\n<td align=\"left\">654225</td>\n<td align=\"left\">裕民县</td>\n</tr>\n<tr>\n<td align=\"left\">654226</td>\n<td align=\"left\">和布克赛尔蒙古自治县</td>\n</tr>\n<tr>\n<td align=\"left\">654300</td>\n<td align=\"left\">阿勒泰地区</td>\n</tr>\n<tr>\n<td align=\"left\">654301</td>\n<td align=\"left\">阿勒泰市</td>\n</tr>\n<tr>\n<td align=\"left\">654321</td>\n<td align=\"left\">布尔津县</td>\n</tr>\n<tr>\n<td align=\"left\">654322</td>\n<td align=\"left\">富蕴县</td>\n</tr>\n<tr>\n<td align=\"left\">654323</td>\n<td align=\"left\">福海县</td>\n</tr>\n<tr>\n<td align=\"left\">654324</td>\n<td align=\"left\">哈巴河县</td>\n</tr>\n<tr>\n<td align=\"left\">654325</td>\n<td align=\"left\">青河县</td>\n</tr>\n<tr>\n<td align=\"left\">654326</td>\n<td align=\"left\">吉木乃县</td>\n</tr>\n<tr>\n<td align=\"left\">659001</td>\n<td align=\"left\">石河子市</td>\n</tr>\n<tr>\n<td align=\"left\">659002</td>\n<td align=\"left\">阿拉尔市</td>\n</tr>\n<tr>\n<td align=\"left\">659003</td>\n<td align=\"left\">图木舒克市</td>\n</tr>\n<tr>\n<td align=\"left\">659004</td>\n<td align=\"left\">五家渠市</td>\n</tr>\n<tr>\n<td align=\"left\">659005</td>\n<td align=\"left\">北屯市</td>\n</tr>\n<tr>\n<td align=\"left\">659006</td>\n<td align=\"left\">铁门关市</td>\n</tr>\n<tr>\n<td align=\"left\">659007</td>\n<td align=\"left\">双河市</td>\n</tr>\n<tr>\n<td align=\"left\">659008</td>\n<td align=\"left\">可克达拉市</td>\n</tr>\n<tr>\n<td align=\"left\">659009</td>\n<td align=\"left\">昆玉市</td>\n</tr>\n<tr>\n<td align=\"left\">659010</td>\n<td align=\"left\">胡杨河市</td>\n</tr>\n<tr>\n<td align=\"left\">710000</td>\n<td align=\"left\">台湾省</td>\n</tr>\n<tr>\n<td align=\"left\">810000</td>\n<td align=\"left\">香港特别行政区</td>\n</tr>\n<tr>\n<td align=\"left\">820000</td>\n<td align=\"left\">澳门特别行政区</td>\n</tr>\n<tr>\n<td align=\"left\">注：1、台湾省、香港特别行政区和澳门特别行政区暂缺地市和区县信息。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2.本表由统计人员每月根据民政统计信息管理系统中上报单位名称变动情况搜集相关文件编制，略滞后于区划调整文件发布时间。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3.为保证上下年度统计工作有效衔接，各级民政统计人员将在当年12月底与区划部门核对并调整统计系统中所有上报单位名称，同时编制发布本表。</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n","slug":"2020年1月中华人民共和国县以上行政区划代码","updated":"2022-11-27T10:39:22.787Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/08/24/2020%E5%B9%B41%E6%9C%88%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%8E%BF%E4%BB%A5%E4%B8%8A%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E4%BB%A3%E7%A0%81/","excerpt":"","categories":[{"name":"工作","slug":"工作","permalink":"http://vwin.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"行政区","slug":"行政区","permalink":"http://vwin.github.io/tags/%E8%A1%8C%E6%94%BF%E5%8C%BA/"}]},{"title":"Github Pages添加域名解析","date":"2022-08-17T08:39:10.000Z","path":"2022/08/17/Github-Pages添加域名解析/","text":"创建CNAME进入github仓库, 在你的库下面添加一个 CNAME （别名记录）文件，建议直接在 GitHub 那创建 因为每次hexo d后会覆盖，所以建议将CNAME文件添加到源码分支 放到源码分支无法在每次hexo d后同步到主分支，在源码分支的source目录下建一个CNAME文件，这样每次hexo g &amp;&amp; hexo d之后会自动生成CNAME文件在主分支的根目录CNAME 记得要大写，然后内容是写你的域名，图中这样的格式，不要加上 http、https、www。 添加DNS解析我用的腾讯云买的域名，进入：https://console.dnspod.cn/添加三条记录 修改仓库设置添加完成后进入库的设置，找到 GitHub Pages ，如果能看到类似 Your site is published at https://yuleweici.com/ 这样的文字，说明就搞定了。 Enforce HTTPS 最好勾选上，GitHub 提供的这个可以直接让你的网站从 HTTP 升级到 HTTPS，非常赞。 完成设置，过一会就可以通过自己的域名访问username.github.io","raw":"---\ntitle: Github Pages添加域名解析\ntoc: true\ndate: 2022-08-17 16:39:10\ntags: [github pages,域名解析]\ncategories: [技术]\ndescription:\n---\n## 创建CNAME\n进入github仓库, 在你的库下面添加一个 CNAME （别名记录）文件，建议直接在 GitHub 那创建\n1. 因为每次hexo d后会覆盖，所以建议将CNAME文件添加到源码分支\n2. 放到源码分支无法在每次hexo d后同步到主分支，在源码分支的source目录下建一个CNAME文件，这样每次hexo g && hexo d之后会自动生成CNAME文件在主分支的根目录\n![创建CNAME](http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/github.png)\nCNAME 记得要大写，然后内容是写你的域名，图中这样的格式，不要加上 http、https、www。\n![CNAME](http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/cname.png)\n\n## 添加DNS解析\n我用的腾讯云买的域名，进入：https://console.dnspod.cn/ \n添加三条记录\n![DNS](http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/dns.png)\n\n## 修改仓库设置\n添加完成后进入库的设置，找到 GitHub Pages ，如果能看到类似  Your site is published at https://yuleweici.com/ 这样的文字，说明就搞定了。\n\nEnforce HTTPS 最好勾选上，GitHub 提供的这个可以直接让你的网站从 HTTP 升级到 HTTPS，非常赞。\n![settings](http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/settings.png)\n\n完成设置，过一会就可以通过自己的域名访问username.github.io","content":"<h2 id=\"创建CNAME\"><a href=\"#创建CNAME\" class=\"headerlink\" title=\"创建CNAME\"></a>创建CNAME</h2><p>进入github仓库, 在你的库下面添加一个 CNAME （别名记录）文件，建议直接在 GitHub 那创建</p>\n<ol>\n<li>因为每次hexo d后会覆盖，所以建议将CNAME文件添加到源码分支</li>\n<li>放到源码分支无法在每次hexo d后同步到主分支，在源码分支的source目录下建一个CNAME文件，这样每次hexo g &amp;&amp; hexo d之后会自动生成CNAME文件在主分支的根目录<br><img src=\"http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/github.png\" alt=\"创建CNAME\"><br>CNAME 记得要大写，然后内容是写你的域名，图中这样的格式，不要加上 http、https、www。<br><img src=\"http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/cname.png\" alt=\"CNAME\"></li>\n</ol>\n<h2 id=\"添加DNS解析\"><a href=\"#添加DNS解析\" class=\"headerlink\" title=\"添加DNS解析\"></a>添加DNS解析</h2><p>我用的腾讯云买的域名，进入：<a href=\"https://console.dnspod.cn/\">https://console.dnspod.cn/</a><br>添加三条记录<br><img src=\"http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/dns.png\" alt=\"DNS\"></p>\n<h2 id=\"修改仓库设置\"><a href=\"#修改仓库设置\" class=\"headerlink\" title=\"修改仓库设置\"></a>修改仓库设置</h2><p>添加完成后进入库的设置，找到 GitHub Pages ，如果能看到类似  Your site is published at <a href=\"https://yuleweici.com/\">https://yuleweici.com/</a> 这样的文字，说明就搞定了。</p>\n<p>Enforce HTTPS 最好勾选上，GitHub 提供的这个可以直接让你的网站从 HTTP 升级到 HTTPS，非常赞。<br><img src=\"http://cdn.yuleweici.com/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/settings.png\" alt=\"settings\"></p>\n<p>完成设置，过一会就可以通过自己的域名访问username.github.io</p>\n","slug":"Github-Pages添加域名解析","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/08/17/Github-Pages%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"github pages","slug":"github-pages","permalink":"http://vwin.github.io/tags/github-pages/"},{"name":"域名解析","slug":"域名解析","permalink":"http://vwin.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]},{"title":"Git-分支策略","date":"2022-08-15T08:28:44.000Z","path":"2022/08/15/分支策略/","text":"对分支策略的期望是什么？这个问题受很多因素的影响，团队的规模，项目团队的数量，项目是否同时开发多个功能，代码发布到生产环境的频率…… 条件越复杂，我们就越需要一个合适的分支策略去支持团队工作。 我们先从简单的需求方案总结我们所期望分支策略做的事，再逐渐复杂化。 首先，作为个体（即使是在个人项目的演示中），我们需要： 有我们所做更改的全部历史版本 可以进行修改对比、必要时还原历史版本 如果我需要创建一个 bugfix ，我可以在不影响我进行中的新功能开发的前提下去开发和部署它 那么，作为团队，除了上述要求，我还需要： 能够正常工作并推送更改到远程服务器而不影响我的同事们 可以将我的更改与同事的更改合并，并以最简单的方式解决任何冲突 无论涉及的人数多少，都要确保代码的质量&#x2F;基本标准这是代码版本控制的基本要求，或者说，是 DevOps 的基本要求。 基本概念分支策略就是在哪个分支上开发、在哪个分支上部署、分支同步和分支合并的原则。现代主流的分支策略有 Git Flow(2010年) GitHub Flow（2011年） Trunk based development（2013年） GitLab Flow（2014年） Git Flow此工作流，是 Vincent Driessen 2010 年发布出来的他自己的分支管理模型，到现在为止，使用度非常高，但也最为复杂。 项目存在两个长期分支： master 主分支，稳定代码，为生产环境做准备的 develop 开发分支，为开发服务 另外项目存在三种短期分支： 特性分支（feature branch）: 从develop分支创建，用于特性开发，完成后要合并回develop分支。 操作过程： 12345git checkout -b newfeature develop，从develop分支创建newfeature特性分支git checkout develop，开发完成后，需要合并回develop分支，先切换到develop分支 git merge --no-ffnewfeature，合并回develop分支，必须加--no-ff参数 git branch -d newfeature，删除特性分支 git push origin develop，把合并后的develop分支推送到远程仓库 发布分支（release branch）:从develop分支创建，用于预发布版本，允许小bug修复，完成后要合并回develop和master。 操作过程： 1234567gitcheckou -b release-1.2 develop，创建一个发布分支 git checkout master，切换到master分支，准备合并 git merge --no-ff release-1.2，把release-1.2分支合并到master分支 git tag 1.2，从master分支打一个标签 gitcheckou develop，切换到develop分支，准备合并 git merge --no-ff release-1.2，把release-1.2分支合并到develop分支 git branch -d release-1.2，删除这个发布分支 修复分支（hotfix branch）:从master分支创建，用于生产环境上的Bug修复，完成后要合并回develop和master。 操作过程： 1234567git checkout -b hotfix-1.2.1 master，从master分支创建一个Bug修复分支 git checkout master，切换到master分支，准备合并 git merge --no-ff hotfix-1.2.1，合并到master分支 git tag 1.2.1，为master分支创建一个标签 git checkout develop，切换到develop分支，准备合并 git merge --no-ff hotfix-1.2.1，合并到develop分支 git branch -d hotfix-1.2.1，删除hotfix-1.2.1分支 优缺点优点: 适合于版本周期明确的大型项目 工作流设计比较完备，包含专门用于生产环境问题修复的渠道 缺点: 开发容易忘记要从develop拉出feature分支，而是习惯从master拉取 开发者使用develop分支进行开发，但是默认的发布分支是release分支，开发者需要频繁的切换分支 对于大部分项目来说，工作流程过于复杂 Github Flow它只有一个长期分支 master ,而且 master 分支上的代码，永远是可发布状态, 一般master 会设置 protected 分支保护，只有有权限的人才能推送代码到 master 分支。 开发流程： 123451. 如果有新功能开发，可以从 master 分支上检出新分支。2. 在本地分支提交代码，并且保证按时向远程仓库推送。3. 当你需要反馈或者帮助，或者你想合并分支时，可以发起一个 pull request。4. 当 review 或者讨论通过后，代码会合并到目标分支。5. 一旦合并到 master 分支，应该立即发布。 优缺点优点: 最大优点就是简单，对于持续发布的产品是最合适的流程 缺点: 要求master分支的更新与产品的发布是一致的。但有时候代码合并进入master分支，并不代表它就能立刻发布。比如有固定发布窗口期和需要等待审核的产品 不适合任何生产环境代码落后于master代码的情况 Trunk Based Development这是Paul Hammant 2013年提出的模型，基本就是SVN的模型，在TBD模型中，所有开发都在主干，但是拉出新的分支交付。这个场景下，假设所有的特性开发都可以快速完成，这样就不会影响CI。 优缺点优点: 合并冲突少 利于持续集成，持续交付 版本迭代速度快 缺点: 对持续集成、验证要求高 对团队成熟度要求高 主干上存在未开发完全的功能 GitLab Flow这个工作流十分地年轻，是GitLab的 CEO SytseSijbrandij在 2014 年 9月 29 正式发布出来的。因为出现的比前面两种工作流稍微晚一些，所以它有个非常大的优势，集百家之长，补百家之短。 对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。 只有紧急情况，才允许跳过上游，直接合并到下游分支。对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。 以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号 优缺点优点: 对于持续部署，持续交付有很好的支持 解决了测试、预发布、正式上线的不同环境问题 有明确开发分支和发布分支的规则定义 支持多版本并行的方式 缺点: 持续发布的工作流只关心最新版本，对历史版本无记录 分支与环境的融合 对比开发、发布分支选择: TBD 是主干开发，支持分支发布，也支持主干发布。 Git-Flow 是分支开发，分支发布。 GitHub-Flow 是分支开发，主干发布。 GitLab-Flow 是分支开发，支持主干发布，也支持分支发布。 各个策略都有优缺点，合适自己的，才是最好的","raw":"---\ntitle: Git-分支策略\ntoc: true\ndate: 2022-08-15 16:28:44\ntags: [测试,分支策略]\ncategories: [测试]\ndescription:\n---\n## 对分支策略的期望是什么？\n这个问题受很多因素的影响，团队的规模，项目团队的数量，项目是否同时开发多个功能，代码发布到生产环境的频率...... 条件越复杂，我们就越需要一个合适的分支策略去支持团队工作。\n\n我们先从简单的需求方案总结我们所期望分支策略做的事，再逐渐复杂化。\n\n首先，作为个体（即使是在个人项目的演示中），我们需要：\n\n1. 有我们所做更改的全部历史版本\n2. 可以进行修改对比、必要时还原历史版本\n3. 如果我需要创建一个 bugfix ，我可以在不影响我进行中的新功能开发的前提下去开发和部署它\n\n那么，作为团队，除了上述要求，我还需要：\n\n1. 能够正常工作并推送更改到远程服务器而不影响我的同事们\n2. 可以将我的更改与同事的更改合并，并以最简单的方式解决任何冲突\n3. 无论涉及的人数多少，都要确保代码的质量/基本标准\n这是代码版本控制的基本要求，或者说，是 DevOps 的基本要求。\n\n\n## 基本概念\n分支策略就是在哪个分支上开发、在哪个分支上部署、分支同步和分支合并的原则。\n现代主流的分支策略有\n\n1. Git Flow(2010年)\n2. GitHub Flow（2011年）\n3. Trunk based development（2013年）\n4. GitLab Flow（2014年）\n\n## [Git Flow](http://nvie.com/posts/a-successful-git-branching-model/)\n此工作流，是 Vincent Driessen 2010 年发布出来的他自己的分支管理模型，到现在为止，使用度非常高，但也最为复杂。\n\n![Git Flow](http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/gitflow_branch.png)\n\n项目存在两个长期分支：\n- master 主分支，稳定代码，为生产环境做准备的\n- develop 开发分支，为开发服务 \n\n另外项目存在三种短期分支：\n\n- 特性分支（feature branch）: 从develop分支创建，用于特性开发，完成后要合并回develop分支。 \n\n    操作过程：\n    ```shell\n    git checkout -b newfeature develop，从develop分支创建newfeature特性分支\n    git checkout develop，开发完成后，需要合并回develop分支，先切换到develop分支 \n    git merge --no-ffnewfeature，合并回develop分支，必须加--no-ff参数 \n    git branch -d newfeature，删除特性分支 \n    git push origin develop，把合并后的develop分支推送到远程仓库 \n    ```\n\n- 发布分支（release branch）:从develop分支创建，用于预发布版本，允许小bug修复，完成后要合并回develop和master。 \n\n    操作过程： \n    ```shell\n    gitcheckou -b release-1.2 develop，创建一个发布分支 \n    git checkout master，切换到master分支，准备合并 \n    git merge --no-ff release-1.2，把release-1.2分支合并到master分支 \n    git tag 1.2，从master分支打一个标签 \n    gitcheckou develop，切换到develop分支，准备合并 \n    git merge --no-ff release-1.2，把release-1.2分支合并到develop分支 \n    git branch -d release-1.2，删除这个发布分支\n    ```\n\n- 修复分支（hotfix branch）:从master分支创建，用于生产环境上的Bug修复，完成后要合并回develop和master。\n    操作过程： \n    ```shell\n    git checkout -b hotfix-1.2.1 master，从master分支创建一个Bug修复分支 \n    git checkout master，切换到master分支，准备合并 \n    git merge --no-ff hotfix-1.2.1，合并到master分支 \n    git tag 1.2.1，为master分支创建一个标签 \n    git checkout develop，切换到develop分支，准备合并 \n    git merge --no-ff hotfix-1.2.1，合并到develop分支 \n    git branch -d hotfix-1.2.1，删除hotfix-1.2.1分支 \n    ```\n### 优缺点\n\n优点:\n1. 适合于版本周期明确的大型项目\n2. 工作流设计比较完备，包含专门用于生产环境问题修复的渠道\n\n缺点:\n1. 开发容易忘记要从develop拉出feature分支，而是习惯从master拉取\n2. 开发者使用develop分支进行开发，但是默认的发布分支是release分支，开发者需要频繁的切换分支\n\n对于大部分项目来说，工作流程过于复杂\n## [Github Flow](https://guides.github.com/introduction/flow/)\n![Github Flow](http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/githubflow_branch.png)\n它只有一个长期分支 master ,而且 master 分支上的代码，永远是可发布状态, 一般master 会设置 protected 分支保护，只有有权限的人才能推送代码到 master 分支。\n\n开发流程：\n```shell\n1. 如果有新功能开发，可以从 master 分支上检出新分支。\n2. 在本地分支提交代码，并且保证按时向远程仓库推送。\n3. 当你需要反馈或者帮助，或者你想合并分支时，可以发起一个 pull request。\n4. 当 review 或者讨论通过后，代码会合并到目标分支。\n5. 一旦合并到 master 分支，应该立即发布。\n```\n### 优缺点\n\n优点:\n1. 最大优点就是简单，对于持续发布的产品是最合适的流程\n\n缺点:\n1. 要求master分支的更新与产品的发布是一致的。但有时候代码合并进入master分支，并不代表它就能立刻发布。比如有固定发布窗口期和需要等待审核的产品\n2. 不适合任何生产环境代码落后于master代码的情况\n\n## [Trunk Based Development](https://trunkbaseddevelopment.com/)\n这是Paul Hammant 2013年提出的模型，基本就是SVN的模型，在TBD模型中，所有开发都在主干，但是拉出新的分支交付。这个场景下，假设所有的特性开发都可以快速完成，这样就不会影响CI。\n![Trunk Based](http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/trunkbasedflow_branch.png)\n\n### 优缺点\n优点:\n1. 合并冲突少\n2. 利于持续集成，持续交付\n3. 版本迭代速度快\n\n缺点:\n1. 对持续集成、验证要求高\n2. 对团队成熟度要求高\n3. 主干上存在未开发完全的功能\n\n## [GitLab Flow](https://docs.gitlab.com/ee/workflow/gitlab_flow.html)\n这个工作流十分地年轻，是GitLab的 CEO SytseSijbrandij在 2014 年 9月 29 正式发布出来的。因为出现的比前面两种工作流稍微晚一些，所以它有个非常大的优势，集百家之长，补百家之短。\n\n 对于\"持续发布\"的项目，它建议在master分支以外，再建立不同的环境分支。比如，\"开发环境\"的分支是master，\"预发环境\"的分支是pre-production，\"生产环境\"的分支是production。\n\n开发分支是预发分支的\"上游\"，预发分支又是生产分支的\"上游\"。代码的变化，必须由\"上游\"向\"下游\"发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。\n\n只有紧急情况，才允许跳过上游，直接合并到下游分支。\n![Gitlab Flow](分支策略/gitlabflow_branch.gif)\n对于\"版本发布\"的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。\n\n以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号\n![Gitlab Flow](分支策略/gitlabflow2_branch.gif)\n\n### 优缺点\n\n优点:\n1. 对于持续部署，持续交付有很好的支持\n2. 解决了测试、预发布、正式上线的不同环境问题\n3. 有明确开发分支和发布分支的规则定义\n4. 支持多版本并行的方式\n\n缺点:\n1. 持续发布的工作流只关心最新版本，对历史版本无记录\n2. 分支与环境的融合\n\n## 对比\n开发、发布分支选择:\n1. TBD 是主干开发，支持分支发布，也支持主干发布。\n2. Git-Flow 是分支开发，分支发布。\n3. GitHub-Flow 是分支开发，主干发布。\n4. GitLab-Flow 是分支开发，支持主干发布，也支持分支发布。\n\n各个策略都有优缺点，合适自己的，才是最好的\n\n![Diff](http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/flow_diff.png)\n![Diff](http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/flow_diff2.jpeg)\n","content":"<h2 id=\"对分支策略的期望是什么？\"><a href=\"#对分支策略的期望是什么？\" class=\"headerlink\" title=\"对分支策略的期望是什么？\"></a>对分支策略的期望是什么？</h2><p>这个问题受很多因素的影响，团队的规模，项目团队的数量，项目是否同时开发多个功能，代码发布到生产环境的频率…… 条件越复杂，我们就越需要一个合适的分支策略去支持团队工作。</p>\n<p>我们先从简单的需求方案总结我们所期望分支策略做的事，再逐渐复杂化。</p>\n<p>首先，作为个体（即使是在个人项目的演示中），我们需要：</p>\n<ol>\n<li>有我们所做更改的全部历史版本</li>\n<li>可以进行修改对比、必要时还原历史版本</li>\n<li>如果我需要创建一个 bugfix ，我可以在不影响我进行中的新功能开发的前提下去开发和部署它</li>\n</ol>\n<p>那么，作为团队，除了上述要求，我还需要：</p>\n<ol>\n<li>能够正常工作并推送更改到远程服务器而不影响我的同事们</li>\n<li>可以将我的更改与同事的更改合并，并以最简单的方式解决任何冲突</li>\n<li>无论涉及的人数多少，都要确保代码的质量&#x2F;基本标准<br>这是代码版本控制的基本要求，或者说，是 DevOps 的基本要求。</li>\n</ol>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>分支策略就是在哪个分支上开发、在哪个分支上部署、分支同步和分支合并的原则。<br>现代主流的分支策略有</p>\n<ol>\n<li>Git Flow(2010年)</li>\n<li>GitHub Flow（2011年）</li>\n<li>Trunk based development（2013年）</li>\n<li>GitLab Flow（2014年）</li>\n</ol>\n<h2 id=\"Git-Flow\"><a href=\"#Git-Flow\" class=\"headerlink\" title=\"Git Flow\"></a><a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">Git Flow</a></h2><p>此工作流，是 Vincent Driessen 2010 年发布出来的他自己的分支管理模型，到现在为止，使用度非常高，但也最为复杂。</p>\n<p><img src=\"http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/gitflow_branch.png\" alt=\"Git Flow\"></p>\n<p>项目存在两个长期分支：</p>\n<ul>\n<li>master 主分支，稳定代码，为生产环境做准备的</li>\n<li>develop 开发分支，为开发服务</li>\n</ul>\n<p>另外项目存在三种短期分支：</p>\n<ul>\n<li><p>特性分支（feature branch）: 从develop分支创建，用于特性开发，完成后要合并回develop分支。 </p>\n<p>  操作过程：</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b newfeature develop，从develop分支创建newfeature特性分支</span><br><span class=\"line\">git checkout develop，开发完成后，需要合并回develop分支，先切换到develop分支 </span><br><span class=\"line\">git merge --no-ffnewfeature，合并回develop分支，必须加--no-ff参数 </span><br><span class=\"line\">git branch -d newfeature，删除特性分支 </span><br><span class=\"line\">git push origin develop，把合并后的develop分支推送到远程仓库 </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布分支（release branch）:从develop分支创建，用于预发布版本，允许小bug修复，完成后要合并回develop和master。 </p>\n<p>  操作过程： </p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitcheckou -b release-1.2 develop，创建一个发布分支 </span><br><span class=\"line\">git checkout master，切换到master分支，准备合并 </span><br><span class=\"line\">git merge --no-ff release-1.2，把release-1.2分支合并到master分支 </span><br><span class=\"line\">git tag 1.2，从master分支打一个标签 </span><br><span class=\"line\">gitcheckou develop，切换到develop分支，准备合并 </span><br><span class=\"line\">git merge --no-ff release-1.2，把release-1.2分支合并到develop分支 </span><br><span class=\"line\">git branch -d release-1.2，删除这个发布分支</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修复分支（hotfix branch）:从master分支创建，用于生产环境上的Bug修复，完成后要合并回develop和master。<br>  操作过程： </p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b hotfix-1.2.1 master，从master分支创建一个Bug修复分支 </span><br><span class=\"line\">git checkout master，切换到master分支，准备合并 </span><br><span class=\"line\">git merge --no-ff hotfix-1.2.1，合并到master分支 </span><br><span class=\"line\">git tag 1.2.1，为master分支创建一个标签 </span><br><span class=\"line\">git checkout develop，切换到develop分支，准备合并 </span><br><span class=\"line\">git merge --no-ff hotfix-1.2.1，合并到develop分支 </span><br><span class=\"line\">git branch -d hotfix-1.2.1，删除hotfix-1.2.1分支 </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>优点:</p>\n<ol>\n<li>适合于版本周期明确的大型项目</li>\n<li>工作流设计比较完备，包含专门用于生产环境问题修复的渠道</li>\n</ol>\n<p>缺点:</p>\n<ol>\n<li>开发容易忘记要从develop拉出feature分支，而是习惯从master拉取</li>\n<li>开发者使用develop分支进行开发，但是默认的发布分支是release分支，开发者需要频繁的切换分支</li>\n</ol>\n<p>对于大部分项目来说，工作流程过于复杂</p>\n<h2 id=\"Github-Flow\"><a href=\"#Github-Flow\" class=\"headerlink\" title=\"Github Flow\"></a><a href=\"https://guides.github.com/introduction/flow/\">Github Flow</a></h2><p><img src=\"http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/githubflow_branch.png\" alt=\"Github Flow\"><br>它只有一个长期分支 master ,而且 master 分支上的代码，永远是可发布状态, 一般master 会设置 protected 分支保护，只有有权限的人才能推送代码到 master 分支。</p>\n<p>开发流程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果有新功能开发，可以从 master 分支上检出新分支。</span><br><span class=\"line\">2. 在本地分支提交代码，并且保证按时向远程仓库推送。</span><br><span class=\"line\">3. 当你需要反馈或者帮助，或者你想合并分支时，可以发起一个 pull request。</span><br><span class=\"line\">4. 当 review 或者讨论通过后，代码会合并到目标分支。</span><br><span class=\"line\">5. 一旦合并到 master 分支，应该立即发布。</span><br></pre></td></tr></table></figure>\n<h3 id=\"优缺点-1\"><a href=\"#优缺点-1\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>优点:</p>\n<ol>\n<li>最大优点就是简单，对于持续发布的产品是最合适的流程</li>\n</ol>\n<p>缺点:</p>\n<ol>\n<li>要求master分支的更新与产品的发布是一致的。但有时候代码合并进入master分支，并不代表它就能立刻发布。比如有固定发布窗口期和需要等待审核的产品</li>\n<li>不适合任何生产环境代码落后于master代码的情况</li>\n</ol>\n<h2 id=\"Trunk-Based-Development\"><a href=\"#Trunk-Based-Development\" class=\"headerlink\" title=\"Trunk Based Development\"></a><a href=\"https://trunkbaseddevelopment.com/\">Trunk Based Development</a></h2><p>这是Paul Hammant 2013年提出的模型，基本就是SVN的模型，在TBD模型中，所有开发都在主干，但是拉出新的分支交付。这个场景下，假设所有的特性开发都可以快速完成，这样就不会影响CI。<br><img src=\"http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/trunkbasedflow_branch.png\" alt=\"Trunk Based\"></p>\n<h3 id=\"优缺点-2\"><a href=\"#优缺点-2\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>优点:</p>\n<ol>\n<li>合并冲突少</li>\n<li>利于持续集成，持续交付</li>\n<li>版本迭代速度快</li>\n</ol>\n<p>缺点:</p>\n<ol>\n<li>对持续集成、验证要求高</li>\n<li>对团队成熟度要求高</li>\n<li>主干上存在未开发完全的功能</li>\n</ol>\n<h2 id=\"GitLab-Flow\"><a href=\"#GitLab-Flow\" class=\"headerlink\" title=\"GitLab Flow\"></a><a href=\"https://docs.gitlab.com/ee/workflow/gitlab_flow.html\">GitLab Flow</a></h2><p>这个工作流十分地年轻，是GitLab的 CEO SytseSijbrandij在 2014 年 9月 29 正式发布出来的。因为出现的比前面两种工作流稍微晚一些，所以它有个非常大的优势，集百家之长，补百家之短。</p>\n<p> 对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。</p>\n<p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。</p>\n<p>只有紧急情况，才允许跳过上游，直接合并到下游分支。<br><img src=\"/2022/08/15/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/gitlabflow_branch.gif\" alt=\"Gitlab Flow\"><br>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。</p>\n<p>以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号<br><img src=\"/2022/08/15/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/gitlabflow2_branch.gif\" alt=\"Gitlab Flow\"></p>\n<h3 id=\"优缺点-3\"><a href=\"#优缺点-3\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>优点:</p>\n<ol>\n<li>对于持续部署，持续交付有很好的支持</li>\n<li>解决了测试、预发布、正式上线的不同环境问题</li>\n<li>有明确开发分支和发布分支的规则定义</li>\n<li>支持多版本并行的方式</li>\n</ol>\n<p>缺点:</p>\n<ol>\n<li>持续发布的工作流只关心最新版本，对历史版本无记录</li>\n<li>分支与环境的融合</li>\n</ol>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><p>开发、发布分支选择:</p>\n<ol>\n<li>TBD 是主干开发，支持分支发布，也支持主干发布。</li>\n<li>Git-Flow 是分支开发，分支发布。</li>\n<li>GitHub-Flow 是分支开发，主干发布。</li>\n<li>GitLab-Flow 是分支开发，支持主干发布，也支持分支发布。</li>\n</ol>\n<p>各个策略都有优缺点，合适自己的，才是最好的</p>\n<p><img src=\"http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/flow_diff.png\" alt=\"Diff\"><br><img src=\"http://cdn.yuleweici.com/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/flow_diff2.jpeg\" alt=\"Diff\"></p>\n","slug":"分支策略","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2022/08/15/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/","excerpt":"","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"分支策略","slug":"分支策略","permalink":"http://vwin.github.io/tags/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/"}]},{"title":"相见恨晚的Python库","date":"2021-09-18T12:31:44.000Z","path":"2021/09/18/相见恨晚的Python库/","text":"常用的Python库，涉及各个方面转自知乎：https://www.zhihu.com/question/24590883相关链接：http://hao.jobbole.com/?catid=144","raw":"---\ntitle: 相见恨晚的Python库\ntoc: true\ndate: 2021-09-18 20:31:44\ntags: [python]\ncategories: [技术]\ndescription: \n---\n常用的Python库，涉及各个方面\n转自知乎：https://www.zhihu.com/question/24590883 \n相关链接：http://hao.jobbole.com/?catid=144\n\n","content":"<p>常用的Python库，涉及各个方面<br>转自知乎：<a href=\"https://www.zhihu.com/question/24590883\">https://www.zhihu.com/question/24590883</a><br>相关链接：<a href=\"http://hao.jobbole.com/?catid=144\">http://hao.jobbole.com/?catid=144</a></p>\n","slug":"相见恨晚的Python库","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2021/09/18/%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A%E7%9A%84Python%E5%BA%93/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"}]},{"title":"Jmeter安装","date":"2021-08-01T07:22:52.000Z","path":"2021/08/01/性能测试-Jmeter安装/","text":"Ubuntu安装JDK 更新软件包列表1sudo apt-get update 安装openjdk-8-jdk1sudo apt-get install openjdk-8-jdk 查看Java版本1java -version Mac安装JavaJRE和JDK的区别 JRE： Java Runtime Environment JDK：Java Development Kit JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。 JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。所以JDK的包比JRE大很多。 如果你需要运行java程序，只需安装JRE就可以了 如果你需要编写java程序，需要安装JDK。 JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本，最常用的是Oracle公司收购SUN公司的JRE版本。 安装JRE&#x2F;JDK JRE下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html JDK下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.htmlMac下载对应的包，下载完成后直接安装即可 环境变量配置 JRE:如果安装的是JRE，那么在Mac上默认的路径是1/Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home 配置环境变量（vi ~&#x2F;.bash_profile）：1234JAVA_HOME=/Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin/Contents/HomePATH=$JAVA_HOME/bin:$PATHexport JAVA_HOMEexport PATH JDK:如果安装的是JDK，那么在Mac上默认的路径是1/Library/Java/JavaVirtualMachines/ 配置环境变量（vi ~&#x2F;.bash_profile）：123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH 安装Jmeter 下载Jmeter4.01wget -c http://www-us.apache.org/dist//jmeter/binaries/apache-jmeter-4.0.tgz 解压1tar -xf apache-jmeter-4.0.tgz 运行sample1apache-jmeter-4.0/bin/./jmeter -n -t apache-jmeter-4.0/extras/Test.jmx Jmeter基础Jmeter环境变量配置 MAC版本,具体路径请根据\b自己本地路径进行替换123export JMETER_HOME=/Users/\bxxx/apache-jmeter-4.0export CLASSPATH=.:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jarexport PATH=$JMETER_HOME/bin:$PATH Mac下启动jmeter1完成环境变量配置后，直接在终端输入jmeter即可启动。 Jmeter基础请看Jmeter基础系列文章。","raw":"---\ntitle: Jmeter安装\ntoc: true\ndate: 2021-08-01 15:22:52\ntags: [ubuntu,jmeter,jdk,jre]\ncategories: [测试]\ndescription: Ubuntu/Mac安装jmeter进行性能测试\n---\n## Ubuntu安装JDK\n1. 更新软件包列表\n```shell\nsudo apt-get update\n```\n2. 安装openjdk-8-jdk\n```shell\nsudo apt-get install openjdk-8-jdk\n```\n3. 查看Java版本\n```shell\njava -version\n```\n## Mac安装Java\n### JRE和JDK的区别\n- JRE： Java Runtime Environment\n- JDK：Java Development Kit \n- JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。\n- JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。所以JDK的包比JRE大很多。\n- 如果你需要运行java程序，只需安装JRE就可以了\n- 如果你需要编写java程序，需要安装JDK。\n- JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本，最常用的是Oracle公司收购SUN公司的JRE版本。\n\n### 安装JRE/JDK\n- JRE下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html\n- JDK下载地址：\nhttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\nMac下载对应的包，下载完成后直接安装即可\n\n### 环境变量配置\n1. JRE:如果安装的是JRE，那么在Mac上默认的路径是\n```\n/Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home\n```\n- 配置环境变量（vi ~/.bash_profile）：\n```\nJAVA_HOME=/Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home\nPATH=$JAVA_HOME/bin:$PATH\nexport JAVA_HOME\nexport PATH\n```\n2. JDK:如果安装的是JDK，那么在Mac上默认的路径是\n```\n/Library/Java/JavaVirtualMachines/\n```\n- 配置环境变量（vi ~/.bash_profile）：\n```\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home\nPATH=$JAVA_HOME/bin:$PATH:.\nCLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.\nexport JAVA_HOME\nexport PATH\nexport CLASSPATH\n```\n## 安装Jmeter\n1. 下载Jmeter4.0\n```shell\nwget -c http://www-us.apache.org/dist//jmeter/binaries/apache-jmeter-4.0.tgz\n```\n2. 解压\n```shell\ntar -xf apache-jmeter-4.0.tgz\n```\n3. 运行sample\n```shell\napache-jmeter-4.0/bin/./jmeter -n -t apache-jmeter-4.0/extras/Test.jmx\n```\n## Jmeter基础\n\n### Jmeter环境变量配置\n- MAC版本,具体路径请根据\b自己本地路径进行替换\n```shell\nexport JMETER_HOME=/Users/\bxxx/apache-jmeter-4.0\nexport CLASSPATH=.:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar\nexport PATH=$JMETER_HOME/bin:$PATH\n```\n- Mac下启动jmeter\n```\n完成环境变量配置后，直接在终端输入jmeter即可启动。\n```\n\n### Jmeter基础\n请看Jmeter基础系列文章。","content":"<h2 id=\"Ubuntu安装JDK\"><a href=\"#Ubuntu安装JDK\" class=\"headerlink\" title=\"Ubuntu安装JDK\"></a>Ubuntu安装JDK</h2><ol>\n<li>更新软件包列表<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure></li>\n<li>安装openjdk-8-jdk<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure></li>\n<li>查看Java版本<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -version</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Mac安装Java\"><a href=\"#Mac安装Java\" class=\"headerlink\" title=\"Mac安装Java\"></a>Mac安装Java</h2><h3 id=\"JRE和JDK的区别\"><a href=\"#JRE和JDK的区别\" class=\"headerlink\" title=\"JRE和JDK的区别\"></a>JRE和JDK的区别</h3><ul>\n<li>JRE： Java Runtime Environment</li>\n<li>JDK：Java Development Kit </li>\n<li>JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。</li>\n<li>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。所以JDK的包比JRE大很多。</li>\n<li>如果你需要运行java程序，只需安装JRE就可以了</li>\n<li>如果你需要编写java程序，需要安装JDK。</li>\n<li>JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本，最常用的是Oracle公司收购SUN公司的JRE版本。</li>\n</ul>\n<h3 id=\"安装JRE-x2F-JDK\"><a href=\"#安装JRE-x2F-JDK\" class=\"headerlink\" title=\"安装JRE&#x2F;JDK\"></a>安装JRE&#x2F;JDK</h3><ul>\n<li>JRE下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html\">http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html</a></li>\n<li>JDK下载地址：<br><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>Mac下载对应的包，下载完成后直接安装即可</li>\n</ul>\n<h3 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h3><ol>\n<li>JRE:如果安装的是JRE，那么在Mac上默认的路径是<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>配置环境变量（vi ~&#x2F;.bash_profile）：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_HOME=/Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class=\"line\">PATH=$JAVA_HOME/bin:$PATH</span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">export PATH</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>JDK:如果安装的是JDK，那么在Mac上默认的路径是<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Library/Java/JavaVirtualMachines/</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>配置环境变量（vi ~&#x2F;.bash_profile）：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home</span><br><span class=\"line\">PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class=\"line\">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class=\"line\">export JAVA_HOME</span><br><span class=\"line\">export PATH</span><br><span class=\"line\">export CLASSPATH</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"安装Jmeter\"><a href=\"#安装Jmeter\" class=\"headerlink\" title=\"安装Jmeter\"></a>安装Jmeter</h2><ol>\n<li>下载Jmeter4.0<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -c http://www-us.apache.org/dist//jmeter/binaries/apache-jmeter-4.0.tgz</span><br></pre></td></tr></table></figure></li>\n<li>解压<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf apache-jmeter-4.0.tgz</span><br></pre></td></tr></table></figure></li>\n<li>运行sample<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apache-jmeter-4.0/bin/./jmeter -n -t apache-jmeter-4.0/extras/Test.jmx</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Jmeter基础\"><a href=\"#Jmeter基础\" class=\"headerlink\" title=\"Jmeter基础\"></a>Jmeter基础</h2><h3 id=\"Jmeter环境变量配置\"><a href=\"#Jmeter环境变量配置\" class=\"headerlink\" title=\"Jmeter环境变量配置\"></a>Jmeter环境变量配置</h3><ul>\n<li>MAC版本,具体路径请根据\b自己本地路径进行替换<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JMETER_HOME=/Users/\bxxx/apache-jmeter-4.0</span><br><span class=\"line\">export CLASSPATH=.:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar</span><br><span class=\"line\">export PATH=$JMETER_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li>\n<li>Mac下启动jmeter<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">完成环境变量配置后，直接在终端输入jmeter即可启动。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Jmeter基础-1\"><a href=\"#Jmeter基础-1\" class=\"headerlink\" title=\"Jmeter基础\"></a>Jmeter基础</h3><p>请看Jmeter基础系列文章。</p>\n","slug":"性能测试-Jmeter安装","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2021/08/01/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-Jmeter%E5%AE%89%E8%A3%85/","excerpt":"","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://vwin.github.io/tags/ubuntu/"},{"name":"jmeter","slug":"jmeter","permalink":"http://vwin.github.io/tags/jmeter/"},{"name":"jdk","slug":"jdk","permalink":"http://vwin.github.io/tags/jdk/"},{"name":"jre","slug":"jre","permalink":"http://vwin.github.io/tags/jre/"}]},{"title":"人工智能产品的测试探索","date":"2020-12-19T21:07:00.000Z","path":"2020/12/19/人工智能产品的测试探索/","text":"什么是人工智能再讲如何测试人工智能产品之前，我觉得我要先跟不熟悉人工智能的同学们解释一下什么是人工智能。毕竟想要测试一个东西，就要先了解它么。用一句话来概括现阶段的人工智能就是：人工智能&#x3D;大数据+机器学习。 我理解的现阶段的人工智能是使用机器学习算法在大量的历史数据下进行训练，从历史数据中找到一定的规律并对未来做出的预测行为。这么说有点拗口。举个例子，曾经给银行做过反欺诈项目。以前在银行里有一群专家，他们的工作就是根据经验向系统中输入一些规则。例如某一张卡在一个城市有了一笔交易，之后1小时内在另一个城市又有了一笔交易。这些专家根据以前的经验判断这种情况是有盗刷的风险的。他们在系统中输入了几千条这样的规则，组成了一个专家系统。 这个专家系统是建立在人类对过往的数据所总结出的经验下建立的。 后来我们引入了机器学习算法，对过往所有的历史数据进行训练，最后在25亿个特征中抽取出8000万条有效特征。大家可以把这些特征就暂且当成是专家系统中的规则。8000万对不到1万，效果是可以预想的。当时对第一版模型上线后的数据做统计，反欺诈效果提升了7倍， 这就是二分类算法典型的业务场景。 为什么叫机器学习呢，因为它给人一种感觉，机器能像人类一样从过去的数据中学习到经验，只不过机器的能力更强。如果想再稍微深究一下机器学习训练出来的模型到底是什么，那大家可以暂且理解为一个二分类的模型主要是就是一个key，value的数据库。key就是在数据中抽取出来的特征，value就是这个特征的权重。 当我们想要预测一个用户的行为的时候，就会从用户的数据中提取特征并在模型中查找对应的权重。 最后根据这些特征的权重算出一个分，也可以说是一个概率。如果大家看过最强大脑这个节目的话。应该记得第一次人机大战项目是人脸识别，第三回合的时候机器给出了两个答案。因为当时做人脸识别项目的志愿者中有一对双胞胎。所以机器计算出的这两个人的概率只差了0.1%，最后为了谨慎起见机器输出两个答案出来。以至于吴恩达先生也很纠结到底该选哪一个答案。再之后的人机对战项目里我们也能看到虽然小度一路高歌，毫无败绩。但是其中是有选错过几次的。所以大家可以看到我们得到的答案其实是一个概率，是一个根据以往的数据进行总结并作出预测的一个行为。并不是100%准确的。即便是阿尔法狗当初也是输过一局的。所以其实我们测试的痛点也就来了，你怎么测试一个概率呢。 接下来我们慢慢的来说这个问题。 这个图就是一个人工智能服务的略缩图。 在历史数据上训练出模型，并发布一个预测服务，这个预测服务可能就是一个http的接口。 然后新的数据过来以后，根据模型算出一个预测值。经过刚才的说明，我们看到数据是人工智能的根本。拥有的数据越多，越丰富，越真实，那么训练出的模型效果越好。 测试思路 数据测试 分层测试 训练集与测试集对比 数据测试根据我们之前对人工智能的定义，我们发现数据是人工智能的根据。 保证数据的正确定是非常必要的。 而且几乎所有的机器学习算法对数据的容错能力都很强，即便数据稍有偏差，它们也能通过一次一次的迭代和对比来减少误差。 所以即便我们的数据有一点问题最后得出的模型效果可能还不差， 但是这个时候我们不能认为模型就没问题了。 因为很可能在某些特定场景下就会出现雪崩效应。 再举个例子。当初阿尔法狗与李世石一战成名。如果说前三盘的结果令各路专家大跌眼镜的话。那第四盘可能是让所有人都大跌眼镜了。阿尔法狗连出昏招，几乎是将这一局拱手相让。那阿尔法狗出bug了？DeepMind团队说，这是一个系统问题。那我们来看看这个系统到底有什么问题。根据当时公布出来的数据我们发现阿尔法狗的养成方法是这样的。 阿尔法狗如何养成 整理过去人类对弈的80多万盘棋局拿1的棋谱，训练一只狗狗，能够预测人类下一步会下在哪里拿2得到的狗狗，每天自己和自己下100万盘棋拿1和3的棋谱，再训练一只狗狗，这就是阿尔法狗。阿尔法狗是基于1亿+盘机器棋局和80万人类棋局训练出来的狗狗。问题出在哪？我们看到，训练阿尔法狗所用的棋谱，只有80万是人类棋局，总数上亿的棋局是机器对弈的。它下的每一步，都是将局面导向历史上(也就是80万人类棋局和1亿自己对弈的棋局)胜率最大的局面。 问题就恰恰出在这里，80万和1亿。相差甚多。那么阿尔法狗选择的所谓胜率最大，一定是赢自己的概率最大，而不是赢人类的概率最大。这样的标准在顺丰棋尚且不容易出问题，一旦遇到逆风局，它的选择就变成了，选择对手犯错概率最大的棋，而这个对手恰恰就是它自己。这就是为什么当初阿尔法狗在逆风局中下出一些匪夷所思的棋。当然这些都只是行业内的人的猜测。但从这个例子就可以看到数据的重要性。数据出现偏差会直接导致不可估计的后果。 所以我们总结出的第一个突破口就是数据测试。保证我们用来建模的数据是正确的。在这里的数据测试会跟我们以往的测试有些不一样。 首先是数据规模的增长。数据大了里面的有些数据可能会发生一些很诡异的事情。然后是存储介质和技术栈的变化，我们用来训练模型的数据都会存放在hadoop集群上，所以一般都会用spark或者Hbase来编写测试脚本。最后是验证方式的变化，之前我们测试的时候都是精确的测试每条数据的正确性。 但是现在我们需要根据业务设定每一个字段的规则。然后扫描每一行数据，如果这条数据超出了这个字段的规定范围，会发出报警。 假如用户年龄这个字段，正常值可能是0~100岁。如果突然出现个300岁，那么这条数据肯定是有问题的。我们之前曾经碰见过这样的数据。本来这条数据应该是30岁的，但不知道抽了什么风多了个0.针对这方面的测试，一般都是使用spark或者Hbase这种大数据处理框架把任务提交到集群上去扫描每一张表。 这方面不多说了，脚本其实蛮好写的，只是需要十分熟悉业务，才能制定出相应的规则去扫表。 分层测试虽然我们能测试用来做训练的数据是正确的。但是一个人工智能系统是很复杂的， 我们只是保证了作为源头的数据貌似是不够的。以前我们测试的时候都知道把系统拆解开做分层测试，所以我们的第二个突破口就是基于这个思路。我们先来了解一下，一个模型的诞生都经理了哪些步骤。 模型诞生的步骤： 数据引入 数据处理(清洗，拆分，拼接等) 特征工程 模型训练 模型上线 数据引入：将历史数据引入到系统中，并做第一步的预处理。例如处理一些明显的异常的行。数据处理： 其中又包含很多种操作。 例如对数据进行清洗，拆分。 把两张表进行拼接等。特征工程：我们从数据中按一定规律提取一些特征出来。之后需要将提取的样本表传递给机器学习算法进行训练 可以看到我们把数据引入到系统后，先是用SQL算子对数据做了拼接，然后清洗一些无效数据。 再把数据拆分为训练集和测试集。分别对两个数据集做特征抽取。之后训练集传递给逻辑回归这个机器学习算法进行训练。训练之后使用测试集来测试一下模型的效果。大家看到这个图了，这是创建一个模型比较常见的流程。图中的逻辑归回就是一种机器学习算法，也是一种最简单的二分类算法，其他的算法诸如GBDT，SVM，DNN等算法的模型都是这个流程。我们可以看到算法上面的流程。全部与机器学习无关。他们都属于大数据处理范畴。而且一个成型的系统在每一个模块都会提供一些固定的接口。 例如我们公司在特征抽取算法上就提供了近百个特征抽取的接口，可以根据不同的情况使用不同的方式提取数据中的特征。 数据拆分也有很多种不同的拆分方法，按随机拆分，分层拆分，规则拆分。 每个子模块都会提供一些接口供上层调用。 所以既然提到接口层面的东西了，大家应该都知道怎么测了吧。 只不过有些接口并不是http或者RPC协议的。 有时候需要我们在产品的repo里写测试用例。 训练集与测试集对比这是我们的第三种测试思路。 我们刚才一直用来举例的分类算法是一种监督学习。 什么是监督学习呢，就是我们的历史数据中是有答案的。还拿刚才的反欺诈的例子说，就是我们的数据中都有一个字段标明了这条数据是否是欺诈场景。 所以我们完全可以把历史数据拆分为训练集和测试集。将测试集输入到模型中以评价模型预测出的结果的正确率如何。所以每次版本迭代都使用同样的数据，同样的参数配置。 统计模型效果并进行对比。当然这种测试方式是一种模糊的方式。就如我再刚开始说的一样，这种方式无法判断问题出在哪里。是bug，还是参数设置错了？我们无法判断。 常见的测试场景自学习几乎所有的人工智能服务都必须要支持自学习场景。就像阿尔法狗一样，它输了一局，就会从输的这一局中学习到经验，以后他就不会那么下了，这也是机器学习恐怖的地方，它会变的越来越无懈可击，以前人类还能赢上一局，但是未来可能人类再也赢不了阿尔法狗了。 做法就是我们的数据每天都是在更新的，用户行为也是一直在变化的。所以我们的模型要有从最新的数据中进行学习的能力。上面是常见的自学习场景流程图。假如我们用历史上n天的数据训练出一个模型并发布成了一个预测的服务。 那么到了隔天的时候。我们抛弃之前第一天的数据，使用第二天到第n+1天的数据重新训练一个模型并代替之前的模型发布一个预测服务。这样不停的循环，每一天都收集到最新的数据参与模型训练。 这时候大家应该明白该测试什么了。每天收集到的新数据，就是测试重点。就是我们刚才说的第一种测试思路，使用spark，Hbase这些技术，根据业务指定规则，扫描这些数据。一旦有异常就要报警。 预测服务下面一个场景是预测服务的。预测服务的架构一般都满复杂的，为了实现高可用，负载均衡等目的，所以一般都是标准的服务发现架构。以etcd这种分布式存储机制为载体。 所有的预测服务分别以自注册的方式来提供服务。 上面的一个图是一个比较流行的预测服务的架构。当然我做了相应的简化，隐去了一些细节。所有的部署任务由master写入ETCD。 所有agent以自注册的方式将自己的信息写入ETCD以接受master的管理并执行部署任务。 而router也同样读取etcd获取所有agent提供的预测服务的信息并负责负载均衡。 有些公司为了做高可用和弹性伸缩甚至将agent纳入了kubernetes的HPA中进行管理。由此我们需要测试这套机制能实现他该有的功能。例如： router会按规则把压力分发到各个agent上。 把某个agent的预测服务被kill掉后，router会自动切换。 预估服务挂掉，agent会自动感知并重新拉起服务 agent被kill掉后，也会被自动拉起 如果做了弹性伸缩，需要将预测服务压到临界点后观察系统是否做了扩容等等 性能测试我们要接触的性能测试跟互联网的不太一样。 我们知道预测服务仍然还是访问密集型业务。 但是模型调研的过程是属于计算密集型业务。 我们要模拟的情况不再是高并发。 而是不同的数据规模，数据分布和数据类型。我们日常的性能测试都是需要在各种不同的数据下跑各种不同的算子和参数。 所以我们首先需要一种造数机制，能帮助我们按需求生成大规模的数据。 我们选择的是spark，利用分布式计算在hadoop集群上生成大量的数据。 原理也很简单，接触过spark的同学肯定都知道在spark中生成一个RDD有两种方式， 一种是从文件中读取，另一种是从内存中的一个list种解析。 第一种方式肯定不是我们想要的， 所以从内存中的list解析就是我们选择的方式。 假如我们想生成一个10亿行的数据。就可以先使用python 的xrange造一个生成器以防止内存被撑爆。然后用这个生成器初始化一个有着10亿行的空的RDD，定义并操作RDD的每一行去生成我们想要的数据，然后设置RDD的分片以及消耗的container，内存，cpu等参数。提交到集群上利用集群庞大的计算资源帮助我们在段时间内生成我们需要的数据。 前两天我再一个3个节点的集群上造过一个1.5T的数据，大概用了5个小时。 这样一开始的时候我们是写spark脚本来完成这些事。 后来需求越来越多，我们发现可以造数做成一个工具。把表和字段都提取到配置文件中进行定义。 就这样我们成立了shannon这个项目。慢慢的从造数脚本到造数工具再到造数平台。它的架构特别简单，就是对原生spark的应用，这里我就不展示spark的架构是什么样了。就贴一下造数工具的设计图吧。简单来说shannon分了3层。 最底层是基本数据类型层。 负责字段实例化，定义并实现了shannon支持的所有数据类型。例如，随机，枚举，主键，unique key，控制分布，大小，范围等等。中间一层是数据表层， 负责表的实例化，遍历和拼接表中的字段。最上层是逻辑控制层， 负责配置的读取和处理。定义所有的表和字段，定义并提交spark任务。 因为我们是做TO B的业务，所以需要提供给客户一份详细的性能测试报告。 测试环境管理常见的测试场景我们基本上都说完了。 我们再说一说测试环境管理的问题。 为了能够保证研发和测试效率，一个能够支撑大规模测试环境的基础设施是十分必要的。为什么这么说呢， 首先但凡是涉及到机器学习的业务，运行时间都非常慢。 有时候做测试的时候跑一个模型要几个小时甚至一天都是有的。也就是说，我们运行测试的成本比较高。如果在运行测试的途中环境出了什么问题那么损失还是很大的。多人共用一套环境难免会有互相踩踏的情况，例如一个RD在测试自己的模块，另一个人上来把服务重启了。这时候我们心里一般就是一万头某种动物飘过。所以我们一般希望每个人都能拥有一套独立的环境甚至一个人多套环境。这就增加了测试环境的数量。尤其是团队越来越大的时候，测试环境的数量已经到达了一个恐怖的量级。 其次如果各位所在的公司也像我们一样做TO B的业务，那么我们的测试环境就需要多版本管理，要有能力随时快速的搭建起特定版本的产品环境供开发，产品，测试，以及技术支持人员使用。所以这无疑又增加了环境管理设置的复杂度。 再有就是随着环境数量的扩张，我们的环境从单节点走向集群，这时候我们对环境调度能力的要求会比较高，例如我们要对环境的资源进行计算和限制，保证最大化利用资源的同时不会撑爆系统。例如我们要保证系统有足够的冗余，在某些环境出现故障的时候能够自动检测出来并在冗余节点进行恢复。例如我们需要能够实现多租户管理，执行资源管控，限制超售行为. 例如我们希望系统有一定能力的无人值守运维能力等等。 所以我们经过一段时间的讨论和实验，引入了k8s+docker来完成这个目标。docker的优势大家应该都知道，快速，标准化，隔离性，可迁移性都不错。 通过镜像我们可以迅速的将测试环境的数量提升一个量级，镜像的版本管理正适合TO B业务的多版本管理。 之所以选择k8s，是因为k8s相较于swarm和mesos 都拥有着更强大的功能和更简单的部署方式。刚才说的预测服务需要部署很多个agent，使用k8s的话只需要设置一下replica set的数量，k8s就会自动帮我们维护好这个数量的实例了，很方便 。k8s的调度机制能很轻松的满足我们刚才说的对于灾难恢复，冗余，多租户，高可用，负载均衡，资源管理等要求。所以我们当初怀揣着对google莫名的憧憬走上了k8s的踩坑之旅。首先说一下我们都用容器做什么。 主要三大类，第一种是诸如testlink，jenkins这种基础服务。 第二种是产品的测试环境，这是占比最多的。 然后就是我们的测试执行机器了。 例如UI自动化，我们采取的是分别将selenium hub和node docker化的做法。如下图：当UI自动化的case增多的时候，分布式运行往往是最好的解决方案。 目前我们通过这种方式容器化了20个浏览器进行并发测试。这些镜像都有官方的版本，使用起来还是蛮方面的。 然后说一下比较关键的网络解决方案，我们从单机到集群，中途历经了集中网络模型的变化。从一开始的端口映射，到利用路由规则给容器分配真实的ip，再到给每个容器在DHCP和DNS服务器上注册和续租。 到最后我们演进出了下面这个k8s的网络模型我们知道每个docker宿主机都会自己维护一个私有网络。 如果想让容器跨主机通讯或者外部访问容器。一般就是通过三种方式： 端口映射，路由规则以及overlay网络。 我们选择在k8s中引入的overlay网络是weave，以解决夸主机通信问题。 安装kube-dns实现服务发现。 之后为了能让外部访问容器服务， 使用了k8s提供的ingress机制来实现。 这个ingress网络其实就是在集群中启动一个容器，这个容器既能访问容器网络的同是还监听了宿主机的80端口。 容器里是一个nginx，它会负责帮忙转发请求。 nginx负责转发的有servicename和path，这里我们是无法使用路径进行转发的。 所以我们在公司内部的DNS上做了泛域名解析。 所有testenv为后缀的域名都会解析成集群的master节点的ip。 这样我们的请求就能命中nginx中固定的servicename并做转发了。通过这种机制我们就可以很方面的访问容器提供的服务。当然ingress的缺点是暂时还无法做4层转发。如果要访问4层协议的服务暂时还是只能暴露node port。 我们这个测试环境的管理平台主要的架构是这样的： 集群中所有的镜像都过公司内部搭建的镜像仓库进行共享， 我们在集群之上安装了各种服务来满足测试环境的需要。 例如使用NFS做数据持久化， Heapster+Grafana+InfluxDB做性能监控，kube-DNS做服务发现，dashboard提供web管理界面，weave做集群网络，ingress做服务的转发。 并且我们在这个整体上针对k8s的APIserver做了一层cli的封装。 我们尝试过脚本管理， web服务管理，但是发现大家对这些方式的接受度都不高。 我们面对的大多数都是一帮做梦都在写代码的人，所以我们换做提供一个cli的方式可以让使用者更灵活来定制自己需要的服务。 通过这种形式，我们在公司内部搭建了一个可以提供测试资源的私有云，配合jenkins我们可以很方便的一键部署我们需要的环境并执行UT,接口,UI自动化测试等等，并提供一个详细的测试报告。下面是我们的部署一个环境后所提供的测试报告","raw":"---\ntitle: 人工智能产品的测试探索\ntoc: true\ndate: 2020-12-20 05:07:00\ntags: [大数据,人工智能,测试]\ncategories: [测试]\ndescription:\n---\n### 什么是人工智能\n再讲如何测试人工智能产品之前，我觉得我要先跟不熟悉人工智能的同学们解释一下什么是人工智能。毕竟想要测试一个东西，就要先了解它么。用一句话来概括现阶段的人工智能就是：人工智能=大数据+机器学习。\n\n<!--more-->\n\n我理解的现阶段的人工智能是使用机器学习算法在大量的历史数据下进行训练，从历史数据中找到一定的规律并对未来做出的预测行为。这么说有点拗口。举个例子，曾经给银行做过反欺诈项目。 \n以前在银行里有一群专家，他们的工作就是根据经验向系统中输入一些规则。例如某一张卡在一个城市有了一笔交易，之后1小时内在另一个城市又有了一笔交易。这些专家根据以前的经验判断这种情况是有盗刷的风险的。他们在系统中输入了几千条这样的规则，组成了一个专家系统。 这个专家系统是建立在人类对过往的数据所总结出的经验下建立的。 后来我们引入了机器学习算法，对过往所有的历史数据进行训练，最后在25亿个特征中抽取出8000万条有效特征。\n大家可以把这些特征就暂且当成是专家系统中的规则。8000万对不到1万，效果是可以预想的。当时对第一版模型上线后的数据做统计，反欺诈效果提升了7倍， 这就是二分类算法典型的业务场景。 为什么叫机器学习呢，因为它给人一种感觉，机器能像人类一样从过去的数据中学习到经验，只不过机器的能力更强。 \n如果想再稍微深究一下机器学习训练出来的模型到底是什么，那大家可以暂且理解为一个二分类的模型主要是就是一个key，value的数据库。key就是在数据中抽取出来的特征，value就是这个特征的权重。 当我们想要预测一个用户的行为的时候，就会从用户的数据中提取特征并在模型中查找对应的权重。 最后根据这些特征的权重算出一个分，也可以说是一个概率。 \n如果大家看过最强大脑这个节目的话。应该记得第一次人机大战项目是人脸识别，第三回合的时候机器给出了两个答案。因为当时做人脸识别项目的志愿者中有一对双胞胎。所以机器计算出的这两个人的概率只差了0.1%，最后为了谨慎起见机器输出两个答案出来。以至于吴恩达先生也很纠结到底该选哪一个答案。再之后的人机对战项目里我们也能看到虽然小度一路高歌，毫无败绩。但是其中是有选错过几次的。\n所以大家可以看到我们得到的答案其实是一个概率，是一个根据以往的数据进行总结并作出预测的一个行为。并不是100%准确的。即便是阿尔法狗当初也是输过一局的。所以其实我们测试的痛点也就来了，你怎么测试一个概率呢。 接下来我们慢慢的来说这个问题。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fyddgqhovmj30c5061t93.jpg)\n这个图就是一个人工智能服务的略缩图。 在历史数据上训练出模型，并发布一个预测服务，这个预测服务可能就是一个http的接口。 然后新的数据过来以后，根据模型算出一个预测值。经过刚才的说明，我们看到数据是人工智能的根本。拥有的数据越多，越丰富，越真实，那么训练出的模型效果越好。\n\n# 测试思路\n- 数据测试\n- 分层测试\n- 训练集与测试集对比\n\n## 数据测试\n\n根据我们之前对人工智能的定义，我们发现数据是人工智能的根据。 保证数据的正确定是非常必要的。 而且几乎所有的机器学习算法对数据的容错能力都很强，即便数据稍有偏差，它们也能通过一次一次的迭代和对比来减少误差。 所以即便我们的数据有一点问题最后得出的模型效果可能还不差， 但是这个时候我们不能认为模型就没问题了。 因为很可能在某些特定场景下就会出现雪崩效应。\n\n再举个例子。当初阿尔法狗与李世石一战成名。如果说前三盘的结果令各路专家大跌眼镜的话。那第四盘可能是让所有人都大跌眼镜了。阿尔法狗连出昏招，几乎是将这一局拱手相让。那阿尔法狗出bug了？DeepMind团队说，这是一个系统问题。那我们来看看这个系统到底有什么问题。根据当时公布出来的数据我们发现阿尔法狗的养成方法是这样的。\n\n阿尔法狗如何养成\n\n整理过去人类对弈的80多万盘棋局\n拿1的棋谱，训练一只狗狗，能够预测人类下一步会下在哪里\n拿2得到的狗狗，每天自己和自己下100万盘棋\n拿1和3的棋谱，再训练一只狗狗，这就是阿尔法狗。\n阿尔法狗是基于1亿+盘机器棋局和80万人类棋局训练出来的狗狗。问题出在哪？我们看到，训练阿尔法狗所用的棋谱，只有80万是人类棋局，总数上亿的棋局是机器对弈的。它下的每一步，都是将局面导向历史上(也就是80万人类棋局和1亿自己对弈的棋局)胜率最大的局面。 问题就恰恰出在这里，80万和1亿。相差甚多。那么阿尔法狗选择的所谓胜率最大，一定是赢自己的概率最大，而不是赢人类的概率最大。这样的标准在顺丰棋尚且不容易出问题，一旦遇到逆风局，它的选择就变成了，选择对手犯错概率最大的棋，而这个对手恰恰就是它自己。这就是为什么当初阿尔法狗在逆风局中下出一些匪夷所思的棋。当然这些都只是行业内的人的猜测。但从这个例子就可以看到数据的重要性。数据出现偏差会直接导致不可估计的后果。\n\n所以我们总结出的第一个突破口就是数据测试。保证我们用来建模的数据是正确的。在这里的数据测试会跟我们以往的测试有些不一样。\n\n首先是数据规模的增长。数据大了里面的有些数据可能会发生一些很诡异的事情。\n然后是存储介质和技术栈的变化，我们用来训练模型的数据都会存放在hadoop集群上，所以一般都会用spark或者Hbase来编写测试脚本。\n最后是验证方式的变化，之前我们测试的时候都是精确的测试每条数据的正确性。 但是现在我们需要根据业务设定每一个字段的规则。然后扫描每一行数据，如果这条数据超出了这个字段的规定范围，会发出报警。 假如用户年龄这个字段，正常值可能是0~100岁。如果突然出现个300岁，那么这条数据肯定是有问题的。我们之前曾经碰见过这样的数据。本来这条数据应该是30岁的，但不知道抽了什么风多了个0.\n针对这方面的测试，一般都是使用spark或者Hbase这种大数据处理框架把任务提交到集群上去扫描每一张表。 这方面不多说了，脚本其实蛮好写的，只是需要十分熟悉业务，才能制定出相应的规则去扫表。\n\n## 分层测试\n虽然我们能测试用来做训练的数据是正确的。但是一个人工智能系统是很复杂的， 我们只是保证了作为源头的数据貌似是不够的。以前我们测试的时候都知道把系统拆解开做分层测试，所以我们的第二个突破口就是基于这个思路。我们先来了解一下，一个模型的诞生都经理了哪些步骤。\n\n模型诞生的步骤：\n\n- 数据引入\n- 数据处理(清洗，拆分，拼接等)\n- 特征工程\n- 模型训练\n- 模型上线\n\n数据引入：将历史数据引入到系统中，并做第一步的预处理。例如处理一些明显的异常的行。\n数据处理： 其中又包含很多种操作。 例如对数据进行清洗，拆分。 把两张表进行拼接等。\n特征工程：我们从数据中按一定规律提取一些特征出来。之后需要将提取的样本表传递给机器学习算法进行训练\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fyddq1zg4zj30br0bkjrt.jpg)\n\n可以看到我们把数据引入到系统后，先是用SQL算子对数据做了拼接，然后清洗一些无效数据。 再把数据拆分为训练集和测试集。分别对两个数据集做特征抽取。之后训练集传递给逻辑回归这个机器学习算法进行训练。训练之后使用测试集来测试一下模型的效果。大家看到这个图了，这是创建一个模型比较常见的流程。图中的逻辑归回就是一种机器学习算法，也是一种最简单的二分类算法，其他的算法诸如GBDT，SVM，DNN等算法的模型都是这个流程。我们可以看到算法上面的流程。全部与机器学习无关。他们都属于大数据处理范畴。而且一个成型的系统在每一个模块都会提供一些固定的接口。 例如我们公司在特征抽取算法上就提供了近百个特征抽取的接口，可以根据不同的情况使用不同的方式提取数据中的特征。 数据拆分也有很多种不同的拆分方法，按随机拆分，分层拆分，规则拆分。 每个子模块都会提供一些接口供上层调用。 所以既然提到接口层面的东西了，大家应该都知道怎么测了吧。 只不过有些接口并不是http或者RPC协议的。 有时候需要我们在产品的repo里写测试用例。\n\n## 训练集与测试集对比\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyddqlk99zj30gs0bagm1.jpg)\n这是我们的第三种测试思路。 我们刚才一直用来举例的分类算法是一种监督学习。 什么是监督学习呢，就是我们的历史数据中是有答案的。还拿刚才的反欺诈的例子说，就是我们的数据中都有一个字段标明了这条数据是否是欺诈场景。 所以我们完全可以把历史数据拆分为训练集和测试集。将测试集输入到模型中以评价模型预测出的结果的正确率如何。所以每次版本迭代都使用同样的数据，同样的参数配置。 统计模型效果并进行对比。当然这种测试方式是一种模糊的方式。就如我再刚开始说的一样，这种方式无法判断问题出在哪里。是bug，还是参数设置错了？我们无法判断。\n\n# 常见的测试场景\n\n## 自学习\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyddr8k6yaj30lm0jo0vw.jpg)\n几乎所有的人工智能服务都必须要支持自学习场景。就像阿尔法狗一样，它输了一局，就会从输的这一局中学习到经验，以后他就不会那么下了，这也是机器学习恐怖的地方，它会变的越来越无懈可击，以前人类还能赢上一局，但是未来可能人类再也赢不了阿尔法狗了。 做法就是我们的数据每天都是在更新的，用户行为也是一直在变化的。所以我们的模型要有从最新的数据中进行学习的能力。上面是常见的自学习场景流程图。假如我们用历史上n天的数据训练出一个模型并发布成了一个预测的服务。 那么到了隔天的时候。我们抛弃之前第一天的数据，使用第二天到第n+1天的数据重新训练一个模型并代替之前的模型发布一个预测服务。这样不停的循环，每一天都收集到最新的数据参与模型训练。 这时候大家应该明白该测试什么了。每天收集到的新数据，就是测试重点。就是我们刚才说的第一种测试思路，使用spark，Hbase这些技术，根据业务指定规则，扫描这些数据。一旦有异常就要报警。\n\n\n## 预测服务\n\n下面一个场景是预测服务的。预测服务的架构一般都满复杂的，为了实现高可用，负载均衡等目的，所以一般都是标准的服务发现架构。以etcd这种分布式存储机制为载体。 所有的预测服务分别以自注册的方式来提供服务。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyddrxq1gfj30ei0andgt.jpg)\n\n上面的一个图是一个比较流行的预测服务的架构。当然我做了相应的简化，隐去了一些细节。所有的部署任务由master写入ETCD。 所有agent以自注册的方式将自己的信息写入ETCD以接受master的管理并执行部署任务。 而router也同样读取etcd获取所有agent提供的预测服务的信息并负责负载均衡。 有些公司为了做高可用和弹性伸缩甚至将agent纳入了kubernetes的HPA中进行管理。由此我们需要测试这套机制能实现他该有的功能。例如：\n\n- router会按规则把压力分发到各个agent上。\n- 把某个agent的预测服务被kill掉后，router会自动切换。\n- 预估服务挂掉，agent会自动感知并重新拉起服务\n- agent被kill掉后，也会被自动拉起\n- 如果做了弹性伸缩，需要将预测服务压到临界点后观察系统是否做了扩容等等\n\n## 性能测试\n\n我们要接触的性能测试跟互联网的不太一样。 我们知道预测服务仍然还是访问密集型业务。 但是模型调研的过程是属于计算密集型业务。 我们要模拟的情况不再是高并发。 而是不同的数据规模，数据分布和数据类型。我们日常的性能测试都是需要在各种不同的数据下跑各种不同的算子和参数。 所以我们首先需要一种造数机制，能帮助我们按需求生成大规模的数据。 我们选择的是spark，利用分布式计算在hadoop集群上生成大量的数据。 原理也很简单，接触过spark的同学肯定都知道在spark中生成一个RDD有两种方式， 一种是从文件中读取，另一种是从内存中的一个list种解析。 第一种方式肯定不是我们想要的， 所以从内存中的list解析就是我们选择的方式。 假如我们想生成一个10亿行的数据。就可以先使用python 的xrange造一个生成器以防止内存被撑爆。然后用这个生成器初始化一个有着10亿行的空的RDD，定义并操作RDD的每一行去生成我们想要的数据，然后设置RDD的分片以及消耗的container，内存，cpu等参数。提交到集群上利用集群庞大的计算资源帮助我们在段时间内生成我们需要的数据。 前两天我再一个3个节点的集群上造过一个1.5T的数据，大概用了5个小时。 这样一开始的时候我们是写spark脚本来完成这些事。 后来需求越来越多，我们发现可以造数做成一个工具。把表和字段都提取到配置文件中进行定义。 就这样我们成立了shannon这个项目。慢慢的从造数脚本到造数工具再到造数平台。\n它的架构特别简单，就是对原生spark的应用，这里我就不展示spark的架构是什么样了。就贴一下造数工具的设计图吧。\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyddt6l71hj30kq0i5q4j.jpg)\n简单来说shannon分了3层。 最底层是基本数据类型层。 负责字段实例化，定义并实现了shannon支持的所有数据类型。例如，随机，枚举，主键，unique key，控制分布，大小，范围等等。\n中间一层是数据表层， 负责表的实例化，遍历和拼接表中的字段。最上层是逻辑控制层， 负责配置的读取和处理。定义所有的表和字段，定义并提交spark任务。 因为我们是做TO B的业务，所以需要提供给客户一份详细的性能测试报告。\n\n# 测试环境管理\n\n常见的测试场景我们基本上都说完了。 我们再说一说测试环境管理的问题。 为了能够保证研发和测试效率，一个能够支撑大规模测试环境的基础设施是十分必要的。为什么这么说呢，\n\n1. 首先但凡是涉及到机器学习的业务，运行时间都非常慢。 有时候做测试的时候跑一个模型要几个小时甚至一天都是有的。也就是说，我们运行测试的成本比较高。如果在运行测试的途中环境出了什么问题那么损失还是很大的。多人共用一套环境难免会有互相踩踏的情况，例如一个RD在测试自己的模块，另一个人上来把服务重启了。这时候我们心里一般就是一万头某种动物飘过。所以我们一般希望每个人都能拥有一套独立的环境甚至一个人多套环境。这就增加了测试环境的数量。尤其是团队越来越大的时候，测试环境的数量已经到达了一个恐怖的量级。\n2. 其次如果各位所在的公司也像我们一样做TO B的业务，那么我们的测试环境就需要多版本管理，要有能力随时快速的搭建起特定版本的产品环境供开发，产品，测试，以及技术支持人员使用。所以这无疑又增加了环境管理设置的复杂度。\n3. 再有就是随着环境数量的扩张，我们的环境从单节点走向集群，这时候我们对环境调度能力的要求会比较高，例如我们要对环境的资源进行计算和限制，保证最大化利用资源的同时不会撑爆系统。例如我们要保证系统有足够的冗余，在某些环境出现故障的时候能够自动检测出来并在冗余节点进行恢复。例如我们需要能够实现多租户管理，执行资源管控，限制超售行为. 例如我们希望系统有一定能力的无人值守运维能力等等。\n\n所以我们经过一段时间的讨论和实验，引入了k8s+docker来完成这个目标。docker的优势大家应该都知道，快速，标准化，隔离性，可迁移性都不错。 通过镜像我们可以迅速的将测试环境的数量提升一个量级，镜像的版本管理正适合TO B业务的多版本管理。 之所以选择k8s，是因为k8s相较于swarm和mesos 都拥有着更强大的功能和更简单的部署方式。刚才说的预测服务需要部署很多个agent，使用k8s的话只需要设置一下replica set的数量，k8s就会自动帮我们维护好这个数量的实例了，很方便 。k8s的调度机制能很轻松的满足我们刚才说的对于灾难恢复，冗余，多租户，高可用，负载均衡，资源管理等要求。所以我们当初怀揣着对google莫名的憧憬走上了k8s的踩坑之旅。\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fydduz7n5wj30ee07u75f.jpg)\n首先说一下我们都用容器做什么。 主要三大类，第一种是诸如testlink，jenkins这种基础服务。 第二种是产品的测试环境，这是占比最多的。 然后就是我们的测试执行机器了。 例如UI自动化，我们采取的是分别将selenium hub和node docker化的做法。如下图：\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyddvaiaylj30er07z3zo.jpg)\n当UI自动化的case增多的时候，分布式运行往往是最好的解决方案。 目前我们通过这种方式容器化了20个浏览器进行并发测试。这些镜像都有官方的版本，使用起来还是蛮方面的。\n\n然后说一下比较关键的网络解决方案，我们从单机到集群，中途历经了集中网络模型的变化。从一开始的端口映射，到利用路由规则给容器分配真实的ip，再到给每个容器在DHCP和DNS服务器上注册和续租。 到最后我们演进出了下面这个k8s的网络模型\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyddvmovrmj30n60cdq4t.jpg)\n我们知道每个docker宿主机都会自己维护一个私有网络。 如果想让容器跨主机通讯或者外部访问容器。一般就是通过三种方式： 端口映射，路由规则以及overlay网络。 我们选择在k8s中引入的overlay网络是weave，以解决夸主机通信问题。 安装kube-dns实现服务发现。 之后为了能让外部访问容器服务， 使用了k8s提供的ingress机制来实现。 这个ingress网络其实就是在集群中启动一个容器，这个容器既能访问容器网络的同是还监听了宿主机的80端口。 容器里是一个nginx，它会负责帮忙转发请求。 nginx负责转发的有servicename和path，这里我们是无法使用路径进行转发的。 所以我们在公司内部的DNS上做了泛域名解析。 所有testenv为后缀的域名都会解析成集群的master节点的ip。 这样我们的请求就能命中nginx中固定的servicename并做转发了。通过这种机制我们就可以很方面的访问容器提供的服务。当然ingress的缺点是暂时还无法做4层转发。如果要访问4层协议的服务暂时还是只能暴露node port。\n\n我们这个测试环境的管理平台主要的架构是这样的：\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fyddw733xpj30gq08vwfl.jpg)\n\n集群中所有的镜像都过公司内部搭建的镜像仓库进行共享， 我们在集群之上安装了各种服务来满足测试环境的需要。 例如使用NFS做数据持久化， Heapster+Grafana+InfluxDB做性能监控，kube-DNS做服务发现，dashboard提供web管理界面，weave做集群网络，ingress做服务的转发。 并且我们在这个整体上针对k8s的APIserver做了一层cli的封装。 我们尝试过脚本管理， web服务管理，但是发现大家对这些方式的接受度都不高。 我们面对的大多数都是一帮做梦都在写代码的人，所以我们换做提供一个cli的方式可以让使用者更灵活来定制自己需要的服务。 通过这种形式，我们在公司内部搭建了一个可以提供测试资源的私有云，配合jenkins我们可以很方便的一键部署我们需要的环境并执行UT,接口,UI自动化测试等等，并提供一个详细的测试报告。下面是我们的部署一个环境后所提供的测试报告\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fyddwjqy1wj30nh0ahtad.jpg)\n","content":"<h3 id=\"什么是人工智能\"><a href=\"#什么是人工智能\" class=\"headerlink\" title=\"什么是人工智能\"></a>什么是人工智能</h3><p>再讲如何测试人工智能产品之前，我觉得我要先跟不熟悉人工智能的同学们解释一下什么是人工智能。毕竟想要测试一个东西，就要先了解它么。用一句话来概括现阶段的人工智能就是：人工智能&#x3D;大数据+机器学习。</p>\n<span id=\"more\"></span>\n\n<p>我理解的现阶段的人工智能是使用机器学习算法在大量的历史数据下进行训练，从历史数据中找到一定的规律并对未来做出的预测行为。这么说有点拗口。举个例子，曾经给银行做过反欺诈项目。<br>以前在银行里有一群专家，他们的工作就是根据经验向系统中输入一些规则。例如某一张卡在一个城市有了一笔交易，之后1小时内在另一个城市又有了一笔交易。这些专家根据以前的经验判断这种情况是有盗刷的风险的。他们在系统中输入了几千条这样的规则，组成了一个专家系统。 这个专家系统是建立在人类对过往的数据所总结出的经验下建立的。 后来我们引入了机器学习算法，对过往所有的历史数据进行训练，最后在25亿个特征中抽取出8000万条有效特征。<br>大家可以把这些特征就暂且当成是专家系统中的规则。8000万对不到1万，效果是可以预想的。当时对第一版模型上线后的数据做统计，反欺诈效果提升了7倍， 这就是二分类算法典型的业务场景。 为什么叫机器学习呢，因为它给人一种感觉，机器能像人类一样从过去的数据中学习到经验，只不过机器的能力更强。<br>如果想再稍微深究一下机器学习训练出来的模型到底是什么，那大家可以暂且理解为一个二分类的模型主要是就是一个key，value的数据库。key就是在数据中抽取出来的特征，value就是这个特征的权重。 当我们想要预测一个用户的行为的时候，就会从用户的数据中提取特征并在模型中查找对应的权重。 最后根据这些特征的权重算出一个分，也可以说是一个概率。<br>如果大家看过最强大脑这个节目的话。应该记得第一次人机大战项目是人脸识别，第三回合的时候机器给出了两个答案。因为当时做人脸识别项目的志愿者中有一对双胞胎。所以机器计算出的这两个人的概率只差了0.1%，最后为了谨慎起见机器输出两个答案出来。以至于吴恩达先生也很纠结到底该选哪一个答案。再之后的人机对战项目里我们也能看到虽然小度一路高歌，毫无败绩。但是其中是有选错过几次的。<br>所以大家可以看到我们得到的答案其实是一个概率，是一个根据以往的数据进行总结并作出预测的一个行为。并不是100%准确的。即便是阿尔法狗当初也是输过一局的。所以其实我们测试的痛点也就来了，你怎么测试一个概率呢。 接下来我们慢慢的来说这个问题。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fyddgqhovmj30c5061t93.jpg\"><br>这个图就是一个人工智能服务的略缩图。 在历史数据上训练出模型，并发布一个预测服务，这个预测服务可能就是一个http的接口。 然后新的数据过来以后，根据模型算出一个预测值。经过刚才的说明，我们看到数据是人工智能的根本。拥有的数据越多，越丰富，越真实，那么训练出的模型效果越好。</p>\n<h1 id=\"测试思路\"><a href=\"#测试思路\" class=\"headerlink\" title=\"测试思路\"></a>测试思路</h1><ul>\n<li>数据测试</li>\n<li>分层测试</li>\n<li>训练集与测试集对比</li>\n</ul>\n<h2 id=\"数据测试\"><a href=\"#数据测试\" class=\"headerlink\" title=\"数据测试\"></a>数据测试</h2><p>根据我们之前对人工智能的定义，我们发现数据是人工智能的根据。 保证数据的正确定是非常必要的。 而且几乎所有的机器学习算法对数据的容错能力都很强，即便数据稍有偏差，它们也能通过一次一次的迭代和对比来减少误差。 所以即便我们的数据有一点问题最后得出的模型效果可能还不差， 但是这个时候我们不能认为模型就没问题了。 因为很可能在某些特定场景下就会出现雪崩效应。</p>\n<p>再举个例子。当初阿尔法狗与李世石一战成名。如果说前三盘的结果令各路专家大跌眼镜的话。那第四盘可能是让所有人都大跌眼镜了。阿尔法狗连出昏招，几乎是将这一局拱手相让。那阿尔法狗出bug了？DeepMind团队说，这是一个系统问题。那我们来看看这个系统到底有什么问题。根据当时公布出来的数据我们发现阿尔法狗的养成方法是这样的。</p>\n<p>阿尔法狗如何养成</p>\n<p>整理过去人类对弈的80多万盘棋局<br>拿1的棋谱，训练一只狗狗，能够预测人类下一步会下在哪里<br>拿2得到的狗狗，每天自己和自己下100万盘棋<br>拿1和3的棋谱，再训练一只狗狗，这就是阿尔法狗。<br>阿尔法狗是基于1亿+盘机器棋局和80万人类棋局训练出来的狗狗。问题出在哪？我们看到，训练阿尔法狗所用的棋谱，只有80万是人类棋局，总数上亿的棋局是机器对弈的。它下的每一步，都是将局面导向历史上(也就是80万人类棋局和1亿自己对弈的棋局)胜率最大的局面。 问题就恰恰出在这里，80万和1亿。相差甚多。那么阿尔法狗选择的所谓胜率最大，一定是赢自己的概率最大，而不是赢人类的概率最大。这样的标准在顺丰棋尚且不容易出问题，一旦遇到逆风局，它的选择就变成了，选择对手犯错概率最大的棋，而这个对手恰恰就是它自己。这就是为什么当初阿尔法狗在逆风局中下出一些匪夷所思的棋。当然这些都只是行业内的人的猜测。但从这个例子就可以看到数据的重要性。数据出现偏差会直接导致不可估计的后果。</p>\n<p>所以我们总结出的第一个突破口就是数据测试。保证我们用来建模的数据是正确的。在这里的数据测试会跟我们以往的测试有些不一样。</p>\n<p>首先是数据规模的增长。数据大了里面的有些数据可能会发生一些很诡异的事情。<br>然后是存储介质和技术栈的变化，我们用来训练模型的数据都会存放在hadoop集群上，所以一般都会用spark或者Hbase来编写测试脚本。<br>最后是验证方式的变化，之前我们测试的时候都是精确的测试每条数据的正确性。 但是现在我们需要根据业务设定每一个字段的规则。然后扫描每一行数据，如果这条数据超出了这个字段的规定范围，会发出报警。 假如用户年龄这个字段，正常值可能是0~100岁。如果突然出现个300岁，那么这条数据肯定是有问题的。我们之前曾经碰见过这样的数据。本来这条数据应该是30岁的，但不知道抽了什么风多了个0.<br>针对这方面的测试，一般都是使用spark或者Hbase这种大数据处理框架把任务提交到集群上去扫描每一张表。 这方面不多说了，脚本其实蛮好写的，只是需要十分熟悉业务，才能制定出相应的规则去扫表。</p>\n<h2 id=\"分层测试\"><a href=\"#分层测试\" class=\"headerlink\" title=\"分层测试\"></a>分层测试</h2><p>虽然我们能测试用来做训练的数据是正确的。但是一个人工智能系统是很复杂的， 我们只是保证了作为源头的数据貌似是不够的。以前我们测试的时候都知道把系统拆解开做分层测试，所以我们的第二个突破口就是基于这个思路。我们先来了解一下，一个模型的诞生都经理了哪些步骤。</p>\n<p>模型诞生的步骤：</p>\n<ul>\n<li>数据引入</li>\n<li>数据处理(清洗，拆分，拼接等)</li>\n<li>特征工程</li>\n<li>模型训练</li>\n<li>模型上线</li>\n</ul>\n<p>数据引入：将历史数据引入到系统中，并做第一步的预处理。例如处理一些明显的异常的行。<br>数据处理： 其中又包含很多种操作。 例如对数据进行清洗，拆分。 把两张表进行拼接等。<br>特征工程：我们从数据中按一定规律提取一些特征出来。之后需要将提取的样本表传递给机器学习算法进行训练<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fyddq1zg4zj30br0bkjrt.jpg\"></p>\n<p>可以看到我们把数据引入到系统后，先是用SQL算子对数据做了拼接，然后清洗一些无效数据。 再把数据拆分为训练集和测试集。分别对两个数据集做特征抽取。之后训练集传递给逻辑回归这个机器学习算法进行训练。训练之后使用测试集来测试一下模型的效果。大家看到这个图了，这是创建一个模型比较常见的流程。图中的逻辑归回就是一种机器学习算法，也是一种最简单的二分类算法，其他的算法诸如GBDT，SVM，DNN等算法的模型都是这个流程。我们可以看到算法上面的流程。全部与机器学习无关。他们都属于大数据处理范畴。而且一个成型的系统在每一个模块都会提供一些固定的接口。 例如我们公司在特征抽取算法上就提供了近百个特征抽取的接口，可以根据不同的情况使用不同的方式提取数据中的特征。 数据拆分也有很多种不同的拆分方法，按随机拆分，分层拆分，规则拆分。 每个子模块都会提供一些接口供上层调用。 所以既然提到接口层面的东西了，大家应该都知道怎么测了吧。 只不过有些接口并不是http或者RPC协议的。 有时候需要我们在产品的repo里写测试用例。</p>\n<h2 id=\"训练集与测试集对比\"><a href=\"#训练集与测试集对比\" class=\"headerlink\" title=\"训练集与测试集对比\"></a>训练集与测试集对比</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyddqlk99zj30gs0bagm1.jpg\"><br>这是我们的第三种测试思路。 我们刚才一直用来举例的分类算法是一种监督学习。 什么是监督学习呢，就是我们的历史数据中是有答案的。还拿刚才的反欺诈的例子说，就是我们的数据中都有一个字段标明了这条数据是否是欺诈场景。 所以我们完全可以把历史数据拆分为训练集和测试集。将测试集输入到模型中以评价模型预测出的结果的正确率如何。所以每次版本迭代都使用同样的数据，同样的参数配置。 统计模型效果并进行对比。当然这种测试方式是一种模糊的方式。就如我再刚开始说的一样，这种方式无法判断问题出在哪里。是bug，还是参数设置错了？我们无法判断。</p>\n<h1 id=\"常见的测试场景\"><a href=\"#常见的测试场景\" class=\"headerlink\" title=\"常见的测试场景\"></a>常见的测试场景</h1><h2 id=\"自学习\"><a href=\"#自学习\" class=\"headerlink\" title=\"自学习\"></a>自学习</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyddr8k6yaj30lm0jo0vw.jpg\"><br>几乎所有的人工智能服务都必须要支持自学习场景。就像阿尔法狗一样，它输了一局，就会从输的这一局中学习到经验，以后他就不会那么下了，这也是机器学习恐怖的地方，它会变的越来越无懈可击，以前人类还能赢上一局，但是未来可能人类再也赢不了阿尔法狗了。 做法就是我们的数据每天都是在更新的，用户行为也是一直在变化的。所以我们的模型要有从最新的数据中进行学习的能力。上面是常见的自学习场景流程图。假如我们用历史上n天的数据训练出一个模型并发布成了一个预测的服务。 那么到了隔天的时候。我们抛弃之前第一天的数据，使用第二天到第n+1天的数据重新训练一个模型并代替之前的模型发布一个预测服务。这样不停的循环，每一天都收集到最新的数据参与模型训练。 这时候大家应该明白该测试什么了。每天收集到的新数据，就是测试重点。就是我们刚才说的第一种测试思路，使用spark，Hbase这些技术，根据业务指定规则，扫描这些数据。一旦有异常就要报警。</p>\n<h2 id=\"预测服务\"><a href=\"#预测服务\" class=\"headerlink\" title=\"预测服务\"></a>预测服务</h2><p>下面一个场景是预测服务的。预测服务的架构一般都满复杂的，为了实现高可用，负载均衡等目的，所以一般都是标准的服务发现架构。以etcd这种分布式存储机制为载体。 所有的预测服务分别以自注册的方式来提供服务。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyddrxq1gfj30ei0andgt.jpg\"></p>\n<p>上面的一个图是一个比较流行的预测服务的架构。当然我做了相应的简化，隐去了一些细节。所有的部署任务由master写入ETCD。 所有agent以自注册的方式将自己的信息写入ETCD以接受master的管理并执行部署任务。 而router也同样读取etcd获取所有agent提供的预测服务的信息并负责负载均衡。 有些公司为了做高可用和弹性伸缩甚至将agent纳入了kubernetes的HPA中进行管理。由此我们需要测试这套机制能实现他该有的功能。例如：</p>\n<ul>\n<li>router会按规则把压力分发到各个agent上。</li>\n<li>把某个agent的预测服务被kill掉后，router会自动切换。</li>\n<li>预估服务挂掉，agent会自动感知并重新拉起服务</li>\n<li>agent被kill掉后，也会被自动拉起</li>\n<li>如果做了弹性伸缩，需要将预测服务压到临界点后观察系统是否做了扩容等等</li>\n</ul>\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><p>我们要接触的性能测试跟互联网的不太一样。 我们知道预测服务仍然还是访问密集型业务。 但是模型调研的过程是属于计算密集型业务。 我们要模拟的情况不再是高并发。 而是不同的数据规模，数据分布和数据类型。我们日常的性能测试都是需要在各种不同的数据下跑各种不同的算子和参数。 所以我们首先需要一种造数机制，能帮助我们按需求生成大规模的数据。 我们选择的是spark，利用分布式计算在hadoop集群上生成大量的数据。 原理也很简单，接触过spark的同学肯定都知道在spark中生成一个RDD有两种方式， 一种是从文件中读取，另一种是从内存中的一个list种解析。 第一种方式肯定不是我们想要的， 所以从内存中的list解析就是我们选择的方式。 假如我们想生成一个10亿行的数据。就可以先使用python 的xrange造一个生成器以防止内存被撑爆。然后用这个生成器初始化一个有着10亿行的空的RDD，定义并操作RDD的每一行去生成我们想要的数据，然后设置RDD的分片以及消耗的container，内存，cpu等参数。提交到集群上利用集群庞大的计算资源帮助我们在段时间内生成我们需要的数据。 前两天我再一个3个节点的集群上造过一个1.5T的数据，大概用了5个小时。 这样一开始的时候我们是写spark脚本来完成这些事。 后来需求越来越多，我们发现可以造数做成一个工具。把表和字段都提取到配置文件中进行定义。 就这样我们成立了shannon这个项目。慢慢的从造数脚本到造数工具再到造数平台。<br>它的架构特别简单，就是对原生spark的应用，这里我就不展示spark的架构是什么样了。就贴一下造数工具的设计图吧。<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyddt6l71hj30kq0i5q4j.jpg\"><br>简单来说shannon分了3层。 最底层是基本数据类型层。 负责字段实例化，定义并实现了shannon支持的所有数据类型。例如，随机，枚举，主键，unique key，控制分布，大小，范围等等。<br>中间一层是数据表层， 负责表的实例化，遍历和拼接表中的字段。最上层是逻辑控制层， 负责配置的读取和处理。定义所有的表和字段，定义并提交spark任务。 因为我们是做TO B的业务，所以需要提供给客户一份详细的性能测试报告。</p>\n<h1 id=\"测试环境管理\"><a href=\"#测试环境管理\" class=\"headerlink\" title=\"测试环境管理\"></a>测试环境管理</h1><p>常见的测试场景我们基本上都说完了。 我们再说一说测试环境管理的问题。 为了能够保证研发和测试效率，一个能够支撑大规模测试环境的基础设施是十分必要的。为什么这么说呢，</p>\n<ol>\n<li>首先但凡是涉及到机器学习的业务，运行时间都非常慢。 有时候做测试的时候跑一个模型要几个小时甚至一天都是有的。也就是说，我们运行测试的成本比较高。如果在运行测试的途中环境出了什么问题那么损失还是很大的。多人共用一套环境难免会有互相踩踏的情况，例如一个RD在测试自己的模块，另一个人上来把服务重启了。这时候我们心里一般就是一万头某种动物飘过。所以我们一般希望每个人都能拥有一套独立的环境甚至一个人多套环境。这就增加了测试环境的数量。尤其是团队越来越大的时候，测试环境的数量已经到达了一个恐怖的量级。</li>\n<li>其次如果各位所在的公司也像我们一样做TO B的业务，那么我们的测试环境就需要多版本管理，要有能力随时快速的搭建起特定版本的产品环境供开发，产品，测试，以及技术支持人员使用。所以这无疑又增加了环境管理设置的复杂度。</li>\n<li>再有就是随着环境数量的扩张，我们的环境从单节点走向集群，这时候我们对环境调度能力的要求会比较高，例如我们要对环境的资源进行计算和限制，保证最大化利用资源的同时不会撑爆系统。例如我们要保证系统有足够的冗余，在某些环境出现故障的时候能够自动检测出来并在冗余节点进行恢复。例如我们需要能够实现多租户管理，执行资源管控，限制超售行为. 例如我们希望系统有一定能力的无人值守运维能力等等。</li>\n</ol>\n<p>所以我们经过一段时间的讨论和实验，引入了k8s+docker来完成这个目标。docker的优势大家应该都知道，快速，标准化，隔离性，可迁移性都不错。 通过镜像我们可以迅速的将测试环境的数量提升一个量级，镜像的版本管理正适合TO B业务的多版本管理。 之所以选择k8s，是因为k8s相较于swarm和mesos 都拥有着更强大的功能和更简单的部署方式。刚才说的预测服务需要部署很多个agent，使用k8s的话只需要设置一下replica set的数量，k8s就会自动帮我们维护好这个数量的实例了，很方便 。k8s的调度机制能很轻松的满足我们刚才说的对于灾难恢复，冗余，多租户，高可用，负载均衡，资源管理等要求。所以我们当初怀揣着对google莫名的憧憬走上了k8s的踩坑之旅。<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fydduz7n5wj30ee07u75f.jpg\"><br>首先说一下我们都用容器做什么。 主要三大类，第一种是诸如testlink，jenkins这种基础服务。 第二种是产品的测试环境，这是占比最多的。 然后就是我们的测试执行机器了。 例如UI自动化，我们采取的是分别将selenium hub和node docker化的做法。如下图：<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyddvaiaylj30er07z3zo.jpg\"><br>当UI自动化的case增多的时候，分布式运行往往是最好的解决方案。 目前我们通过这种方式容器化了20个浏览器进行并发测试。这些镜像都有官方的版本，使用起来还是蛮方面的。</p>\n<p>然后说一下比较关键的网络解决方案，我们从单机到集群，中途历经了集中网络模型的变化。从一开始的端口映射，到利用路由规则给容器分配真实的ip，再到给每个容器在DHCP和DNS服务器上注册和续租。 到最后我们演进出了下面这个k8s的网络模型<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyddvmovrmj30n60cdq4t.jpg\"><br>我们知道每个docker宿主机都会自己维护一个私有网络。 如果想让容器跨主机通讯或者外部访问容器。一般就是通过三种方式： 端口映射，路由规则以及overlay网络。 我们选择在k8s中引入的overlay网络是weave，以解决夸主机通信问题。 安装kube-dns实现服务发现。 之后为了能让外部访问容器服务， 使用了k8s提供的ingress机制来实现。 这个ingress网络其实就是在集群中启动一个容器，这个容器既能访问容器网络的同是还监听了宿主机的80端口。 容器里是一个nginx，它会负责帮忙转发请求。 nginx负责转发的有servicename和path，这里我们是无法使用路径进行转发的。 所以我们在公司内部的DNS上做了泛域名解析。 所有testenv为后缀的域名都会解析成集群的master节点的ip。 这样我们的请求就能命中nginx中固定的servicename并做转发了。通过这种机制我们就可以很方面的访问容器提供的服务。当然ingress的缺点是暂时还无法做4层转发。如果要访问4层协议的服务暂时还是只能暴露node port。</p>\n<p>我们这个测试环境的管理平台主要的架构是这样的：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fyddw733xpj30gq08vwfl.jpg\"></p>\n<p>集群中所有的镜像都过公司内部搭建的镜像仓库进行共享， 我们在集群之上安装了各种服务来满足测试环境的需要。 例如使用NFS做数据持久化， Heapster+Grafana+InfluxDB做性能监控，kube-DNS做服务发现，dashboard提供web管理界面，weave做集群网络，ingress做服务的转发。 并且我们在这个整体上针对k8s的APIserver做了一层cli的封装。 我们尝试过脚本管理， web服务管理，但是发现大家对这些方式的接受度都不高。 我们面对的大多数都是一帮做梦都在写代码的人，所以我们换做提供一个cli的方式可以让使用者更灵活来定制自己需要的服务。 通过这种形式，我们在公司内部搭建了一个可以提供测试资源的私有云，配合jenkins我们可以很方便的一键部署我们需要的环境并执行UT,接口,UI自动化测试等等，并提供一个详细的测试报告。下面是我们的部署一个环境后所提供的测试报告<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fyddwjqy1wj30nh0ahtad.jpg\"></p>\n","slug":"人工智能产品的测试探索","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2020/12/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BA%A7%E5%93%81%E7%9A%84%E6%B5%8B%E8%AF%95%E6%8E%A2%E7%B4%A2/","excerpt":"什么是人工智能再讲如何测试人工智能产品之前，我觉得我要先跟不熟悉人工智能的同学们解释一下什么是人工智能。毕竟想要测试一个东西，就要先了解它么。用一句话来概括现阶段的人工智能就是：人工智能&#x3D;大数据+机器学习。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://vwin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"人工智能","slug":"人工智能","permalink":"http://vwin.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Jmeter使用总结","date":"2020-08-10T10:05:09.000Z","path":"2020/08/10/性能测试-Jmeter使用总结/","text":"Jmeter使用总结 多个线程组顺序执行和并行执行在测试计划的设置中可以设置 勾选 Run Thread Groups consecutively(i.e.one at time)，则表示顺序执行。顺序执行，指的是测试计划中存在多个线程组时，第一个线程组执行完后再执行下一个线程组。 不勾选 Run Thread Groups consecutively(i.e.one at time)，则表示并行执行。并行执行，指的是指的是测试计划中存在多个线程组时，所有线程组都在同一时刻执行 Jmeter 命令行运行参数说明 总结","raw":"---\ntitle: Jmeter使用总结\ntoc: true\ndate: 2020-08-10 18:05:09\n# tags: [jmeter]\n# categories: [性能测试]\ncategories:\n  - 测试\ntags:\n  - jmeter\ndescription: \n---\nJmeter使用总结\n<!--more-->\n\n## 多个线程组顺序执行和并行执行\n在测试计划的设置中可以设置\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fu4rlcw08sj30nn0flab8.jpg)\n1. 勾选 Run Thread Groups consecutively(i.e.one at time)，则表示顺序执行。顺序执行，指的是测试计划中存在多个线程组时，第一个线程组执行完后再执行下一个线程组。\n\n2. 不勾选 Run Thread Groups consecutively(i.e.one at time)，则表示并行执行。并行执行，指的是指的是测试计划中存在多个线程组时，所有线程组都在同一时刻执行\n\n\n## Jmeter 命令行运行参数说明\n   ![](https://ws2.sinaimg.cn/large/006tNc79ly1fz72m4h9gpj30l10dejtx.jpg)\n\n\n\n## [总结](http://www.cnblogs.com/puresoul/p/5092628.html)","content":"<p>Jmeter使用总结</p>\n<span id=\"more\"></span>\n\n<h2 id=\"多个线程组顺序执行和并行执行\"><a href=\"#多个线程组顺序执行和并行执行\" class=\"headerlink\" title=\"多个线程组顺序执行和并行执行\"></a>多个线程组顺序执行和并行执行</h2><p>在测试计划的设置中可以设置<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fu4rlcw08sj30nn0flab8.jpg\"></p>\n<ol>\n<li><p>勾选 Run Thread Groups consecutively(i.e.one at time)，则表示顺序执行。顺序执行，指的是测试计划中存在多个线程组时，第一个线程组执行完后再执行下一个线程组。</p>\n</li>\n<li><p>不勾选 Run Thread Groups consecutively(i.e.one at time)，则表示并行执行。并行执行，指的是指的是测试计划中存在多个线程组时，所有线程组都在同一时刻执行</p>\n</li>\n</ol>\n<h2 id=\"Jmeter-命令行运行参数说明\"><a href=\"#Jmeter-命令行运行参数说明\" class=\"headerlink\" title=\"Jmeter 命令行运行参数说明\"></a>Jmeter 命令行运行参数说明</h2><p>   <img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fz72m4h9gpj30l10dejtx.jpg\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><a href=\"http://www.cnblogs.com/puresoul/p/5092628.html\">总结</a></h2>","slug":"性能测试-Jmeter使用总结","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2020/08/10/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-Jmeter%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"Jmeter使用总结","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"http://vwin.github.io/tags/jmeter/"}]},{"title":"Jmeter基础--概念","date":"2020-08-07T07:53:24.000Z","path":"2020/08/07/性能测试-Jmeter基础概念/","text":"Jmeter基础概念 Jmeter介绍一个优秀的开源性能测试工具官网地址：http://jmeter.apache.org/download_jmeter.cgi Jmeter包含组件Jmeter工具和其他性能工具在原理上完全一致，工具包含4个部分： （1）负载发生器：用于产生负载，通常以多线程或是多进程的方式模拟用户行为。 （2）用户运行器：通常是一个脚本运行引擎，用户运行器附加在线程或进程上，根据脚本要求模拟指定的用户行为。 （3）资源生成器：用于生成测试过程中服务器、负载机的资源数据。 （4）报表生成器：根据测试中霍地的数据生成报表，提供可视化的数据显示方式。 Jmeter设置中文 jmeter.properties中配置Jmeter界面语言&#x2F;apache-jmeter-4.0&#x2F;bin&#x2F;jmeter.properties中language&#x3D;en默认屏蔽，取消屏蔽后显示英文界面，language&#x3D;zh强制显示简体中文界面。 GUI界面配置： 测试计划Test Plan (测试计划)：用来描述一个性能测试，包含与本次性能测试所有相关的功能。也就说本的性能测试的所有内容是于基于一个计划的。下面看一下一个计划下面都有哪些主要的功能模块（右键单击“测试计划”弹出菜单）。虽然有三个添加线程组的选项，名字不一样， 创建之后，其界面是完全一样的。之前的版本只有一个线程组的名字。现在多一个setUp theread Group 与terDown Thread Group setup thread group一种特殊类型的ThreadGroup的，可用于执行预测试操作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试前进行定期线程组的执行。 teardown thread group.一种特殊类型的ThreadGroup的，可用于执行测试后动作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试结束后执行定期的线程组。 thread group(线程组).这个就是我们通常添加运行的线程。通俗的讲一个线程组,，可以看做一个虚拟用户组，线程组中的每个线程都可以理解为一个虚拟用户。线程组中包含的线程数量在测试执行过程中是不会发生改变的。 测试片段测试片段元素是控制器上的一个种特殊的线程组，它在测试树上与线程组处于一个层级。它与线程组有所不同，因为它不被执行，除非它是一个模块控制器或者是被控制器所引用时才会被执行。 控制器JMeter有两种类型的控制器：取样器（sample）和逻辑控制器（Logic Controller），用这些原件来驱动处理一个测试。 采样器取样器（Sample）是性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元，JMeter 原生支持多种不同的sampler ，如 HTTP Request Sampler 、 FTP Request Sample 、TCP Request Sample 、JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求。 逻辑控制器（Logic Controller）逻辑控制器，包括两类无件，一类是用于控制test plan 中 sampler 节点发送请求的逻辑顺序的控制器，常用的有 如果（If）控制器 、switch Controller 、Runtime Controller、循环控制器等。另一类是用来组织可控制 sampler 来节点的，如 事务控制器、吞吐量控制器。 配置元件配置元件（config element）用于提供对静态数据配置的支持。CSV Data Set config 可以将本地数据文件形成数据池（Data Pool），而对应于HTTP Request Sampler和 TCP Request Sampler等类型的配制无件则可以修改Sampler的默认数据。（例如，HTTP Cookie Manager 可以用于对 HTTP Request Sampler 的cookie 进行管理） 定时器定时器（Timer）用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手端。类似于LoadRunner里面的“思考时间”。JMeter 定义了Bean Shell Timer、Constant Throughput Timer、固定定时器等不同类型的Timer。 前置处理器（Per Processors）用于在实际的请求发出之前对即将发出的请求进行特殊处理。例如，HTTP URL重写修复符则可以实现URL重写，当RUL中有sessionID 一类的session信息时，可以通过该处理器填充发出请求的实际的sessionID 。 后置处理器（Post Processors）用于对Sampler 发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据（类似LoadRunner测试工具中的关联概念）。例如，XPath Extractor 则可以用于提取响应数据中通过给定XPath 值获得的数据。 断言（Assertions） 断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点，用以保证性能测试过程中的数据交互是否与预期一致。 监听器（Listener）这个监听器可不是用来监听系统资源的元件。它是用来对测试结果数据进行处理和可视化展示的一系列元件。 图行结果、查看结果树、聚合报告。都是我们经常用到的元件。","raw":"---\ntitle: Jmeter基础--概念\ntoc: true\ndate: 2020-08-07 15:53:24\ntags: [jmeter]\ncategories: [测试]\ndescription:\n---\nJmeter基础概念\n<!-- more -->\n## Jmeter介绍\n一个优秀的开源性能测试工具\n官网地址：http://jmeter.apache.org/download_jmeter.cgi \n\n## Jmeter包含组件\n\nJmeter工具和其他性能工具在原理上完全一致，工具包含4个部分：\n\n（1）负载发生器：用于产生负载，通常以多线程或是多进程的方式模拟用户行为。\n\n（2）用户运行器：通常是一个脚本运行引擎，用户运行器附加在线程或进程上，根据脚本要求模拟指定的用户行为。\n\n（3）资源生成器：用于生成测试过程中服务器、负载机的资源数据。\n\n（4）报表生成器：根据测试中霍地的数据生成报表，提供可视化的数据显示方式。\n\n### Jmeter设置中文\n1. jmeter.properties中配置Jmeter界面语言\n/apache-jmeter-4.0/bin/jmeter.properties中language=en默认屏蔽，取消屏蔽后显示英文界面，language=zh强制显示简体中文界面。\n2. GUI界面配置：\n![Jmeter\b语言\b选择](https://github.com/vwin/markdownpic/raw/master/hexo-blog/jmeter-lang.png)\n\n### 测试计划\nTest Plan (测试计划)：用来描述一个性能测试，包含与本次性能测试所有相关的功能。也就说本的性能测试的所有内容是于基于一个计划的。下面看一下一个计划下面都有哪些主要的功能模块（右键单击“测试计划”弹出菜单）。\n![测试计划](https://ws2.sinaimg.cn/large/0069RVTdly1fu1dlm6u0wj30w00k00ve.jpg)\n虽然有三个添加线程组的选项，名字不一样， 创建之后，其界面是完全一样的。之前的版本只有一个线程组的名字。现在多一个setUp theread Group 与terDown Thread Group \n1. setup thread group  \n一种特殊类型的ThreadGroup的，可用于执行预测试操作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试前进行定期线程组的执行。\n2. teardown thread group.  \n一种特殊类型的ThreadGroup的，可用于执行测试后动作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试结束后执行定期的线程组。\n3. thread group(线程组).\n这个就是我们通常添加运行的线程。通俗的讲一个线程组,，可以看做一个虚拟用户组，线程组中的每个线程都可以理解为一个虚拟用户。线程组中包含的线程数量在测试执行过程中是不会发生改变的。\n\n### 测试片段\n测试片段元素是控制器上的一个种特殊的线程组，它在测试树上与线程组处于一个层级。它与线程组有所不同，因为它不被执行，除非它是一个模块控制器或者是被控制器所引用时才会被执行。\n![测试片段](https://ws4.sinaimg.cn/large/0069RVTdly1fu1dp4x6jjj30hb0a0755.jpg)\n\n### 控制器\nJMeter有两种类型的控制器：取样器（sample）和逻辑控制器（Logic Controller），用这些原件来驱动处理一个测试。\n#### 采样器\n取样器（Sample）是性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元，JMeter 原生支持多种不同的sampler ，如 HTTP Request Sampler 、 FTP  Request Sample 、TCP  Request Sample 、JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求。\n![采样器](https://ws2.sinaimg.cn/large/0069RVTdly1fu1ds3unxyj30lh0fnacb.jpg)\n\n#### 逻辑控制器（Logic Controller）\n逻辑控制器，包括两类无件，一类是用于控制test plan 中 sampler 节点发送请求的逻辑顺序的控制器，常用的有 如果（If）控制器 、switch Controller 、Runtime Controller、循环控制器等。另一类是用来组织可控制 sampler 来节点的，如 事务控制器、吞吐量控制器。\n![逻辑控制器](https://ws2.sinaimg.cn/large/0069RVTdly1fu1dukjfaqj30w00k0dir.jpg)\n\n### 配置元件\n配置元件（config element）用于提供对静态数据配置的支持。CSV Data Set config 可以将本地数据文件形成数据池（Data Pool），而对应于HTTP Request Sampler和 TCP Request Sampler等类型的配制无件则可以修改Sampler的默认数据。（例如，HTTP Cookie Manager 可以用于对 HTTP Request Sampler 的cookie 进行管理）\n![配置元件](https://ws4.sinaimg.cn/large/0069RVTdly1fu1dvqv6w8j30w00k041t.jpg)\n\n### 定时器\n定时器（Timer）用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手端。类似于LoadRunner里面的“思考时间”。JMeter 定义了Bean Shell Timer、Constant Throughput Timer、固定定时器等不同类型的Timer。\n![定时器](https://ws2.sinaimg.cn/large/0069RVTdly1fu1dwdrmb8j30w00k0n03.jpg)\n\n### 前置处理器（Per Processors）\n用于在实际的请求发出之前对即将发出的请求进行特殊处理。例如，HTTP URL重写修复符则可以实现URL重写，当RUL中有sessionID 一类的session信息时，可以通过该处理器填充发出请求的实际的sessionID 。\n![前置处理器](https://ws3.sinaimg.cn/large/0069RVTdly1fu1dxfqrxxj30w00k0ju8.jpg)\n\n### 后置处理器（Post Processors）\n用于对Sampler 发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据（类似LoadRunner测试工具中的关联概念）。例如，XPath  Extractor 则可以用于提取响应数据中通过给定XPath 值获得的数据。\n![后置处理器](https://ws3.sinaimg.cn/large/0069RVTdly1fu1dy72ixkj30w00k0q5x.jpg)\n\n### 断言（Assertions）\n 断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点，用以保证性能测试过程中的数据交互是否与预期一致。\n ![断言](https://ws1.sinaimg.cn/large/0069RVTdly1fu1dywlw7ej30w00k0q5w.jpg)\n\n### 监听器（Listener）\n这个监听器可不是用来监听系统资源的元件。它是用来对测试结果数据进行处理和可视化展示的一系列元件。 图行结果、查看结果树、聚合报告。都是我们经常用到的元件。\n\n![监听器](https://ws4.sinaimg.cn/large/0069RVTdly1fu1dzp8i85j30w00k0jul.jpg)","content":"<p>Jmeter基础概念</p>\n<span id=\"more\"></span>\n<h2 id=\"Jmeter介绍\"><a href=\"#Jmeter介绍\" class=\"headerlink\" title=\"Jmeter介绍\"></a>Jmeter介绍</h2><p>一个优秀的开源性能测试工具<br>官网地址：<a href=\"http://jmeter.apache.org/download_jmeter.cgi\">http://jmeter.apache.org/download_jmeter.cgi</a> </p>\n<h2 id=\"Jmeter包含组件\"><a href=\"#Jmeter包含组件\" class=\"headerlink\" title=\"Jmeter包含组件\"></a>Jmeter包含组件</h2><p>Jmeter工具和其他性能工具在原理上完全一致，工具包含4个部分：</p>\n<p>（1）负载发生器：用于产生负载，通常以多线程或是多进程的方式模拟用户行为。</p>\n<p>（2）用户运行器：通常是一个脚本运行引擎，用户运行器附加在线程或进程上，根据脚本要求模拟指定的用户行为。</p>\n<p>（3）资源生成器：用于生成测试过程中服务器、负载机的资源数据。</p>\n<p>（4）报表生成器：根据测试中霍地的数据生成报表，提供可视化的数据显示方式。</p>\n<h3 id=\"Jmeter设置中文\"><a href=\"#Jmeter设置中文\" class=\"headerlink\" title=\"Jmeter设置中文\"></a>Jmeter设置中文</h3><ol>\n<li>jmeter.properties中配置Jmeter界面语言<br>&#x2F;apache-jmeter-4.0&#x2F;bin&#x2F;jmeter.properties中language&#x3D;en默认屏蔽，取消屏蔽后显示英文界面，language&#x3D;zh强制显示简体中文界面。</li>\n<li>GUI界面配置：<br><img src=\"https://github.com/vwin/markdownpic/raw/master/hexo-blog/jmeter-lang.png\" alt=\"Jmeter\b语言\b选择\"></li>\n</ol>\n<h3 id=\"测试计划\"><a href=\"#测试计划\" class=\"headerlink\" title=\"测试计划\"></a>测试计划</h3><p>Test Plan (测试计划)：用来描述一个性能测试，包含与本次性能测试所有相关的功能。也就说本的性能测试的所有内容是于基于一个计划的。下面看一下一个计划下面都有哪些主要的功能模块（右键单击“测试计划”弹出菜单）。<br><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu1dlm6u0wj30w00k00ve.jpg\" alt=\"测试计划\"><br>虽然有三个添加线程组的选项，名字不一样， 创建之后，其界面是完全一样的。之前的版本只有一个线程组的名字。现在多一个setUp theread Group 与terDown Thread Group </p>\n<ol>\n<li>setup thread group<br>一种特殊类型的ThreadGroup的，可用于执行预测试操作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试前进行定期线程组的执行。</li>\n<li>teardown thread group.<br>一种特殊类型的ThreadGroup的，可用于执行测试后动作。这些线程的行为完全像一个正常的线程组元件。不同的是，这些类型的线程执行测试结束后执行定期的线程组。</li>\n<li>thread group(线程组).<br>这个就是我们通常添加运行的线程。通俗的讲一个线程组,，可以看做一个虚拟用户组，线程组中的每个线程都可以理解为一个虚拟用户。线程组中包含的线程数量在测试执行过程中是不会发生改变的。</li>\n</ol>\n<h3 id=\"测试片段\"><a href=\"#测试片段\" class=\"headerlink\" title=\"测试片段\"></a>测试片段</h3><p>测试片段元素是控制器上的一个种特殊的线程组，它在测试树上与线程组处于一个层级。它与线程组有所不同，因为它不被执行，除非它是一个模块控制器或者是被控制器所引用时才会被执行。<br><img src=\"https://ws4.sinaimg.cn/large/0069RVTdly1fu1dp4x6jjj30hb0a0755.jpg\" alt=\"测试片段\"></p>\n<h3 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h3><p>JMeter有两种类型的控制器：取样器（sample）和逻辑控制器（Logic Controller），用这些原件来驱动处理一个测试。</p>\n<h4 id=\"采样器\"><a href=\"#采样器\" class=\"headerlink\" title=\"采样器\"></a>采样器</h4><p>取样器（Sample）是性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元，JMeter 原生支持多种不同的sampler ，如 HTTP Request Sampler 、 FTP  Request Sample 、TCP  Request Sample 、JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求。<br><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu1ds3unxyj30lh0fnacb.jpg\" alt=\"采样器\"></p>\n<h4 id=\"逻辑控制器（Logic-Controller）\"><a href=\"#逻辑控制器（Logic-Controller）\" class=\"headerlink\" title=\"逻辑控制器（Logic Controller）\"></a>逻辑控制器（Logic Controller）</h4><p>逻辑控制器，包括两类无件，一类是用于控制test plan 中 sampler 节点发送请求的逻辑顺序的控制器，常用的有 如果（If）控制器 、switch Controller 、Runtime Controller、循环控制器等。另一类是用来组织可控制 sampler 来节点的，如 事务控制器、吞吐量控制器。<br><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu1dukjfaqj30w00k0dir.jpg\" alt=\"逻辑控制器\"></p>\n<h3 id=\"配置元件\"><a href=\"#配置元件\" class=\"headerlink\" title=\"配置元件\"></a>配置元件</h3><p>配置元件（config element）用于提供对静态数据配置的支持。CSV Data Set config 可以将本地数据文件形成数据池（Data Pool），而对应于HTTP Request Sampler和 TCP Request Sampler等类型的配制无件则可以修改Sampler的默认数据。（例如，HTTP Cookie Manager 可以用于对 HTTP Request Sampler 的cookie 进行管理）<br><img src=\"https://ws4.sinaimg.cn/large/0069RVTdly1fu1dvqv6w8j30w00k041t.jpg\" alt=\"配置元件\"></p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>定时器（Timer）用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手端。类似于LoadRunner里面的“思考时间”。JMeter 定义了Bean Shell Timer、Constant Throughput Timer、固定定时器等不同类型的Timer。<br><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu1dwdrmb8j30w00k0n03.jpg\" alt=\"定时器\"></p>\n<h3 id=\"前置处理器（Per-Processors）\"><a href=\"#前置处理器（Per-Processors）\" class=\"headerlink\" title=\"前置处理器（Per Processors）\"></a>前置处理器（Per Processors）</h3><p>用于在实际的请求发出之前对即将发出的请求进行特殊处理。例如，HTTP URL重写修复符则可以实现URL重写，当RUL中有sessionID 一类的session信息时，可以通过该处理器填充发出请求的实际的sessionID 。<br><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fu1dxfqrxxj30w00k0ju8.jpg\" alt=\"前置处理器\"></p>\n<h3 id=\"后置处理器（Post-Processors）\"><a href=\"#后置处理器（Post-Processors）\" class=\"headerlink\" title=\"后置处理器（Post Processors）\"></a>后置处理器（Post Processors）</h3><p>用于对Sampler 发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据（类似LoadRunner测试工具中的关联概念）。例如，XPath  Extractor 则可以用于提取响应数据中通过给定XPath 值获得的数据。<br><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fu1dy72ixkj30w00k0q5x.jpg\" alt=\"后置处理器\"></p>\n<h3 id=\"断言（Assertions）\"><a href=\"#断言（Assertions）\" class=\"headerlink\" title=\"断言（Assertions）\"></a>断言（Assertions）</h3><p> 断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点，用以保证性能测试过程中的数据交互是否与预期一致。<br> <img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu1dywlw7ej30w00k0q5w.jpg\" alt=\"断言\"></p>\n<h3 id=\"监听器（Listener）\"><a href=\"#监听器（Listener）\" class=\"headerlink\" title=\"监听器（Listener）\"></a>监听器（Listener）</h3><p>这个监听器可不是用来监听系统资源的元件。它是用来对测试结果数据进行处理和可视化展示的一系列元件。 图行结果、查看结果树、聚合报告。都是我们经常用到的元件。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/0069RVTdly1fu1dzp8i85j30w00k0jul.jpg\" alt=\"监听器\"></p>\n","slug":"性能测试-Jmeter基础概念","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2020/08/07/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-Jmeter%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"Jmeter基础概念","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"http://vwin.github.io/tags/jmeter/"}]},{"title":"网络环境模拟和测试","date":"2020-01-08T08:02:26.000Z","path":"2020/01/08/网络环境模拟和测试/","text":"Ubuntu下，网络环境模拟以及测试，可以使用自带命令netem和tc，需要注意的是：此方法只能控制发包动作，不能控制收包动作，同时，它直接对物理接口生效，如果控制了物理的eth0，那么逻辑网卡（比如eth0:1）也会受到影响，反之，如果您在逻辑网卡上做控制，该控制可能是无效的。（注：虚拟机中的多个网卡可以在虚拟机中视为多个物理网卡） 常用命令如下： 模拟延迟传输 1tc qdisc add dev eth0 root netem delay 100ms 10ms 50% 说明： eth0: 表示需要操作的网卡。 100ms：基础延迟为100ms。 10ms：浮动延迟范围±10ms。 50%： 50%的包进行浮动延迟。 模拟网络丢包 1tc qdisc add dev eth0 root netem delay loss 3% 50% 说明： 3%：随机丢包3%。 50%：丢包成功率50%。 查看当前网卡配置 1tc qdisc show dev eth0 删除当前网卡配置 1tc qdisc del dev eth0 root 说明： 不需要要模拟时，一定要删除掉配置，以防影响正常使用。 参考：https://cizixs.com/2017/10/23/tc-netem-for-terrible-network/","raw":"---\ntitle: 网络环境模拟和测试\ntoc: true\ndate: 2020-01-08 16:02:26\ntags: [网络环境,测试]\ncategories: [测试]\ndescription:\n---\nUbuntu下，网络环境模拟以及测试，可以使用自带命令netem和tc，需要注意的是：此方法只能控制发包动作，不能控制收包动作，同时，它直接对物理接口生效，如果控制了物理的eth0，那么逻辑网卡（比如eth0:1）也会受到影响，反之，如果您在逻辑网卡上做控制，该控制可能是无效的。\n（注：虚拟机中的多个网卡可以在虚拟机中视为多个物理网卡）\n\n常用命令如下：\n\n1. 模拟延迟传输\n\n    ```shell\n    tc qdisc add dev eth0 root netem delay 100ms 10ms 50%\n    ```\n\n    说明：\n\n    - eth0: 表示需要操作的网卡。\n    - 100ms：基础延迟为100ms。\n    - 10ms：浮动延迟范围±10ms。\n    - 50%： 50%的包进行浮动延迟。\n\n2. 模拟网络丢包\n\n    ```shell\n    tc qdisc add dev eth0 root netem delay loss 3% 50% \n    ```\n\n    说明：\n    - 3%：随机丢包3%。\n    - 50%：丢包成功率50%。\n\n3. 查看当前网卡配置\n\n    ```shell\n    tc qdisc show dev eth0\n    ```\n\n4. 删除当前网卡配置\n\n    ```shell\n    tc qdisc del dev eth0 root\n    ```\n\n    说明：\n    - 不需要要模拟时，一定要删除掉配置，以防影响正常使用。\n\n参考：https://cizixs.com/2017/10/23/tc-netem-for-terrible-network/ \n","content":"<p>Ubuntu下，网络环境模拟以及测试，可以使用自带命令netem和tc，需要注意的是：此方法只能控制发包动作，不能控制收包动作，同时，它直接对物理接口生效，如果控制了物理的eth0，那么逻辑网卡（比如eth0:1）也会受到影响，反之，如果您在逻辑网卡上做控制，该控制可能是无效的。<br>（注：虚拟机中的多个网卡可以在虚拟机中视为多个物理网卡）</p>\n<p>常用命令如下：</p>\n<ol>\n<li><p>模拟延迟传输</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tc qdisc add dev eth0 root netem delay 100ms 10ms 50%</span><br></pre></td></tr></table></figure>\n\n<p> 说明：</p>\n<ul>\n<li>eth0: 表示需要操作的网卡。</li>\n<li>100ms：基础延迟为100ms。</li>\n<li>10ms：浮动延迟范围±10ms。</li>\n<li>50%： 50%的包进行浮动延迟。</li>\n</ul>\n</li>\n<li><p>模拟网络丢包</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tc qdisc add dev eth0 root netem delay loss 3% 50% </span><br></pre></td></tr></table></figure>\n\n<p> 说明：</p>\n<ul>\n<li>3%：随机丢包3%。</li>\n<li>50%：丢包成功率50%。</li>\n</ul>\n</li>\n<li><p>查看当前网卡配置</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tc qdisc show dev eth0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除当前网卡配置</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tc qdisc del dev eth0 root</span><br></pre></td></tr></table></figure>\n\n<p> 说明：</p>\n<ul>\n<li>不需要要模拟时，一定要删除掉配置，以防影响正常使用。</li>\n</ul>\n</li>\n</ol>\n<p>参考：<a href=\"https://cizixs.com/2017/10/23/tc-netem-for-terrible-network/\">https://cizixs.com/2017/10/23/tc-netem-for-terrible-network/</a> </p>\n","slug":"网络环境模拟和测试","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2020/01/08/%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F%E5%92%8C%E6%B5%8B%E8%AF%95/","excerpt":"","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"网络环境","slug":"网络环境","permalink":"http://vwin.github.io/tags/%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83/"}]},{"title":"性能测试总结-测试流程","date":"2019-08-10T11:54:49.000Z","path":"2019/08/10/性能测试总结-测试流程/","text":"本文主要介绍下性能测试的基本流程，性能测试从实际执行层面来看，测试的过程一般分为这么几个阶段，如下图： 下面分别介绍下每个阶段具体需要做什么： 性能需求分析：性能需求分析是整个性能测试工作开展的基础，如果连性能的需求都没弄清楚，后面的性能测试执行其实是没有任何意义的，而且性能需求分析做的好不好直接影响到性能测试的结果。 一些性能测试人员常犯的错误就是测试一开始就直接用工具对系统进行加压，没有弄清楚性能测试的目的，稀里糊涂做完了以后也不知道结果是否满足性能需求。市面上的书籍也大都是直接讲性能测试工具如LR，jmeter如何使用，导致很多新手一提到性能测试就直接拿工具来进行录制回放，使得很多人认为会使用性能测试工具就等于会性能测试了，殊不知工具其实只是性能测试过程中很小的一部分。 在需求分析阶段，测试人员需要与项目相关的人员进行沟通，收集各种项目资料，对系统进行分析，建立性能测试数据模型，并将其转化为可衡量的具体性能指标，确认测试的目标。所以性能测试需求分析过程是繁杂的，需要测试人员有深厚的性能理论知识，除此之外还需要懂一些数学建模的知识来帮助我们建立性能测试模型。 首先，让我们来看看通过性能需求分析我们需要得出哪些结论或目标： 明确倒底要不要做性能测试？性能测试的目的是什么？ 明确被测系统是什么？被测试系统的相关技术信息如：架构、平台、协议等 明确被测系统的基本业务、关键业务，用户行为 明确性能测试点是什么？哪些需要测，为什么？哪些不需要测，又是为什么？ 明确被测系统未来的业务拓展规划以及性能需求？ 明确性能测试策略，即应该怎么测试？ 明确性能测试的指标，知道测试出来的结果怎么算通过？ 其次，需求分析阶段我们可以从以下几个方面入手： 系统信息调研：指对被测试系统进行分析，需要对其有全面的了解和认识，这是我们做好性能测试的前提，而且在后续进行性能分析和调优时将会大有用处，试想如果连系统的架构、协议都不了解，我们如何进行准确的性能测试？如果进行性能分析与调优？ 需要分析的系统信息如下（包括但不仅限于如下这些）： 业务信息调研：指对被测试的业务进行分析，通过对业务的分析和了解，方便我们后续进行性能测试场景的确定以及性能测试指标的确定。需要分析的业务信息如下（包括但不仅限于如下这些）： 性能需求评估：在实施性能测试之前，我们需要对被测系统做相应的评估，主要目的是明确是否需要做性能测试。如果确定需要做性能测试，需要进一步确立性能测试点和指标，明确该测什么、性能指标是多少，测试通过or不通过的标准？性能指标也会根据情况评估，要求被测系统能满足将来一定时间段的业务压力。 判断是否进行性能测试主要从下面两个方面进行思考： 业务角度: 系统是公司内部 or 对外？系统使用的人数的多少？如果一个系统上线后基本没几个人使用，无论系统多大，设计多么复杂，并发性的性能测试都是没必要的，前期可以否决。当然，除非在功能测试阶段发现非常明显的性能问题，使得用户体验较差的，此时可进行性能测试来排查问题。 系统角度：系统又可以从以下3个方面进行分析 系统架构：如果一个系统采用的框架是老的系统框架（通常大公司都有自己的统一框架），只是在此框架上增加一些应用，其实是没有必要做性能测试，因为老框架的使用肯定是经过了验证的。如果一个系统采用的是一种新的框架，可以考虑做性能测试。 数据库要求： 很多情况下，性能测试是大数据量的并发访问、修改数据库，而瓶颈在于连接数据库池的数量，而非数据库本身的负载、吞吐能力。这时，可以结合DBA的建议，来决定是否来做性能测试。 系统特殊要求： 从实时性角度来分析，某些系统对响应时间要求比较，比如证券系统，系统的快慢直接影响客户的收益，这种情况就有作并发测试的必要，在大并发量的场景下，查看这个功能的响应时间。 从大数据量上传下载角度分析，某些系统经常需要进行较大数据量的上传和下载操作，虽然此种操作使用的人数不会太多，但是也有必要进行性能测试，确定系统能处理的最大容量，如果超过这个容量时系统需要进行相关控制，避免由于不人工误操作导致系统内存溢出或崩溃。 确定性能测试点：在上面第3点中，我们简单分析了如何确定一个系统是否需要做性能测试。下面简单总结下如果一个系统确定要做性能测试，我们如何确定被测系统的性能测试点？我们可以从下面几个方面进行分析： 关键业务：确定被测项目是否属于关键业务，有哪些主要的业务逻辑点，特别是跟交易相关的功能点。例如转账，扣款等接口。如果项目（或功能点）不属于关键业务（或关键业务点），则可转入下面。 日请求量：确定被测项目各功能点的日请求量（可以统计不同时间粒度下的请求量如：小时，日，周，月）。如果日请求量很高，系统压力很大，而且又是关键业务，该项目需要做性能测试，而且关键业务点，可以被确定为性能点。 逻辑复杂度：判定被测项目各功能点的逻辑复杂度。如果一个主要业务的日请求量不高，但是逻辑很复杂，则也需要通过性能测试。原因是，在分布式方式的调用中，当某一个环节响应较慢，就会影响到其它环节，造成雪崩效应。 运营推广活动：根据运营的推广计划来判定待测系统未来的压力。未雨绸缪、防患于未然、降低运营风险是性能测试的主要目标。被测系统的性能不仅能满足当前压力，更需要满足未来一定时间段内的压力。因此，事先了解运营推广计划，对性能点的制定有很大的作用。例如，运营计划做活动，要求系统每天能支撑多少 PV、多少 UV，或者一个季度后，需要能支撑多大的访问量等等数据。当新项目（或功能点）属于运营重点推广计划范畴之内，则该项目（或功能点）也需要做性能测试。 以上 4 点，是相辅相成、环环相扣的。在实际工作中应该具体问题具体分析。例如，当一个功能点不满足以上 4 点，但又属于资源高消耗（内存、CPU），也可列入性能测试点行列。 确定性能指标：性能需求分析一个很重要的目标就是需要确定后期性能分析用的性能指标，性能指标有很多，可以根据具体项目选取和设定，而具体的指标值则需要根据业务特点进行设定，本文不详细进行阐述，后续可考虑就此单独写一篇。 性能测试准备测试环境准备： 系统运行环境：这个通常就是我们的测试环境，有些时候需求比较多，做性能测试担心把环境搞跨了影响其它的功能测试，可能需要重新搭建一套专门用来做性能测试的环境。 执行机环境：这个就是用来生成负载的执行机，通常需要在物理机上运行，而物理机又是稀缺资源，所以我们每次做性能测试都需要提前准备好执行机环境。 测试场景设计：根据性能需求分析来设计符合用户使用习惯的场景，场景设计的好不好直接影响到性能测试的效果。性能工具准备： 负载工具：根据需求分析和系统特点选择合适的负载工具，比如LR、Jmeter或galting等 监控工具：准备性能测试时的服务器资源、JVM、数据库监控工具，以便进行后续的性能测试分析与调优。 测试脚本准备如果性能测试工具不能满足被测系统的要求或只能满足部分要求时，需要我们自己开发脚本配合工具进行性能测试。 测试数据准备： 负载测试数据：并发测试时需要多少数据？比如登录场景？ DB数据量大小：为了尽量符合生产场景，需要模拟线上大量数据情况，那么要往数据库里提前插入一定的数据量。这可能需要花费一些时间，特点是关联系统较多，逻辑复杂的业务可能同时涉及多张表。 其它：如果需要其它其它关联系统或专业人士如DBA配合的，也需要提前进行沟通。性能测试执行 人工边执行边分析通常我们做性能测试都是人工执行并随时观察系统运行的情况、资源的使用率等指标。性能测试的吸引力之一就在于它的不可预知性。当我们在做性能测试的时候遇到跟预期不符的情况很正常，这个时候需要冷静的分析。但这个过程可能会很慢长，需要不断的调整系统配置或程序代码来定位问题，耗时耗人力。特别是在当前敏捷开发模式比较流行的大环境下，版本发布非常频繁且版本周期短（通常1~2周一个版本），没有那么长的时间来做性能测试。 无人值守执行性能测试无人值守是最理想化的目标，目前我们也朝着这个方向努力。无人值守不是说没有人力介入，而是把人为的分析和\b执行过程分离，执行过程只是机器服从指令的运行而已。通常测试环境在白天比较繁忙，出现性能问题及定位难度较大且会影响功能测试。所以一般性能测试最好在晚上或周末进行，在相对较安静的条件有利于测试结果的稳定性。这种方法也相对比较适合敏捷的模式，不需要人工一直守着。只需要在拿到结果后进行分析就好了。同进，这种方式对测试人员能力的要求比较高，需要我们能进行自动化的收集各种监控数据、生成报表便于后续分析。 结果分析与调优关于性能分析与调优这是一个比较大的话题，后续会单独进行总结和分析。 测试报告与总结 性能测试报告是性能测试的里程碑，通过报告能展示出性能测试的最终成果，展示系统性能是否符合需求，是否有性能隐患。性能测试报告中需要阐明性能测试目标、性能测试环境、性能测试数据构造规则、性能测试策略、性能测试结果、性能测试调优说明、性能测试过程中遇到的问题和解决办法等。 性能测试工程师完成该次性能测试后，需要将测试结果进行备案，并做为下次性能测试的基线标准，具体包括性能测试结果数据、性能测试瓶颈和调优方案等。同时需要将测试过程中遇到的问题，包括代码瓶颈、配置项问题、数据问题和沟通问题，以及解决办法或解决方案，进行知识沉淀。","raw":"---\ntitle: 性能测试总结-测试流程\ntoc: true\ndate: 2019-08-10 19:54:49\ntags: [性能测试]\ncategories: [测试]\ndescription:\n---\n本文主要介绍下性能测试的基本流程，性能测试从实际执行层面来看，测试的过程一般分为这么几个阶段，如下图：\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fynqexw9ogj30cq0n2dh1.jpg)\n\n<!--more-->\n\n下面分别介绍下每个阶段具体需要做什么：\n\n# 性能需求分析：\n性能需求分析是整个性能测试工作开展的基础，如果连性能的需求都没弄清楚，后面的性能测试执行其实是没有任何意义的，而且性能需求分析做的好不好直接影响到性能测试的结果。\n\n一些性能测试人员常犯的错误就是测试一开始就直接用工具对系统进行加压，没有弄清楚性能测试的目的，稀里糊涂做完了以后也不知道结果是否满足性能需求。市面上的书籍也大都是直接讲性能测试工具如LR，jmeter如何使用，导致很多新手一提到性能测试就直接拿工具来进行录制回放，使得很多人认为会使用性能测试工具就等于会性能测试了，殊不知工具其实只是性能测试过程中很小的一部分。\n\n在需求分析阶段，测试人员需要与项目相关的人员进行沟通，收集各种项目资料，对系统进行分析，建立性能测试数据模型，并将其转化为可衡量的具体性能指标，确认测试的目标。所以性能测试需求分析过程是繁杂的，需要测试人员有深厚的性能理论知识，除此之外还需要懂一些数学建模的知识来帮助我们建立性能测试模型。\n\n\n首先，让我们来看看通过性能需求分析我们需要得出哪些结论或目标：\n\n- 明确倒底要不要做性能测试？性能测试的目的是什么？\n- 明确被测系统是什么？被测试系统的相关技术信息如：架构、平台、协议等\n- 明确被测系统的基本业务、关键业务，用户行为\n- 明确性能测试点是什么？哪些需要测，为什么？哪些不需要测，又是为什么？\n- 明确被测系统未来的业务拓展规划以及性能需求？\n- 明确性能测试策略，即应该怎么测试？\n- 明确性能测试的指标，知道测试出来的结果怎么算通过？\n \n其次，需求分析阶段我们可以从以下几个方面入手：\n\n## 系统信息调研：\n\n指对被测试系统进行分析，需要对其有全面的了解和认识，这是我们做好性能测试的前提，而且在后续进行性能分析和调优时将会大有用处，试想如果连系统的架构、协议都不了解，我们如何进行准确的性能测试？如果进行性能分析与调优？\n\n需要分析的系统信息如下（包括但不仅限于如下这些）：\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fynqf0teg3j30qe0iudic.jpg)\n \n\n## 业务信息调研：\n\n指对被测试的业务进行分析，通过对业务的分析和了解，方便我们后续进行性能测试场景的确定以及性能测试指标的确定。需要分析的业务信息如下（包括但不仅限于如下这些）：\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fynqf3ipk0j30o00eq40d.jpg)\n\n## 性能需求评估：\n\n在实施性能测试之前，我们需要对被测系统做相应的评估，主要目的是明确是否需要做性能测试。如果确定需要做性能测试，需要进一步确立性能测试点和指标，明确该测什么、性能指标是多少，测试通过or不通过的标准？性能指标也会根据情况评估，要求被测系统能满足将来一定时间段的业务压力。\n\n判断是否进行性能测试主要从下面两个方面进行思考：\n\n### 业务角度:\n　　 系统是公司内部 or 对外？系统使用的人数的多少？如果一个系统上线后基本没几个人使用，无论系统多大，设计多么复杂，并发性的性能测试都是没必要的，前期可以否决。当然，除非在功能测试阶段发现非常明显的性能问题，使得用户体验较差的，此时可进行性能测试来排查问题。\n\n### 系统角度：系统又可以从以下3个方面进行分析\n1. 系统架构：\n   如果一个系统采用的框架是老的系统框架（通常大公司都有自己的统一框架），只是在此框架上增加一些应用，其实是没有必要做性能测试，因为老框架的使用肯定是经过了验证的。如果一个系统采用的是一种新的框架，可以考虑做性能测试。\n2. 数据库要求：\n    很多情况下，性能测试是大数据量的并发访问、修改数据库，而瓶颈在于连接数据库池的数量，而非数据库本身的负载、吞吐能力。这时，可以结合DBA的建议，来决定是否来做性能测试。\n3. 系统特殊要求：\n   1. 从实时性角度来分析，某些系统对响应时间要求比较，比如证券系统，系统的快慢直接影响客户的收益，这种情况就有作并发测试的必要，在大并发量的场景下，查看这个功能的响应时间。\n   2. 从大数据量上传下载角度分析，某些系统经常需要进行较大数据量的上传和下载操作，虽然此种操作使用的人数不会太多，但是也有必要进行性能测试，确定系统能处理的最大容量，如果超过这个容量时系统需要进行相关控制，避免由于不人工误操作导致系统内存溢出或崩溃。\n\n \n\n## 确定性能测试点： \n在上面第3点中，我们简单分析了如何确定一个系统是否需要做性能测试。下面简单总结下如果一个系统确定要做性能测试，我们如何确定被测系统的性能测试点？\n我们可以从下面几个方面进行分析：\n\n1. 关键业务：\n   确定被测项目是否属于关键业务，有哪些主要的业务逻辑点，特别是跟交易相关的功能点。例如转账，扣款等接口。如果项目（或功能点）不属于关键业务（或关键业务点），则可转入下面。\n\n2. 日请求量：\n   确定被测项目各功能点的日请求量（可以统计不同时间粒度下的请求量如：小时，日，周，月）。如果日请求量很高，系统压力很大，而且又是关键业务，该项目需要做性能测试，而且关键业务点，可以被确定为性能点。\n\n3. 逻辑复杂度：\n   判定被测项目各功能点的逻辑复杂度。如果一个主要业务的日请求量不高，但是逻辑很复杂，则也需要通过性能测试。原因是，在分布式方式的调用中，当某一个环节响应较慢，就会影响到其它环节，造成雪崩效应。\n\n4. 运营推广活动：\n   根据运营的推广计划来判定待测系统未来的压力。未雨绸缪、防患于未然、降低运营风险是性能测试的主要目标。被测系统的性能不仅能满足当前压力，更需要满足未来一定时间段内的压力。因此，事先了解运营推广计划，对性能点的制定有很大的作用。例如，运营计划做活动，要求系统每天能支撑多少 PV、多少 UV，或者一个季度后，需要能支撑多大的访问量等等数据。当新项目（或功能点）属于运营重点推广计划范畴之内，则该项目（或功能点）也需要做性能测试。\n\n以上 4 点，是相辅相成、环环相扣的。在实际工作中应该具体问题具体分析。例如，当一个功能点不满足以上 4 点，但又属于资源高消耗（内存、CPU），也可列入性能测试点行列。\n\n\n## 确定性能指标： \n性能需求分析一个很重要的目标就是需要确定后期性能分析用的性能指标，性能指标有很多，可以根据具体项目选取和设定，而具体的指标值则需要根据业务特点进行设定，本文不详细进行阐述，后续可考虑就此单独写一篇。\n\n\n# 性能测试准备\n\n## 测试环境准备：\n1. 系统运行环境：这个通常就是我们的测试环境，有些时候需求比较多，做性能测试担心把环境搞跨了影响其它的功能测试，可能需要重新搭建一套专门用来做性能测试的环境。\n2. 执行机环境：这个就是用来生成负载的执行机，通常需要在物理机上运行，而物理机又是稀缺资源，所以我们每次做性能测试都需要提前准备好执行机环境。\n\n## 测试场景设计：根据性能需求分析来设计符合用户使用习惯的场景，场景设计的好不好直接影响到性能测试的效果。\n\n## 性能工具准备：\n\n1. 负载工具：根据需求分析和系统特点选择合适的负载工具，比如LR、Jmeter或galting等\n2. 监控工具：准备性能测试时的服务器资源、JVM、数据库监控工具，以便进行后续的性能测试分析与调优。\n\n## 测试脚本准备\n如果性能测试工具不能满足被测系统的要求或只能满足部分要求时，需要我们自己开发脚本配合工具进行性能测试。\n\n## 测试数据准备：\n1. 负载测试数据：并发测试时需要多少数据？比如登录场景？\n2. DB数据量大小：为了尽量符合生产场景，需要模拟线上大量数据情况，那么要往数据库里提前插入一定的数据量。这可能需要花费一些时间，特点是关联系统较多，逻辑复杂的业务可能同时涉及多张表。\n\n## 其它：如果需要其它其它关联系统或专业人士如DBA配合的，也需要提前进行沟通。\n\n# 性能测试执行\n1. 人工边执行边分析\n   通常我们做性能测试都是人工执行并随时观察系统运行的情况、资源的使用率等指标。性能测试的吸引力之一就在于它的不可预知性。当我们在做性能测试的时候遇到跟预期不符的情况很正常，这个时候需要冷静的分析。但这个过程可能会很慢长，需要不断的调整系统配置或程序代码来定位问题，耗时耗人力。特别是在当前敏捷开发模式比较流行的大环境下，版本发布非常频繁且版本周期短（通常1~2周一个版本），没有那么长的时间来做性能测试。\n\n2. 无人值守执行性能测试\n   无人值守是最理想化的目标，目前我们也朝着这个方向努力。无人值守不是说没有人力介入，而是把人为的分析和\b执行过程分离，执行过程只是机器服从指令的运行而已。通常测试环境在白天比较繁忙，出现性能问题及定位难度较大且会影响功能测试。所以一般性能测试最好在晚上或周末进行，在相对较安静的条件有利于测试结果的稳定性。这种方法也相对比较适合敏捷的模式，不需要人工一直守着。只需要在拿到结果后进行分析就好了。同进，这种方式对测试人员能力的要求比较高，需要我们能进行自动化的收集各种监控数据、生成报表便于后续分析。\n\n \n\n# 结果分析与调优\n\n关于性能分析与调优这是一个比较大的话题，后续会单独进行总结和分析。\n\n# 测试报告与总结\n1. 性能测试报告是性能测试的里程碑，通过报告能展示出性能测试的最终成果，展示系统性能是否符合需求，是否有性能隐患。性能测试报告中需要阐明性能测试目标、性能测试环境、性能测试数据构造规则、性能测试策略、性能测试结果、性能测试调优说明、性能测试过程中遇到的问题和解决办法等。\n\n2. 性能测试工程师完成该次性能测试后，需要将测试结果进行备案，并做为下次性能测试的基线标准，具体包括性能测试结果数据、性能测试瓶颈和调优方案等。同时需要将测试过程中遇到的问题，包括代码瓶颈、配置项问题、数据问题和沟通问题，以及解决办法或解决方案，进行知识沉淀。\n","content":"<p>本文主要介绍下性能测试的基本流程，性能测试从实际执行层面来看，测试的过程一般分为这么几个阶段，如下图：<br><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fynqexw9ogj30cq0n2dh1.jpg\"></p>\n<span id=\"more\"></span>\n\n<p>下面分别介绍下每个阶段具体需要做什么：</p>\n<h1 id=\"性能需求分析：\"><a href=\"#性能需求分析：\" class=\"headerlink\" title=\"性能需求分析：\"></a>性能需求分析：</h1><p>性能需求分析是整个性能测试工作开展的基础，如果连性能的需求都没弄清楚，后面的性能测试执行其实是没有任何意义的，而且性能需求分析做的好不好直接影响到性能测试的结果。</p>\n<p>一些性能测试人员常犯的错误就是测试一开始就直接用工具对系统进行加压，没有弄清楚性能测试的目的，稀里糊涂做完了以后也不知道结果是否满足性能需求。市面上的书籍也大都是直接讲性能测试工具如LR，jmeter如何使用，导致很多新手一提到性能测试就直接拿工具来进行录制回放，使得很多人认为会使用性能测试工具就等于会性能测试了，殊不知工具其实只是性能测试过程中很小的一部分。</p>\n<p>在需求分析阶段，测试人员需要与项目相关的人员进行沟通，收集各种项目资料，对系统进行分析，建立性能测试数据模型，并将其转化为可衡量的具体性能指标，确认测试的目标。所以性能测试需求分析过程是繁杂的，需要测试人员有深厚的性能理论知识，除此之外还需要懂一些数学建模的知识来帮助我们建立性能测试模型。</p>\n<p>首先，让我们来看看通过性能需求分析我们需要得出哪些结论或目标：</p>\n<ul>\n<li>明确倒底要不要做性能测试？性能测试的目的是什么？</li>\n<li>明确被测系统是什么？被测试系统的相关技术信息如：架构、平台、协议等</li>\n<li>明确被测系统的基本业务、关键业务，用户行为</li>\n<li>明确性能测试点是什么？哪些需要测，为什么？哪些不需要测，又是为什么？</li>\n<li>明确被测系统未来的业务拓展规划以及性能需求？</li>\n<li>明确性能测试策略，即应该怎么测试？</li>\n<li>明确性能测试的指标，知道测试出来的结果怎么算通过？</li>\n</ul>\n<p>其次，需求分析阶段我们可以从以下几个方面入手：</p>\n<h2 id=\"系统信息调研：\"><a href=\"#系统信息调研：\" class=\"headerlink\" title=\"系统信息调研：\"></a>系统信息调研：</h2><p>指对被测试系统进行分析，需要对其有全面的了解和认识，这是我们做好性能测试的前提，而且在后续进行性能分析和调优时将会大有用处，试想如果连系统的架构、协议都不了解，我们如何进行准确的性能测试？如果进行性能分析与调优？</p>\n<p>需要分析的系统信息如下（包括但不仅限于如下这些）：<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fynqf0teg3j30qe0iudic.jpg\"></p>\n<h2 id=\"业务信息调研：\"><a href=\"#业务信息调研：\" class=\"headerlink\" title=\"业务信息调研：\"></a>业务信息调研：</h2><p>指对被测试的业务进行分析，通过对业务的分析和了解，方便我们后续进行性能测试场景的确定以及性能测试指标的确定。需要分析的业务信息如下（包括但不仅限于如下这些）：<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fynqf3ipk0j30o00eq40d.jpg\"></p>\n<h2 id=\"性能需求评估：\"><a href=\"#性能需求评估：\" class=\"headerlink\" title=\"性能需求评估：\"></a>性能需求评估：</h2><p>在实施性能测试之前，我们需要对被测系统做相应的评估，主要目的是明确是否需要做性能测试。如果确定需要做性能测试，需要进一步确立性能测试点和指标，明确该测什么、性能指标是多少，测试通过or不通过的标准？性能指标也会根据情况评估，要求被测系统能满足将来一定时间段的业务压力。</p>\n<p>判断是否进行性能测试主要从下面两个方面进行思考：</p>\n<h3 id=\"业务角度\"><a href=\"#业务角度\" class=\"headerlink\" title=\"业务角度:\"></a>业务角度:</h3><p>　　 系统是公司内部 or 对外？系统使用的人数的多少？如果一个系统上线后基本没几个人使用，无论系统多大，设计多么复杂，并发性的性能测试都是没必要的，前期可以否决。当然，除非在功能测试阶段发现非常明显的性能问题，使得用户体验较差的，此时可进行性能测试来排查问题。</p>\n<h3 id=\"系统角度：系统又可以从以下3个方面进行分析\"><a href=\"#系统角度：系统又可以从以下3个方面进行分析\" class=\"headerlink\" title=\"系统角度：系统又可以从以下3个方面进行分析\"></a>系统角度：系统又可以从以下3个方面进行分析</h3><ol>\n<li>系统架构：<br>如果一个系统采用的框架是老的系统框架（通常大公司都有自己的统一框架），只是在此框架上增加一些应用，其实是没有必要做性能测试，因为老框架的使用肯定是经过了验证的。如果一个系统采用的是一种新的框架，可以考虑做性能测试。</li>\n<li>数据库要求：<br> 很多情况下，性能测试是大数据量的并发访问、修改数据库，而瓶颈在于连接数据库池的数量，而非数据库本身的负载、吞吐能力。这时，可以结合DBA的建议，来决定是否来做性能测试。</li>\n<li>系统特殊要求：<ol>\n<li>从实时性角度来分析，某些系统对响应时间要求比较，比如证券系统，系统的快慢直接影响客户的收益，这种情况就有作并发测试的必要，在大并发量的场景下，查看这个功能的响应时间。</li>\n<li>从大数据量上传下载角度分析，某些系统经常需要进行较大数据量的上传和下载操作，虽然此种操作使用的人数不会太多，但是也有必要进行性能测试，确定系统能处理的最大容量，如果超过这个容量时系统需要进行相关控制，避免由于不人工误操作导致系统内存溢出或崩溃。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"确定性能测试点：\"><a href=\"#确定性能测试点：\" class=\"headerlink\" title=\"确定性能测试点：\"></a>确定性能测试点：</h2><p>在上面第3点中，我们简单分析了如何确定一个系统是否需要做性能测试。下面简单总结下如果一个系统确定要做性能测试，我们如何确定被测系统的性能测试点？<br>我们可以从下面几个方面进行分析：</p>\n<ol>\n<li><p>关键业务：<br>确定被测项目是否属于关键业务，有哪些主要的业务逻辑点，特别是跟交易相关的功能点。例如转账，扣款等接口。如果项目（或功能点）不属于关键业务（或关键业务点），则可转入下面。</p>\n</li>\n<li><p>日请求量：<br>确定被测项目各功能点的日请求量（可以统计不同时间粒度下的请求量如：小时，日，周，月）。如果日请求量很高，系统压力很大，而且又是关键业务，该项目需要做性能测试，而且关键业务点，可以被确定为性能点。</p>\n</li>\n<li><p>逻辑复杂度：<br>判定被测项目各功能点的逻辑复杂度。如果一个主要业务的日请求量不高，但是逻辑很复杂，则也需要通过性能测试。原因是，在分布式方式的调用中，当某一个环节响应较慢，就会影响到其它环节，造成雪崩效应。</p>\n</li>\n<li><p>运营推广活动：<br>根据运营的推广计划来判定待测系统未来的压力。未雨绸缪、防患于未然、降低运营风险是性能测试的主要目标。被测系统的性能不仅能满足当前压力，更需要满足未来一定时间段内的压力。因此，事先了解运营推广计划，对性能点的制定有很大的作用。例如，运营计划做活动，要求系统每天能支撑多少 PV、多少 UV，或者一个季度后，需要能支撑多大的访问量等等数据。当新项目（或功能点）属于运营重点推广计划范畴之内，则该项目（或功能点）也需要做性能测试。</p>\n</li>\n</ol>\n<p>以上 4 点，是相辅相成、环环相扣的。在实际工作中应该具体问题具体分析。例如，当一个功能点不满足以上 4 点，但又属于资源高消耗（内存、CPU），也可列入性能测试点行列。</p>\n<h2 id=\"确定性能指标：\"><a href=\"#确定性能指标：\" class=\"headerlink\" title=\"确定性能指标：\"></a>确定性能指标：</h2><p>性能需求分析一个很重要的目标就是需要确定后期性能分析用的性能指标，性能指标有很多，可以根据具体项目选取和设定，而具体的指标值则需要根据业务特点进行设定，本文不详细进行阐述，后续可考虑就此单独写一篇。</p>\n<h1 id=\"性能测试准备\"><a href=\"#性能测试准备\" class=\"headerlink\" title=\"性能测试准备\"></a>性能测试准备</h1><h2 id=\"测试环境准备：\"><a href=\"#测试环境准备：\" class=\"headerlink\" title=\"测试环境准备：\"></a>测试环境准备：</h2><ol>\n<li>系统运行环境：这个通常就是我们的测试环境，有些时候需求比较多，做性能测试担心把环境搞跨了影响其它的功能测试，可能需要重新搭建一套专门用来做性能测试的环境。</li>\n<li>执行机环境：这个就是用来生成负载的执行机，通常需要在物理机上运行，而物理机又是稀缺资源，所以我们每次做性能测试都需要提前准备好执行机环境。</li>\n</ol>\n<h2 id=\"测试场景设计：根据性能需求分析来设计符合用户使用习惯的场景，场景设计的好不好直接影响到性能测试的效果。\"><a href=\"#测试场景设计：根据性能需求分析来设计符合用户使用习惯的场景，场景设计的好不好直接影响到性能测试的效果。\" class=\"headerlink\" title=\"测试场景设计：根据性能需求分析来设计符合用户使用习惯的场景，场景设计的好不好直接影响到性能测试的效果。\"></a>测试场景设计：根据性能需求分析来设计符合用户使用习惯的场景，场景设计的好不好直接影响到性能测试的效果。</h2><h2 id=\"性能工具准备：\"><a href=\"#性能工具准备：\" class=\"headerlink\" title=\"性能工具准备：\"></a>性能工具准备：</h2><ol>\n<li>负载工具：根据需求分析和系统特点选择合适的负载工具，比如LR、Jmeter或galting等</li>\n<li>监控工具：准备性能测试时的服务器资源、JVM、数据库监控工具，以便进行后续的性能测试分析与调优。</li>\n</ol>\n<h2 id=\"测试脚本准备\"><a href=\"#测试脚本准备\" class=\"headerlink\" title=\"测试脚本准备\"></a>测试脚本准备</h2><p>如果性能测试工具不能满足被测系统的要求或只能满足部分要求时，需要我们自己开发脚本配合工具进行性能测试。</p>\n<h2 id=\"测试数据准备：\"><a href=\"#测试数据准备：\" class=\"headerlink\" title=\"测试数据准备：\"></a>测试数据准备：</h2><ol>\n<li>负载测试数据：并发测试时需要多少数据？比如登录场景？</li>\n<li>DB数据量大小：为了尽量符合生产场景，需要模拟线上大量数据情况，那么要往数据库里提前插入一定的数据量。这可能需要花费一些时间，特点是关联系统较多，逻辑复杂的业务可能同时涉及多张表。</li>\n</ol>\n<h2 id=\"其它：如果需要其它其它关联系统或专业人士如DBA配合的，也需要提前进行沟通。\"><a href=\"#其它：如果需要其它其它关联系统或专业人士如DBA配合的，也需要提前进行沟通。\" class=\"headerlink\" title=\"其它：如果需要其它其它关联系统或专业人士如DBA配合的，也需要提前进行沟通。\"></a>其它：如果需要其它其它关联系统或专业人士如DBA配合的，也需要提前进行沟通。</h2><h1 id=\"性能测试执行\"><a href=\"#性能测试执行\" class=\"headerlink\" title=\"性能测试执行\"></a>性能测试执行</h1><ol>\n<li><p>人工边执行边分析<br>通常我们做性能测试都是人工执行并随时观察系统运行的情况、资源的使用率等指标。性能测试的吸引力之一就在于它的不可预知性。当我们在做性能测试的时候遇到跟预期不符的情况很正常，这个时候需要冷静的分析。但这个过程可能会很慢长，需要不断的调整系统配置或程序代码来定位问题，耗时耗人力。特别是在当前敏捷开发模式比较流行的大环境下，版本发布非常频繁且版本周期短（通常1~2周一个版本），没有那么长的时间来做性能测试。</p>\n</li>\n<li><p>无人值守执行性能测试<br>无人值守是最理想化的目标，目前我们也朝着这个方向努力。无人值守不是说没有人力介入，而是把人为的分析和\b执行过程分离，执行过程只是机器服从指令的运行而已。通常测试环境在白天比较繁忙，出现性能问题及定位难度较大且会影响功能测试。所以一般性能测试最好在晚上或周末进行，在相对较安静的条件有利于测试结果的稳定性。这种方法也相对比较适合敏捷的模式，不需要人工一直守着。只需要在拿到结果后进行分析就好了。同进，这种方式对测试人员能力的要求比较高，需要我们能进行自动化的收集各种监控数据、生成报表便于后续分析。</p>\n</li>\n</ol>\n<h1 id=\"结果分析与调优\"><a href=\"#结果分析与调优\" class=\"headerlink\" title=\"结果分析与调优\"></a>结果分析与调优</h1><p>关于性能分析与调优这是一个比较大的话题，后续会单独进行总结和分析。</p>\n<h1 id=\"测试报告与总结\"><a href=\"#测试报告与总结\" class=\"headerlink\" title=\"测试报告与总结\"></a>测试报告与总结</h1><ol>\n<li><p>性能测试报告是性能测试的里程碑，通过报告能展示出性能测试的最终成果，展示系统性能是否符合需求，是否有性能隐患。性能测试报告中需要阐明性能测试目标、性能测试环境、性能测试数据构造规则、性能测试策略、性能测试结果、性能测试调优说明、性能测试过程中遇到的问题和解决办法等。</p>\n</li>\n<li><p>性能测试工程师完成该次性能测试后，需要将测试结果进行备案，并做为下次性能测试的基线标准，具体包括性能测试结果数据、性能测试瓶颈和调优方案等。同时需要将测试过程中遇到的问题，包括代码瓶颈、配置项问题、数据问题和沟通问题，以及解决办法或解决方案，进行知识沉淀。</p>\n</li>\n</ol>\n","slug":"性能测试总结-测试流程","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/08/10/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93-%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/","excerpt":"本文主要介绍下性能测试的基本流程，性能测试从实际执行层面来看，测试的过程一般分为这么几个阶段，如下图：","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"性能测试总结-测试工具","date":"2019-08-09T12:54:54.000Z","path":"2019/08/09/性能测试总结-测试工具/","text":"本篇文章主要简单总结下性能测试工具的原理以及如何选型。性能测试和功能测试不同，性能测试的执行是基本功能的重复和并发，需要模拟多用户，在性能测试执行时需要监控指标参数，同时性能测试的结果不是那么显而易见，需要对数据进行分析。这些特点决定了性能测试更适合通过工具来完成。 浅谈为什么需要工具我们来看下工具的定义：它原指工作时所需用的器具，后引申为为达到、完成或促进某一事物的手段。（—来自百度的解释） 从人类进化的角度来看，会制造并使用工具是人和猿人最根本的区别，因为工具可以帮助我们提高生产力和效率。 想象下如果不使用工具进行性能测试会怎么样？ 我们可以从性能测试的定义的角度来分析，性能测试是指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。如果不使用工具，仅靠人工进行性能测试会存在以下的弊端： 测试需要投入大量的资源为了模拟多种负载、并发的场景需要多人协同工作，通常测试没有很多的资源，而且就算有资源人工的效果也会大打折扣，甚至于某些场景仅凭人工是无法完成的。 可重复性非常差性能测试经常需要反复调优和测试执行，如果没有工具的帮助，全靠人工实在不敢想象。 测试准确性较差由于需要模拟多种负载和并发场景，如果由人工来操作，难免会存在误差，而且相对工具或程序来说这种误差会更大，对测试结果影响也非常大。 结果的收集、整理和呈现形式差如果没有工具，全凭人工采集数据相对工具来说也会存在较大的误差。 性能测试与性能测试工具的关系 性能测试从测试阶段来划分属于系统测试，其和具体使用什么工具并没有直接的关系。使用工具只是为了提高性能测试效率和准确性的一种方法和手段。从本质上来看，同做其它事情时使用工具没有什么实质性的区别。 性能测试不等于Loadrunner，LR只是性能测试工具其中的一种，而且它也不是万能的，在某些情况下它也并不能派上用场。推荐看下《让LoadRunner走下神坛》和《让LoadRunner再次走下神坛》这两篇文章于对性能测试和LR的关系讲的比较深刻。 自动化测试工具与性能测试工具的区别：性能测试工具一般是基于通信协议的（客户器与服务器交换信息所遵守的约定），它可以不关心系统的UI，而自动化使用的是对象识别技术，关注UI界面。自动化无法或很难造成负载，但是通过协议很容易。 性能测试工具选型参考通常在公司或项目中，我们选择任何工具时都会做一些调研，目的就是为了选择适合公司或项目的工具。那么性能测试工具也不例外，通常可以从以下几个方面进行考虑： 成本方面 工具成本：工具通常分为商业闭(shou)源(fei)和非商业开(mian)源(fei)两种，商业工具通常功能比较强大，收费，由于收费所以可提供售后服务，如果出了问题有专业人士帮忙处理。而开源工具通常是免费的，功能有限，维护工具的组织也是自发的，所以如果碰到问题需要自行解决，没有专人提供服务。具体选择商业还是开源的工具，需要根据公司的情况，比如公司规模、愿意承担的成本、项目综合情况等方面考虑。一般来看大公司通常可以承担的起工具的费用，会考虑购买商业工具。而小公司由于资金压力，可能会选择开源的工具。 学习成本：使用任何工具都需要进行学习，这样一来就会产生学习成本（比如：时间），因此我们在选择工具时也需要考虑到项目组成员的学习成本。如果有两种工具A和B都能满足项目组测试的需求，如果A工具大部分人都会使用，而B工具只有极少部分人会使用，那么建议优先考虑A工具。通常，对于测试人员最好熟悉一款流程的商业（性能）工具，一款开源免费（性能）工具，还需要熟悉常见的（性能）脚本开发语言等，这是基本要求。 支持的协议性能测试通常跟协议联系非常紧密，比如B&#x2F;S的系统通常使用http协议进行客户端和服务器商的信息交换，C&#x2F;S的系统通常使用socket协议进行信息交换。在选择工具时，需要考虑项目使用的协议。一个测试工具能否满足测试需求，能否达到令人满意的测试结果，是选择测试工具要考虑的最基本的问题。 生命力现在的性能测试工具非常多，比如LR，jmeter这类较大众的工具网上相关的资料非常多，但一些小众工具可能网上资料比较少。如果在工具使用过程中碰到了比较极手的问题，在录求解决方案或帮助时，大众的的工具相对来说会比较有优势一点，毕竟使用的人越多，资料越多，那么自己碰到的问题也许别人早就碰到并解决了，即时之前没有人碰到过，由于使用研究的人多，通过社区或论坛的帮助相信总会有高手能协助解决的。 跨平台这一点自不必多说，看看JAVA为什么一直这流行就知道了。 常见性能测试工具性能测试工具，从理论上来讲在性能测试过程中使用到的所有工具都可以称其为性能测试工具，通常分为以下几类： 说明： 服务器端性能测试工具：需要支持产生压力和负载，录制和生成脚本，设置和部署场景，产生并发用户和向系统施加持续的压力。 web前端性能测试工具：需要关于心浏览器等客户端工具对具体需要展现的页面的处理过程。 移动端性能测试工具：同web端性能测试工具也需要关心页面的处理过程，另外还要具体数据采集的功能，比如：手机CPU、内存、电量，启动时间等数据的记录。 资源监控工具：这个主要是能够收集性能测试过程中的数据以及良好的结果展现方式。 常见性能测试工具特点 JMeter采用的是多线程模型，扩展性很强，不过制造压力没有那么高。它很适合用来压一些Tomcat服务，或者一些后端接口。JMeter的缺点是压力值不能精确控制，难以适应高并发的情况，而且由于是JAVA编写的，本身比较消耗资源。 LoadRunner更像是一个模拟器，它比较适用于前端构造较复杂场景的情况，比如模拟100个用户登录的场景，LoadRunner对非技术人员提供了很好的支持。LoadRunner不适用后端接口。下表为JMeter和LoadRunner对比表： 描述 JMeter LoadRunner 架构原理 通过中间代理，监控和收集并发客户端的指令，把他们生成脚本，再发送的应用服务器，再监控应用服务器反馈的过程 同JMeter 安装 简单，解压即可，比较灵活 LoadRunner安装包比较大，安装比较麻烦，工具本身相对比较笨重 支持的协议 支持多种协议：HTTP、HTTPS、SOAP、FTP、Database via JDBC、JMS等，但相对LR还是不够全面，由于此原因相对来说jemter比较灵活，轻便 支持的协议非常多，比较全面，但正因此显得工具本身比较笨重，不够灵活 脚本录制 提供了一个利用本地ProxyServer（代理服务器）来录制生成测试脚本的功能，也支持badboy录制再生成JMeter脚本 自带录制功能强大，可直接录制回放 并发模型 通过增加线程组的数目，或者是设置循环次数来增加并发用户 支持多种并发模型，通过在场景中选择要设置什么样的场景，然后选择虚拟用户数 分布式测试 支持，可设置多台代理，通过远程控制实现多台机器并发压力 同JMeter 资源监控 通过JMeterPlugins插件和ServerAgent实现 自带资源监控功能 报告分析 通过与Ant集成，生成HTML报告 自身支持生成HTML、Word报告 虚拟IP 不支持 支持 网速模拟 不支持 支持 扩展性 开源，可根据需求修改源码 通过扩展函数库实现 学习成本 主要是自学官网上的资料 网上资料和相关培训很多，购买正版的话，还有技术支持 性能测试工具学习教程：https://testerhome.com/columns/Gatling http://liuxiang.github.io/2018/04/05/gatling(%E5%8E%8B%E6%B5%8B)%20%E4%BD%93%E9%AA%8C/ https://testerhome.com/topics/16375","raw":"---\ntitle: 性能测试总结-测试工具\ntoc: true\ndate: 2019-08-09 20:54:54\ntags: [性能测试]\ncategories: [测试]\ndescription:\n---\n本篇文章主要简单总结下性能测试工具的原理以及如何选型。性能测试和功能测试不同，性能测试的执行是基本功能的重复和并发，需要模拟多用户，在性能测试执行时需要监控指标参数，同时性能测试的结果不是那么显而易见，需要对数据进行分析。这些特点决定了性能测试更适合通过工具来完成。\n\n <!--more-->\n\n# 浅谈为什么需要工具\n我们来看下工具的定义：它原指工作时所需用的器具，后引申为为达到、完成或促进某一事物的手段。（---来自百度的解释） \n\n1. 从人类进化的角度来看，会制造并使用工具是人和猿人最根本的区别，因为工具可以帮助我们提高生产力和效率。\n2. 想象下如果不使用工具进行性能测试会怎么样？\n\n我们可以从性能测试的定义的角度来分析，性能测试是指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。如果不使用工具，仅靠人工进行性能测试会存在以下的弊端：\n\n1. 测试需要投入大量的资源\n   为了模拟多种负载、并发的场景需要多人协同工作，通常测试没有很多的资源，而且就算有资源人工的效果也会大打折扣，甚至于某些场景仅凭人工是无法完成的。\n2. 可重复性非常差\n   性能测试经常需要反复调优和测试执行，如果没有工具的帮助，全靠人工实在不敢想象。\n3. 测试准确性较差\n   由于需要模拟多种负载和并发场景，如果由人工来操作，难免会存在误差，而且相对工具或程序来说这种误差会更大，对测试结果影响也非常大。\n4. 结果的收集、整理和呈现形式差\n   如果没有工具，全凭人工采集数据相对工具来说也会存在较大的误差。\n\n# 性能测试与性能测试工具的关系\n1. 性能测试从测试阶段来划分属于系统测试，其和具体使用什么工具并没有直接的关系。使用工具只是为了提高性能测试效率和准确性的一种方法和手段。从本质上来看，同做其它事情时使用工具没有什么实质性的区别。\n\n2. 性能测试不等于Loadrunner，LR只是性能测试工具其中的一种，而且它也不是万能的，在某些情况下它也并不能派上用场。推荐看下《让LoadRunner走下神坛》和《让LoadRunner再次走下神坛》这两篇文章于对性能测试和LR的关系讲的比较深刻。\n\n3. 自动化测试工具与性能测试工具的区别：性能测试工具一般是基于通信协议的（客户器与服务器交换信息所遵守的约定），它可以不关心系统的UI，而自动化使用的是对象识别技术，关注UI界面。自动化无法或很难造成负载，但是通过协议很容易。\n\n# 性能测试工具选型参考\n\n通常在公司或项目中，我们选择任何工具时都会做一些调研，目的就是为了选择适合公司或项目的工具。那么性能测试工具也不例外，通常可以从以下几个方面进行考虑：\n1. 成本方面\n   - 工具成本：工具通常分为商业闭(shou)源(fei)和非商业开(mian)源(fei)两种，商业工具通常功能比较强大，收费，由于收费所以可提供售后服务，如果出了问题有专业人士帮忙处理。而开源工具通常是免费的，功能有限，维护工具的组织也是自发的，所以如果碰到问题需要自行解决，没有专人提供服务。具体选择商业还是开源的工具，需要根据公司的情况，比如公司规模、愿意承担的成本、项目综合情况等方面考虑。一般来看大公司通常可以承担的起工具的费用，会考虑购买商业工具。而小公司由于资金压力，可能会选择开源的工具。\n   - 学习成本：使用任何工具都需要进行学习，这样一来就会产生学习成本（比如：时间），因此我们在选择工具时也需要考虑到项目组成员的学习成本。如果有两种工具A和B都能满足项目组测试的需求，如果A工具大部分人都会使用，而B工具只有极少部分人会使用，那么建议优先考虑A工具。通常，对于测试人员最好熟悉一款流程的商业（性能）工具，一款开源免费（性能）工具，还需要熟悉常见的（性能）脚本开发语言等，这是基本要求。\n2. 支持的协议\n   性能测试通常跟协议联系非常紧密，比如B/S的系统通常使用http协议进行客户端和服务器商的信息交换，C/S的系统通常使用socket协议进行信息交换。在选择工具时，需要考虑项目使用的协议。一个测试工具能否满足测试需求，能否达到令人满意的测试结果，是选择测试工具要考虑的最基本的问题。\n3. 生命力\n   现在的性能测试工具非常多，比如LR，jmeter这类较大众的工具网上相关的资料非常多，但一些小众工具可能网上资料比较少。如果在工具使用过程中碰到了比较极手的问题，在录求解决方案或帮助时，大众的的工具相对来说会比较有优势一点，毕竟使用的人越多，资料越多，那么自己碰到的问题也许别人早就碰到并解决了，即时之前没有人碰到过，由于使用研究的人多，通过社区或论坛的帮助相信总会有高手能协助解决的。\n4. 跨平台\n   这一点自不必多说，看看JAVA为什么一直这流行就知道了。\n\n# 常见性能测试工具\n性能测试工具，从理论上来讲在性能测试过程中使用到的所有工具都可以称其为性能测试工具，通常分为以下几类：\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fynqm20zwbj30zg0oo0w5.jpg)\n\n说明：\n\n- 服务器端性能测试工具：需要支持产生压力和负载，录制和生成脚本，设置和部署场景，产生并发用户和向系统施加持续的压力。\n- web前端性能测试工具：需要关于心浏览器等客户端工具对具体需要展现的页面的处理过程。\n- 移动端性能测试工具：同web端性能测试工具也需要关心页面的处理过程，另外还要具体数据采集的功能，比如：手机CPU、内存、电量，启动时间等数据的记录。\n- 资源监控工具：这个主要是能够收集性能测试过程中的数据以及良好的结果展现方式。\n\n# 常见性能测试工具特点\n\n1. JMeter\n   采用的是多线程模型，扩展性很强，不过制造压力没有那么高。它很适合用来压一些Tomcat服务，或者一些后端接口。JMeter的缺点是压力值不能精确控制，难以适应高并发的情况，而且由于是JAVA编写的，本身比较消耗资源。\n2. LoadRunner\n   更像是一个模拟器，它比较适用于前端构造较复杂场景的情况，比如模拟100个用户登录的场景，LoadRunner对非技术人员提供了很好的支持。LoadRunner不适用后端接口。\n下表为JMeter和LoadRunner对比表：\n\n| 描述|JMeter|LoadRunner\n| ------ | ------ | ------ |\n|架构原理|通过中间代理，监控和收集并发客户端的指令，把他们生成脚本，再发送的应用服务器，再监控应用服务器反馈的过程|同JMeter\n|安装|简单，解压即可，比较灵活|LoadRunner安装包比较大，安装比较麻烦，工具本身相对比较笨重\n|支持的协议|支持多种协议：HTTP、HTTPS、SOAP、FTP、Database via JDBC、JMS等，但相对LR还是不够全面，由于此原因相对来说jemter比较灵活，轻便|支持的协议非常多，比较全面，但正因此显得工具本身比较笨重，不够灵活\n|脚本录制|提供了一个利用本地ProxyServer（代理服务器）来录制生成测试脚本的功能，也支持badboy录制再生成JMeter脚本|自带录制功能强大，可直接录制回放\n|并发模型|通过增加线程组的数目，或者是设置循环次数来增加并发用户|支持多种并发模型，通过在场景中选择要设置什么样的场景，然后选择虚拟用户数\n|分布式测试|支持，可设置多台代理，通过远程控制实现多台机器并发压力|同JMeter\n|资源监控|通过JMeterPlugins插件和ServerAgent实现|自带资源监控功能\n|报告分析|通过与Ant集成，生成HTML报告|自身支持生成HTML、Word报告\n|虚拟IP|不支持|支持\n|网速模拟|不支持|支持\n|扩展性|开源，可根据需求修改源码|通过扩展函数库实现\n|学习成本|主要是自学官网上的资料|网上资料和相关培训很多，购买正版的话，还有技术支持\n \n\n# 性能测试工具学习教程：\nhttps://testerhome.com/columns/Gatling\n\nhttp://liuxiang.github.io/2018/04/05/gatling(%E5%8E%8B%E6%B5%8B)%20%E4%BD%93%E9%AA%8C/\n\nhttps://testerhome.com/topics/16375","content":"<p>本篇文章主要简单总结下性能测试工具的原理以及如何选型。性能测试和功能测试不同，性能测试的执行是基本功能的重复和并发，需要模拟多用户，在性能测试执行时需要监控指标参数，同时性能测试的结果不是那么显而易见，需要对数据进行分析。这些特点决定了性能测试更适合通过工具来完成。</p>\n <span id=\"more\"></span>\n\n<h1 id=\"浅谈为什么需要工具\"><a href=\"#浅谈为什么需要工具\" class=\"headerlink\" title=\"浅谈为什么需要工具\"></a>浅谈为什么需要工具</h1><p>我们来看下工具的定义：它原指工作时所需用的器具，后引申为为达到、完成或促进某一事物的手段。（—来自百度的解释） </p>\n<ol>\n<li>从人类进化的角度来看，会制造并使用工具是人和猿人最根本的区别，因为工具可以帮助我们提高生产力和效率。</li>\n<li>想象下如果不使用工具进行性能测试会怎么样？</li>\n</ol>\n<p>我们可以从性能测试的定义的角度来分析，性能测试是指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。如果不使用工具，仅靠人工进行性能测试会存在以下的弊端：</p>\n<ol>\n<li>测试需要投入大量的资源<br>为了模拟多种负载、并发的场景需要多人协同工作，通常测试没有很多的资源，而且就算有资源人工的效果也会大打折扣，甚至于某些场景仅凭人工是无法完成的。</li>\n<li>可重复性非常差<br>性能测试经常需要反复调优和测试执行，如果没有工具的帮助，全靠人工实在不敢想象。</li>\n<li>测试准确性较差<br>由于需要模拟多种负载和并发场景，如果由人工来操作，难免会存在误差，而且相对工具或程序来说这种误差会更大，对测试结果影响也非常大。</li>\n<li>结果的收集、整理和呈现形式差<br>如果没有工具，全凭人工采集数据相对工具来说也会存在较大的误差。</li>\n</ol>\n<h1 id=\"性能测试与性能测试工具的关系\"><a href=\"#性能测试与性能测试工具的关系\" class=\"headerlink\" title=\"性能测试与性能测试工具的关系\"></a>性能测试与性能测试工具的关系</h1><ol>\n<li><p>性能测试从测试阶段来划分属于系统测试，其和具体使用什么工具并没有直接的关系。使用工具只是为了提高性能测试效率和准确性的一种方法和手段。从本质上来看，同做其它事情时使用工具没有什么实质性的区别。</p>\n</li>\n<li><p>性能测试不等于Loadrunner，LR只是性能测试工具其中的一种，而且它也不是万能的，在某些情况下它也并不能派上用场。推荐看下《让LoadRunner走下神坛》和《让LoadRunner再次走下神坛》这两篇文章于对性能测试和LR的关系讲的比较深刻。</p>\n</li>\n<li><p>自动化测试工具与性能测试工具的区别：性能测试工具一般是基于通信协议的（客户器与服务器交换信息所遵守的约定），它可以不关心系统的UI，而自动化使用的是对象识别技术，关注UI界面。自动化无法或很难造成负载，但是通过协议很容易。</p>\n</li>\n</ol>\n<h1 id=\"性能测试工具选型参考\"><a href=\"#性能测试工具选型参考\" class=\"headerlink\" title=\"性能测试工具选型参考\"></a>性能测试工具选型参考</h1><p>通常在公司或项目中，我们选择任何工具时都会做一些调研，目的就是为了选择适合公司或项目的工具。那么性能测试工具也不例外，通常可以从以下几个方面进行考虑：</p>\n<ol>\n<li>成本方面<ul>\n<li>工具成本：工具通常分为商业闭(shou)源(fei)和非商业开(mian)源(fei)两种，商业工具通常功能比较强大，收费，由于收费所以可提供售后服务，如果出了问题有专业人士帮忙处理。而开源工具通常是免费的，功能有限，维护工具的组织也是自发的，所以如果碰到问题需要自行解决，没有专人提供服务。具体选择商业还是开源的工具，需要根据公司的情况，比如公司规模、愿意承担的成本、项目综合情况等方面考虑。一般来看大公司通常可以承担的起工具的费用，会考虑购买商业工具。而小公司由于资金压力，可能会选择开源的工具。</li>\n<li>学习成本：使用任何工具都需要进行学习，这样一来就会产生学习成本（比如：时间），因此我们在选择工具时也需要考虑到项目组成员的学习成本。如果有两种工具A和B都能满足项目组测试的需求，如果A工具大部分人都会使用，而B工具只有极少部分人会使用，那么建议优先考虑A工具。通常，对于测试人员最好熟悉一款流程的商业（性能）工具，一款开源免费（性能）工具，还需要熟悉常见的（性能）脚本开发语言等，这是基本要求。</li>\n</ul>\n</li>\n<li>支持的协议<br>性能测试通常跟协议联系非常紧密，比如B&#x2F;S的系统通常使用http协议进行客户端和服务器商的信息交换，C&#x2F;S的系统通常使用socket协议进行信息交换。在选择工具时，需要考虑项目使用的协议。一个测试工具能否满足测试需求，能否达到令人满意的测试结果，是选择测试工具要考虑的最基本的问题。</li>\n<li>生命力<br>现在的性能测试工具非常多，比如LR，jmeter这类较大众的工具网上相关的资料非常多，但一些小众工具可能网上资料比较少。如果在工具使用过程中碰到了比较极手的问题，在录求解决方案或帮助时，大众的的工具相对来说会比较有优势一点，毕竟使用的人越多，资料越多，那么自己碰到的问题也许别人早就碰到并解决了，即时之前没有人碰到过，由于使用研究的人多，通过社区或论坛的帮助相信总会有高手能协助解决的。</li>\n<li>跨平台<br>这一点自不必多说，看看JAVA为什么一直这流行就知道了。</li>\n</ol>\n<h1 id=\"常见性能测试工具\"><a href=\"#常见性能测试工具\" class=\"headerlink\" title=\"常见性能测试工具\"></a>常见性能测试工具</h1><p>性能测试工具，从理论上来讲在性能测试过程中使用到的所有工具都可以称其为性能测试工具，通常分为以下几类：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fynqm20zwbj30zg0oo0w5.jpg\"></p>\n<p>说明：</p>\n<ul>\n<li>服务器端性能测试工具：需要支持产生压力和负载，录制和生成脚本，设置和部署场景，产生并发用户和向系统施加持续的压力。</li>\n<li>web前端性能测试工具：需要关于心浏览器等客户端工具对具体需要展现的页面的处理过程。</li>\n<li>移动端性能测试工具：同web端性能测试工具也需要关心页面的处理过程，另外还要具体数据采集的功能，比如：手机CPU、内存、电量，启动时间等数据的记录。</li>\n<li>资源监控工具：这个主要是能够收集性能测试过程中的数据以及良好的结果展现方式。</li>\n</ul>\n<h1 id=\"常见性能测试工具特点\"><a href=\"#常见性能测试工具特点\" class=\"headerlink\" title=\"常见性能测试工具特点\"></a>常见性能测试工具特点</h1><ol>\n<li>JMeter<br>采用的是多线程模型，扩展性很强，不过制造压力没有那么高。它很适合用来压一些Tomcat服务，或者一些后端接口。JMeter的缺点是压力值不能精确控制，难以适应高并发的情况，而且由于是JAVA编写的，本身比较消耗资源。</li>\n<li>LoadRunner<br>更像是一个模拟器，它比较适用于前端构造较复杂场景的情况，比如模拟100个用户登录的场景，LoadRunner对非技术人员提供了很好的支持。LoadRunner不适用后端接口。<br>下表为JMeter和LoadRunner对比表：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>JMeter</th>\n<th>LoadRunner</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>架构原理</td>\n<td>通过中间代理，监控和收集并发客户端的指令，把他们生成脚本，再发送的应用服务器，再监控应用服务器反馈的过程</td>\n<td>同JMeter</td>\n</tr>\n<tr>\n<td>安装</td>\n<td>简单，解压即可，比较灵活</td>\n<td>LoadRunner安装包比较大，安装比较麻烦，工具本身相对比较笨重</td>\n</tr>\n<tr>\n<td>支持的协议</td>\n<td>支持多种协议：HTTP、HTTPS、SOAP、FTP、Database via JDBC、JMS等，但相对LR还是不够全面，由于此原因相对来说jemter比较灵活，轻便</td>\n<td>支持的协议非常多，比较全面，但正因此显得工具本身比较笨重，不够灵活</td>\n</tr>\n<tr>\n<td>脚本录制</td>\n<td>提供了一个利用本地ProxyServer（代理服务器）来录制生成测试脚本的功能，也支持badboy录制再生成JMeter脚本</td>\n<td>自带录制功能强大，可直接录制回放</td>\n</tr>\n<tr>\n<td>并发模型</td>\n<td>通过增加线程组的数目，或者是设置循环次数来增加并发用户</td>\n<td>支持多种并发模型，通过在场景中选择要设置什么样的场景，然后选择虚拟用户数</td>\n</tr>\n<tr>\n<td>分布式测试</td>\n<td>支持，可设置多台代理，通过远程控制实现多台机器并发压力</td>\n<td>同JMeter</td>\n</tr>\n<tr>\n<td>资源监控</td>\n<td>通过JMeterPlugins插件和ServerAgent实现</td>\n<td>自带资源监控功能</td>\n</tr>\n<tr>\n<td>报告分析</td>\n<td>通过与Ant集成，生成HTML报告</td>\n<td>自身支持生成HTML、Word报告</td>\n</tr>\n<tr>\n<td>虚拟IP</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>网速模拟</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>扩展性</td>\n<td>开源，可根据需求修改源码</td>\n<td>通过扩展函数库实现</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>主要是自学官网上的资料</td>\n<td>网上资料和相关培训很多，购买正版的话，还有技术支持</td>\n</tr>\n</tbody></table>\n<h1 id=\"性能测试工具学习教程：\"><a href=\"#性能测试工具学习教程：\" class=\"headerlink\" title=\"性能测试工具学习教程：\"></a>性能测试工具学习教程：</h1><p><a href=\"https://testerhome.com/columns/Gatling\">https://testerhome.com/columns/Gatling</a></p>\n<p><a href=\"http://liuxiang.github.io/2018/04/05/gatling(%E5%8E%8B%E6%B5%8B)%20%E4%BD%93%E9%AA%8C/\">http://liuxiang.github.io/2018/04/05/gatling(%E5%8E%8B%E6%B5%8B)%20%E4%BD%93%E9%AA%8C/</a></p>\n<p><a href=\"https://testerhome.com/topics/16375\">https://testerhome.com/topics/16375</a></p>\n","slug":"性能测试总结-测试工具","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/08/09/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/","excerpt":"本篇文章主要简单总结下性能测试工具的原理以及如何选型。性能测试和功能测试不同，性能测试的执行是基本功能的重复和并发，需要模拟多用户，在性能测试执行时需要监控指标参数，同时性能测试的结果不是那么显而易见，需要对数据进行分析。这些特点决定了性能测试更适合通过工具来完成。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"性能测试总结-如何做","date":"2019-08-09T06:08:47.000Z","path":"2019/08/09/性能测试总结-如何做/","text":"转载自：https://coolshell.cn/articles/17381.html偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。首先，这份测试报告里的主要问题如下： 用的全是平均值。老实说，平均值是非常不靠谱的。 响应时间没有和吞吐量TPS&#x2F;QPS挂钩。而只是测试了低速率的情况，这是完全错误的。 响应时间和吞吐量没有和成功率挂钩。 为什么平均值不靠谱关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，平均工资，平均房价，平均支出，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力） 软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《Why Averages Suck and Percentiles are Great》，我在这里简单说一下。 我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。 另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。 当然，最为正确的统计做法是用百分比分布统计。也就是英文中的TP – Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。 比如：我们有一组数据：[ 10ms, 1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(40.5)&#x3D;2时间是小于100ms的，TP90就是90%的请求ceil(40.9)&#x3D;4时间小于1s。于是：TP50就是100ms，TP90就是1s。 我以前在路透做的金融系统响应时间的性能测试的要求是这样的，99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。 为什么响应时间（latency）要和吞吐量（Thoughput）挂钩系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。 我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。 所以，吞吐量的值必需有响应时间来卡。比如：TP99小于100ms的时候，系统可以承载的最大并发数是1000qps。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。 为什么响应时间吞吐量和成功率要挂钩我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是40%，那么，这10万的并发完全就是一个笑话了。 性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。 如何严谨地做性能测试一般来说，性能测试要统一考虑这么几个因素：Thoughput吞吐量，Latency响应时间，资源利用（CPU&#x2F;MEM&#x2F;IO&#x2F;Bandwidth…），成功率，系统稳定性。 下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。 你得定义一个系统的响应时间latency，建议是TP99，以及成功率。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。 在这个响应时间的限制下，找到最高的吞吐量。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。 在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。然后收集CPU，内存，硬盘&#x2F;网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能 找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。 做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。收集系统数据：CPU、内存、硬盘&#x2F;网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。 低吞吐量和网络小包的测试。有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。","raw":"---\ntitle: 性能测试总结-如何做\ntoc: true\ndate: 2019-08-09 14:08:47\ntags: [性能测试]\ncategories: [测试]\ndescription:\n---\n转载自：https://coolshell.cn/articles/17381.html\n偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。\n首先，这份测试报告里的主要问题如下：\n1. 用的全是平均值。老实说，平均值是非常不靠谱的。\n2. 响应时间没有和吞吐量TPS/QPS挂钩。而只是测试了低速率的情况，这是完全错误的。\n3. 响应时间和吞吐量没有和成功率挂钩。\n\n<!--more-->\n\n# 为什么平均值不靠谱\n关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，平均工资，平均房价，平均支出，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）\n\n软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章[《Why Averages Suck and Percentiles are Great》](http://apmblog.dynatrace.com/2012/11/14/why-averages-suck-and-percentiles-are-great/)，我在这里简单说一下。\n\n我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。\n\n另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。\n\n当然，最为正确的统计做法是用百分比分布统计。也就是英文中的TP – Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。\n\n比如：我们有一组数据：[ 10ms,  1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4*0.5)=2时间是小于100ms的，TP90就是90%的请求ceil(4*0.9)=4时间小于1s。于是：TP50就是100ms，TP90就是1s。\n\n我以前在路透做的金融系统响应时间的性能测试的要求是这样的，99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。\n\n# 为什么响应时间（latency）要和吞吐量（Thoughput）挂钩\n系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。\n\n我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fynqbe4rnij30ev09jjsf.jpg)\n\n所以，吞吐量的值必需有响应时间来卡。比如：TP99小于100ms的时候，系统可以承载的最大并发数是1000qps。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。\n\n\n# 为什么响应时间吞吐量和成功率要挂钩\n我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是40%，那么，这10万的并发完全就是一个笑话了。\n\n性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。\n\n# 如何严谨地做性能测试\n一般来说，性能测试要统一考虑这么几个因素：Thoughput吞吐量，Latency响应时间，资源利用（CPU/MEM/IO/Bandwidth…），成功率，系统稳定性。\n\n下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。\n\n1. 你得定义一个系统的响应时间latency，建议是TP99，以及成功率。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。\n2. 在这个响应时间的限制下，找到最高的吞吐量。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。\n3. 在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能\n4. 找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。\n   \n5. 做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。\n6. 低吞吐量和网络小包的测试。有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。\n（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）\n是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。\n","content":"<p>转载自：<a href=\"https://coolshell.cn/articles/17381.html\">https://coolshell.cn/articles/17381.html</a><br>偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。<br>首先，这份测试报告里的主要问题如下：</p>\n<ol>\n<li>用的全是平均值。老实说，平均值是非常不靠谱的。</li>\n<li>响应时间没有和吞吐量TPS&#x2F;QPS挂钩。而只是测试了低速率的情况，这是完全错误的。</li>\n<li>响应时间和吞吐量没有和成功率挂钩。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h1 id=\"为什么平均值不靠谱\"><a href=\"#为什么平均值不靠谱\" class=\"headerlink\" title=\"为什么平均值不靠谱\"></a>为什么平均值不靠谱</h1><p>关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，平均工资，平均房价，平均支出，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）</p>\n<p>软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章<a href=\"http://apmblog.dynatrace.com/2012/11/14/why-averages-suck-and-percentiles-are-great/\">《Why Averages Suck and Percentiles are Great》</a>，我在这里简单说一下。</p>\n<p>我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。</p>\n<p>另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。</p>\n<p>当然，最为正确的统计做法是用百分比分布统计。也就是英文中的TP – Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。</p>\n<p>比如：我们有一组数据：[ 10ms,  1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4<em>0.5)&#x3D;2时间是小于100ms的，TP90就是90%的请求ceil(4</em>0.9)&#x3D;4时间小于1s。于是：TP50就是100ms，TP90就是1s。</p>\n<p>我以前在路透做的金融系统响应时间的性能测试的要求是这样的，99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。</p>\n<h1 id=\"为什么响应时间（latency）要和吞吐量（Thoughput）挂钩\"><a href=\"#为什么响应时间（latency）要和吞吐量（Thoughput）挂钩\" class=\"headerlink\" title=\"为什么响应时间（latency）要和吞吐量（Thoughput）挂钩\"></a>为什么响应时间（latency）要和吞吐量（Thoughput）挂钩</h1><p>系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。</p>\n<p>我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fynqbe4rnij30ev09jjsf.jpg\"></p>\n<p>所以，吞吐量的值必需有响应时间来卡。比如：TP99小于100ms的时候，系统可以承载的最大并发数是1000qps。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。</p>\n<h1 id=\"为什么响应时间吞吐量和成功率要挂钩\"><a href=\"#为什么响应时间吞吐量和成功率要挂钩\" class=\"headerlink\" title=\"为什么响应时间吞吐量和成功率要挂钩\"></a>为什么响应时间吞吐量和成功率要挂钩</h1><p>我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是40%，那么，这10万的并发完全就是一个笑话了。</p>\n<p>性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。</p>\n<h1 id=\"如何严谨地做性能测试\"><a href=\"#如何严谨地做性能测试\" class=\"headerlink\" title=\"如何严谨地做性能测试\"></a>如何严谨地做性能测试</h1><p>一般来说，性能测试要统一考虑这么几个因素：Thoughput吞吐量，Latency响应时间，资源利用（CPU&#x2F;MEM&#x2F;IO&#x2F;Bandwidth…），成功率，系统稳定性。</p>\n<p>下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。</p>\n<ol>\n<li><p>你得定义一个系统的响应时间latency，建议是TP99，以及成功率。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。</p>\n</li>\n<li><p>在这个响应时间的限制下，找到最高的吞吐量。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。</p>\n</li>\n<li><p>在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。然后收集CPU，内存，硬盘&#x2F;网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能</p>\n</li>\n<li><p>找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。</p>\n</li>\n<li><p>做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。收集系统数据：CPU、内存、硬盘&#x2F;网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。</p>\n</li>\n<li><p>低吞吐量和网络小包的测试。有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。<br>（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）<br>是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。</p>\n</li>\n</ol>\n","slug":"性能测试总结-如何做","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/08/09/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93-%E5%A6%82%E4%BD%95%E5%81%9A/","excerpt":"转载自：https://coolshell.cn/articles/17381.html偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。首先，这份测试报告里的主要问题如下： 用的全是平均值。老实说，平均值是非常不靠谱的。 响应时间没有和吞吐量TPS&#x2F;QPS挂钩。而只是测试了低速率的情况，这是完全错误的。 响应时间和吞吐量没有和成功率挂钩。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"性能测试基础--指标理解","date":"2019-08-08T11:08:42.000Z","path":"2019/08/08/性能测试基础--指标/","text":"性能测试中会涉及到许多性能指标，在本文中进行了总结。目前只有QPS和TPS两个指标。 基本概念QPSQueries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 TPS是Transactions Per Second的缩写，也就是事务数&#x2F;秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体TPS得分。 QPS（TPS）&#x3D; 并发数&#x2F;平均响应时间 或者 并发数 &#x3D; QPS * 平均响应时间 (这里响应时间的单位是秒) 举例，我们一个HTTP请求的响应时间是20ms，在10个并发的情况下，QPS就是10*1000&#x2F;20&#x3D;500。 这里有个关键的点就是QPS一定是跟并发数联系在一起的，离开并发数谈QPS是没意义的。QPS、TPS和性能的关系 一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。 从上图可以看出，开始，系统只有一个用户，CPU工作肯定是不饱合的。一方面该服务器可能有多个cpu，但是只处理单个进程，另一方面，在处理一个进程中，有些阶段可能是IO阶段，这个时候会造成CPU等待，但是又没有其他请求进程可以被处理。 随着并发用户数的增加，CPU利用率上升，QPS相应也增加（公式为QPS&#x3D;并发用户数&#x2F;平均响应时间。） 随着并发用户数的增加，平均响应时间也在增加，而且平均响应时间的增加是一个指数增加曲线。 而当并发数增加到很大时，每秒钟都会有很多请求需要处理，会造成进程（线程）频繁切换，反而真正用于处理请求的时间变少，每秒能够处理的请求数反而变少，同时用户的请求等待时间也会变大，甚至超过用户的心理底线。 我们对单台服务器进行压测有了性能测试数据以后，可以根据业务上能接受最大客户响应时间对应到相应的QPS数，从而计算出需要的服务器的数量。 举例来说，响应时间10ms和1000ms对通过浏览器的客户是没有明显体验差别的，基于1000ms估算服务器的数量我们的成本会降低很多。 每天300wPV的在单台机器上，这台机器需要多少QPS？对于这样的问题，假设每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。 (3000000 x 0.8) &#x2F; (3600 x 24 x 0.2) &#x3D; 139 (QPS). 还是上面的数据，如果一台机器的QPS是58，需要几台机器来支持？答：139 &#x2F; 58 &#x3D; 3","raw":"---\ntitle: 性能测试基础--指标理解\ntoc: true\ndate: 2019-08-08 19:08:42\ntags: [QPS,TPS,性能测试]\ncategories: [测试]\ndescription:\n---\n性能测试中会涉及到许多性能指标，在本文中进行了总结。目前只有QPS和TPS两个指标。\n<!--more-->\n## 基本概念\n\n### QPS\nQueries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。\n\n### TPS\n是Transactions Per Second的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体TPS得分。\n\nQPS（TPS）= 并发数/平均响应时间 或者 并发数 = QPS * 平均响应时间 (这里响应时间的单位是秒)\n\n举例，我们一个HTTP请求的响应时间是20ms，在10个并发的情况下，QPS就是10*1000/20=500。\n\n这里有个关键的点就是QPS一定是跟并发数联系在一起的，离开并发数谈QPS是没意义的。\nQPS、TPS和性能的关系\n\n一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fu2i7uawaaj30jg0amab4.jpg)\n\n从上图可以看出，开始，系统只有一个用户，CPU工作肯定是不饱合的。一方面该服务器可能有多个cpu，但是只处理单个进程，另一方面，在处理一个进程中，有些阶段可能是IO阶段，这个时候会造成CPU等待，但是又没有其他请求进程可以被处理。\n\n随着并发用户数的增加，CPU利用率上升，QPS相应也增加（公式为QPS=并发用户数/平均响应时间。）\n\n随着并发用户数的增加，平均响应时间也在增加，而且平均响应时间的增加是一个指数增加曲线。\n\n而当并发数增加到很大时，每秒钟都会有很多请求需要处理，会造成进程（线程）频繁切换，反而真正用于处理请求的时间变少，每秒能够处理的请求数反而变少，同时用户的请求等待时间也会变大，甚至超过用户的心理底线。\n\n我们对单台服务器进行压测有了性能测试数据以后，可以根据业务上能接受最大客户响应时间对应到相应的QPS数，从而计算出需要的服务器的数量。\n\n举例来说，响应时间10ms和1000ms对通过浏览器的客户是没有明显体验差别的，基于1000ms估算服务器的数量我们的成本会降低很多。\n\n每天300wPV的在单台机器上，这台机器需要多少QPS？对于这样的问题，假设每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。\n\n(3000000 x 0.8) / (3600 x 24 x 0.2) = 139 (QPS).\n\n还是上面的数据，如果一台机器的QPS是58，需要几台机器来支持？答：139 / 58 = 3","content":"<p>性能测试中会涉及到许多性能指标，在本文中进行了总结。目前只有QPS和TPS两个指标。</p>\n<span id=\"more\"></span>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"QPS\"><a href=\"#QPS\" class=\"headerlink\" title=\"QPS\"></a>QPS</h3><p>Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>\n<h3 id=\"TPS\"><a href=\"#TPS\" class=\"headerlink\" title=\"TPS\"></a>TPS</h3><p>是Transactions Per Second的缩写，也就是事务数&#x2F;秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体TPS得分。</p>\n<p>QPS（TPS）&#x3D; 并发数&#x2F;平均响应时间 或者 并发数 &#x3D; QPS * 平均响应时间 (这里响应时间的单位是秒)</p>\n<p>举例，我们一个HTTP请求的响应时间是20ms，在10个并发的情况下，QPS就是10*1000&#x2F;20&#x3D;500。</p>\n<p>这里有个关键的点就是QPS一定是跟并发数联系在一起的，离开并发数谈QPS是没意义的。<br>QPS、TPS和性能的关系</p>\n<p>一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。<br><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fu2i7uawaaj30jg0amab4.jpg\"></p>\n<p>从上图可以看出，开始，系统只有一个用户，CPU工作肯定是不饱合的。一方面该服务器可能有多个cpu，但是只处理单个进程，另一方面，在处理一个进程中，有些阶段可能是IO阶段，这个时候会造成CPU等待，但是又没有其他请求进程可以被处理。</p>\n<p>随着并发用户数的增加，CPU利用率上升，QPS相应也增加（公式为QPS&#x3D;并发用户数&#x2F;平均响应时间。）</p>\n<p>随着并发用户数的增加，平均响应时间也在增加，而且平均响应时间的增加是一个指数增加曲线。</p>\n<p>而当并发数增加到很大时，每秒钟都会有很多请求需要处理，会造成进程（线程）频繁切换，反而真正用于处理请求的时间变少，每秒能够处理的请求数反而变少，同时用户的请求等待时间也会变大，甚至超过用户的心理底线。</p>\n<p>我们对单台服务器进行压测有了性能测试数据以后，可以根据业务上能接受最大客户响应时间对应到相应的QPS数，从而计算出需要的服务器的数量。</p>\n<p>举例来说，响应时间10ms和1000ms对通过浏览器的客户是没有明显体验差别的，基于1000ms估算服务器的数量我们的成本会降低很多。</p>\n<p>每天300wPV的在单台机器上，这台机器需要多少QPS？对于这样的问题，假设每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。</p>\n<p>(3000000 x 0.8) &#x2F; (3600 x 24 x 0.2) &#x3D; 139 (QPS).</p>\n<p>还是上面的数据，如果一台机器的QPS是58，需要几台机器来支持？答：139 &#x2F; 58 &#x3D; 3</p>\n","slug":"性能测试基础--指标","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/08/08/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80--%E6%8C%87%E6%A0%87/","excerpt":"性能测试中会涉及到许多性能指标，在本文中进行了总结。目前只有QPS和TPS两个指标。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"QPS","slug":"QPS","permalink":"http://vwin.github.io/tags/QPS/"},{"name":"TPS","slug":"TPS","permalink":"http://vwin.github.io/tags/TPS/"}]},{"title":"性能测试总结-基础理论","date":"2019-08-08T06:35:53.000Z","path":"2019/08/08/性能测试总结-基础理论/","text":"随着软件行业的快速发展，现代的软件系统越来越复杂，功能越来越多，测试人员除了需要保证基本的功能测试质量，性能也随越来越受到人们的关注。但是一提到性能测试，很多人就直接连想到Loadrunner。认为LR就等于性能测试，其实这是不对的。LR只是性能测试的一个工具，但性能测试不仅仅是LR。本文会从以下几个方面介绍基础的性能测试理论，后续也会持续更新相关文章，尽量理论结合实践，让性能测试学习不在是工具的学习。 一、 什么是软件性能定义：软件的性能是软件的一种非功能特性，它关注的不是软件是否能够完成特定的功能，而是在完成该功能时展示出来的及时性。 由定义可知性能关注的是软件的非功能特性，所以一般来说性能测试介入的时机是在功能测试完成之后。另外，由定义中的及时性可知性能也是一种指标，可以用时间或其它指标来衡量，通常我们会使用某些工具或手段来检测软件的某些指标是否达到了要求，这就是性能测试。 性能测试定义：指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。 二、不同群体眼中的性能不同的人由于人生观、世界观、价值观以及教育背景、知识体系、人生阅历的不同，对于同一事物或问题的看法可能不同。对于软件性能也是如此，不同的人由于视角的不同，所关注的点也可能不同。下面来看看在不同的人群眼中性能分别是什么样的。 用户眼中的性能 开发眼中的性能 运维眼中的性能 测开眼中的性能测试人员通常是做为软件质量控制的一个角色，不仅仅是找bug，需要对整个软件的质量负责，性能也属于质量的一部分，因此测试人员眼中的性能应该是全面的，考虑的东西也需要全面： 测试人员需要考虑全面的性能，包括用户、开发、管理员等各个视角的性能。 测试人员在做性能测试时除开要关注表面的现象如响应时间，也需要关注本质，比如用户看不到的服务器资料利用率，架构设计是否合理？代码是否合理等言方方面面。 性能测试类型 基准测试：在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考 负载测试：是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。 压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。 稳定性测试：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。并发测试：测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题， 性能测试应用场景 性能测试应用场景（领域）主要有：能力验证、规划能力、性能调优、缺陷发现、性能基准比较，下表简单介绍和对比了这几个场景的各自用途和特点： 通常在某个性能场景（领域）中需要联合使用多种性能测试方法一起进行性能测试，下表为性能测试应用领域与测试方法关联： 性能测试基本概念响应时间 定义：从用户发送一个请求到用户接收到服务器返回的响应数据这段时间就是响应时间 关键路径：下图为一次http请求经过的路径，请求会经过网络发送到web服务器进行处理，如果需要操作DB，再由网络转发到数据库进行处理，然后返回值给web服务器，web服务器最后把结果数据通过网络返回给客户端。 计算方法：Response time &#x3D; (N1+N2+N3+N4)+ (A1+A2+a3)，即：（网络时间 + 应用程序处理时间） 响应时间-负载对应关系： 图中拐点说明： 响应时间突然增加 意味着系统的一种或多种资源利用达到的极限 通常可以利用拐点来进行性能测试分析与定位 吞吐量 定义：单位时间内系统处理的客户端请求的数量 计算单位：一般使用请求数／秒做为吞吐量的单位，出可以使用 页面数／秒表表示。另外，从业务角度来说也可以使用 访问人数 &#x2F;天 或 页面访问量／天 做为单位。 计算方法：Throughput &#x3D; (number of requests) &#x2F; (total time). 吞吐量-负载对应关系： 图中拐点说明： 吞吐量逐渐达到饱和 意味着系统的一种或多种资源利用达到的极限 通常可以利用拐点来进行性能测试分析与定位 并发数： 并发用户数：某一物理时刻同时向系统提交请求的用户数，提交的请求可能是同一个场景或功能，也可以是不同场景或功能。 在线用户数：某段时间内访问系统的用户数，这些用户并不一定同时向系统提交请求 系统用户数：系统注册的总用户数据三者之间的关系：系统用户数 &gt;&#x3D; 在线用户数 &gt;&#x3D; 并发用户数 资源利用率 定义：指的是对不同系统资源的使用程度，通常以占用最大值的百分比来衡量 通常需要关注的服务器资源如下： CPU：就像人的大脑，主要负责相关事情的判断以及实际处理的机制 内存：大脑中的记忆块区，将眼睛，皮肤等收集到的信息记录起来的地方，以供cpu进行判断，但是是临时的，访问速度快，如果关机或断电这里的数据会消失。 磁盘IO：大脑中的记忆区块，将重要的数据保存起来（永久保存，关机或断电不会丢失，速度慢），以便将来再次使用这些数据。 网络：网络传输情况 资源利用-负载对应关系：图中拐点说明： 服务器某荐资源使用逐渐达到饱和 通常可以利用拐点来进行性能测试分析与定位 其它常用概念： TPS：Transactions Per Second，每秒事务数 思考时间：用户每个操作后的暂停时间，或者叫操作之间的间隔时间，此时间内是不对服务器产生压力的 点击数：每秒钟用户向WEB服务器提交的HTTP请求数。这个指标是WEB应用特有的一个指标:WEB应用是”请求-响应”模式,用户发出一次申请,服务器就要处理一次，所以点击是WEB应用能够处理的交易的最小单位。如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力越大。点击率只是一个性能参考指标，重要的是分析点击时产生的影响。需要注意的是，这里的点击并非指鼠标的一次单击操作，因为在一次单击操作中，客户端可能向服务器发出多个HTTP请求. PV：访问一个URL，产生一个PV（Page View，页面访问量），每日每个网站的总PV量是形容一个 网站规模的重要指标。 UV：作为一个独立的用户，访问站点的所有页面均算作一个UV（Unique Visitor，用户访问）","raw":"---\ntitle: 性能测试总结-基础理论\ntoc: true\ndate: 2019-08-08 14:35:53\ntags: [性能测试]\ncategories: [测试]\ndescription:\n---\n随着软件行业的快速发展，现代的软件系统越来越复杂，功能越来越多，测试人员除了需要保证基本的功能测试质量，性能也随越来越受到人们的关注。但是一提到性能测试，很多人就直接连想到Loadrunner。认为LR就等于性能测试，其实这是不对的。LR只是性能测试的一个工具，但性能测试不仅仅是LR。本文会从以下几个方面介绍基础的性能测试理论，后续也会持续更新相关文章，尽量理论结合实践，让性能测试学习不在是工具的学习。\n\n<!--more-->\n# 一、 什么是软件性能\n\n定义：软件的性能是软件的一种非功能特性，它关注的不是软件是否能够完成特定的功能，而是在完成该功能时展示出来的及时性。\n\n由定义可知性能关注的是软件的非功能特性，所以一般来说性能测试介入的时机是在功能测试完成之后。另外，由定义中的及时性可知性能也是一种指标，可以用时间或其它指标来衡量，通常我们会使用某些工具或手段来检测软件的某些指标是否达到了要求，这就是性能测试。 \n\n性能测试定义：指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。\n\n\n# 二、不同群体眼中的性能\n\n不同的人由于人生观、世界观、价值观以及教育背景、知识体系、人生阅历的不同，对于同一事物或问题的看法可能不同。对于软件性能也是如此，不同的人由于视角的不同，所关注的点也可能不同。下面来看看在不同的人群眼中性能分别是什么样的。\n## 用户眼中的性能\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fynpdybgdmj30fm052mxh.jpg)\n\n## 开发眼中的性能\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fynpe0sm8uj30gc08d3zn.jpg)\n\n## 运维眼中的性能\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fynpe2oe39j30i407zwfo.jpg)\n## 测开眼中的性能\n测试人员通常是做为软件质量控制的一个角色，不仅仅是找bug，需要对整个软件的质量负责，性能也属于质量的一部分，因此测试人员眼中的性能应该是全面的，考虑的东西也需要全面：\n1. 测试人员需要考虑全面的性能，包括用户、开发、管理员等各个视角的性能。\n2. 测试人员在做性能测试时除开要关注表面的现象如响应时间，也需要关注本质，比如用户看不到的服务器资料利用率，架构设计是否合理？代码是否合理等言方方面面。\n\n# 性能测试类型\n- 基准测试：在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考\n- 负载测试：是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。\n- 压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。\n- 稳定性测试：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。\n并发测试：测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题，\n\n# 性能测试应用场景\n1. 性能测试应用场景（领域）主要有：能力验证、规划能力、性能调优、缺陷发现、性能基准比较，下表简单介绍和对比了这几个场景的各自用途和特点： \n![](https://ws2.sinaimg.cn/large/006tNbRwly1fynpg9whmhj30hs0j7n0r.jpg)\n2. 通常在某个性能场景（领域）中需要联合使用多种性能测试方法一起进行性能测试，下表为性能测试应用领域与测试方法关联：\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fynpgq0ox2j30g20bsmxq.jpg)\n\n# 性能测试基本概念\n## 响应时间\n1. 定义：从用户发送一个请求到用户接收到服务器返回的响应数据这段时间就是响应时间\n2. 关键路径：下图为一次http请求经过的路径，请求会经过网络发送到web服务器进行处理，如果需要操作DB，再由网络转发到数据库进行处理，然后返回值给web服务器，web服务器最后把结果数据通过网络返回给客户端。\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fynphpjne7j30iv06swf5.jpg)\n3. 计算方法：Response time = (N1+N2+N3+N4)+ (A1+A2+a3)，即：（网络时间 + 应用程序处理时间）\n4. 响应时间-负载对应关系：\n    ![](https://ws1.sinaimg.cn/large/006tNbRwly1fynpi6gmubj30hl0a50t0.jpg)\n    图中拐点说明：\n    1. 响应时间突然增加\n    2. 意味着系统的一种或多种资源利用达到的极限\n    3. 通常可以利用拐点来进行性能测试分析与定位\n\n## 吞吐量\n1. 定义：单位时间内系统处理的客户端请求的数量\n2. 计算单位：一般使用请求数／秒做为吞吐量的单位，出可以使用 页面数／秒表表示。\n   另外，从业务角度来说也可以使用 访问人数 /天 或 页面访问量／天 做为单位。\n3. 计算方法：Throughput = (number of requests) / (total time).\n4. 吞吐量-负载对应关系：\n   ![](https://ws4.sinaimg.cn/large/006tNbRwly1fynpka9lcxj30pc0eymxt.jpg)\n   \n   图中拐点说明：\n   1. 吞吐量逐渐达到饱和\n   2. 意味着系统的一种或多种资源利用达到的极限\n   3. 通常可以利用拐点来进行性能测试分析与定位 \n\n## 并发数：\n1. 并发用户数：某一物理时刻同时向系统提交请求的用户数，提交的请求可能是同一个场景或功能，也可以是不同场景或功能。\n2. 在线用户数：某段时间内访问系统的用户数，这些用户并不一定同时向系统提交请求\n3. 系统用户数：系统注册的总用户数据\n三者之间的关系：系统用户数 >= 在线用户数 >= 并发用户数\n\n## 资源利用率\n1. 定义：指的是对不同系统资源的使用程度，通常以占用最大值的百分比来衡量\n2. 通常需要关注的服务器资源如下：\n   1. CPU：就像人的大脑，主要负责相关事情的判断以及实际处理的机制\n   2. 内存：大脑中的记忆块区，将眼睛，皮肤等收集到的信息记录起来的地方，以供cpu进行判断，但是是临时的，访问速度快，如果关机或断电这里的数据会消失。\n   3. 磁盘IO：大脑中的记忆区块，将重要的数据保存起来（永久保存，关机或断电不会丢失，速度慢），以便将来再次使用这些数据。\n   4. 网络：网络传输情况\n\n3. 资源利用-负载对应关系：\n   ![](https://ws2.sinaimg.cn/large/006tNbRwly1fynpm6stvcj30se0fct9j.jpg)\n   图中拐点说明：\n   1. 服务器某荐资源使用逐渐达到饱和\n   2. 通常可以利用拐点来进行性能测试分析与定位\n\n## 其它常用概念：\n1. TPS：Transactions Per Second，每秒事务数\n2. 思考时间：用户每个操作后的暂停时间，或者叫操作之间的间隔时间，此时间内是不对服务器产生压力的\n3. 点击数：每秒钟用户向WEB服务器提交的HTTP请求数。这个指标是WEB应用特有的一个指标:WEB应用是\"请求-响应\"模式,用户发出一次申请,服务器就要处理一次，所以点击是WEB应用能够处理的交易的最小单位。如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力越大。点击率只是一个性能参考指标，重要的是分析点击时产生的影响。需要注意的是，这里的点击并非指鼠标的一次单击操作，因为在一次单击操作中，客户端可能向服务器发出多个HTTP请求.\n4. PV：访问一个URL，产生一个PV（Page View，页面访问量），每日每个网站的总PV量是形容一个 网站规模的重要指标。\n5. UV：作为一个独立的用户，访问站点的所有页面均算作一个UV（Unique Visitor，用户访问）\n\n ","content":"<p>随着软件行业的快速发展，现代的软件系统越来越复杂，功能越来越多，测试人员除了需要保证基本的功能测试质量，性能也随越来越受到人们的关注。但是一提到性能测试，很多人就直接连想到Loadrunner。认为LR就等于性能测试，其实这是不对的。LR只是性能测试的一个工具，但性能测试不仅仅是LR。本文会从以下几个方面介绍基础的性能测试理论，后续也会持续更新相关文章，尽量理论结合实践，让性能测试学习不在是工具的学习。</p>\n<span id=\"more\"></span>\n<h1 id=\"一、-什么是软件性能\"><a href=\"#一、-什么是软件性能\" class=\"headerlink\" title=\"一、 什么是软件性能\"></a>一、 什么是软件性能</h1><p>定义：软件的性能是软件的一种非功能特性，它关注的不是软件是否能够完成特定的功能，而是在完成该功能时展示出来的及时性。</p>\n<p>由定义可知性能关注的是软件的非功能特性，所以一般来说性能测试介入的时机是在功能测试完成之后。另外，由定义中的及时性可知性能也是一种指标，可以用时间或其它指标来衡量，通常我们会使用某些工具或手段来检测软件的某些指标是否达到了要求，这就是性能测试。 </p>\n<p>性能测试定义：指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p>\n<h1 id=\"二、不同群体眼中的性能\"><a href=\"#二、不同群体眼中的性能\" class=\"headerlink\" title=\"二、不同群体眼中的性能\"></a>二、不同群体眼中的性能</h1><p>不同的人由于人生观、世界观、价值观以及教育背景、知识体系、人生阅历的不同，对于同一事物或问题的看法可能不同。对于软件性能也是如此，不同的人由于视角的不同，所关注的点也可能不同。下面来看看在不同的人群眼中性能分别是什么样的。</p>\n<h2 id=\"用户眼中的性能\"><a href=\"#用户眼中的性能\" class=\"headerlink\" title=\"用户眼中的性能\"></a>用户眼中的性能</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fynpdybgdmj30fm052mxh.jpg\"></p>\n<h2 id=\"开发眼中的性能\"><a href=\"#开发眼中的性能\" class=\"headerlink\" title=\"开发眼中的性能\"></a>开发眼中的性能</h2><p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fynpe0sm8uj30gc08d3zn.jpg\"></p>\n<h2 id=\"运维眼中的性能\"><a href=\"#运维眼中的性能\" class=\"headerlink\" title=\"运维眼中的性能\"></a>运维眼中的性能</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fynpe2oe39j30i407zwfo.jpg\"></p>\n<h2 id=\"测开眼中的性能\"><a href=\"#测开眼中的性能\" class=\"headerlink\" title=\"测开眼中的性能\"></a>测开眼中的性能</h2><p>测试人员通常是做为软件质量控制的一个角色，不仅仅是找bug，需要对整个软件的质量负责，性能也属于质量的一部分，因此测试人员眼中的性能应该是全面的，考虑的东西也需要全面：</p>\n<ol>\n<li>测试人员需要考虑全面的性能，包括用户、开发、管理员等各个视角的性能。</li>\n<li>测试人员在做性能测试时除开要关注表面的现象如响应时间，也需要关注本质，比如用户看不到的服务器资料利用率，架构设计是否合理？代码是否合理等言方方面面。</li>\n</ol>\n<h1 id=\"性能测试类型\"><a href=\"#性能测试类型\" class=\"headerlink\" title=\"性能测试类型\"></a>性能测试类型</h1><ul>\n<li>基准测试：在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考</li>\n<li>负载测试：是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。</li>\n<li>压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。</li>\n<li>稳定性测试：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。<br>并发测试：测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题，</li>\n</ul>\n<h1 id=\"性能测试应用场景\"><a href=\"#性能测试应用场景\" class=\"headerlink\" title=\"性能测试应用场景\"></a>性能测试应用场景</h1><ol>\n<li>性能测试应用场景（领域）主要有：能力验证、规划能力、性能调优、缺陷发现、性能基准比较，下表简单介绍和对比了这几个场景的各自用途和特点：<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fynpg9whmhj30hs0j7n0r.jpg\"></li>\n<li>通常在某个性能场景（领域）中需要联合使用多种性能测试方法一起进行性能测试，下表为性能测试应用领域与测试方法关联：<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fynpgq0ox2j30g20bsmxq.jpg\"></li>\n</ol>\n<h1 id=\"性能测试基本概念\"><a href=\"#性能测试基本概念\" class=\"headerlink\" title=\"性能测试基本概念\"></a>性能测试基本概念</h1><h2 id=\"响应时间\"><a href=\"#响应时间\" class=\"headerlink\" title=\"响应时间\"></a>响应时间</h2><ol>\n<li>定义：从用户发送一个请求到用户接收到服务器返回的响应数据这段时间就是响应时间</li>\n<li>关键路径：下图为一次http请求经过的路径，请求会经过网络发送到web服务器进行处理，如果需要操作DB，再由网络转发到数据库进行处理，然后返回值给web服务器，web服务器最后把结果数据通过网络返回给客户端。<br><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fynphpjne7j30iv06swf5.jpg\"></li>\n<li>计算方法：Response time &#x3D; (N1+N2+N3+N4)+ (A1+A2+a3)，即：（网络时间 + 应用程序处理时间）</li>\n<li>响应时间-负载对应关系：<br> <img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fynpi6gmubj30hl0a50t0.jpg\"><br> 图中拐点说明：<ol>\n<li>响应时间突然增加</li>\n<li>意味着系统的一种或多种资源利用达到的极限</li>\n<li>通常可以利用拐点来进行性能测试分析与定位</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"吞吐量\"><a href=\"#吞吐量\" class=\"headerlink\" title=\"吞吐量\"></a>吞吐量</h2><ol>\n<li><p>定义：单位时间内系统处理的客户端请求的数量</p>\n</li>\n<li><p>计算单位：一般使用请求数／秒做为吞吐量的单位，出可以使用 页面数／秒表表示。<br>另外，从业务角度来说也可以使用 访问人数 &#x2F;天 或 页面访问量／天 做为单位。</p>\n</li>\n<li><p>计算方法：Throughput &#x3D; (number of requests) &#x2F; (total time).</p>\n</li>\n<li><p>吞吐量-负载对应关系：<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fynpka9lcxj30pc0eymxt.jpg\"></p>\n<p>图中拐点说明：</p>\n<ol>\n<li>吞吐量逐渐达到饱和</li>\n<li>意味着系统的一种或多种资源利用达到的极限</li>\n<li>通常可以利用拐点来进行性能测试分析与定位</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"并发数：\"><a href=\"#并发数：\" class=\"headerlink\" title=\"并发数：\"></a>并发数：</h2><ol>\n<li>并发用户数：某一物理时刻同时向系统提交请求的用户数，提交的请求可能是同一个场景或功能，也可以是不同场景或功能。</li>\n<li>在线用户数：某段时间内访问系统的用户数，这些用户并不一定同时向系统提交请求</li>\n<li>系统用户数：系统注册的总用户数据<br>三者之间的关系：系统用户数 &gt;&#x3D; 在线用户数 &gt;&#x3D; 并发用户数</li>\n</ol>\n<h2 id=\"资源利用率\"><a href=\"#资源利用率\" class=\"headerlink\" title=\"资源利用率\"></a>资源利用率</h2><ol>\n<li><p>定义：指的是对不同系统资源的使用程度，通常以占用最大值的百分比来衡量</p>\n</li>\n<li><p>通常需要关注的服务器资源如下：</p>\n<ol>\n<li>CPU：就像人的大脑，主要负责相关事情的判断以及实际处理的机制</li>\n<li>内存：大脑中的记忆块区，将眼睛，皮肤等收集到的信息记录起来的地方，以供cpu进行判断，但是是临时的，访问速度快，如果关机或断电这里的数据会消失。</li>\n<li>磁盘IO：大脑中的记忆区块，将重要的数据保存起来（永久保存，关机或断电不会丢失，速度慢），以便将来再次使用这些数据。</li>\n<li>网络：网络传输情况</li>\n</ol>\n</li>\n<li><p>资源利用-负载对应关系：<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fynpm6stvcj30se0fct9j.jpg\"><br>图中拐点说明：</p>\n<ol>\n<li>服务器某荐资源使用逐渐达到饱和</li>\n<li>通常可以利用拐点来进行性能测试分析与定位</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"其它常用概念：\"><a href=\"#其它常用概念：\" class=\"headerlink\" title=\"其它常用概念：\"></a>其它常用概念：</h2><ol>\n<li>TPS：Transactions Per Second，每秒事务数</li>\n<li>思考时间：用户每个操作后的暂停时间，或者叫操作之间的间隔时间，此时间内是不对服务器产生压力的</li>\n<li>点击数：每秒钟用户向WEB服务器提交的HTTP请求数。这个指标是WEB应用特有的一个指标:WEB应用是”请求-响应”模式,用户发出一次申请,服务器就要处理一次，所以点击是WEB应用能够处理的交易的最小单位。如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力越大。点击率只是一个性能参考指标，重要的是分析点击时产生的影响。需要注意的是，这里的点击并非指鼠标的一次单击操作，因为在一次单击操作中，客户端可能向服务器发出多个HTTP请求.</li>\n<li>PV：访问一个URL，产生一个PV（Page View，页面访问量），每日每个网站的总PV量是形容一个 网站规模的重要指标。</li>\n<li>UV：作为一个独立的用户，访问站点的所有页面均算作一个UV（Unique Visitor，用户访问）</li>\n</ol>\n","slug":"性能测试总结-基础理论","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/08/08/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/","excerpt":"随着软件行业的快速发展，现代的软件系统越来越复杂，功能越来越多，测试人员除了需要保证基本的功能测试质量，性能也随越来越受到人们的关注。但是一提到性能测试，很多人就直接连想到Loadrunner。认为LR就等于性能测试，其实这是不对的。LR只是性能测试的一个工具，但性能测试不仅仅是LR。本文会从以下几个方面介绍基础的性能测试理论，后续也会持续更新相关文章，尽量理论结合实践，让性能测试学习不在是工具的学习。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Github ssh","date":"2019-01-08T07:27:57.000Z","path":"2019/01/08/Github-ssh/","text":"本地连接GitHub远程仓库，操作步骤 本地生成ssh公钥1ssh-keygen 添加本地公钥到github上 本地执行123456789ssh-agent -sssh-add id_rsa文件路径如果出现：Could not open a connection to your authentication agent. 那么执行eval `ssh-agent -s`然后再执行：ssh-add id_rsa文件路径验证是否添加成功：ssh -T git@github.comorssh -T -v git@github.com","raw":"---\ntitle: Github ssh\ntoc: true\ndate: 2019-01-08 15:27:57\ntags: [github,ssh]\ncategories: [技术]\ndescription:\n---\n本地连接GitHub远程仓库，操作步骤\n1. 本地生成ssh公钥\n```shell\nssh-keygen\n```\n2. 添加本地公钥到github上\n3. 本地执行\n```shell\nssh-agent -s\nssh-add id_rsa文件路径\n如果出现：Could not open a connection to your authentication agent. 那么执行\neval `ssh-agent -s`\n然后再执行：ssh-add id_rsa文件路径\n验证是否添加成功：\nssh -T git@github.com\nor\nssh -T -v git@github.com\n```","content":"<p>本地连接GitHub远程仓库，操作步骤</p>\n<ol>\n<li>本地生成ssh公钥<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure></li>\n<li>添加本地公钥到github上</li>\n<li>本地执行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-agent -s</span><br><span class=\"line\">ssh-add id_rsa文件路径</span><br><span class=\"line\">如果出现：Could not open a connection to your authentication agent. 那么执行</span><br><span class=\"line\">eval `ssh-agent -s`</span><br><span class=\"line\">然后再执行：ssh-add id_rsa文件路径</span><br><span class=\"line\">验证是否添加成功：</span><br><span class=\"line\">ssh -T git@github.com</span><br><span class=\"line\">or</span><br><span class=\"line\">ssh -T -v git@github.com</span><br></pre></td></tr></table></figure></li>\n</ol>\n","slug":"Github-ssh","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/01/08/Github-ssh/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"github","slug":"github","permalink":"http://vwin.github.io/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"http://vwin.github.io/tags/ssh/"}]},{"title":"保险配置","date":"2019-01-06T22:06:41.000Z","path":"2019/01/06/保险配置/","text":"保险-防患于未然参考： https://zhuanlan.zhihu.com/p/54116024 https://www.zhihu.com/question/22316395/answer/100909780 https://zhuanlan.zhihu.com/p/21759861 意外险参考：https://mp.weixin.qq.com/s/5_w2bvV1QemnHGuZYqeFcA 50w 成人意外险 结论 如果追求性价比：上海人寿小蜜蜂不仅价格最低，而且还有特定意外 20 万的额外赔付，意外医疗 5 万元也足够了，性价比非常高。 如果想保障更全面：可以考虑众安全面无忧，包含 50 万的特定交通意外责任，不限社保用药，社保外可以报销 80%，综合保障还不错。 如果想要猝死保障：微信护身福猝死保额最高，小米综合意外险、安意保也可以考虑，不过有必要提醒大家，应对猝死等身故风险，最应该购买的是 定期寿险。 100w 成人意外险 结论 如果是女性用户：首推百万玫瑰女性意外险，100 万保额，3 万意外医疗不限社保用药，只需 299 元，1-2 类职业的女性朋友有福了。 如果追求性价比：可以考虑小米意外险，100 万保额，5 万意外医疗，价格只需要 299 元，性价比非常高。 重疾险百年康惠保重大疾病保险 百年康惠保（旗舰版）重大疾病保险 百年康惠保重大疾病保险康惠保旗舰版购买链接：http://www.kaixinbao.com/jiankang-baoxian/315704.shtml康惠保购买链接：http://www.kaixinbao.com/jiankang-baoxian/309551.shtml或登录百年人寿官网http://www.aeonlife.com.cn/news/2837.shtml扫页面上的二维码购买（仅限康惠保） 推荐理由（2017年末）因为第0位推荐买不了（如果看了我17年末推荐的，知道我说的是华夏人寿优优保重大疾病保险，今年为节省篇幅删了，因为不可能再上市了），只能推荐本产品了。不用看了，这款产品保险公司肯定赔钱，非常便宜。以后有没有公司能做到比它和华夏优优保更便宜？不太可能，除非脑子坏了。它在部分销售模式甚至还匪夷所思地提供“返佣”（我本人对“返佣”不评论，本文评论亦请勿宣导任何返佣方式，在评论包括留下私信方式的，必删）。当然等哪天华夏想开了又重新卖它的优优宝了，我就按优先推荐第一个打开市场局面的原则，不再推荐本产品。另外请注意它的附加轻症责任比较贵，只需购买主险重大疾病责任即可。当然我也说过很多次轻症并不是一个重要责任。百年人寿在全国开的机构亦已经比较多，相信能满足国内地理位置不同地方朋友的需求。 推荐理由（2019年初）康惠保旗舰版的重疾责任部分为有史以来中国地区包括港澳台在内最便宜的单卖的长期重大疾病责任。“长期”在保险产品范畴里面除了意味着保险期间大于一年也意味着产品是保证费率保证续保，在中国只有人寿保险公司才能开展长期人身险业务，同时需要承担更大的风险并且有更复杂的监管要求，这也是为什么国内人寿保险公司比财产险公司牌照值钱，估值要更贵的原因之一。基本上符合投保要求的朋友我非常建议每一个人都买一份这个产品，因为不会再有如此便宜的重疾产品了。 非要说康惠保旗舰版不好的地方就是，虽然它条款里写的中症和轻症责任为可选责任，也就是只有重大疾病责任是必选责任，其他可买可不买，但它目前实际销售中重大疾病责任只能与中轻症责任一起捆绑购买，而熟悉我回答的朋友都知道我李某对于轻症或者实际上是加强版轻症的中症兴趣不大，我希望你们的每一个保费花在最划算的地方。它仅在双十一期间短暂开放过重大疾病单独投保的窗口，直到我写这个回答这一刻都再没有出现过。 所以还是把可以单独投保重大疾病责任的老康惠保列在这里，它也是极度便宜，当然纯重疾的价格还是比康惠保旗舰版纯重疾部分的价格略贵一点。 但是即使搭配了可选的中轻症责任，康惠保两兄弟的价格基本还是秒了其他公司重疾产品一个太平洋。 国华华瑞国民定期重大疾病保险 国华华瑞1号国民定期重大疾病保险 国华华瑞2号国民定期重大疾病保险华瑞1号购买链接：http://www.huaruisales.com/mall/productDetail.html?itemcode=HRGW_0004 扫页面上的二维码购买华瑞2号购买链接：请在支付宝上的蚂蚁保险里找到国华人寿“成人及儿童长期重疾险” （华瑞保险为国华人寿全资保险销售公司，和百年康惠保旗舰版不在百年人寿官网卖一样，这两款重疾在国华人寿的官网也是没有的；基本可以认为华瑞2号其实就是华瑞1号国华人寿给支付宝的专供版。今年新上榜） 推荐理由它的成人重疾部分没有第一名便宜，如能购买百年产品的并不推荐这款。我推荐的是18岁以下朋友去投保这个产品，它的少儿重疾部分费率非常低，并且提供保险期间为20年或30年的选择，特别适合为自己小孩买不起康惠保兄弟”保至70岁“和”保至终身“的朋友。我特别”讨厌“看到朋友圈发小孩得重疾需要轻松筹的，你们可以看看国华这款产品的保费有多低，你收入即使只有知乎平均收入的1&#x2F;10也能为自己的子女买得起。 当然如果您经济能力如果能承受，建议还是买康惠保兄弟至少”保至70岁“的选择，因为他俩是有史以来最便宜的重疾产品。而目前国内重疾产品赔付经验一直在恶化（唉，就这样还有人说中国的重疾产品很难理赔），我个人预期未来重疾产品价格将可能上涨，现在能用最低的价格锁定风险长一点时间不是更好？ 医疗险人保健康健康金福悠享保个人医疗保险（2018款）购买链接：和PS独占美国末日一样，此产品为支付宝独占产品，在人保健康官网产品页面扫码跳转至支付宝，或者在支付宝蚂蚁保险搜索”好医保 长期医疗“。注意不是”好医保 住院医疗“，”好医保 住院医疗“为另一家保险公司承保，并不推荐，别看错了。 推荐理由：由于医疗产品承保经验波动的天性，所以基本上市面是极少保证续保医疗险存在的。而我一向认为不能锁定长期风险的保险产品不是好的保险产品，所以对于疾病风险，我希望你们优先投保能最长可以将重大疾病风险锁定至终身的长期重疾保险。对于此类医疗风险，应该留给你的雇佣单位用团体保险承担（当然我也知道好的公司很少）。在你配置好足够的重疾保障后可以将本中端医疗产品作为一个可选项配置。当然，若果您现在经济能力还承受不了重疾，本产品可以作为一个初级风险保障配置，但是一旦有足够经济能力，还是应该立刻投保足额的重大疾病保险。 作为目前市场唯二能保证续保6年的中端医疗产品（另外一款出来太晚，我只推荐第一个出来吃螃蟹的），续保6年在医疗险范畴也算很大的进步，而监管也早已锁死报备更高保证续保年限的通路，所以人保健这个产品卡死了目前市场最可能高的保证续保条件，也吊打了所有无法提供任何保证续保的财险公司的中端医疗产品。 同时它的费率确实很便宜，至少购买后6年内不怕它消失。 财险平安家庭财产保险组合购买链接：http://baoxian.pingan.com/product/jiatingcaichanbaoxian.shtml （注意：我认为只需要保房屋主体结构责任即可，最多加保一个水暖管爆裂损失责任，其余责任属于不那么重要的添头。由于地震在房屋险为标准除外责任，如果需要购买地震保障，请额外购买地震责任http://baoxian.pingan.com/product/dizhenbaoxian.shtml，价格偏中等，考虑平安目前国内完善的服务网络，仍然推荐） 推荐原因（2017年末）财险本身多数都是一年期短期险，财险公司也以打价格战闻名，大不了今年赔钱明年调高价格，先把客户吸引过来再说。而这款保险大概至少5年以来都维持在现在这个极低的价格，我还没有找到比它更便宜的，当然有个别公司“故意”做低一点想对标的，但是房屋保险属于保额很高保费很低的产品，特别还存在超高保额部分保额增长和保费增长并不是比例关系，这需要保险公司有非常大的盘子及像再保安排这样的风控措施去承担这种超高额赔付带来的损失波动（比如杭州保姆纵火案中遭受波及的豪宅邻居（林爸爸即使买了可能也无法获得理赔，因为是家庭雇佣人员的故意行为，属于除外）），风控措施不好很容易就会带来每年保费调整，而平安财险的承保池我认为已经足以支撑房屋保险可能会出现的大经验波动了，它能长时间维持现在这个价格就是一个证明。我通常不推荐短期险，但这个是例外。而目前房屋几乎是国内很多家庭单一最大资产，投保房屋保险非常重要，甚至比先帮你自己投保还重要。 推荐原因（2019年初）现在看来没有任何财产险公司在这个产品上有打倒平安财的可能性，零。其实平安财还出了一款可以同时投保同一地区所有房屋的家财险，打个比方你在北京市朝阳区有20套房子，买它那一个产品一次就可以承保这20套房子，而价格仅较上面那个单一版本略为上涨（不是20倍，可能连20%都没有），但中国平安把它商标后缀改成“金融 科技”后它官网还是难用的一笔，我实在找不到那款产品的链接了，因此还是推荐原来这个吧。 定期寿险华贵人寿大麦定期寿险新加入的搅局者，便宜！！！ 弘康人寿大白智能定寿目前在售的定寿产品比较： 渤海人寿优选定期寿险购买链接：在微信上搜索“渤海人寿“，关注其官方微信号，在官微上完成投保 推荐理由（2017年末）渤海人寿这款产品虽然名字里有优选定期寿险字样，但它其实是一款“假”优选体定寿。渤海人寿可能出于促销或者想打开品牌等原因，它所谓的优选体实际上普通人完成健康告知既可以承保，不需要进行正常优选体定寿产品要求的体检，也就是相当于就是直接把优选体的费率拿出来当普通人群的费率来卖，因此价格非常非常非常便宜。有人说它的健康告知比较“苛刻“，我个人觉得和多数其他网销定寿产品并无实质性差异。 由于定期寿险不像健康险一样有分支机构销售限制，也就是网销健康险你需要在当地省市有分公司才能网销到该地区。寿险可以无限制网销卖全国保单。这款几乎是我唯一推荐定期寿险。但是考虑我本文一开始那两个常见问题所遇到的情况，我还是要推荐多一顺位产品做备份。 你会说还有很多很多某某产品价格也很有竞争力，我当然知道了，我比你们大多数人都熟悉人寿保险产品，但是我不也说了，我只推荐第一个把价格打到如此的产品，以资鼓励第一个吃螃蟹的。大家可以做对标这种“鸡贼“事（我也常做），但总要让大家知道第一个勇敢的人啊。 推荐理由（2019年初）渤海人寿此款产品和我第1位拟推荐的贵了一点，但是还是在前年那波网销定寿大潮中第一个做到把价格打下一大截并且保持非常低的节奏，为鼓励这家艰难的公司（坐拥100多亿资本金但因为特殊原因开不了更多分支机构），我今年还是继续推荐它的优选定寿产品。","raw":"---\ntitle: 保险配置\ntoc: true\ndate: 2019-01-07 06:06:41\ntags: [保险]\ncategories: [生活]\ndescription:\n---\n保险-防患于未然\n参考：\n1. https://zhuanlan.zhihu.com/p/54116024\n2. https://www.zhihu.com/question/22316395/answer/100909780\n3. https://zhuanlan.zhihu.com/p/21759861 \n\n<!--more-->\n\n# 意外险\n参考：https://mp.weixin.qq.com/s/5_w2bvV1QemnHGuZYqeFcA\n## 50w 成人意外险\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fyy9venvp9j30gl0hhq6k.jpg)\n### 结论\n- 如果追求性价比：上海人寿小蜜蜂不仅价格最低，而且还有特定意外 20 万的额外赔付，意外医疗 5 万元也足够了，性价比非常高。\n- 如果想保障更全面：可以考虑众安全面无忧，包含 50 万的特定交通意外责任，不限社保用药，社保外可以报销 80%，综合保障还不错。\n- 如果想要猝死保障：微信护身福猝死保额最高，小米综合意外险、安意保也可以考虑，不过有必要提醒大家，应对猝死等身故风险，最应该购买的是 定期寿险。\n\n## 100w 成人意外险\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fyy9yivo80j30fs0go0w4.jpg)\n### 结论\n- 如果是女性用户：首推百万玫瑰女性意外险，100 万保额，3 万意外医疗不限社保用药，只需 299 元，1-2 类职业的女性朋友有福了。\n- 如果追求性价比：可以考虑小米意外险，100 万保额，5 万意外医疗，价格只需要 299 元，性价比非常高。\n\n# 重疾险\n## 百年康惠保重大疾病保险\n1. 百年康惠保（旗舰版）重大疾病保险\n2. 百年康惠保重大疾病保险\n康惠保旗舰版购买链接：http://www.kaixinbao.com/jiankang-baoxian/315704.shtml\n康惠保购买链接：http://www.kaixinbao.com/jiankang-baoxian/309551.shtml\n或登录百年人寿官网http://www.aeonlife.com.cn/news/2837.shtml扫页面上的二维码购买（仅限康惠保）\n\n### 推荐理由（2017年末）\n因为第0位推荐买不了（如果看了我17年末推荐的，知道我说的是华夏人寿优优保重大疾病保险，今年为节省篇幅删了，因为不可能再上市了），只能推荐本产品了。不用看了，这款产品保险公司肯定赔钱，非常便宜。以后有没有公司能做到比它和华夏优优保更便宜？不太可能，除非脑子坏了。它在部分销售模式甚至还匪夷所思地提供“返佣”（我本人对“返佣”不评论，本文评论亦请勿宣导任何返佣方式，在评论包括留下私信方式的，必删）。当然等哪天华夏想开了又重新卖它的优优宝了，我就按优先推荐第一个打开市场局面的原则，不再推荐本产品。另外请注意它的附加轻症责任比较贵，只需购买主险重大疾病责任即可。当然我也说过很多次轻症并不是一个重要责任。百年人寿在全国开的机构亦已经比较多，相信能满足国内地理位置不同地方朋友的需求。\n\n### 推荐理由（2019年初）\n康惠保旗舰版的重疾责任部分为有史以来中国地区包括港澳台在内最便宜的单卖的长期重大疾病责任。“长期”在保险产品范畴里面除了意味着保险期间大于一年也意味着产品是保证费率保证续保，在中国只有人寿保险公司才能开展长期人身险业务，同时需要承担更大的风险并且有更复杂的监管要求，这也是为什么国内人寿保险公司比财产险公司牌照值钱，估值要更贵的原因之一。基本上符合投保要求的朋友我非常建议每一个人都买一份这个产品，因为不会再有如此便宜的重疾产品了。\n\n非要说康惠保旗舰版不好的地方就是，虽然它条款里写的中症和轻症责任为可选责任，也就是只有重大疾病责任是必选责任，其他可买可不买，但它目前实际销售中重大疾病责任只能与中轻症责任一起捆绑购买，而熟悉我回答的朋友都知道我李某对于轻症或者实际上是加强版轻症的中症兴趣不大，我希望你们的每一个保费花在最划算的地方。它仅在双十一期间短暂开放过重大疾病单独投保的窗口，直到我写这个回答这一刻都再没有出现过。\n\n所以还是把可以单独投保重大疾病责任的老康惠保列在这里，它也是极度便宜，当然纯重疾的价格还是比康惠保旗舰版纯重疾部分的价格略贵一点。\n\n但是即使搭配了可选的中轻症责任，康惠保两兄弟的价格基本还是秒了其他公司重疾产品一个太平洋。\n\n## 国华华瑞国民定期重大疾病保险\n1. 国华华瑞1号国民定期重大疾病保险\n2. 国华华瑞2号国民定期重大疾病保险\n华瑞1号购买链接：http://www.huaruisales.com/mall/productDetail.html?itemcode=HRGW_0004 扫页面上的二维码购买\n华瑞2号购买链接：请在支付宝上的蚂蚁保险里找到国华人寿“成人及儿童长期重疾险”\n\n（华瑞保险为国华人寿全资保险销售公司，和百年康惠保旗舰版不在百年人寿官网卖一样，这两款重疾在国华人寿的官网也是没有的；基本可以认为华瑞2号其实就是华瑞1号国华人寿给支付宝的专供版。今年新上榜）\n\n### 推荐理由\n它的成人重疾部分没有第一名便宜，如能购买百年产品的并不推荐这款。我推荐的是18岁以下朋友去投保这个产品，它的少儿重疾部分费率非常低，并且提供保险期间为20年或30年的选择，特别适合为自己小孩买不起康惠保兄弟”保至70岁“和”保至终身“的朋友。我特别”讨厌“看到朋友圈发小孩得重疾需要轻松筹的，你们可以看看国华这款产品的保费有多低，你收入即使只有知乎平均收入的1/10也能为自己的子女买得起。\n\n当然如果您经济能力如果能承受，建议还是买康惠保兄弟至少”保至70岁“的选择，因为他俩是有史以来最便宜的重疾产品。而目前国内重疾产品赔付经验一直在恶化（唉，就这样还有人说中国的重疾产品很难理赔），我个人预期未来重疾产品价格将可能上涨，现在能用最低的价格锁定风险长一点时间不是更好？\n\n\n# 医疗险\n## 人保健康健康金福悠享保个人医疗保险（2018款）\n购买链接：和PS独占美国末日一样，此产品为支付宝独占产品，在人保健康官网产品页面扫码跳转至支付宝，或者在支付宝蚂蚁保险搜索”好医保 长期医疗“。注意不是”好医保 住院医疗“，”好医保 住院医疗“为另一家保险公司承保，并不推荐，别看错了。\n\n推荐理由：由于医疗产品承保经验波动的天性，所以基本上市面是极少保证续保医疗险存在的。而我一向认为不能锁定长期风险的保险产品不是好的保险产品，所以对于疾病风险，我希望你们优先投保能最长可以将重大疾病风险锁定至终身的长期重疾保险。对于此类医疗风险，应该留给你的雇佣单位用团体保险承担（当然我也知道好的公司很少）。在你配置好足够的重疾保障后可以将本中端医疗产品作为一个可选项配置。当然，若果您现在经济能力还承受不了重疾，本产品可以作为一个初级风险保障配置，但是一旦有足够经济能力，还是应该立刻投保足额的重大疾病保险。\n\n作为目前市场唯二能保证续保6年的中端医疗产品（另外一款出来太晚，我只推荐第一个出来吃螃蟹的），续保6年在医疗险范畴也算很大的进步，而监管也早已锁死报备更高保证续保年限的通路，所以人保健这个产品卡死了目前市场最可能高的保证续保条件，也吊打了所有无法提供任何保证续保的财险公司的中端医疗产品。\n\n同时它的费率确实很便宜，至少购买后6年内不怕它消失。\n\n# 财险\n## 平安家庭财产保险组合\n购买链接：http://baoxian.pingan.com/product/jiatingcaichanbaoxian.shtml\n\n（注意：我认为只需要保房屋主体结构责任即可，最多加保一个水暖管爆裂损失责任，其余责任属于不那么重要的添头。由于地震在房屋险为标准除外责任，如果需要购买地震保障，请额外购买地震责任http://baoxian.pingan.com/product/dizhenbaoxian.shtml，价格偏中等，考虑平安目前国内完善的服务网络，仍然推荐）\n\n### 推荐原因（2017年末）\n财险本身多数都是一年期短期险，财险公司也以打价格战闻名，大不了今年赔钱明年调高价格，先把客户吸引过来再说。而这款保险大概至少5年以来都维持在现在这个极低的价格，我还没有找到比它更便宜的，当然有个别公司“故意”做低一点想对标的，但是房屋保险属于保额很高保费很低的产品，特别还存在超高保额部分保额增长和保费增长并不是比例关系，这需要保险公司有非常大的盘子及像再保安排这样的风控措施去承担这种超高额赔付带来的损失波动（比如杭州保姆纵火案中遭受波及的豪宅邻居（林爸爸即使买了可能也无法获得理赔，因为是家庭雇佣人员的故意行为，属于除外）），风控措施不好很容易就会带来每年保费调整，而平安财险的承保池我认为已经足以支撑房屋保险可能会出现的大经验波动了，它能长时间维持现在这个价格就是一个证明。我通常不推荐短期险，但这个是例外。而目前房屋几乎是国内很多家庭单一最大资产，投保房屋保险非常重要，甚至比先帮你自己投保还重要。\n\n### 推荐原因（2019年初）\n现在看来没有任何财产险公司在这个产品上有打倒平安财的可能性，零。其实平安财还出了一款可以同时投保同一地区所有房屋的家财险，打个比方你在北京市朝阳区有20套房子，买它那一个产品一次就可以承保这20套房子，而价格仅较上面那个单一版本略为上涨（不是20倍，可能连20%都没有），但中国平安把它商标后缀改成“金融 科技”后它官网还是难用的一笔，我实在找不到那款产品的链接了，因此还是推荐原来这个吧。\n\n# 定期寿险\n## 华贵人寿大麦定期寿险\n新加入的搅局者，便宜！！！\n## 弘康人寿大白智能定寿\n目前在售的定寿产品比较：\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fyz719fwjtj30zk0otn0x.jpg)\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fyz71j8zpfj30zk0k3acm.jpg)\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fyz71rcb6rj313y0r0ae7.jpg)\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fyz71zql41j30zk0ezdhm.jpg)\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fyyz6rfvu0j31i70u0gup.jpg)\n## 渤海人寿优选定期寿险\n购买链接：在微信上搜索“渤海人寿“，关注其官方微信号，在官微上完成投保\n\n### 推荐理由（2017年末）\n渤海人寿这款产品虽然名字里有优选定期寿险字样，但它其实是一款“假”优选体定寿。渤海人寿可能出于促销或者想打开品牌等原因，它所谓的优选体实际上普通人完成健康告知既可以承保，不需要进行正常优选体定寿产品要求的体检，也就是相当于就是直接把优选体的费率拿出来当普通人群的费率来卖，因此价格非常非常非常便宜。有人说它的健康告知比较“苛刻“，我个人觉得和多数其他网销定寿产品并无实质性差异。\n\n由于定期寿险不像健康险一样有分支机构销售限制，也就是网销健康险你需要在当地省市有分公司才能网销到该地区。寿险可以无限制网销卖全国保单。这款几乎是我唯一推荐定期寿险。但是考虑我本文一开始那两个常见问题所遇到的情况，我还是要推荐多一顺位产品做备份。\n\n你会说还有很多很多某某产品价格也很有竞争力，我当然知道了，我比你们大多数人都熟悉人寿保险产品，但是我不也说了，我只推荐第一个把价格打到如此的产品，以资鼓励第一个吃螃蟹的。大家可以做对标这种“鸡贼“事（我也常做），但总要让大家知道第一个勇敢的人啊。\n\n### 推荐理由（2019年初）\n渤海人寿此款产品和我第1位拟推荐的贵了一点，但是还是在前年那波网销定寿大潮中第一个做到把价格打下一大截并且保持非常低的节奏，为鼓励这家艰难的公司（坐拥100多亿资本金但因为特殊原因开不了更多分支机构），我今年还是继续推荐它的优选定寿产品。\n\n\n\n","content":"<p>保险-防患于未然<br>参考：</p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/54116024\">https://zhuanlan.zhihu.com/p/54116024</a></li>\n<li><a href=\"https://www.zhihu.com/question/22316395/answer/100909780\">https://www.zhihu.com/question/22316395/answer/100909780</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21759861\">https://zhuanlan.zhihu.com/p/21759861</a></li>\n</ol>\n<span id=\"more\"></span>\n\n<h1 id=\"意外险\"><a href=\"#意外险\" class=\"headerlink\" title=\"意外险\"></a>意外险</h1><p>参考：<a href=\"https://mp.weixin.qq.com/s/5_w2bvV1QemnHGuZYqeFcA\">https://mp.weixin.qq.com/s/5_w2bvV1QemnHGuZYqeFcA</a></p>\n<h2 id=\"50w-成人意外险\"><a href=\"#50w-成人意外险\" class=\"headerlink\" title=\"50w 成人意外险\"></a>50w 成人意外险</h2><p><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fyy9venvp9j30gl0hhq6k.jpg\"></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><ul>\n<li>如果追求性价比：上海人寿小蜜蜂不仅价格最低，而且还有特定意外 20 万的额外赔付，意外医疗 5 万元也足够了，性价比非常高。</li>\n<li>如果想保障更全面：可以考虑众安全面无忧，包含 50 万的特定交通意外责任，不限社保用药，社保外可以报销 80%，综合保障还不错。</li>\n<li>如果想要猝死保障：微信护身福猝死保额最高，小米综合意外险、安意保也可以考虑，不过有必要提醒大家，应对猝死等身故风险，最应该购买的是 定期寿险。</li>\n</ul>\n<h2 id=\"100w-成人意外险\"><a href=\"#100w-成人意外险\" class=\"headerlink\" title=\"100w 成人意外险\"></a>100w 成人意外险</h2><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fyy9yivo80j30fs0go0w4.jpg\"></p>\n<h3 id=\"结论-1\"><a href=\"#结论-1\" class=\"headerlink\" title=\"结论\"></a>结论</h3><ul>\n<li>如果是女性用户：首推百万玫瑰女性意外险，100 万保额，3 万意外医疗不限社保用药，只需 299 元，1-2 类职业的女性朋友有福了。</li>\n<li>如果追求性价比：可以考虑小米意外险，100 万保额，5 万意外医疗，价格只需要 299 元，性价比非常高。</li>\n</ul>\n<h1 id=\"重疾险\"><a href=\"#重疾险\" class=\"headerlink\" title=\"重疾险\"></a>重疾险</h1><h2 id=\"百年康惠保重大疾病保险\"><a href=\"#百年康惠保重大疾病保险\" class=\"headerlink\" title=\"百年康惠保重大疾病保险\"></a>百年康惠保重大疾病保险</h2><ol>\n<li>百年康惠保（旗舰版）重大疾病保险</li>\n<li>百年康惠保重大疾病保险<br>康惠保旗舰版购买链接：<a href=\"http://www.kaixinbao.com/jiankang-baoxian/315704.shtml\">http://www.kaixinbao.com/jiankang-baoxian/315704.shtml</a><br>康惠保购买链接：<a href=\"http://www.kaixinbao.com/jiankang-baoxian/309551.shtml\">http://www.kaixinbao.com/jiankang-baoxian/309551.shtml</a><br>或登录百年人寿官网<a href=\"http://www.aeonlife.com.cn/news/2837.shtml%E6%89%AB%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%B4%AD%E4%B9%B0%EF%BC%88%E4%BB%85%E9%99%90%E5%BA%B7%E6%83%A0%E4%BF%9D%EF%BC%89\">http://www.aeonlife.com.cn/news/2837.shtml扫页面上的二维码购买（仅限康惠保）</a></li>\n</ol>\n<h3 id=\"推荐理由（2017年末）\"><a href=\"#推荐理由（2017年末）\" class=\"headerlink\" title=\"推荐理由（2017年末）\"></a>推荐理由（2017年末）</h3><p>因为第0位推荐买不了（如果看了我17年末推荐的，知道我说的是华夏人寿优优保重大疾病保险，今年为节省篇幅删了，因为不可能再上市了），只能推荐本产品了。不用看了，这款产品保险公司肯定赔钱，非常便宜。以后有没有公司能做到比它和华夏优优保更便宜？不太可能，除非脑子坏了。它在部分销售模式甚至还匪夷所思地提供“返佣”（我本人对“返佣”不评论，本文评论亦请勿宣导任何返佣方式，在评论包括留下私信方式的，必删）。当然等哪天华夏想开了又重新卖它的优优宝了，我就按优先推荐第一个打开市场局面的原则，不再推荐本产品。另外请注意它的附加轻症责任比较贵，只需购买主险重大疾病责任即可。当然我也说过很多次轻症并不是一个重要责任。百年人寿在全国开的机构亦已经比较多，相信能满足国内地理位置不同地方朋友的需求。</p>\n<h3 id=\"推荐理由（2019年初）\"><a href=\"#推荐理由（2019年初）\" class=\"headerlink\" title=\"推荐理由（2019年初）\"></a>推荐理由（2019年初）</h3><p>康惠保旗舰版的重疾责任部分为有史以来中国地区包括港澳台在内最便宜的单卖的长期重大疾病责任。“长期”在保险产品范畴里面除了意味着保险期间大于一年也意味着产品是保证费率保证续保，在中国只有人寿保险公司才能开展长期人身险业务，同时需要承担更大的风险并且有更复杂的监管要求，这也是为什么国内人寿保险公司比财产险公司牌照值钱，估值要更贵的原因之一。基本上符合投保要求的朋友我非常建议每一个人都买一份这个产品，因为不会再有如此便宜的重疾产品了。</p>\n<p>非要说康惠保旗舰版不好的地方就是，虽然它条款里写的中症和轻症责任为可选责任，也就是只有重大疾病责任是必选责任，其他可买可不买，但它目前实际销售中重大疾病责任只能与中轻症责任一起捆绑购买，而熟悉我回答的朋友都知道我李某对于轻症或者实际上是加强版轻症的中症兴趣不大，我希望你们的每一个保费花在最划算的地方。它仅在双十一期间短暂开放过重大疾病单独投保的窗口，直到我写这个回答这一刻都再没有出现过。</p>\n<p>所以还是把可以单独投保重大疾病责任的老康惠保列在这里，它也是极度便宜，当然纯重疾的价格还是比康惠保旗舰版纯重疾部分的价格略贵一点。</p>\n<p>但是即使搭配了可选的中轻症责任，康惠保两兄弟的价格基本还是秒了其他公司重疾产品一个太平洋。</p>\n<h2 id=\"国华华瑞国民定期重大疾病保险\"><a href=\"#国华华瑞国民定期重大疾病保险\" class=\"headerlink\" title=\"国华华瑞国民定期重大疾病保险\"></a>国华华瑞国民定期重大疾病保险</h2><ol>\n<li>国华华瑞1号国民定期重大疾病保险</li>\n<li>国华华瑞2号国民定期重大疾病保险<br>华瑞1号购买链接：<a href=\"http://www.huaruisales.com/mall/productDetail.html?itemcode=HRGW_0004\">http://www.huaruisales.com/mall/productDetail.html?itemcode=HRGW_0004</a> 扫页面上的二维码购买<br>华瑞2号购买链接：请在支付宝上的蚂蚁保险里找到国华人寿“成人及儿童长期重疾险”</li>\n</ol>\n<p>（华瑞保险为国华人寿全资保险销售公司，和百年康惠保旗舰版不在百年人寿官网卖一样，这两款重疾在国华人寿的官网也是没有的；基本可以认为华瑞2号其实就是华瑞1号国华人寿给支付宝的专供版。今年新上榜）</p>\n<h3 id=\"推荐理由\"><a href=\"#推荐理由\" class=\"headerlink\" title=\"推荐理由\"></a>推荐理由</h3><p>它的成人重疾部分没有第一名便宜，如能购买百年产品的并不推荐这款。我推荐的是18岁以下朋友去投保这个产品，它的少儿重疾部分费率非常低，并且提供保险期间为20年或30年的选择，特别适合为自己小孩买不起康惠保兄弟”保至70岁“和”保至终身“的朋友。我特别”讨厌“看到朋友圈发小孩得重疾需要轻松筹的，你们可以看看国华这款产品的保费有多低，你收入即使只有知乎平均收入的1&#x2F;10也能为自己的子女买得起。</p>\n<p>当然如果您经济能力如果能承受，建议还是买康惠保兄弟至少”保至70岁“的选择，因为他俩是有史以来最便宜的重疾产品。而目前国内重疾产品赔付经验一直在恶化（唉，就这样还有人说中国的重疾产品很难理赔），我个人预期未来重疾产品价格将可能上涨，现在能用最低的价格锁定风险长一点时间不是更好？</p>\n<h1 id=\"医疗险\"><a href=\"#医疗险\" class=\"headerlink\" title=\"医疗险\"></a>医疗险</h1><h2 id=\"人保健康健康金福悠享保个人医疗保险（2018款）\"><a href=\"#人保健康健康金福悠享保个人医疗保险（2018款）\" class=\"headerlink\" title=\"人保健康健康金福悠享保个人医疗保险（2018款）\"></a>人保健康健康金福悠享保个人医疗保险（2018款）</h2><p>购买链接：和PS独占美国末日一样，此产品为支付宝独占产品，在人保健康官网产品页面扫码跳转至支付宝，或者在支付宝蚂蚁保险搜索”好医保 长期医疗“。注意不是”好医保 住院医疗“，”好医保 住院医疗“为另一家保险公司承保，并不推荐，别看错了。</p>\n<p>推荐理由：由于医疗产品承保经验波动的天性，所以基本上市面是极少保证续保医疗险存在的。而我一向认为不能锁定长期风险的保险产品不是好的保险产品，所以对于疾病风险，我希望你们优先投保能最长可以将重大疾病风险锁定至终身的长期重疾保险。对于此类医疗风险，应该留给你的雇佣单位用团体保险承担（当然我也知道好的公司很少）。在你配置好足够的重疾保障后可以将本中端医疗产品作为一个可选项配置。当然，若果您现在经济能力还承受不了重疾，本产品可以作为一个初级风险保障配置，但是一旦有足够经济能力，还是应该立刻投保足额的重大疾病保险。</p>\n<p>作为目前市场唯二能保证续保6年的中端医疗产品（另外一款出来太晚，我只推荐第一个出来吃螃蟹的），续保6年在医疗险范畴也算很大的进步，而监管也早已锁死报备更高保证续保年限的通路，所以人保健这个产品卡死了目前市场最可能高的保证续保条件，也吊打了所有无法提供任何保证续保的财险公司的中端医疗产品。</p>\n<p>同时它的费率确实很便宜，至少购买后6年内不怕它消失。</p>\n<h1 id=\"财险\"><a href=\"#财险\" class=\"headerlink\" title=\"财险\"></a>财险</h1><h2 id=\"平安家庭财产保险组合\"><a href=\"#平安家庭财产保险组合\" class=\"headerlink\" title=\"平安家庭财产保险组合\"></a>平安家庭财产保险组合</h2><p>购买链接：<a href=\"http://baoxian.pingan.com/product/jiatingcaichanbaoxian.shtml\">http://baoxian.pingan.com/product/jiatingcaichanbaoxian.shtml</a></p>\n<p>（注意：我认为只需要保房屋主体结构责任即可，最多加保一个水暖管爆裂损失责任，其余责任属于不那么重要的添头。由于地震在房屋险为标准除外责任，如果需要购买地震保障，请额外购买地震责任<a href=\"http://baoxian.pingan.com/product/dizhenbaoxian.shtml%EF%BC%8C%E4%BB%B7%E6%A0%BC%E5%81%8F%E4%B8%AD%E7%AD%89%EF%BC%8C%E8%80%83%E8%99%91%E5%B9%B3%E5%AE%89%E7%9B%AE%E5%89%8D%E5%9B%BD%E5%86%85%E5%AE%8C%E5%96%84%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%EF%BC%8C%E4%BB%8D%E7%84%B6%E6%8E%A8%E8%8D%90%EF%BC%89\">http://baoxian.pingan.com/product/dizhenbaoxian.shtml，价格偏中等，考虑平安目前国内完善的服务网络，仍然推荐）</a></p>\n<h3 id=\"推荐原因（2017年末）\"><a href=\"#推荐原因（2017年末）\" class=\"headerlink\" title=\"推荐原因（2017年末）\"></a>推荐原因（2017年末）</h3><p>财险本身多数都是一年期短期险，财险公司也以打价格战闻名，大不了今年赔钱明年调高价格，先把客户吸引过来再说。而这款保险大概至少5年以来都维持在现在这个极低的价格，我还没有找到比它更便宜的，当然有个别公司“故意”做低一点想对标的，但是房屋保险属于保额很高保费很低的产品，特别还存在超高保额部分保额增长和保费增长并不是比例关系，这需要保险公司有非常大的盘子及像再保安排这样的风控措施去承担这种超高额赔付带来的损失波动（比如杭州保姆纵火案中遭受波及的豪宅邻居（林爸爸即使买了可能也无法获得理赔，因为是家庭雇佣人员的故意行为，属于除外）），风控措施不好很容易就会带来每年保费调整，而平安财险的承保池我认为已经足以支撑房屋保险可能会出现的大经验波动了，它能长时间维持现在这个价格就是一个证明。我通常不推荐短期险，但这个是例外。而目前房屋几乎是国内很多家庭单一最大资产，投保房屋保险非常重要，甚至比先帮你自己投保还重要。</p>\n<h3 id=\"推荐原因（2019年初）\"><a href=\"#推荐原因（2019年初）\" class=\"headerlink\" title=\"推荐原因（2019年初）\"></a>推荐原因（2019年初）</h3><p>现在看来没有任何财产险公司在这个产品上有打倒平安财的可能性，零。其实平安财还出了一款可以同时投保同一地区所有房屋的家财险，打个比方你在北京市朝阳区有20套房子，买它那一个产品一次就可以承保这20套房子，而价格仅较上面那个单一版本略为上涨（不是20倍，可能连20%都没有），但中国平安把它商标后缀改成“金融 科技”后它官网还是难用的一笔，我实在找不到那款产品的链接了，因此还是推荐原来这个吧。</p>\n<h1 id=\"定期寿险\"><a href=\"#定期寿险\" class=\"headerlink\" title=\"定期寿险\"></a>定期寿险</h1><h2 id=\"华贵人寿大麦定期寿险\"><a href=\"#华贵人寿大麦定期寿险\" class=\"headerlink\" title=\"华贵人寿大麦定期寿险\"></a>华贵人寿大麦定期寿险</h2><p>新加入的搅局者，便宜！！！</p>\n<h2 id=\"弘康人寿大白智能定寿\"><a href=\"#弘康人寿大白智能定寿\" class=\"headerlink\" title=\"弘康人寿大白智能定寿\"></a>弘康人寿大白智能定寿</h2><p>目前在售的定寿产品比较：<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fyz719fwjtj30zk0otn0x.jpg\"><br><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fyz71j8zpfj30zk0k3acm.jpg\"><br><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fyz71rcb6rj313y0r0ae7.jpg\"><br><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fyz71zql41j30zk0ezdhm.jpg\"><br><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fyyz6rfvu0j31i70u0gup.jpg\"></p>\n<h2 id=\"渤海人寿优选定期寿险\"><a href=\"#渤海人寿优选定期寿险\" class=\"headerlink\" title=\"渤海人寿优选定期寿险\"></a>渤海人寿优选定期寿险</h2><p>购买链接：在微信上搜索“渤海人寿“，关注其官方微信号，在官微上完成投保</p>\n<h3 id=\"推荐理由（2017年末）-1\"><a href=\"#推荐理由（2017年末）-1\" class=\"headerlink\" title=\"推荐理由（2017年末）\"></a>推荐理由（2017年末）</h3><p>渤海人寿这款产品虽然名字里有优选定期寿险字样，但它其实是一款“假”优选体定寿。渤海人寿可能出于促销或者想打开品牌等原因，它所谓的优选体实际上普通人完成健康告知既可以承保，不需要进行正常优选体定寿产品要求的体检，也就是相当于就是直接把优选体的费率拿出来当普通人群的费率来卖，因此价格非常非常非常便宜。有人说它的健康告知比较“苛刻“，我个人觉得和多数其他网销定寿产品并无实质性差异。</p>\n<p>由于定期寿险不像健康险一样有分支机构销售限制，也就是网销健康险你需要在当地省市有分公司才能网销到该地区。寿险可以无限制网销卖全国保单。这款几乎是我唯一推荐定期寿险。但是考虑我本文一开始那两个常见问题所遇到的情况，我还是要推荐多一顺位产品做备份。</p>\n<p>你会说还有很多很多某某产品价格也很有竞争力，我当然知道了，我比你们大多数人都熟悉人寿保险产品，但是我不也说了，我只推荐第一个把价格打到如此的产品，以资鼓励第一个吃螃蟹的。大家可以做对标这种“鸡贼“事（我也常做），但总要让大家知道第一个勇敢的人啊。</p>\n<h3 id=\"推荐理由（2019年初）-1\"><a href=\"#推荐理由（2019年初）-1\" class=\"headerlink\" title=\"推荐理由（2019年初）\"></a>推荐理由（2019年初）</h3><p>渤海人寿此款产品和我第1位拟推荐的贵了一点，但是还是在前年那波网销定寿大潮中第一个做到把价格打下一大截并且保持非常低的节奏，为鼓励这家艰难的公司（坐拥100多亿资本金但因为特殊原因开不了更多分支机构），我今年还是继续推荐它的优选定寿产品。</p>\n","slug":"保险配置","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/01/06/%E4%BF%9D%E9%99%A9%E9%85%8D%E7%BD%AE/","excerpt":"保险-防患于未然参考： https://zhuanlan.zhihu.com/p/54116024 https://www.zhihu.com/question/22316395/answer/100909780 https://zhuanlan.zhihu.com/p/21759861","categories":[{"name":"生活","slug":"生活","permalink":"http://vwin.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"保险","slug":"保险","permalink":"http://vwin.github.io/tags/%E4%BF%9D%E9%99%A9/"}]},{"title":"Jenkins高效插件整理","date":"2019-01-06T21:18:35.000Z","path":"2019/01/06/Jenkins-高效插件整理/","text":"开源版本的Jenkins 具有三大能力：Master-Slave的分布式构建调度能力、Pipeline编排能力、强大的开源生态（插件）能力。 2017年4月，Jenkins创始人KK（Kohsuke Kawaguchi ）来到中国，交流中他也明确表示Jenkins的成功主要取决于其开源生态系统，Jenkins有1400多个插件可供使用。因为有开源的插件生态系统的存在，Jenkins要用得好，插件一定是不能少的，需要我们充分发现和使用插件来实现我们的需求，而不是重复造轮子，自己去实现。 但是面对林林总总的插件，到底该怎么选？我的常用需求有哪些插件可以满足，笔者根据以往在企业中管理Jenkins的经验推荐如下常用的插件列表，希望大家基于Jenkins及其插件生态实现自己的持续交付与DevOps平台。 用户及权限Jenkins 用户权限管理是Jenkins Administration中非常很重要的环节，由于大部分企业都会有自己的域控管理，所以和LDAP集成并基于用户组实现权限模型设计与管理是企业级Jenkins实践的重要内容。 LDAP 这个插件允许使用LDAP对用户进行认证，LDAP 服务器可以为Active Directory 或者 OpenLDAP。 Active Directory 这个插件允许使用Active Directory对用户进行认证，同时结合诸如Matrix Authorization Strategy插件，可以识别用户所在的所有用户组，对用户授权进行灵活配置。基于Windows Active Directory进行域管理的企业，推荐采用Active Directory。 GitHub Authentication 这个插件提供了使用GitHub进行用户认证和授权的方案。 Gitlab Authentication 这个插件提供了使用GitLab进行用户认证和授权的方案。 Matrix Authorization Strategy 这个插件提供了基于矩阵的授权策略，支持全局和项目级别的配置。 Role-based Authorization Strategy 这个插件提供了一种基于角色（Role）的用户权限管理策略，支持创建global角色、Project角色、Slave角色，以及给用户分配这些角色。这款插件是最常用的Jenkins权限策略和管理插件。 代码管理Jenkins 项目中配置Source Code Management 去下载代码进行构建任务，是非常普遍的应用场景。Jenkins插件支持很多SCM的系统，使用最常见的是Git 和SVN。 Git 支持使用Github、GitLab、Gerrit等系统管理代码仓库。 Subversion 支持Subversion系统管理源代码。 项目及视图Jenkins中对Project 和 view的管理，是用户日常工作中使用很多的功能。 Folder 这个插件支持用户使用目录管理项目，目录支持嵌套，并且支持目录中创建视图。 List view Jenkins 默认支持List类型的视图，用户可以创建List视图过滤所关心的项目。 Sectioned View 这个插件支持一种新的视图，视图可以分为多个部分，每部分可以单独配置显示所选择的项目信息。 Nested View 这个插件支持一种新的视图，其表示直接显示项目，而是以目录图标显示所包含的子视图，每个子视图显示所选项目信息。 Build Pipeline 这个插件提供了一种Build Pipeline 视图，用于显示上、下游项目构建的关系。 构建触发Jenkins支持多种Build 触发方式，尤其一些自动化触发方式非常有用 Build periodically，Jenkins 内置功能，可以设置类似crontab时间，周期性地自动触发构建。Poll SCM，Jenkins 内置功能，类似Build periodically，可以设置类似crontab时间，不同的是不是直接进行构建，而是周期性地在后台检查所配置的SCM有没有更新，只有当有代码更新时才会触发构建。 Trigger builds remotely (e.g., from scripts)，Jenkins 内置功能，远程触发构建，通过设置token可以支持远程脚本中触发Jenkins构建。 Gerrit Trigger 这个插件将Jenkins集成到Gerrit code review中，支持Jenkins配置Gerrit服务器等信息，实现Gerrit event 触发Jenkins 构建。 GitLab 这个插件将Jenkins 集成到GitLab web hook中，支持Gitlab 分支及Merge Request等相关事件触发Jenkins构建。 GitHub Integration 这个插件将Jenkins集成到GitHub中，支持Gitgub分支及Pull requests 触发Jenkins 构建。 JIRA Trigger 这个插件将Jenkins集成到Jira WebHooks中，支持Jira issue的状态等变化时触发Jenkins构建。 构建参数Jenkins除了支持普通的参数类型（布尔型、字符串型、多行文本型、选择型和文件型 ）外，还有一些插件支持更加丰富实用的参数类型，比如参数间动态关联、多层级参数、隐藏参数等 。 nodelabelparameter 这个插件增加了一个新的参数类型，Node 和 Label，从而使用户通过参数可以选择项目构建运行的节点。其他插件不一一列举，可以查看插件说明 https://plugins.jenkins.io/hidden-parameter https://plugins.jenkins.io/extended-choice-parameter https://plugins.jenkins.io/validating-string-parameter https://plugins.jenkins.io/extensible-choice-parameter https://wiki.jenkins.io/display/JENKINS/Active+Choices+Plugin 构建任务及环境围绕构建任务，有许多小的插件，却提供了一些实用的功能 Workspace Cleanup 这个插件支持在构建前后 删除或者部分删除workspace description setter 这个插件支持正则表达式匹配构建log输出，设置构建的描述 build-name-setter 这个插件支持设置构建的显示名字，而不是默认的为#1，#2，……，#buildnum Environment Injector 这个插件支持在构建任务的不同阶段插入环境变量，并且在构建结束导出所有的环境变量等功能。 构建通知把构建状态及时地通知用户，是Jenkins的一个必不可少的功能。Jenkins支持多种主动和被动的通知方式。 Mailer 这个插件支持基本的邮件通知功能，比如构建失败和构建恢复成功可以发送邮件通知给相关人员。 Email Extension 这个插件是邮件通知的扩展，支持定制邮件内容，触发条件以及邮件接收者，功能比基本邮件通知要灵活强大的多。 Slack Notification 这个插件支持把构建结果推送到Slack channel。 容器化SlaveJenkins的Master-Slave架构实现了分布式构建，可以充分的横向扩展Slave来提升构建能力，将Slave容器化是目前主流的构建环境标准化、集群化和弹性化的方式。 https://plugins.jenkins.io/docker-plugin 这个插件可以配置docker host ，从而动态的提供Jenkins Agent（Slave），运行构建后再销毁这个slave。 https://plugins.jenkins.io/kubernetes 这个插件支持利用Kubernetes cluster 动态的提供Jenkins Agent（Slave），利用Kubernetes 调度机制来优化Jenkins 负载等。 Admin相关插件 Configuration Slicing https://plugins.jenkins.io/configurationslicing 这个插件支持批量修改项目配置 Mask Passwords https://plugins.jenkins.io/mask-passwords 这个插件支持遮挡构建log输出的password等敏感信息 Backup https://plugins.jenkins.io/backup 这个插件添加备份功能到Jenkins management","raw":"---\ntitle: Jenkins高效插件整理\ntoc: true\ndate: 2019-01-07 05:18:35\ntags: [Jenkins,插件]\ncategories: [测试]\ndescription:\n---\n开源版本的Jenkins 具有三大能力：Master-Slave的分布式构建调度能力、Pipeline编排能力、强大的开源生态（插件）能力。\n\n2017年4月，Jenkins创始人KK（Kohsuke Kawaguchi ）来到中国，交流中他也明确表示Jenkins的成功主要取决于其开源生态系统，Jenkins有1400多个插件可供使用。因为有开源的插件生态系统的存在，Jenkins要用得好，插件一定是不能少的，需要我们充分发现和使用插件来实现我们的需求，而不是重复造轮子，自己去实现。\n\n但是面对林林总总的插件，到底该怎么选？我的常用需求有哪些插件可以满足，笔者根据以往在企业中管理Jenkins的经验推荐如下常用的插件列表，希望大家基于Jenkins及其插件生态实现自己的持续交付与DevOps平台。\n<!--more-->\n\n# 用户及权限\nJenkins 用户权限管理是Jenkins Administration中非常很重要的环节，由于大部分企业都会有自己的域控管理，所以和LDAP集成并基于用户组实现权限模型设计与管理是企业级Jenkins实践的重要内容。\n1. [LDAP](https://plugins.jenkins.io/ldap) 这个插件允许使用LDAP对用户进行认证，LDAP 服务器可以为Active Directory 或者 OpenLDAP。\n2. [Active Directory](https://plugins.jenkins.io/active-directory)  这个插件允许使用Active Directory对用户进行认证，同时结合诸如Matrix Authorization Strategy插件，可以识别用户所在的所有用户组，对用户授权进行灵活配置。\n基于Windows Active Directory进行域管理的企业，推荐采用Active Directory。\n3. [GitHub Authentication](https://plugins.jenkins.io/github-oauth) 这个插件提供了使用GitHub进行用户认证和授权的方案。\n4. [Gitlab Authentication](https://plugins.jenkins.io/gitlab-oauth) 这个插件提供了使用GitLab进行用户认证和授权的方案。\n5. [Matrix Authorization Strategy](https://plugins.jenkins.io/matrix-auth) 这个插件提供了基于矩阵的授权策略，支持全局和项目级别的配置。\n6. [Role-based Authorization Strategy](https://plugins.jenkins.io/role-strategy) 这个插件提供了一种基于角色（Role）的用户权限管理策略，支持创建global角色、Project角色、Slave角色，以及给用户分配这些角色。这款插件是最常用的Jenkins权限策略和管理插件。\n\n# 代码管理\nJenkins 项目中配置Source Code Management 去下载代码进行构建任务，是非常普遍的应用场景。Jenkins插件支持很多SCM的系统，使用最常见的是Git 和SVN。\n\n1. [Git](https://plugins.jenkins.io/git) 支持使用Github、GitLab、Gerrit等系统管理代码仓库。\n2. [Subversion](https://plugins.jenkins.io/subversion) 支持Subversion系统管理源代码。\n\n# 项目及视图\nJenkins中对Project 和 view的管理，是用户日常工作中使用很多的功能。\n\n1. [Folder](https://plugins.jenkins.io/cloudbees-folder) 这个插件支持用户使用目录管理项目，目录支持嵌套，并且支持目录中创建视图。\n2. List view Jenkins 默认支持List类型的视图，用户可以创建List视图过滤所关心的项目。\n3. [Sectioned View](https://plugins.jenkins.io/sectioned-view) 这个插件支持一种新的视图，视图可以分为多个部分，每部分可以单独配置显示所选择的项目信息。\n4. [Nested View](https://plugins.jenkins.io/nested-view) 这个插件支持一种新的视图，其表示直接显示项目，而是以目录图标显示所包含的子视图，每个子视图显示所选项目信息。\n5. [Build Pipeline](https://plugins.jenkins.io/build-pipeline-plugin) 这个插件提供了一种Build Pipeline 视图，用于显示上、下游项目构建的关系。\n\n# 构建触发\nJenkins支持多种Build 触发方式，尤其一些自动化触发方式非常有用\n\n1. Build periodically，Jenkins 内置功能，可以设置类似crontab时间，周期性地自动触发构建。\nPoll SCM，Jenkins 内置功能，类似Build periodically，可以设置类似crontab时间，不同的是不是直接进行构建，而是周期性地在后台检查所配置的SCM有没有更新，只有当有代码更新时才会触发构建。\n2. Trigger builds remotely (e.g., from scripts)，Jenkins 内置功能，远程触发构建，通过设置token可以支持远程脚本中触发Jenkins构建。\n3. [Gerrit Trigger](https://plugins.jenkins.io/gerrit-trigger) 这个插件将Jenkins集成到Gerrit code review中，支持Jenkins配置Gerrit服务器等信息，实现Gerrit event 触发Jenkins 构建。\n4. [GitLab](https://plugins.jenkins.io/gitlab-plugin) 这个插件将Jenkins 集成到GitLab web hook中，支持Gitlab 分支及Merge Request等相关事件触发Jenkins构建。\n5. [GitHub Integration](https://plugins.jenkins.io/github-pullrequest) 这个插件将Jenkins集成到GitHub中，支持Gitgub分支及Pull requests 触发Jenkins 构建。\n6. [JIRA Trigger](https://plugins.jenkins.io/jira-trigger) 这个插件将Jenkins集成到Jira WebHooks中，支持Jira issue的状态等变化时触发Jenkins构建。\n\n# 构建参数\nJenkins除了支持普通的参数类型（布尔型、字符串型、多行文本型、选择型和文件型 ）外，还有一些插件支持更加丰富实用的参数类型，比如参数间动态关联、多层级参数、隐藏参数等 。\n\n1. [nodelabelparameter](https://plugins.jenkins.io/nodelabelparameter) 这个插件增加了一个新的参数类型，Node 和 Label，从而使用户通过参数可以选择项目构建运行的节点。\n其他插件不一一列举，可以查看插件说明\n   - https://plugins.jenkins.io/hidden-parameter\n   - https://plugins.jenkins.io/extended-choice-parameter\n   - https://plugins.jenkins.io/validating-string-parameter\n   - https://plugins.jenkins.io/extensible-choice-parameter\n   - https://wiki.jenkins.io/display/JENKINS/Active+Choices+Plugin\n\n# 构建任务及环境\n围绕构建任务，有许多小的插件，却提供了一些实用的功能\n\n1. [Workspace Cleanup](https://plugins.jenkins.io/ws-cleanup) 这个插件支持在构建前后 删除或者部分删除workspace\n2. [description setter](https://plugins.jenkins.io/description-setter) 这个插件支持正则表达式匹配构建log输出，设置构建的描述\n3. [build-name-setter](https://plugins.jenkins.io/build-name-setter) 这个插件支持设置构建的显示名字，而不是默认的为#1，#2，……，#buildnum\n4. [Environment Injector](https://plugins.jenkins.io/envinject) 这个插件支持在构建任务的不同阶段插入环境变量，并且在构建结束导出所有的环境变量等功能。\n\n# 构建通知\n把构建状态及时地通知用户，是Jenkins的一个必不可少的功能。Jenkins支持多种主动和被动的通知方式。\n\n1. [Mailer](https://plugins.jenkins.io/mailer) 这个插件支持基本的邮件通知功能，比如构建失败和构建恢复成功可以发送邮件通知给相关人员。\n2. [Email Extension](https://plugins.jenkins.io/email-ext) 这个插件是邮件通知的扩展，支持定制邮件内容，触发条件以及邮件接收者，功能比基本邮件通知要灵活强大的多。\n3. [Slack Notification](https://plugins.jenkins.io/slack) 这个插件支持把构建结果推送到Slack channel。\n\n# 容器化Slave\nJenkins的Master-Slave架构实现了分布式构建，可以充分的横向扩展Slave来提升构建能力，将Slave容器化是目前主流的构建环境标准化、集群化和弹性化的方式。\n\n1. https://plugins.jenkins.io/docker-plugin 这个插件可以配置docker host ，从而动态的提供Jenkins Agent（Slave），运行构建后再销毁这个slave。\n2. https://plugins.jenkins.io/kubernetes 这个插件支持利用Kubernetes  cluster 动态的提供Jenkins Agent（Slave），利用Kubernetes 调度机制来优化Jenkins 负载等。\n\n# Admin相关插件\n1. Configuration Slicing  https://plugins.jenkins.io/configurationslicing 这个插件支持批量修改项目配置\n2. Mask Passwords https://plugins.jenkins.io/mask-passwords 这个插件支持遮挡构建log输出的password等敏感信息\n3. Backup https://plugins.jenkins.io/backup 这个插件添加备份功能到Jenkins management\n","content":"<p>开源版本的Jenkins 具有三大能力：Master-Slave的分布式构建调度能力、Pipeline编排能力、强大的开源生态（插件）能力。</p>\n<p>2017年4月，Jenkins创始人KK（Kohsuke Kawaguchi ）来到中国，交流中他也明确表示Jenkins的成功主要取决于其开源生态系统，Jenkins有1400多个插件可供使用。因为有开源的插件生态系统的存在，Jenkins要用得好，插件一定是不能少的，需要我们充分发现和使用插件来实现我们的需求，而不是重复造轮子，自己去实现。</p>\n<p>但是面对林林总总的插件，到底该怎么选？我的常用需求有哪些插件可以满足，笔者根据以往在企业中管理Jenkins的经验推荐如下常用的插件列表，希望大家基于Jenkins及其插件生态实现自己的持续交付与DevOps平台。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"用户及权限\"><a href=\"#用户及权限\" class=\"headerlink\" title=\"用户及权限\"></a>用户及权限</h1><p>Jenkins 用户权限管理是Jenkins Administration中非常很重要的环节，由于大部分企业都会有自己的域控管理，所以和LDAP集成并基于用户组实现权限模型设计与管理是企业级Jenkins实践的重要内容。</p>\n<ol>\n<li><a href=\"https://plugins.jenkins.io/ldap\">LDAP</a> 这个插件允许使用LDAP对用户进行认证，LDAP 服务器可以为Active Directory 或者 OpenLDAP。</li>\n<li><a href=\"https://plugins.jenkins.io/active-directory\">Active Directory</a>  这个插件允许使用Active Directory对用户进行认证，同时结合诸如Matrix Authorization Strategy插件，可以识别用户所在的所有用户组，对用户授权进行灵活配置。<br>基于Windows Active Directory进行域管理的企业，推荐采用Active Directory。</li>\n<li><a href=\"https://plugins.jenkins.io/github-oauth\">GitHub Authentication</a> 这个插件提供了使用GitHub进行用户认证和授权的方案。</li>\n<li><a href=\"https://plugins.jenkins.io/gitlab-oauth\">Gitlab Authentication</a> 这个插件提供了使用GitLab进行用户认证和授权的方案。</li>\n<li><a href=\"https://plugins.jenkins.io/matrix-auth\">Matrix Authorization Strategy</a> 这个插件提供了基于矩阵的授权策略，支持全局和项目级别的配置。</li>\n<li><a href=\"https://plugins.jenkins.io/role-strategy\">Role-based Authorization Strategy</a> 这个插件提供了一种基于角色（Role）的用户权限管理策略，支持创建global角色、Project角色、Slave角色，以及给用户分配这些角色。这款插件是最常用的Jenkins权限策略和管理插件。</li>\n</ol>\n<h1 id=\"代码管理\"><a href=\"#代码管理\" class=\"headerlink\" title=\"代码管理\"></a>代码管理</h1><p>Jenkins 项目中配置Source Code Management 去下载代码进行构建任务，是非常普遍的应用场景。Jenkins插件支持很多SCM的系统，使用最常见的是Git 和SVN。</p>\n<ol>\n<li><a href=\"https://plugins.jenkins.io/git\">Git</a> 支持使用Github、GitLab、Gerrit等系统管理代码仓库。</li>\n<li><a href=\"https://plugins.jenkins.io/subversion\">Subversion</a> 支持Subversion系统管理源代码。</li>\n</ol>\n<h1 id=\"项目及视图\"><a href=\"#项目及视图\" class=\"headerlink\" title=\"项目及视图\"></a>项目及视图</h1><p>Jenkins中对Project 和 view的管理，是用户日常工作中使用很多的功能。</p>\n<ol>\n<li><a href=\"https://plugins.jenkins.io/cloudbees-folder\">Folder</a> 这个插件支持用户使用目录管理项目，目录支持嵌套，并且支持目录中创建视图。</li>\n<li>List view Jenkins 默认支持List类型的视图，用户可以创建List视图过滤所关心的项目。</li>\n<li><a href=\"https://plugins.jenkins.io/sectioned-view\">Sectioned View</a> 这个插件支持一种新的视图，视图可以分为多个部分，每部分可以单独配置显示所选择的项目信息。</li>\n<li><a href=\"https://plugins.jenkins.io/nested-view\">Nested View</a> 这个插件支持一种新的视图，其表示直接显示项目，而是以目录图标显示所包含的子视图，每个子视图显示所选项目信息。</li>\n<li><a href=\"https://plugins.jenkins.io/build-pipeline-plugin\">Build Pipeline</a> 这个插件提供了一种Build Pipeline 视图，用于显示上、下游项目构建的关系。</li>\n</ol>\n<h1 id=\"构建触发\"><a href=\"#构建触发\" class=\"headerlink\" title=\"构建触发\"></a>构建触发</h1><p>Jenkins支持多种Build 触发方式，尤其一些自动化触发方式非常有用</p>\n<ol>\n<li>Build periodically，Jenkins 内置功能，可以设置类似crontab时间，周期性地自动触发构建。<br>Poll SCM，Jenkins 内置功能，类似Build periodically，可以设置类似crontab时间，不同的是不是直接进行构建，而是周期性地在后台检查所配置的SCM有没有更新，只有当有代码更新时才会触发构建。</li>\n<li>Trigger builds remotely (e.g., from scripts)，Jenkins 内置功能，远程触发构建，通过设置token可以支持远程脚本中触发Jenkins构建。</li>\n<li><a href=\"https://plugins.jenkins.io/gerrit-trigger\">Gerrit Trigger</a> 这个插件将Jenkins集成到Gerrit code review中，支持Jenkins配置Gerrit服务器等信息，实现Gerrit event 触发Jenkins 构建。</li>\n<li><a href=\"https://plugins.jenkins.io/gitlab-plugin\">GitLab</a> 这个插件将Jenkins 集成到GitLab web hook中，支持Gitlab 分支及Merge Request等相关事件触发Jenkins构建。</li>\n<li><a href=\"https://plugins.jenkins.io/github-pullrequest\">GitHub Integration</a> 这个插件将Jenkins集成到GitHub中，支持Gitgub分支及Pull requests 触发Jenkins 构建。</li>\n<li><a href=\"https://plugins.jenkins.io/jira-trigger\">JIRA Trigger</a> 这个插件将Jenkins集成到Jira WebHooks中，支持Jira issue的状态等变化时触发Jenkins构建。</li>\n</ol>\n<h1 id=\"构建参数\"><a href=\"#构建参数\" class=\"headerlink\" title=\"构建参数\"></a>构建参数</h1><p>Jenkins除了支持普通的参数类型（布尔型、字符串型、多行文本型、选择型和文件型 ）外，还有一些插件支持更加丰富实用的参数类型，比如参数间动态关联、多层级参数、隐藏参数等 。</p>\n<ol>\n<li><a href=\"https://plugins.jenkins.io/nodelabelparameter\">nodelabelparameter</a> 这个插件增加了一个新的参数类型，Node 和 Label，从而使用户通过参数可以选择项目构建运行的节点。<br>其他插件不一一列举，可以查看插件说明<ul>\n<li><a href=\"https://plugins.jenkins.io/hidden-parameter\">https://plugins.jenkins.io/hidden-parameter</a></li>\n<li><a href=\"https://plugins.jenkins.io/extended-choice-parameter\">https://plugins.jenkins.io/extended-choice-parameter</a></li>\n<li><a href=\"https://plugins.jenkins.io/validating-string-parameter\">https://plugins.jenkins.io/validating-string-parameter</a></li>\n<li><a href=\"https://plugins.jenkins.io/extensible-choice-parameter\">https://plugins.jenkins.io/extensible-choice-parameter</a></li>\n<li><a href=\"https://wiki.jenkins.io/display/JENKINS/Active+Choices+Plugin\">https://wiki.jenkins.io/display/JENKINS/Active+Choices+Plugin</a></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"构建任务及环境\"><a href=\"#构建任务及环境\" class=\"headerlink\" title=\"构建任务及环境\"></a>构建任务及环境</h1><p>围绕构建任务，有许多小的插件，却提供了一些实用的功能</p>\n<ol>\n<li><a href=\"https://plugins.jenkins.io/ws-cleanup\">Workspace Cleanup</a> 这个插件支持在构建前后 删除或者部分删除workspace</li>\n<li><a href=\"https://plugins.jenkins.io/description-setter\">description setter</a> 这个插件支持正则表达式匹配构建log输出，设置构建的描述</li>\n<li><a href=\"https://plugins.jenkins.io/build-name-setter\">build-name-setter</a> 这个插件支持设置构建的显示名字，而不是默认的为#1，#2，……，#buildnum</li>\n<li><a href=\"https://plugins.jenkins.io/envinject\">Environment Injector</a> 这个插件支持在构建任务的不同阶段插入环境变量，并且在构建结束导出所有的环境变量等功能。</li>\n</ol>\n<h1 id=\"构建通知\"><a href=\"#构建通知\" class=\"headerlink\" title=\"构建通知\"></a>构建通知</h1><p>把构建状态及时地通知用户，是Jenkins的一个必不可少的功能。Jenkins支持多种主动和被动的通知方式。</p>\n<ol>\n<li><a href=\"https://plugins.jenkins.io/mailer\">Mailer</a> 这个插件支持基本的邮件通知功能，比如构建失败和构建恢复成功可以发送邮件通知给相关人员。</li>\n<li><a href=\"https://plugins.jenkins.io/email-ext\">Email Extension</a> 这个插件是邮件通知的扩展，支持定制邮件内容，触发条件以及邮件接收者，功能比基本邮件通知要灵活强大的多。</li>\n<li><a href=\"https://plugins.jenkins.io/slack\">Slack Notification</a> 这个插件支持把构建结果推送到Slack channel。</li>\n</ol>\n<h1 id=\"容器化Slave\"><a href=\"#容器化Slave\" class=\"headerlink\" title=\"容器化Slave\"></a>容器化Slave</h1><p>Jenkins的Master-Slave架构实现了分布式构建，可以充分的横向扩展Slave来提升构建能力，将Slave容器化是目前主流的构建环境标准化、集群化和弹性化的方式。</p>\n<ol>\n<li><a href=\"https://plugins.jenkins.io/docker-plugin\">https://plugins.jenkins.io/docker-plugin</a> 这个插件可以配置docker host ，从而动态的提供Jenkins Agent（Slave），运行构建后再销毁这个slave。</li>\n<li><a href=\"https://plugins.jenkins.io/kubernetes\">https://plugins.jenkins.io/kubernetes</a> 这个插件支持利用Kubernetes  cluster 动态的提供Jenkins Agent（Slave），利用Kubernetes 调度机制来优化Jenkins 负载等。</li>\n</ol>\n<h1 id=\"Admin相关插件\"><a href=\"#Admin相关插件\" class=\"headerlink\" title=\"Admin相关插件\"></a>Admin相关插件</h1><ol>\n<li>Configuration Slicing  <a href=\"https://plugins.jenkins.io/configurationslicing\">https://plugins.jenkins.io/configurationslicing</a> 这个插件支持批量修改项目配置</li>\n<li>Mask Passwords <a href=\"https://plugins.jenkins.io/mask-passwords\">https://plugins.jenkins.io/mask-passwords</a> 这个插件支持遮挡构建log输出的password等敏感信息</li>\n<li>Backup <a href=\"https://plugins.jenkins.io/backup\">https://plugins.jenkins.io/backup</a> 这个插件添加备份功能到Jenkins management</li>\n</ol>\n","slug":"Jenkins-高效插件整理","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2019/01/06/Jenkins-%E9%AB%98%E6%95%88%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/","excerpt":"开源版本的Jenkins 具有三大能力：Master-Slave的分布式构建调度能力、Pipeline编排能力、强大的开源生态（插件）能力。 2017年4月，Jenkins创始人KK（Kohsuke Kawaguchi ）来到中国，交流中他也明确表示Jenkins的成功主要取决于其开源生态系统，Jenkins有1400多个插件可供使用。因为有开源的插件生态系统的存在，Jenkins要用得好，插件一定是不能少的，需要我们充分发现和使用插件来实现我们的需求，而不是重复造轮子，自己去实现。 但是面对林林总总的插件，到底该怎么选？我的常用需求有哪些插件可以满足，笔者根据以往在企业中管理Jenkins的经验推荐如下常用的插件列表，希望大家基于Jenkins及其插件生态实现自己的持续交付与DevOps平台。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://vwin.github.io/tags/Jenkins/"},{"name":"插件","slug":"插件","permalink":"http://vwin.github.io/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"WebSocket学习","date":"2018-12-28T19:07:49.000Z","path":"2018/12/28/WebSocket学习/","text":"WebSocket 是一种网络通信协议，很多高级功能都需要它。本文介绍 WebSocket 协议的使用方法。 为什么需要 WebSocket？初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 ws:&#x2F;&#x2F;example.com:80&#x2F;some&#x2F;path 客户端的简单示例WebSocket 的用法相当简单。 下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。 123456789101112131415var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) &#123; console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;);&#125;;ws.onmessage = function(evt) &#123; console.log( &quot;Received Message: &quot; + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log(&quot;Connection closed.&quot;);&#125;; 客户端的 APIWebSocket 客户端的 API 如下。 WebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket(&#x27;ws://localhost:8080&#x27;); 执行上面语句之后，客户端就会与服务器进行连接。 webSocket.readyStatereadyState属性返回实例对象的当前状态，共有四种。 1234CONNECTING：值为0，表示正在连接。OPEN：值为1，表示连接成功，可以通信了。CLOSING：值为2，表示连接正在关闭。CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个示例。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; webSocket.onopen实例对象的onopen属性，用于指定连接成功后的回调函数。 123ws.onopen = function () &#123; ws.send(&#x27;Hello Server!&#x27;);&#125; 如果要指定多个回调函数，可以使用addEventListener方法。 123ws.addEventListener(&#x27;open&#x27;, function (event) &#123; ws.send(&#x27;Hello Server!&#x27;);&#125;); webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。 12345678910111213ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener(&quot;close&quot;, function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); webSocket.onmessage实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 123456789ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener(&quot;message&quot;, function(event) &#123; var data = event.data; // 处理数据&#125;); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。 12345678910ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log(&quot;Received data string&quot;); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log(&quot;Received arraybuffer&quot;); &#125;&#125; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。 1234567891011// 收到的是 blob 数据ws.binaryType = &quot;blob&quot;;ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = &quot;arraybuffer&quot;;ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; webSocket.send()实例对象的send()方法用于向服务器发送数据。 发送文本的例子。 12ws.send(&#x27;your message&#x27;); 发送 Blob 对象的例子。 1234var file = document .querySelector(&#x27;input[type=&quot;file&quot;]&#x27;) .files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 1234567// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); webSocket.bufferedAmount实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。 12345678var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; webSocket.onerror实例对象的onerror属性，用于指定报错时的回调函数。 1234567socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener(&quot;error&quot;, function(event) &#123; // handle error event&#125;); 服务端的实现WebSocket 服务器的实现，可以查看维基百科的列表。 常用的 Node 实现有以下三种。 µWebSockets Socket.IO WebSocket-Node 具体的用法请查看它们的文档，这里不详细介绍了。 WebSocketd下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。 它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。 举例来说，下面是一个 Bash 脚本counter.sh。 1234567891011#!/bin/bashecho 1sleep 1echo 2sleep 1echo 3 命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。 1234$ bash ./counter.sh123 现在，启动websocketd，指定这个脚本作为服务。 1$ websocketd --port=8080 bash ./counter.sh 上面的命令会启动一个 WebSocket 服务器，端口是8080。每当客户端连接这个服务器，就会执行counter.sh脚本，并将它的输出推送给客户端。 12345var ws = new WebSocket(&#x27;ws://localhost:8080/&#x27;);ws.onmessage = function(event) &#123; console.log(event.data);&#125;; 上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。 有了它，就可以很方便地将命令行的输出，发给浏览器。 1$ websocketd --port=8080 ls 上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。 更多的用法可以参考官方示例。 Bash 脚本读取客户端输入的例子；五行代码实现一个最简单的聊天服务器 websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务greeter.js。 12345678process.stdin.setEncoding(&#x27;utf8&#x27;);process.stdin.on(&#x27;readable&#x27;, function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write(&#x27;data: &#x27; + chunk); &#125;&#125;); 启动这个脚本的命令如下。 1$ websocketd --port=8080 node ./greeter.js 官方仓库还有其他各种语言的例子。 七、参考链接How to Use WebSockets WebSockets - Send &amp; Receive Messages Introducing WebSockets: Bringing Sockets to the Web 阮一峰博客","raw":"---\ntitle: WebSocket学习\ntoc: true\ndate: 2018-12-29 03:07:49\ntags: [websocket,http]\ncategories: [技术]\ndescription:\n---\nWebSocket 是一种网络通信协议，很多高级功能都需要它。\n本文介绍 WebSocket 协议的使用方法。\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fynojzlbryj30b404cglv.jpg)\n\n<!--more-->\n\n# 为什么需要 WebSocket？\n初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？\n答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。\n举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fynok2w9ohj30hq0dbaao.jpg)\n\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用\"轮询\"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。\n\n轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。\n\n# 简介\nWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。\n\n它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fynoks9d3pj30hg0e73zy.jpg)\n\n其他特点包括：\n\n1. 建立在 TCP 协议之上，服务器端的实现比较容易。\n2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n3. 数据格式比较轻量，性能开销小，通信高效。\n4. 可以发送文本，也可以发送二进制数据。\n5. 没有同源限制，客户端可以与任意服务器通信。\n6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n\n> ws://example.com:80/some/path\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fynolibqubj30bm08oaao.jpg)\n\n# 客户端的简单示例\nWebSocket 的用法相当简单。\n\n下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。\n\n```js\nvar ws = new WebSocket(\"wss://echo.websocket.org\");\n\nws.onopen = function(evt) { \n  console.log(\"Connection open ...\"); \n  ws.send(\"Hello WebSockets!\");\n};\n\nws.onmessage = function(evt) {\n  console.log( \"Received Message: \" + evt.data);\n  ws.close();\n};\n\nws.onclose = function(evt) {\n  console.log(\"Connection closed.\");\n};      \n```\n\n# 客户端的 API\nWebSocket 客户端的 API 如下。\n\n## WebSocket 构造函数\nWebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。\n\n```js\nvar ws = new WebSocket('ws://localhost:8080');\n```\n执行上面语句之后，客户端就会与服务器进行连接。\n\n## webSocket.readyState\nreadyState属性返回实例对象的当前状态，共有四种。\n\n```shell\nCONNECTING：值为0，表示正在连接。\nOPEN：值为1，表示连接成功，可以通信了。\nCLOSING：值为2，表示连接正在关闭。\nCLOSED：值为3，表示连接已经关闭，或者打开连接失败。\n```\n下面是一个示例。\n```js\nswitch (ws.readyState) {\n  case WebSocket.CONNECTING:\n    // do something\n    break;\n  case WebSocket.OPEN:\n    // do something\n    break;\n  case WebSocket.CLOSING:\n    // do something\n    break;\n  case WebSocket.CLOSED:\n    // do something\n    break;\n  default:\n    // this never happens\n    break;\n}\n```\n## webSocket.onopen\n实例对象的onopen属性，用于指定连接成功后的回调函数。\n\n```js\nws.onopen = function () {\n  ws.send('Hello Server!');\n}\n```\n如果要指定多个回调函数，可以使用addEventListener方法。\n\n```js\nws.addEventListener('open', function (event) {\n  ws.send('Hello Server!');\n});\n```\n\n## webSocket.onclose\n实例对象的onclose属性，用于指定连接关闭后的回调函数。\n\n```js\nws.onclose = function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n};\n\nws.addEventListener(\"close\", function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n});\n```\n## webSocket.onmessage\n实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。\n\n```js\nws.onmessage = function(event) {\n  var data = event.data;\n  // 处理数据\n};\n\nws.addEventListener(\"message\", function(event) {\n  var data = event.data;\n  // 处理数据\n});\n```\n注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。\n\n```js\nws.onmessage = function(event){\n  if(typeof event.data === String) {\n    console.log(\"Received data string\");\n  }\n\n  if(event.data instanceof ArrayBuffer){\n    var buffer = event.data;\n    console.log(\"Received arraybuffer\");\n  }\n}\n```\n除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。\n\n```js\n// 收到的是 blob 数据\nws.binaryType = \"blob\";\nws.onmessage = function(e) {\n  console.log(e.data.size);\n};\n\n// 收到的是 ArrayBuffer 数据\nws.binaryType = \"arraybuffer\";\nws.onmessage = function(e) {\n  console.log(e.data.byteLength);\n};\n```\n## webSocket.send()\n实例对象的send()方法用于向服务器发送数据。\n\n发送文本的例子。\n```js\n\nws.send('your message');\n```\n\n发送 Blob 对象的例子。\n\n```js\nvar file = document\n  .querySelector('input[type=\"file\"]')\n  .files[0];\nws.send(file);\n```\n发送 ArrayBuffer 对象的例子。\n\n```js\n// Sending canvas ImageData as ArrayBuffer\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i < img.data.length; i++) {\n  binary[i] = img.data[i];\n}\nws.send(binary.buffer);\n```\n## webSocket.bufferedAmount\n实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。\n\n```js\nvar data = new ArrayBuffer(10000000);\nsocket.send(data);\n\nif (socket.bufferedAmount === 0) {\n  // 发送完毕\n} else {\n  // 发送还没结束\n}\n```\n\n## webSocket.onerror\n实例对象的onerror属性，用于指定报错时的回调函数。\n\n```js\nsocket.onerror = function(event) {\n  // handle error event\n};\n\nsocket.addEventListener(\"error\", function(event) {\n  // handle error event\n});\n```\n# 服务端的实现\nWebSocket 服务器的实现，可以查看维基百科的列表。\n\n常用的 Node 实现有以下三种。\n1. [µWebSockets](https://github.com/uWebSockets/uWebSockets)\n2. [Socket.IO](http://socket.io/)\n3. [WebSocket-Node](https://github.com/theturtle32/WebSocket-Node)\n   \n具体的用法请查看它们的文档，这里不详细介绍了。\n\n# WebSocketd\n下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。\n\n它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fynopud1poj30go081wf9.jpg)\n\n\n举例来说，下面是一个 Bash 脚本counter.sh。\n```shell\n\n#!/bin/bash\n\necho 1\nsleep 1\n\necho 2\nsleep 1\n\n\necho 3\n```\n命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。\n\n```shell\n$ bash ./counter.sh\n1\n2\n3\n```\n现在，启动websocketd，指定这个脚本作为服务。\n\n```shell\n$ websocketd --port=8080 bash ./counter.sh\n```\n上面的命令会启动一个 WebSocket 服务器，端口是8080。每当客户端连接这个服务器，就会执行counter.sh脚本，并将它的输出推送给客户端。\n\n```js\nvar ws = new WebSocket('ws://localhost:8080/');\n\nws.onmessage = function(event) {\n  console.log(event.data);\n};\n```\n上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。\n\n有了它，就可以很方便地将命令行的输出，发给浏览器。\n\n```shell\n$ websocketd --port=8080 ls\n```\n上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fynos0nf9sj30go0ct3zs.jpg)\n\n更多的用法可以参考[官方示例](https://github.com/joewalnes/websocketd/tree/master/examples/bash)。\n\n\n>Bash 脚本读取客户端输入的例子；五行代码实现一个最简单的聊天服务器\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fynosmjojhj30ib08kjsg.jpg)\nwebsocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务greeter.js。\n```js\nprocess.stdin.setEncoding('utf8');\n\nprocess.stdin.on('readable', function() {\n  var chunk = process.stdin.read();\n  if (chunk !== null) {\n    process.stdout.write('data: ' + chunk);\n  }\n});\n```\n启动这个脚本的命令如下。\n\n```shell\n$ websocketd --port=8080 node ./greeter.js\n```\n官方仓库还有其他各种语言的例子。\n\n# 七、参考链接\n[How to Use WebSockets](http://cjihrig.com/blog/how-to-use-websockets/)\n\n[WebSockets - Send & Receive Messages](https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm)\n\n[Introducing WebSockets: Bringing Sockets to the Web](https://www.html5rocks.com/en/tutorials/websockets/basics/)\n\n[阮一峰博客](http://www.ruanyifeng.com/blog/2017/05/websocket.html)","content":"<p>WebSocket 是一种网络通信协议，很多高级功能都需要它。<br>本文介绍 WebSocket 协议的使用方法。<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fynojzlbryj30b404cglv.jpg\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"为什么需要-WebSocket？\"><a href=\"#为什么需要-WebSocket？\" class=\"headerlink\" title=\"为什么需要 WebSocket？\"></a>为什么需要 WebSocket？</h1><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？<br>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。<br>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fynok2w9ohj30hq0dbaao.jpg\"></p>\n<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>\n<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>\n<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fynoks9d3pj30hg0e73zy.jpg\"></p>\n<p>其他特点包括：</p>\n<ol>\n<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>\n<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>\n<li>数据格式比较轻量，性能开销小，通信高效。</li>\n<li>可以发送文本，也可以发送二进制数据。</li>\n<li>没有同源限制，客户端可以与任意服务器通信。</li>\n<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li>\n</ol>\n<blockquote>\n<p>ws:&#x2F;&#x2F;example.com:80&#x2F;some&#x2F;path</p>\n</blockquote>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fynolibqubj30bm08oaao.jpg\"></p>\n<h1 id=\"客户端的简单示例\"><a href=\"#客户端的简单示例\" class=\"headerlink\" title=\"客户端的简单示例\"></a>客户端的简单示例</h1><p>WebSocket 的用法相当简单。</p>\n<p>下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>(<span class=\"string\">&quot;wss://echo.websocket.org&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ws.<span class=\"property\">onopen</span> = <span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) &#123; </span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Connection open ...&quot;</span>); </span><br><span class=\"line\">  ws.<span class=\"title function_\">send</span>(<span class=\"string\">&quot;Hello WebSockets!&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&quot;Received Message: &quot;</span> + evt.<span class=\"property\">data</span>);</span><br><span class=\"line\">  ws.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.<span class=\"property\">onclose</span> = <span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Connection closed.&quot;</span>);</span><br><span class=\"line\">&#125;;      </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"客户端的-API\"><a href=\"#客户端的-API\" class=\"headerlink\" title=\"客户端的 API\"></a>客户端的 API</h1><p>WebSocket 客户端的 API 如下。</p>\n<h2 id=\"WebSocket-构造函数\"><a href=\"#WebSocket-构造函数\" class=\"headerlink\" title=\"WebSocket 构造函数\"></a>WebSocket 构造函数</h2><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>(<span class=\"string\">&#x27;ws://localhost:8080&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>执行上面语句之后，客户端就会与服务器进行连接。</p>\n<h2 id=\"webSocket-readyState\"><a href=\"#webSocket-readyState\" class=\"headerlink\" title=\"webSocket.readyState\"></a>webSocket.readyState</h2><p>readyState属性返回实例对象的当前状态，共有四种。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONNECTING：值为0，表示正在连接。</span><br><span class=\"line\">OPEN：值为1，表示连接成功，可以通信了。</span><br><span class=\"line\">CLOSING：值为2，表示连接正在关闭。</span><br><span class=\"line\">CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</span><br></pre></td></tr></table></figure>\n<p>下面是一个示例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (ws.<span class=\"property\">readyState</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"title class_\">WebSocket</span>.<span class=\"property\">CONNECTING</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"title class_\">WebSocket</span>.<span class=\"property\">OPEN</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"title class_\">WebSocket</span>.<span class=\"property\">CLOSING</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"title class_\">WebSocket</span>.<span class=\"property\">CLOSED</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"attr\">default</span>:</span><br><span class=\"line\">    <span class=\"comment\">// this never happens</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"webSocket-onopen\"><a href=\"#webSocket-onopen\" class=\"headerlink\" title=\"webSocket.onopen\"></a>webSocket.onopen</h2><p>实例对象的onopen属性，用于指定连接成功后的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws.<span class=\"property\">onopen</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  ws.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;Hello Server!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要指定多个回调函数，可以使用addEventListener方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;open&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  ws.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;Hello Server!&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"webSocket-onclose\"><a href=\"#webSocket-onclose\" class=\"headerlink\" title=\"webSocket.onclose\"></a>webSocket.onclose</h2><p>实例对象的onclose属性，用于指定连接关闭后的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws.<span class=\"property\">onclose</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> code = event.<span class=\"property\">code</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> reason = event.<span class=\"property\">reason</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wasClean = event.<span class=\"property\">wasClean</span>;</span><br><span class=\"line\">  <span class=\"comment\">// handle close event</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;close&quot;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> code = event.<span class=\"property\">code</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> reason = event.<span class=\"property\">reason</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wasClean = event.<span class=\"property\">wasClean</span>;</span><br><span class=\"line\">  <span class=\"comment\">// handle close event</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"webSocket-onmessage\"><a href=\"#webSocket-onmessage\" class=\"headerlink\" title=\"webSocket.onmessage\"></a>webSocket.onmessage</h2><p>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = event.<span class=\"property\">data</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数据</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;message&quot;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = event.<span class=\"property\">data</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数据</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> event.<span class=\"property\">data</span> === <span class=\"title class_\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Received data string&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(event.<span class=\"property\">data</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">ArrayBuffer</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buffer = event.<span class=\"property\">data</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Received arraybuffer&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 收到的是 blob 数据</span></span><br><span class=\"line\">ws.<span class=\"property\">binaryType</span> = <span class=\"string\">&quot;blob&quot;</span>;</span><br><span class=\"line\">ws.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e.<span class=\"property\">data</span>.<span class=\"property\">size</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收到的是 ArrayBuffer 数据</span></span><br><span class=\"line\">ws.<span class=\"property\">binaryType</span> = <span class=\"string\">&quot;arraybuffer&quot;</span>;</span><br><span class=\"line\">ws.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e.<span class=\"property\">data</span>.<span class=\"property\">byteLength</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"webSocket-send\"><a href=\"#webSocket-send\" class=\"headerlink\" title=\"webSocket.send()\"></a>webSocket.send()</h2><p>实例对象的send()方法用于向服务器发送数据。</p>\n<p>发送文本的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ws.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;your message&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>发送 Blob 对象的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> file = <span class=\"variable language_\">document</span></span><br><span class=\"line\">  .<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;input[type=&quot;file&quot;]&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"property\">files</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">ws.<span class=\"title function_\">send</span>(file);</span><br></pre></td></tr></table></figure>\n<p>发送 ArrayBuffer 对象的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> img = canvas_context.<span class=\"title function_\">getImageData</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">400</span>, <span class=\"number\">320</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> binary = <span class=\"keyword\">new</span> <span class=\"title class_\">Uint8Array</span>(img.<span class=\"property\">data</span>.<span class=\"property\">length</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; img.<span class=\"property\">data</span>.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">  binary[i] = img.<span class=\"property\">data</span>[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ws.<span class=\"title function_\">send</span>(binary.<span class=\"property\">buffer</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"webSocket-bufferedAmount\"><a href=\"#webSocket-bufferedAmount\" class=\"headerlink\" title=\"webSocket.bufferedAmount\"></a>webSocket.bufferedAmount</h2><p>实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBuffer</span>(<span class=\"number\">10000000</span>);</span><br><span class=\"line\">socket.<span class=\"title function_\">send</span>(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (socket.<span class=\"property\">bufferedAmount</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 发送完毕</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 发送还没结束</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"webSocket-onerror\"><a href=\"#webSocket-onerror\" class=\"headerlink\" title=\"webSocket.onerror\"></a>webSocket.onerror</h2><p>实例对象的onerror属性，用于指定报错时的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error event</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">socket.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;error&quot;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error event</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"服务端的实现\"><a href=\"#服务端的实现\" class=\"headerlink\" title=\"服务端的实现\"></a>服务端的实现</h1><p>WebSocket 服务器的实现，可以查看维基百科的列表。</p>\n<p>常用的 Node 实现有以下三种。</p>\n<ol>\n<li><a href=\"https://github.com/uWebSockets/uWebSockets\">µWebSockets</a></li>\n<li><a href=\"http://socket.io/\">Socket.IO</a></li>\n<li><a href=\"https://github.com/theturtle32/WebSocket-Node\">WebSocket-Node</a></li>\n</ol>\n<p>具体的用法请查看它们的文档，这里不详细介绍了。</p>\n<h1 id=\"WebSocketd\"><a href=\"#WebSocketd\" class=\"headerlink\" title=\"WebSocketd\"></a>WebSocketd</h1><p>下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。</p>\n<p>它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fynopud1poj30go081wf9.jpg\"></p>\n<p>举例来说，下面是一个 Bash 脚本counter.sh。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo 1</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\"></span><br><span class=\"line\">echo 2</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">echo 3</span><br></pre></td></tr></table></figure>\n<p>命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">bash ./counter.sh</span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n<p>现在，启动websocketd，指定这个脚本作为服务。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">websocketd --port=8080 bash ./counter.sh</span></span><br></pre></td></tr></table></figure>\n<p>上面的命令会启动一个 WebSocket 服务器，端口是8080。每当客户端连接这个服务器，就会执行counter.sh脚本，并将它的输出推送给客户端。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>(<span class=\"string\">&#x27;ws://localhost:8080/&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ws.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。</p>\n<p>有了它，就可以很方便地将命令行的输出，发给浏览器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">websocketd --port=8080 <span class=\"built_in\">ls</span></span></span><br></pre></td></tr></table></figure>\n<p>上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fynos0nf9sj30go0ct3zs.jpg\"></p>\n<p>更多的用法可以参考<a href=\"https://github.com/joewalnes/websocketd/tree/master/examples/bash\">官方示例</a>。</p>\n<blockquote>\n<p>Bash 脚本读取客户端输入的例子；五行代码实现一个最简单的聊天服务器</p>\n</blockquote>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fynosmjojhj30ib08kjsg.jpg\"><br>websocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务greeter.js。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.<span class=\"property\">stdin</span>.<span class=\"title function_\">setEncoding</span>(<span class=\"string\">&#x27;utf8&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">process.<span class=\"property\">stdin</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;readable&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = process.<span class=\"property\">stdin</span>.<span class=\"title function_\">read</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (chunk !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    process.<span class=\"property\">stdout</span>.<span class=\"title function_\">write</span>(<span class=\"string\">&#x27;data: &#x27;</span> + chunk);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>启动这个脚本的命令如下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">websocketd --port=8080 node ./greeter.js</span></span><br></pre></td></tr></table></figure>\n<p>官方仓库还有其他各种语言的例子。</p>\n<h1 id=\"七、参考链接\"><a href=\"#七、参考链接\" class=\"headerlink\" title=\"七、参考链接\"></a>七、参考链接</h1><p><a href=\"http://cjihrig.com/blog/how-to-use-websockets/\">How to Use WebSockets</a></p>\n<p><a href=\"https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm\">WebSockets - Send &amp; Receive Messages</a></p>\n<p><a href=\"https://www.html5rocks.com/en/tutorials/websockets/basics/\">Introducing WebSockets: Bringing Sockets to the Web</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\">阮一峰博客</a></p>\n","slug":"WebSocket学习","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/28/WebSocket%E5%AD%A6%E4%B9%A0/","excerpt":"WebSocket 是一种网络通信协议，很多高级功能都需要它。本文介绍 WebSocket 协议的使用方法。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"http://vwin.github.io/tags/websocket/"},{"name":"http","slug":"http","permalink":"http://vwin.github.io/tags/http/"}]},{"title":"Python-flask资源","date":"2018-12-25T20:41:02.000Z","path":"2018/12/25/Python-flask资源/","text":"Flask 是 Python 中最流行的 Web 框架之一，以小巧、灵活、可扩展性强著称，相比 Django，它给了开发者最大限度的自由，如果你不喜欢关系型数据库，ok，没问题，切换成本非常低，而 Django 呢？你能遇到的问题它都帮你想好并且提供了对应解决方案，你自己就不要去重复造轮子了，比如模版引擎，ORM，不爽想替换？这个有点难。 给大家安利几个 Flask 学习资源 The Flask Mega-Tutorial 教程这个教程是《Flask Web开发：基于Python的Web应用开发实战》作者 Miguel Grinberg 写的 2017版 Flask 教程，也是我强烈推荐给大家的 Flask 教程，英语阅读水平过得去的话，建议直接读原文，英语渣也有福音，国内已有网友把它翻译成了中文。 英文地址：https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world中文地址：https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh Flask之旅如果你已经入门了Flask，肯定希望有一个 Flask 最佳实践指南，让你的 Flask 项目看起来更加 professional，而本书涉及的主题就是Flask的最佳编程实践和模式。尽量避免啰嗦官方文档中提到的内容，同时也会再次强调一些概念来加深印象。 英文地址： http://exploreflask.com/en/latest/中文地址：https://spacewander.github.io/explore-flask-zh/index.html Flask 源码解析如果你已经熟练掌握了 Flask 框架，是不是惊叹于 Flask 框架背后的设计精髓，一个精悍的Web框架究竟是如何实现的？了解它最好的办法就是窥探它的源码，还好，这件事已经有人帮你做了。 地址：http://cizixs.com/2017/01/13/flask-insight-context Awesome Flask最后强烈推荐的是这个 Awesome 系列的 Flask 资源大集合，涵盖了 Flask 的各方各面，包括第三方扩展插件以及教程、书籍和视频、PPT还有项目结构等等。 地址：https://github.com/humiaozuzu/awesome-flask Flask for Fun and ProfitFlask 作者 Armin Ronacher 在PyBay2016上的一个视频分享，手把手教你如何构建一个大型复杂的易于测试的API服务。同时还有在开发Flask的过程的一些设计思想。 视频地址：https://www.youtube.com/watch?v=1ByQhAM5c1IPPT：https://speakerdeck.com/player/94a53afb6a524ad88f301f62166a27e4?# 再补充一些其它资源： Flask Web 开发入门https://funhacks.gitbooks.io/head-first-flask/content/chapter02/section2.03.html Flask入门系列教程http://www.bjhee.com/flask-1.html Flask进阶系列教程http://www.bjhee.com/flask-ad1.html Full Stack Web Development with Flask (视频教程，需要翻土啬)https://github.com/realpython/discover-flask Full Stack Pythonhttps://www.fullstackpython.com/flask.html","raw":"---\ntitle: Python-flask资源\ntoc: true\ndate: 2018-12-26 04:41:02\ntags: [python,flask]\ncategories: [技术]\ndescription:\n---\nFlask 是 Python 中最流行的 Web 框架之一，以小巧、灵活、可扩展性强著称，相比 Django，它给了开发者最大限度的自由，如果你不喜欢关系型数据库，ok，没问题，切换成本非常低，而 Django 呢？你能遇到的问题它都帮你想好并且提供了对应解决方案，你自己就不要去重复造轮子了，比如模版引擎，ORM，不爽想替换？这个有点难。\n\n给大家安利几个 Flask 学习资源\n<!--more-->\n# The Flask Mega-Tutorial 教程\n这个教程是《Flask Web开发：基于Python的Web应用开发实战》作者 Miguel Grinberg 写的 2017版 Flask 教程，也是我强烈推荐给大家的 Flask 教程，英语阅读水平过得去的话，建议直接读原文，英语渣也有福音，国内已有网友把它翻译成了中文。\n\n英文地址：https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world\n中文地址：https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh\n\n# Flask之旅\n如果你已经入门了Flask，肯定希望有一个 Flask 最佳实践指南，让你的 Flask 项目看起来更加 professional，而本书涉及的主题就是Flask的最佳编程实践和模式。尽量避免啰嗦官方文档中提到的内容，同时也会再次强调一些概念来加深印象。\n\n英文地址： http://exploreflask.com/en/latest/\n中文地址：https://spacewander.github.io/explore-flask-zh/index.html\n\n# Flask 源码解析\n如果你已经熟练掌握了 Flask 框架，是不是惊叹于 Flask 框架背后的设计精髓，一个精悍的Web框架究竟是如何实现的？了解它最好的办法就是窥探它的源码，还好，这件事已经有人帮你做了。\n\n地址：http://cizixs.com/2017/01/13/flask-insight-context\n\n# Awesome Flask\n最后强烈推荐的是这个 Awesome 系列的 Flask 资源大集合，涵盖了 Flask 的各方各面，包括第三方扩展插件以及教程、书籍和视频、PPT还有项目结构等等。\n\n地址：https://github.com/humiaozuzu/awesome-flask\n\n# Flask for Fun and Profit\nFlask 作者 Armin Ronacher 在PyBay2016上的一个视频分享，手把手教你如何构建一个大型复杂的易于测试的API服务。同时还有在开发Flask的过程的一些设计思想。\n\n视频地址：https://www.youtube.com/watch?v=1ByQhAM5c1I\nPPT：https://speakerdeck.com/player/94a53afb6a524ad88f301f62166a27e4?#\n\n再补充一些其它资源：\n\nFlask Web 开发入门\nhttps://funhacks.gitbooks.io/head-first-flask/content/chapter02/section2.03.html\n\nFlask入门系列教程\nhttp://www.bjhee.com/flask-1.html\n\nFlask进阶系列教程\nhttp://www.bjhee.com/flask-ad1.html\n\nFull Stack Web Development with Flask (视频教程，需要翻土啬)\nhttps://github.com/realpython/discover-flask\n\nFull Stack Python\nhttps://www.fullstackpython.com/flask.html","content":"<p>Flask 是 Python 中最流行的 Web 框架之一，以小巧、灵活、可扩展性强著称，相比 Django，它给了开发者最大限度的自由，如果你不喜欢关系型数据库，ok，没问题，切换成本非常低，而 Django 呢？你能遇到的问题它都帮你想好并且提供了对应解决方案，你自己就不要去重复造轮子了，比如模版引擎，ORM，不爽想替换？这个有点难。</p>\n<p>给大家安利几个 Flask 学习资源</p>\n<span id=\"more\"></span>\n<h1 id=\"The-Flask-Mega-Tutorial-教程\"><a href=\"#The-Flask-Mega-Tutorial-教程\" class=\"headerlink\" title=\"The Flask Mega-Tutorial 教程\"></a>The Flask Mega-Tutorial 教程</h1><p>这个教程是《Flask Web开发：基于Python的Web应用开发实战》作者 Miguel Grinberg 写的 2017版 Flask 教程，也是我强烈推荐给大家的 Flask 教程，英语阅读水平过得去的话，建议直接读原文，英语渣也有福音，国内已有网友把它翻译成了中文。</p>\n<p>英文地址：<a href=\"https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world\">https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world</a><br>中文地址：<a href=\"https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh\">https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh</a></p>\n<h1 id=\"Flask之旅\"><a href=\"#Flask之旅\" class=\"headerlink\" title=\"Flask之旅\"></a>Flask之旅</h1><p>如果你已经入门了Flask，肯定希望有一个 Flask 最佳实践指南，让你的 Flask 项目看起来更加 professional，而本书涉及的主题就是Flask的最佳编程实践和模式。尽量避免啰嗦官方文档中提到的内容，同时也会再次强调一些概念来加深印象。</p>\n<p>英文地址： <a href=\"http://exploreflask.com/en/latest/\">http://exploreflask.com/en/latest/</a><br>中文地址：<a href=\"https://spacewander.github.io/explore-flask-zh/index.html\">https://spacewander.github.io/explore-flask-zh/index.html</a></p>\n<h1 id=\"Flask-源码解析\"><a href=\"#Flask-源码解析\" class=\"headerlink\" title=\"Flask 源码解析\"></a>Flask 源码解析</h1><p>如果你已经熟练掌握了 Flask 框架，是不是惊叹于 Flask 框架背后的设计精髓，一个精悍的Web框架究竟是如何实现的？了解它最好的办法就是窥探它的源码，还好，这件事已经有人帮你做了。</p>\n<p>地址：<a href=\"http://cizixs.com/2017/01/13/flask-insight-context\">http://cizixs.com/2017/01/13/flask-insight-context</a></p>\n<h1 id=\"Awesome-Flask\"><a href=\"#Awesome-Flask\" class=\"headerlink\" title=\"Awesome Flask\"></a>Awesome Flask</h1><p>最后强烈推荐的是这个 Awesome 系列的 Flask 资源大集合，涵盖了 Flask 的各方各面，包括第三方扩展插件以及教程、书籍和视频、PPT还有项目结构等等。</p>\n<p>地址：<a href=\"https://github.com/humiaozuzu/awesome-flask\">https://github.com/humiaozuzu/awesome-flask</a></p>\n<h1 id=\"Flask-for-Fun-and-Profit\"><a href=\"#Flask-for-Fun-and-Profit\" class=\"headerlink\" title=\"Flask for Fun and Profit\"></a>Flask for Fun and Profit</h1><p>Flask 作者 Armin Ronacher 在PyBay2016上的一个视频分享，手把手教你如何构建一个大型复杂的易于测试的API服务。同时还有在开发Flask的过程的一些设计思想。</p>\n<p>视频地址：<a href=\"https://www.youtube.com/watch?v=1ByQhAM5c1I\">https://www.youtube.com/watch?v=1ByQhAM5c1I</a><br>PPT：<a href=\"https://speakerdeck.com/player/94a53afb6a524ad88f301f62166a27e4#\">https://speakerdeck.com/player/94a53afb6a524ad88f301f62166a27e4?#</a></p>\n<p>再补充一些其它资源：</p>\n<p>Flask Web 开发入门<br><a href=\"https://funhacks.gitbooks.io/head-first-flask/content/chapter02/section2.03.html\">https://funhacks.gitbooks.io/head-first-flask/content/chapter02/section2.03.html</a></p>\n<p>Flask入门系列教程<br><a href=\"http://www.bjhee.com/flask-1.html\">http://www.bjhee.com/flask-1.html</a></p>\n<p>Flask进阶系列教程<br><a href=\"http://www.bjhee.com/flask-ad1.html\">http://www.bjhee.com/flask-ad1.html</a></p>\n<p>Full Stack Web Development with Flask (视频教程，需要翻土啬)<br><a href=\"https://github.com/realpython/discover-flask\">https://github.com/realpython/discover-flask</a></p>\n<p>Full Stack Python<br><a href=\"https://www.fullstackpython.com/flask.html\">https://www.fullstackpython.com/flask.html</a></p>\n","slug":"Python-flask资源","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/25/Python-flask%E8%B5%84%E6%BA%90/","excerpt":"Flask 是 Python 中最流行的 Web 框架之一，以小巧、灵活、可扩展性强著称，相比 Django，它给了开发者最大限度的自由，如果你不喜欢关系型数据库，ok，没问题，切换成本非常低，而 Django 呢？你能遇到的问题它都帮你想好并且提供了对应解决方案，你自己就不要去重复造轮子了，比如模版引擎，ORM，不爽想替换？这个有点难。 给大家安利几个 Flask 学习资源","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://vwin.github.io/tags/flask/"}]},{"title":"Python-celery基础","date":"2018-12-25T20:28:22.000Z","path":"2018/12/25/Python-celery基础/","text":"在一个应用服务中，对于时效性要求没那么高的业务场景，我们没必要等到所有任务执行完才返回结果，例如用户注册场景中，保存了用户账号密码之后，就可以立即返回，后续的账号激活邮件，可以用一种异步的形式去处理，这种异步操作可以用队列服务来实现。否则，如果等到邮件发送成功可能几秒过去了。 Celery 是什么？Celery 是 Python 语言实现的分布式队列服务，除了支持即时任务，还支持定时任务，Celery 有5个核心角色。 Task任务(Task)就是你要做的事情，例如一个注册流程里面有很多任务，给用户发验证邮件就是一个任务，这种耗时任务可以交给Celery去处理，还有一种任务是定时任务，比如每天定时统计网站的注册人数，这个也可以交给Celery周期性的处理。 BrokerBroker 的中文意思是经纪人，指为市场上买卖双方提供中介服务的人。在Celery中它介于生产者和消费者之间经纪人，这个角色相当于数据结构中的队列。例如一个Web系统中，生产者是处理核心业务的Web程序，业务中可能会产生一些耗时的任务，比如短信，生产者会将任务发送给 Broker，就是把这个任务暂时放到队列中，等待消费者来处理。消费者是 Worker，是专门用于执行任务的后台服务。Worker 将实时监控队列中是否有新的任务，如果有就拿出来进行处理。Celery 本身不提供队列服务，一般用 Redis 或者 RabbitMQ 来扮演 Broker 的角色 WorkerWorker 就是那个一直在后台执行任务的人，也称为任务的消费者，它会实时地监控队列中有没有任务，如果有就立即取出来执行。 BeatBeat 是一个定时任务调度器，它会根据配置定时将任务发送给 Broker，等待 Worker 来消费。 BackendBackend 用于保存任务的执行结果，每个任务都有返回值，比如发送邮件的服务会告诉我们有没有发送成功，这个结果就是存在Backend中，当然我们并不总是要关心任务的执行结果。 记住这5个角色后面理解Celery就轻松了。 快速入门接触任何新东西，没有什么比实际动手学得更快了。假设我们选择Redis作为broker，你需要安装redis并且已经启动了redis服务（这个步骤请自行借用搜索引擎解决） 安装celery1pip install -U &quot;celery[redis]&quot; 创建Celery实例1234# tasks.pyfrom celery import Celeryapp = Celery(&#x27;tasks&#x27;, broker=&#x27;redis://localhost:6379/0&#x27;) 创建任务假设这个发送邮件的任务需要5秒钟才能执行完 1234567# tasks.py@app.taskdef send_mail(email): print(&quot;send mail to &quot;, email) import time time.sleep(5) return &quot;success&quot; 在没有Celery的情况下，程序顺序执行，每个步骤都需要等上一步执行完成。又叫同步操作，例如： 1231. 插入记录到数据库2. 发邮件3. 注册成功 我们可以把2放在一个任务中交给celery去异步执行，这样我们就不需要等待发邮件完成，你只需要安排celery去处理帮我去完成就好了。代码就变成了 1231. 插入记录到数据库2. 安排 celery 帮我去发邮件3. 注册成功 第二步是非常快的，它只需要把任务放进队列里面去，并不会等任务真正执行完。这跟生活是完全贴切的，例如我们很多事情都不是自己亲历其为去做，而是将一个不太重要或即时性没那么高的事情转交给别人处理，我可以继续处理后面的事情。 启动 Worker启动 Worker，监听 Broker 中是否有任务，命令：celery worker，你可能需要指定参数 1celery -A tasks worker --loglevel=info -A： 指定 celery 实例在哪个模块中，例子中，celery实例在tasks.py文件中，启动成功后，能看到信息 函数用app.task 装饰器修饰之后，就会成为Celery中的一个Task。 调用任务在主程序中调用任务，将任务发送给 Broker， 而不是真正执行该任务，比如下面的主程序是 register 1234567891011121314# user.pyfrom tasks import send_maildef register(): import time start = time.time() print(&quot;1. 插入记录到数据库&quot;) print(&quot;2. celery 帮我发邮件&quot;) send_mail.delay(&quot;xx@gmail.com&quot;) print(&quot;3. 告诉用户注册成功&quot;) print(&quot;耗时：%s 秒 &quot; % (time.time() - start))if __name__ == &#x27;__main__&#x27;: register() 在主程序中，调用函数的.delay方法 目录结构： 123── celery_test ├── tasks.py └── user.py 运行 python user.py， 启动应用程序 12341. 插入记录到数据库2. celery 帮我发邮件3. 告诉用户注册成功耗时：0.22688984870910645 秒 程序花了不到0.23秒就执行完成，如果按照正常的同步逻辑去执行，至少需要5秒钟，因为发邮件的任务就花了5秒。 在worker服务窗口看日志信息 注意： celery worker 启动时，如果是root用户，需要设置环境变量： 1$ export C_FORCE_ROOT=&#x27;true&#x27; Celery4.x 开始不再支持Windows平台，如果需要在Windows开发，请使用3.x的版本。 使用 RabbitMQ 或 Redis 作为 Broker，生产环境永远不要使用关系数据库 不要使用复杂对象作为任务函数的参数 1234567891011# Good@app.taskdef my_task(user_id): user = User.objects.get(id=user_id) print(user.name) # ...# Bad@app.taskdef my_task(user): print(user.name) # ... 小结学习Celery，首先需要知道它的应用场景，然后是Celery中的常见角色，最后按照步骤感受一下Celery是如何跑起来的。 参考链接： http://funhacks.net/2016/12/13/celery/https://celery.readthedocs.io/en/latest/userguide/tasks.html#tips-and-best-practiceshttp://celerytaskschecklist.com/","raw":"---\ntitle: Python-celery基础\ntoc: true\ndate: 2018-12-26 04:28:22\ntags: [python,celery]\ncategories: [技术]\ndescription:\n---\n在一个应用服务中，对于时效性要求没那么高的业务场景，我们没必要等到所有任务执行完才返回结果，例如用户注册场景中，保存了用户账号密码之后，就可以立即返回，后续的账号激活邮件，可以用一种异步的形式去处理，这种异步操作可以用队列服务来实现。否则，如果等到邮件发送成功可能几秒过去了。\n<!--more-->\n### Celery 是什么？\nCelery 是 Python 语言实现的分布式队列服务，除了支持即时任务，还支持定时任务，Celery 有5个核心角色。\n\n### Task\n任务(Task)就是你要做的事情，例如一个注册流程里面有很多任务，给用户发验证邮件就是一个任务，这种耗时任务可以交给Celery去处理，还有一种任务是定时任务，比如每天定时统计网站的注册人数，这个也可以交给Celery周期性的处理。\n\n### Broker\nBroker 的中文意思是经纪人，指为市场上买卖双方提供中介服务的人。在Celery中它介于生产者和消费者之间经纪人，这个角色相当于数据结构中的队列。例如一个Web系统中，生产者是处理核心业务的Web程序，业务中可能会产生一些耗时的任务，比如短信，生产者会将任务发送给 Broker，就是把这个任务暂时放到队列中，等待消费者来处理。消费者是 Worker，是专门用于执行任务的后台服务。Worker 将实时监控队列中是否有新的任务，如果有就拿出来进行处理。Celery 本身不提供队列服务，一般用 Redis 或者 RabbitMQ 来扮演 Broker 的角色\n\n### Worker\nWorker 就是那个一直在后台执行任务的人，也称为任务的消费者，它会实时地监控队列中有没有任务，如果有就立即取出来执行。\n\n### Beat\nBeat 是一个定时任务调度器，它会根据配置定时将任务发送给 Broker，等待 Worker 来消费。\n\n### Backend\nBackend 用于保存任务的执行结果，每个任务都有返回值，比如发送邮件的服务会告诉我们有没有发送成功，这个结果就是存在Backend中，当然我们并不总是要关心任务的执行结果。\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fyka02ulmsj30c60cqab2.jpg)\n\n记住这5个角色后面理解Celery就轻松了。\n\n### 快速入门\n接触任何新东西，没有什么比实际动手学得更快了。假设我们选择Redis作为broker，你需要安装redis并且已经启动了redis服务（这个步骤请自行借用搜索引擎解决）\n\n#### 安装celery\n```shell\npip install -U \"celery[redis]\"\n```\n#### 创建Celery实例\n```python\n# tasks.py\nfrom celery import Celery\n\napp = Celery('tasks', broker='redis://localhost:6379/0')\n```\n#### 创建任务\n假设这个发送邮件的任务需要5秒钟才能执行完\n```python\n# tasks.py\n@app.task\ndef send_mail(email):\n    print(\"send mail to \", email)\n    import time\n    time.sleep(5)\n    return \"success\"\n```\n在没有Celery的情况下，程序顺序执行，每个步骤都需要等上一步执行完成。又叫同步操作，例如：\n```shell\n1. 插入记录到数据库\n2. 发邮件\n3. 注册成功\n```\n我们可以把2放在一个任务中交给celery去异步执行，这样我们就不需要等待发邮件完成，你只需要安排celery去处理帮我去完成就好了。代码就变成了\n```shell\n1. 插入记录到数据库\n2. 安排 celery 帮我去发邮件\n3. 注册成功\n```\n第二步是非常快的，它只需要把任务放进队列里面去，并不会等任务真正执行完。这跟生活是完全贴切的，例如我们很多事情都不是自己亲历其为去做，而是将一个不太重要或即时性没那么高的事情转交给别人处理，我可以继续处理后面的事情。\n\n#### 启动 Worker\n启动 Worker，监听 Broker 中是否有任务，命令：celery worker，你可能需要指定参数\n\n```shell\ncelery -A tasks worker --loglevel=info\n```\n\n-A： 指定 celery 实例在哪个模块中，例子中，celery实例在tasks.py文件中，启动成功后，能看到信息\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fyka17x4hqj30nl0f941i.jpg)\n\n函数用app.task 装饰器修饰之后，就会成为Celery中的一个Task。\n\n#### 调用任务\n在主程序中调用任务，将任务发送给 Broker， 而不是真正执行该任务，比如下面的主程序是 register\n```python\n# user.py\nfrom tasks import send_mail\n\ndef register():\n    import time\n    start = time.time()\n    print(\"1. 插入记录到数据库\")\n    print(\"2. celery 帮我发邮件\")\n    send_mail.delay(\"xx@gmail.com\")\n    print(\"3. 告诉用户注册成功\")\n    print(\"耗时：%s 秒 \" % (time.time() - start))\n\nif __name__ == '__main__':\n    register()\n```\n在主程序中，调用函数的.delay方法\n\n目录结构：\n```s\n── celery_test\n   ├── tasks.py\n   └── user.py\n```\n运行 python user.py， 启动应用程序\n```s\n1. 插入记录到数据库\n2. celery 帮我发邮件\n3. 告诉用户注册成功\n耗时：0.22688984870910645 秒 \n```\n程序花了不到0.23秒就执行完成，如果按照正常的同步逻辑去执行，至少需要5秒钟，因为发邮件的任务就花了5秒。\n\n在worker服务窗口看日志信息\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyka234owij30ta048myr.jpg)\n\n注意：\n1. celery worker 启动时，如果是root用户，需要设置环境变量：\n    ```s\n    $ export C_FORCE_ROOT='true'\n    ```\n2. Celery4.x 开始不再支持Windows平台，如果需要在Windows开发，请使用3.x的版本。\n3. 使用 RabbitMQ 或 Redis 作为 Broker，生产环境永远不要使用关系数据库\n4. 不要使用复杂对象作为任务函数的参数\n\n    ```python\n    # Good\n    @app.task\n    def my_task(user_id):\n        user = User.objects.get(id=user_id)\n        print(user.name)\n        # ...\n    # Bad\n    @app.task\n    def my_task(user):\n        print(user.name)\n        # ...\n    ```\n### 小结\n学习Celery，首先需要知道它的应用场景，然后是Celery中的常见角色，最后按照步骤感受一下Celery是如何跑起来的。\n\n参考链接：\n\nhttp://funhacks.net/2016/12/13/celery/\nhttps://celery.readthedocs.io/en/latest/userguide/tasks.html#tips-and-best-practices\nhttp://celerytaskschecklist.com/","content":"<p>在一个应用服务中，对于时效性要求没那么高的业务场景，我们没必要等到所有任务执行完才返回结果，例如用户注册场景中，保存了用户账号密码之后，就可以立即返回，后续的账号激活邮件，可以用一种异步的形式去处理，这种异步操作可以用队列服务来实现。否则，如果等到邮件发送成功可能几秒过去了。</p>\n<span id=\"more\"></span>\n<h3 id=\"Celery-是什么？\"><a href=\"#Celery-是什么？\" class=\"headerlink\" title=\"Celery 是什么？\"></a>Celery 是什么？</h3><p>Celery 是 Python 语言实现的分布式队列服务，除了支持即时任务，还支持定时任务，Celery 有5个核心角色。</p>\n<h3 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h3><p>任务(Task)就是你要做的事情，例如一个注册流程里面有很多任务，给用户发验证邮件就是一个任务，这种耗时任务可以交给Celery去处理，还有一种任务是定时任务，比如每天定时统计网站的注册人数，这个也可以交给Celery周期性的处理。</p>\n<h3 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h3><p>Broker 的中文意思是经纪人，指为市场上买卖双方提供中介服务的人。在Celery中它介于生产者和消费者之间经纪人，这个角色相当于数据结构中的队列。例如一个Web系统中，生产者是处理核心业务的Web程序，业务中可能会产生一些耗时的任务，比如短信，生产者会将任务发送给 Broker，就是把这个任务暂时放到队列中，等待消费者来处理。消费者是 Worker，是专门用于执行任务的后台服务。Worker 将实时监控队列中是否有新的任务，如果有就拿出来进行处理。Celery 本身不提供队列服务，一般用 Redis 或者 RabbitMQ 来扮演 Broker 的角色</p>\n<h3 id=\"Worker\"><a href=\"#Worker\" class=\"headerlink\" title=\"Worker\"></a>Worker</h3><p>Worker 就是那个一直在后台执行任务的人，也称为任务的消费者，它会实时地监控队列中有没有任务，如果有就立即取出来执行。</p>\n<h3 id=\"Beat\"><a href=\"#Beat\" class=\"headerlink\" title=\"Beat\"></a>Beat</h3><p>Beat 是一个定时任务调度器，它会根据配置定时将任务发送给 Broker，等待 Worker 来消费。</p>\n<h3 id=\"Backend\"><a href=\"#Backend\" class=\"headerlink\" title=\"Backend\"></a>Backend</h3><p>Backend 用于保存任务的执行结果，每个任务都有返回值，比如发送邮件的服务会告诉我们有没有发送成功，这个结果就是存在Backend中，当然我们并不总是要关心任务的执行结果。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fyka02ulmsj30c60cqab2.jpg\"></p>\n<p>记住这5个角色后面理解Celery就轻松了。</p>\n<h3 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h3><p>接触任何新东西，没有什么比实际动手学得更快了。假设我们选择Redis作为broker，你需要安装redis并且已经启动了redis服务（这个步骤请自行借用搜索引擎解决）</p>\n<h4 id=\"安装celery\"><a href=\"#安装celery\" class=\"headerlink\" title=\"安装celery\"></a>安装celery</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U &quot;celery[redis]&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建Celery实例\"><a href=\"#创建Celery实例\" class=\"headerlink\" title=\"创建Celery实例\"></a>创建Celery实例</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># tasks.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> celery <span class=\"keyword\">import</span> Celery</span><br><span class=\"line\"></span><br><span class=\"line\">app = Celery(<span class=\"string\">&#x27;tasks&#x27;</span>, broker=<span class=\"string\">&#x27;redis://localhost:6379/0&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h4><p>假设这个发送邮件的任务需要5秒钟才能执行完</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># tasks.py</span></span><br><span class=\"line\"><span class=\"meta\">@app.task</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">send_mail</span>(<span class=\"params\">email</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;send mail to &quot;</span>, email)</span><br><span class=\"line\">    <span class=\"keyword\">import</span> time</span><br><span class=\"line\">    time.sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span></span><br></pre></td></tr></table></figure>\n<p>在没有Celery的情况下，程序顺序执行，每个步骤都需要等上一步执行完成。又叫同步操作，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 插入记录到数据库</span><br><span class=\"line\">2. 发邮件</span><br><span class=\"line\">3. 注册成功</span><br></pre></td></tr></table></figure>\n<p>我们可以把2放在一个任务中交给celery去异步执行，这样我们就不需要等待发邮件完成，你只需要安排celery去处理帮我去完成就好了。代码就变成了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 插入记录到数据库</span><br><span class=\"line\">2. 安排 celery 帮我去发邮件</span><br><span class=\"line\">3. 注册成功</span><br></pre></td></tr></table></figure>\n<p>第二步是非常快的，它只需要把任务放进队列里面去，并不会等任务真正执行完。这跟生活是完全贴切的，例如我们很多事情都不是自己亲历其为去做，而是将一个不太重要或即时性没那么高的事情转交给别人处理，我可以继续处理后面的事情。</p>\n<h4 id=\"启动-Worker\"><a href=\"#启动-Worker\" class=\"headerlink\" title=\"启动 Worker\"></a>启动 Worker</h4><p>启动 Worker，监听 Broker 中是否有任务，命令：celery worker，你可能需要指定参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">celery -A tasks worker --loglevel=info</span><br></pre></td></tr></table></figure>\n\n<p>-A： 指定 celery 实例在哪个模块中，例子中，celery实例在tasks.py文件中，启动成功后，能看到信息</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fyka17x4hqj30nl0f941i.jpg\"></p>\n<p>函数用app.task 装饰器修饰之后，就会成为Celery中的一个Task。</p>\n<h4 id=\"调用任务\"><a href=\"#调用任务\" class=\"headerlink\" title=\"调用任务\"></a>调用任务</h4><p>在主程序中调用任务，将任务发送给 Broker， 而不是真正执行该任务，比如下面的主程序是 register</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># user.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> tasks <span class=\"keyword\">import</span> send_mail</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">register</span>():</span><br><span class=\"line\">    <span class=\"keyword\">import</span> time</span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;1. 插入记录到数据库&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;2. celery 帮我发邮件&quot;</span>)</span><br><span class=\"line\">    send_mail.delay(<span class=\"string\">&quot;xx@gmail.com&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;3. 告诉用户注册成功&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;耗时：%s 秒 &quot;</span> % (time.time() - start))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    register()</span><br></pre></td></tr></table></figure>\n<p>在主程序中，调用函数的.delay方法</p>\n<p>目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">── celery_test</span><br><span class=\"line\">   ├── tasks.py</span><br><span class=\"line\">   └── user.py</span><br></pre></td></tr></table></figure>\n<p>运行 python user.py， 启动应用程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 插入记录到数据库</span><br><span class=\"line\">2. celery 帮我发邮件</span><br><span class=\"line\">3. 告诉用户注册成功</span><br><span class=\"line\">耗时：0.22688984870910645 秒 </span><br></pre></td></tr></table></figure>\n<p>程序花了不到0.23秒就执行完成，如果按照正常的同步逻辑去执行，至少需要5秒钟，因为发邮件的任务就花了5秒。</p>\n<p>在worker服务窗口看日志信息</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyka234owij30ta048myr.jpg\"></p>\n<p>注意：</p>\n<ol>\n<li><p>celery worker 启动时，如果是root用户，需要设置环境变量：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ export C_FORCE_ROOT=&#x27;true&#x27;</span><br></pre></td></tr></table></figure></li>\n<li><p>Celery4.x 开始不再支持Windows平台，如果需要在Windows开发，请使用3.x的版本。</p>\n</li>\n<li><p>使用 RabbitMQ 或 Redis 作为 Broker，生产环境永远不要使用关系数据库</p>\n</li>\n<li><p>不要使用复杂对象作为任务函数的参数</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Good</span></span><br><span class=\"line\"><span class=\"meta\">@app.task</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_task</span>(<span class=\"params\">user_id</span>):</span><br><span class=\"line\">    user = User.objects.get(<span class=\"built_in\">id</span>=user_id)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(user.name)</span><br><span class=\"line\">    <span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"comment\"># Bad</span></span><br><span class=\"line\"><span class=\"meta\">@app.task</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_task</span>(<span class=\"params\">user</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(user.name)</span><br><span class=\"line\">    <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>学习Celery，首先需要知道它的应用场景，然后是Celery中的常见角色，最后按照步骤感受一下Celery是如何跑起来的。</p>\n<p>参考链接：</p>\n<p><a href=\"http://funhacks.net/2016/12/13/celery/\">http://funhacks.net/2016/12/13/celery/</a><br><a href=\"https://celery.readthedocs.io/en/latest/userguide/tasks.html#tips-and-best-practices\">https://celery.readthedocs.io/en/latest/userguide/tasks.html#tips-and-best-practices</a><br><a href=\"http://celerytaskschecklist.com/\">http://celerytaskschecklist.com/</a></p>\n","slug":"Python-celery基础","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/25/Python-celery%E5%9F%BA%E7%A1%80/","excerpt":"在一个应用服务中，对于时效性要求没那么高的业务场景，我们没必要等到所有任务执行完才返回结果，例如用户注册场景中，保存了用户账号密码之后，就可以立即返回，后续的账号激活邮件，可以用一种异步的形式去处理，这种异步操作可以用队列服务来实现。否则，如果等到邮件发送成功可能几秒过去了。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"celery","slug":"celery","permalink":"http://vwin.github.io/tags/celery/"}]},{"title":"Python-闭包","date":"2018-12-25T20:11:10.000Z","path":"2018/12/25/Python-闭包/","text":"什么是闭包？闭包有什么用？为什么要用闭包？今天我们就带着这3个问题来一步一步认识闭包。闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念 作用域作用域是程序运行时变量可被访问的范围，定义在函数内的变量是局部变量，局部变量的作用范围只能是函数内部范围内，它不能在函数外引用。 123def foo(): num = 10 # 局部变量print(num) # NameError: name &#x27;num&#x27; is not defined 定义在模块最外层的变量是全局变量，它是全局范围内可见的，当然在函数里面也可以读取到全局变量的。例如： 123num = 10 # 全局变量def foo(): print(num) # 10 嵌套函数函数不仅可以定义在模块的最外层，还可以定义在另外一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数（nested function）例如： 12345678910def print_msg(): # print_msg 是外围函数 msg = &quot;zen of python&quot; def printer(): # printer是嵌套函数 print(msg) printer()# 输出 zen of pythonprint_msg() 对于嵌套函数，它可以访问到其外层作用域中声明的非局部（non-local）变量，比如代码示例中的变量 msg 可以被嵌套函数 printer 正常访问。 那么有没有一种可能即使脱离了函数本身的作用范围，局部变量还可以被访问得到呢？答案是闭包 什么是闭包函数身为第一类对象，它可以作为函数的返回值返回，现在我们来考虑如下的例子： 1234567891011def print_msg(): # print_msg 是外围函数 msg = &quot;zen of python&quot; def printer(): # printer 是嵌套函数 print(msg) return printeranother = print_msg()# 输出 zen of pythonanother() 这段代码和前面例子的效果完全一样，同样输出 “zen of python”。不同的地方在于内部函数 printer 直接作为返回值返回了。 一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦 print_msg() 执行过后，我们会认为 msg变量将不再可用。然而，在这里我们发现 print_msg 执行完之后，在调用 another 的时候 msg 变量的值正常输出了，这就是闭包的作用，闭包使得局部变量在函数外被访问成为可能。 看完这个例子，我们再来定义闭包，维基百科上的解释是: 在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 这里的 another 就是一个闭包，闭包本质上是一个函数，它有两部分组成，printer 函数和变量 msg。闭包使得这些变量的值始终保存在内存中。 闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。 为什么要使用闭包闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。 一般来说，当对象中只有一个方法时，这时使用闭包是更好的选择。来看一个例子： 12345678910def adder(x): def wrapper(y): return x + y return wrapperadder5 = adder(5)# 输出 15adder5(10)# 输出 11adder5(6) 这比用类来实现更优雅，此外装饰器也是基于闭包的一种应用场景。 所有函数都有一个 __closure__属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。 12345&gt;&gt;&gt; adder.__closure__&gt;&gt;&gt; adder5.__closure__(&lt;cell at 0x103075910: int object at 0x7fd251604518&gt;,)&gt;&gt;&gt; adder5.__closure__[0].cell_contents5 这解释了为什么局部变量脱离函数之后，还可以在函数之外被访问的原因的，因为它存储在了闭包的 cell_contents中了。","raw":"---\ntitle: Python-闭包\ntoc: true\ndate: 2018-12-26 04:11:10\ntags: [闭包,python]\ncategories: [技术]\ndescription:\n---\n什么是闭包？闭包有什么用？为什么要用闭包？今天我们就带着这3个问题来一步一步认识闭包。闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念\n<!--more-->\n\n# 作用域\n作用域是程序运行时变量可被访问的范围，定义在函数内的变量是局部变量，局部变量的作用范围只能是函数内部范围内，它不能在函数外引用。\n```python\ndef foo():\n    num = 10 # 局部变量\nprint(num)  # NameError: name 'num' is not defined\n```\n定义在模块最外层的变量是全局变量，它是全局范围内可见的，当然在函数里面也可以读取到全局变量的。例如：\n```python\nnum = 10 # 全局变量\ndef foo():\n    print(num)  # 10\n```\n# 嵌套函数\n函数不仅可以定义在模块的最外层，还可以定义在另外一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数（nested function）例如：\n```python\ndef print_msg():\n    # print_msg 是外围函数\n    msg = \"zen of python\"\n\n    def printer():\n        # printer是嵌套函数\n        print(msg)\n    printer()\n# 输出 zen of python\nprint_msg()\n```\n对于嵌套函数，它可以访问到其外层作用域中声明的非局部（non-local）变量，比如代码示例中的变量 msg 可以被嵌套函数 printer 正常访问。\n\n那么有没有一种可能即使脱离了函数本身的作用范围，局部变量还可以被访问得到呢？答案是闭包\n\n# 什么是闭包\n函数身为第一类对象，它可以作为函数的返回值返回，现在我们来考虑如下的例子：\n```python\ndef print_msg():\n    # print_msg 是外围函数\n    msg = \"zen of python\"\n    def printer():\n        # printer 是嵌套函数\n        print(msg)\n    return printer\n\nanother = print_msg()\n# 输出 zen of python\nanother()\n```\n这段代码和前面例子的效果完全一样，同样输出 \"zen of python\"。不同的地方在于内部函数 printer 直接作为返回值返回了。\n\n一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦 print_msg() 执行过后，我们会认为 msg变量将不再可用。然而，在这里我们发现 print_msg 执行完之后，在调用 another 的时候 msg 变量的值正常输出了，这就是闭包的作用，闭包使得局部变量在函数外被访问成为可能。\n\n看完这个例子，我们再来定义闭包，维基百科上的解释是:\n\n>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。\n\n这里的 another 就是一个闭包，闭包本质上是一个函数，它有两部分组成，printer 函数和变量 msg。闭包使得这些变量的值始终保存在内存中。\n\n<b>闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。</b>\n\n# 为什么要使用闭包\n闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。\n\n一般来说，当对象中只有一个方法时，这时使用闭包是更好的选择。来看一个例子：\n```python\ndef adder(x):\n    def wrapper(y):\n        return x + y\n    return wrapper\n\nadder5 = adder(5)\n# 输出 15\nadder5(10)\n# 输出 11\nadder5(6)\n```\n这比用类来实现更优雅，此外装饰器也是基于闭包的一种应用场景。\n\n所有函数都有一个 __closure__属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。\n```python\n>>> adder.__closure__\n>>> adder5.__closure__\n(<cell at 0x103075910: int object at 0x7fd251604518>,)\n>>> adder5.__closure__[0].cell_contents\n5\n```\n这解释了为什么局部变量脱离函数之后，还可以在函数之外被访问的原因的，因为它存储在了闭包的 cell_contents中了。\n","content":"<p>什么是闭包？闭包有什么用？为什么要用闭包？今天我们就带着这3个问题来一步一步认识闭包。闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念</p>\n<span id=\"more\"></span>\n\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>作用域是程序运行时变量可被访问的范围，定义在函数内的变量是局部变量，局部变量的作用范围只能是函数内部范围内，它不能在函数外引用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">foo</span>():</span><br><span class=\"line\">    num = <span class=\"number\">10</span> <span class=\"comment\"># 局部变量</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(num)  <span class=\"comment\"># NameError: name &#x27;num&#x27; is not defined</span></span><br></pre></td></tr></table></figure>\n<p>定义在模块最外层的变量是全局变量，它是全局范围内可见的，当然在函数里面也可以读取到全局变量的。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = <span class=\"number\">10</span> <span class=\"comment\"># 全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">foo</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(num)  <span class=\"comment\"># 10</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h1><p>函数不仅可以定义在模块的最外层，还可以定义在另外一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数（nested function）例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">print_msg</span>():</span><br><span class=\"line\">    <span class=\"comment\"># print_msg 是外围函数</span></span><br><span class=\"line\">    msg = <span class=\"string\">&quot;zen of python&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">printer</span>():</span><br><span class=\"line\">        <span class=\"comment\"># printer是嵌套函数</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(msg)</span><br><span class=\"line\">    printer()</span><br><span class=\"line\"><span class=\"comment\"># 输出 zen of python</span></span><br><span class=\"line\">print_msg()</span><br></pre></td></tr></table></figure>\n<p>对于嵌套函数，它可以访问到其外层作用域中声明的非局部（non-local）变量，比如代码示例中的变量 msg 可以被嵌套函数 printer 正常访问。</p>\n<p>那么有没有一种可能即使脱离了函数本身的作用范围，局部变量还可以被访问得到呢？答案是闭包</p>\n<h1 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h1><p>函数身为第一类对象，它可以作为函数的返回值返回，现在我们来考虑如下的例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">print_msg</span>():</span><br><span class=\"line\">    <span class=\"comment\"># print_msg 是外围函数</span></span><br><span class=\"line\">    msg = <span class=\"string\">&quot;zen of python&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">printer</span>():</span><br><span class=\"line\">        <span class=\"comment\"># printer 是嵌套函数</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(msg)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> printer</span><br><span class=\"line\"></span><br><span class=\"line\">another = print_msg()</span><br><span class=\"line\"><span class=\"comment\"># 输出 zen of python</span></span><br><span class=\"line\">another()</span><br></pre></td></tr></table></figure>\n<p>这段代码和前面例子的效果完全一样，同样输出 “zen of python”。不同的地方在于内部函数 printer 直接作为返回值返回了。</p>\n<p>一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦 print_msg() 执行过后，我们会认为 msg变量将不再可用。然而，在这里我们发现 print_msg 执行完之后，在调用 another 的时候 msg 变量的值正常输出了，这就是闭包的作用，闭包使得局部变量在函数外被访问成为可能。</p>\n<p>看完这个例子，我们再来定义闭包，维基百科上的解释是:</p>\n<blockquote>\n<p>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p>\n</blockquote>\n<p>这里的 another 就是一个闭包，闭包本质上是一个函数，它有两部分组成，printer 函数和变量 msg。闭包使得这些变量的值始终保存在内存中。</p>\n<p><b>闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。</b></p>\n<h1 id=\"为什么要使用闭包\"><a href=\"#为什么要使用闭包\" class=\"headerlink\" title=\"为什么要使用闭包\"></a>为什么要使用闭包</h1><p>闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>\n<p>一般来说，当对象中只有一个方法时，这时使用闭包是更好的选择。来看一个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">adder</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">y</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">adder5 = adder(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\"># 输出 15</span></span><br><span class=\"line\">adder5(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\"># 输出 11</span></span><br><span class=\"line\">adder5(<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n<p>这比用类来实现更优雅，此外装饰器也是基于闭包的一种应用场景。</p>\n<p>所有函数都有一个 __closure__属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>adder.__closure__</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>adder5.__closure__</span><br><span class=\"line\">(&lt;cell at <span class=\"number\">0x103075910</span>: <span class=\"built_in\">int</span> <span class=\"built_in\">object</span> at <span class=\"number\">0x7fd251604518</span>&gt;,)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>adder5.__closure__[<span class=\"number\">0</span>].cell_contents</span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>这解释了为什么局部变量脱离函数之后，还可以在函数之外被访问的原因的，因为它存储在了闭包的 cell_contents中了。</p>\n","slug":"Python-闭包","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/25/Python-%E9%97%AD%E5%8C%85/","excerpt":"什么是闭包？闭包有什么用？为什么要用闭包？今天我们就带着这3个问题来一步一步认识闭包。闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"http://vwin.github.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"Python-lambda函数","date":"2018-12-25T20:08:54.000Z","path":"2018/12/25/Python-lambda函数/","text":"Python 中定义函数有两种方法，一种是用常规方式 def 定义，函数要指定名字，第二种是用 lambda 定义，不需要指定名字，称为 Lambda 函数。 Lambda 函数又称匿名函数，匿名函数就是没有名字的函数，函数没有名字也行？当然可以啦。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就没必要非给它取个名字不可。 好比电影里面的群众演员，往往他们的戏份很少，最多是衬托主演，跑跑龙套，他们需要名字吗？不需要，因为他们仅仅只是临时出镜，下次可能就用不着了，所以犯不着费心思给他们每个人编个号取个名字，毕竟取个优雅的名字是很费劲的事情。 先来看个简单 lambda 函数 12&gt;&gt;&gt; lambda x, y : x+y&lt;function &lt;lambda&gt; at 0x102bc1c80&gt; x 和 y 是函数的两个参数，冒号后面的表达式是函数的返回值，你能一眼看出这个函数就是是在求两个变量的和，但作为一个函数，没有名字如何使用呢？这里我们暂且给这个匿名函数绑定一个名字，这样使得我们调用匿名函数成为可能 12345&gt;&gt;&gt; add = lambda x, y : x+y&gt;&gt;&gt; add&lt;function &lt;lambda&gt; at 0x102bc2140&gt;&gt;&gt;&gt; add(1,2)3 它等同于常规函数 1234567&gt;&gt;&gt; def add2(x, y):... return x+y...&gt;&gt;&gt; add2&lt;function add2 at 0x102bc1c80&gt;&gt;&gt;&gt; add2(1,2)3 如果定义匿名函数，还要给它绑定一个名字的话，有点画蛇添足，通常是直接使用 lambda 函数。那么 lamdba 函数的正确使用场景在哪呢？ 函数式编程尽管 Python 算不上是一门纯函数式编程语言，但它本身提供了很多函数式编程的特性，像 map、reduce、filter、sorted 这些函数都支持函数作为参数，lambda 函数就可以应用在函数式编程中。 请看题：一个整数列表，要求按照列表中元素的绝对值大小升序排列，你会怎么做？思考一分钟往下看 123&gt;&gt;&gt; list1 = [3,5,-4,-1,0,-2,-6]&gt;&gt;&gt; sorted(list1, key=lambda x: abs(x))[0, -1, -2, 3, -4, 5, -6] 排序函数 sorted 支持接收一个函数作为参数，该参数作为 sorted 的排序依据，这里按照列表元素的绝对值进行排序，当然，我也可以用普通函数来实现： 12345&gt;&gt;&gt; def foo(x):... return abs(x)...&gt;&gt;&gt; sorted(list1, key=foo)[0, -1, -2, 3, -4, 5, -6] 只不过是这种方式代码看起来不够 Pythonic 而已。 闭包闭包本身是一个晦涩难懂的概念，它可以专门单独用一篇文章来介绍，不过在这里我们可以简单粗暴地理解为闭包就是一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域范围也依然能被访问到。 来看一个用 lambda 函数作为闭包的例子。 123456&gt;&gt;&gt; def my_add(n):... return lambda x:x+n...&gt;&gt;&gt; add_3 = my_add(3)&gt;&gt;&gt; add_3(7)10 这里的 lambda 函数就是一个闭包，在全局作用域范围中，add_3(7) 可以正常执行且返回值为10，之所以返回10是因为在 my_add 局部作用域中，变量 n 的值在闭包的作用使得它在全局作用域也可以被访问到。 换成常规函数也可以实现闭包，只不过是这种方式稍显啰嗦。 12345678&gt;&gt;&gt; def my_add(n):... def wrapper(x):... return x+n... return wrapper...&gt;&gt;&gt; add_5 = my_add(5)&gt;&gt;&gt; add_5(2)7 那么是不是任何情况 lambda 函数都要比常规函数更清晰明了呢？看这个例子： 1f = lambda x: [[y for j, y in enumerate(set(x)) if (i &gt;&gt; j) &amp; 1] for i in range(2**len(set(x)))] 这是一个返回某个集合的所有子集的 lambda 函数，你看明白了吗？我是很难一眼看出来 zen of python 中有这样一句话是 Explicit is better than implicit(明了胜于晦涩)。记住，如果用 lambda 函数不能使你的代码变得更清晰时，这时你就要考虑使用常规的方式来定义函数。","raw":"---\ntitle: Python-lambda函数\ntoc: true\ndate: 2018-12-26 04:08:54\ntags: [python,lambda]\ncategories: [技术]\ndescription:\n---\nPython 中定义函数有两种方法，一种是用常规方式 def 定义，函数要指定名字，第二种是用 lambda 定义，不需要指定名字，称为 Lambda 函数。\n\nLambda 函数又称匿名函数，匿名函数就是没有名字的函数，函数没有名字也行？当然可以啦。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就没必要非给它取个名字不可。\n\n好比电影里面的群众演员，往往他们的戏份很少，最多是衬托主演，跑跑龙套，他们需要名字吗？不需要，因为他们仅仅只是临时出镜，下次可能就用不着了，所以犯不着费心思给他们每个人编个号取个名字，毕竟取个优雅的名字是很费劲的事情。\n\n<!--more-->\n先来看个简单 lambda 函数\n```python\n>>> lambda x, y : x+y\n<function <lambda> at 0x102bc1c80>\n```\nx 和 y 是函数的两个参数，冒号后面的表达式是函数的返回值，你能一眼看出这个函数就是是在求两个变量的和，但作为一个函数，没有名字如何使用呢？这里我们暂且给这个匿名函数绑定一个名字，这样使得我们调用匿名函数成为可能\n```python\n>>> add = lambda x, y : x+y\n>>> add\n<function <lambda> at 0x102bc2140>\n>>> add(1,2)\n3\n```\n它等同于常规函数\n```python\n>>> def add2(x, y):\n...     return x+y\n...\n>>> add2\n<function add2 at 0x102bc1c80>\n>>> add2(1,2)\n3\n```\n如果定义匿名函数，还要给它绑定一个名字的话，有点画蛇添足，通常是直接使用 lambda 函数。那么 lamdba 函数的正确使用场景在哪呢？\n\n# 函数式编程\n\n尽管 Python 算不上是一门纯函数式编程语言，但它本身提供了很多函数式编程的特性，像 map、reduce、filter、sorted 这些函数都支持函数作为参数，lambda 函数就可以应用在函数式编程中。\n\n请看题：一个整数列表，要求按照列表中元素的绝对值大小升序排列，你会怎么做？思考一分钟往下看\n```python\n>>> list1 = [3,5,-4,-1,0,-2,-6]\n>>> sorted(list1, key=lambda x: abs(x))\n[0, -1, -2, 3, -4, 5, -6]\n```\n排序函数 sorted 支持接收一个函数作为参数，该参数作为 sorted 的排序依据，这里按照列表元素的绝对值进行排序，当然，我也可以用普通函数来实现：\n```python\n>>> def foo(x):\n...     return abs(x)\n...\n>>> sorted(list1, key=foo)\n[0, -1, -2, 3, -4, 5, -6]\n```\n只不过是这种方式代码看起来不够 Pythonic 而已。\n\n# 闭包\n\n闭包本身是一个晦涩难懂的概念，它可以专门单独用一篇文章来介绍，不过在这里我们可以简单粗暴地理解为闭包就是一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域范围也依然能被访问到。\n\n来看一个用 lambda 函数作为闭包的例子。\n```python\n>>> def my_add(n):\n...     return lambda x:x+n\n...\n>>> add_3 = my_add(3)\n>>> add_3(7)\n10\n```\n这里的 lambda 函数就是一个闭包，在全局作用域范围中，add_3(7) 可以正常执行且返回值为10，之所以返回10是因为在 my_add 局部作用域中，变量 n 的值在闭包的作用使得它在全局作用域也可以被访问到。\n\n换成常规函数也可以实现闭包，只不过是这种方式稍显啰嗦。\n```python\n>>> def my_add(n):\n...     def wrapper(x):\n...         return x+n\n...     return wrapper\n...\n>>> add_5 = my_add(5)\n>>> add_5(2)\n7\n```\n那么是不是任何情况 lambda 函数都要比常规函数更清晰明了呢？看这个例子：\n```python\nf = lambda x: [[y for j, y in enumerate(set(x)) if (i >> j) & 1] for i in range(2**len(set(x)))]\n```\n这是一个返回某个集合的所有子集的 lambda 函数，你看明白了吗？我是很难一眼看出来\n\nzen of python 中有这样一句话是 Explicit is better than implicit(明了胜于晦涩)。记住，如果用 lambda 函数不能使你的代码变得更清晰时，这时你就要考虑使用常规的方式来定义函数。\n","content":"<p>Python 中定义函数有两种方法，一种是用常规方式 def 定义，函数要指定名字，第二种是用 lambda 定义，不需要指定名字，称为 Lambda 函数。</p>\n<p>Lambda 函数又称匿名函数，匿名函数就是没有名字的函数，函数没有名字也行？当然可以啦。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就没必要非给它取个名字不可。</p>\n<p>好比电影里面的群众演员，往往他们的戏份很少，最多是衬托主演，跑跑龙套，他们需要名字吗？不需要，因为他们仅仅只是临时出镜，下次可能就用不着了，所以犯不着费心思给他们每个人编个号取个名字，毕竟取个优雅的名字是很费劲的事情。</p>\n<span id=\"more\"></span>\n<p>先来看个简单 lambda 函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">lambda</span> x, y : x+y</span><br><span class=\"line\">&lt;function &lt;<span class=\"keyword\">lambda</span>&gt; at <span class=\"number\">0x102bc1c80</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>x 和 y 是函数的两个参数，冒号后面的表达式是函数的返回值，你能一眼看出这个函数就是是在求两个变量的和，但作为一个函数，没有名字如何使用呢？这里我们暂且给这个匿名函数绑定一个名字，这样使得我们调用匿名函数成为可能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add = <span class=\"keyword\">lambda</span> x, y : x+y</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add</span><br><span class=\"line\">&lt;function &lt;<span class=\"keyword\">lambda</span>&gt; at <span class=\"number\">0x102bc2140</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>它等同于常规函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">add2</span>(<span class=\"params\">x, y</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> x+y</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add2</span><br><span class=\"line\">&lt;function add2 at <span class=\"number\">0x102bc1c80</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add2(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>如果定义匿名函数，还要给它绑定一个名字的话，有点画蛇添足，通常是直接使用 lambda 函数。那么 lamdba 函数的正确使用场景在哪呢？</p>\n<h1 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h1><p>尽管 Python 算不上是一门纯函数式编程语言，但它本身提供了很多函数式编程的特性，像 map、reduce、filter、sorted 这些函数都支持函数作为参数，lambda 函数就可以应用在函数式编程中。</p>\n<p>请看题：一个整数列表，要求按照列表中元素的绝对值大小升序排列，你会怎么做？思考一分钟往下看</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>list1 = [<span class=\"number\">3</span>,<span class=\"number\">5</span>,-<span class=\"number\">4</span>,-<span class=\"number\">1</span>,<span class=\"number\">0</span>,-<span class=\"number\">2</span>,-<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(list1, key=<span class=\"keyword\">lambda</span> x: <span class=\"built_in\">abs</span>(x))</span><br><span class=\"line\">[<span class=\"number\">0</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2</span>, <span class=\"number\">3</span>, -<span class=\"number\">4</span>, <span class=\"number\">5</span>, -<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>排序函数 sorted 支持接收一个函数作为参数，该参数作为 sorted 的排序依据，这里按照列表元素的绝对值进行排序，当然，我也可以用普通函数来实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(x)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(list1, key=foo)</span><br><span class=\"line\">[<span class=\"number\">0</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2</span>, <span class=\"number\">3</span>, -<span class=\"number\">4</span>, <span class=\"number\">5</span>, -<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>只不过是这种方式代码看起来不够 Pythonic 而已。</p>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>闭包本身是一个晦涩难懂的概念，它可以专门单独用一篇文章来介绍，不过在这里我们可以简单粗暴地理解为闭包就是一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域范围也依然能被访问到。</p>\n<p>来看一个用 lambda 函数作为闭包的例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">my_add</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> x:x+n</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_3 = my_add(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_3(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>这里的 lambda 函数就是一个闭包，在全局作用域范围中，add_3(7) 可以正常执行且返回值为10，之所以返回10是因为在 my_add 局部作用域中，变量 n 的值在闭包的作用使得它在全局作用域也可以被访问到。</p>\n<p>换成常规函数也可以实现闭包，只不过是这种方式稍显啰嗦。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">my_add</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> x+n</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_5 = my_add(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_5(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>那么是不是任何情况 lambda 函数都要比常规函数更清晰明了呢？看这个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = <span class=\"keyword\">lambda</span> x: [[y <span class=\"keyword\">for</span> j, y <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(<span class=\"built_in\">set</span>(x)) <span class=\"keyword\">if</span> (i &gt;&gt; j) &amp; <span class=\"number\">1</span>] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>**<span class=\"built_in\">len</span>(<span class=\"built_in\">set</span>(x)))]</span><br></pre></td></tr></table></figure>\n<p>这是一个返回某个集合的所有子集的 lambda 函数，你看明白了吗？我是很难一眼看出来</p>\n<p>zen of python 中有这样一句话是 Explicit is better than implicit(明了胜于晦涩)。记住，如果用 lambda 函数不能使你的代码变得更清晰时，这时你就要考虑使用常规的方式来定义函数。</p>\n","slug":"Python-lambda函数","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/25/Python-lambda%E5%87%BD%E6%95%B0/","excerpt":"Python 中定义函数有两种方法，一种是用常规方式 def 定义，函数要指定名字，第二种是用 lambda 定义，不需要指定名字，称为 Lambda 函数。 Lambda 函数又称匿名函数，匿名函数就是没有名字的函数，函数没有名字也行？当然可以啦。有些函数如果只是临时一用，而且它的业务逻辑也很简单时，就没必要非给它取个名字不可。 好比电影里面的群众演员，往往他们的戏份很少，最多是衬托主演，跑跑龙套，他们需要名字吗？不需要，因为他们仅仅只是临时出镜，下次可能就用不着了，所以犯不着费心思给他们每个人编个号取个名字，毕竟取个优雅的名字是很费劲的事情。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"lambda","slug":"lambda","permalink":"http://vwin.github.io/tags/lambda/"}]},{"title":"Python-sorted函数","date":"2018-12-25T14:48:34.000Z","path":"2018/12/25/Python-sorted函数/","text":"sorted 用于对集合进行排序（这里说的集合是对可迭代对象的一个统称，他们可以是列表、字典、set、甚至是字符串），它的功能非常强大，本文将深入浅出地介绍 sorted 的各种使用场景。 默认排序默认情况，sorted 函数将按列表升序进行排序，并返回一个新列表对象，原列表保持不变，最简单的排序 123&gt;&gt;&gt; nums = [3,4,5,2,1]&gt;&gt;&gt; sorted(nums)[1, 2, 3, 4, 5] 降序排序降序排序，如果要按照降序排列，只需指定参数 reverse&#x3D;True 即可 12&gt;&gt;&gt; sorted(nums, reverse=True)[5, 4, 3, 2, 1] 自定义规则排序如果要按照某个特定的规则排序，则需指定参数 key， key 是一个函数（或其它可调用对象），例如：一个字符串构成的列表，我想按照字符串的长度来排序 123&gt;&gt;&gt; chars = [&#x27;Andrew&#x27;, &#x27;This&#x27;, &#x27;a&#x27;, &#x27;from&#x27;, &#x27;is&#x27;, &#x27;string&#x27;, &#x27;test&#x27;]&gt;&gt;&gt; sorted(chars, key=len)[&#x27;a&#x27;, &#x27;is&#x27;, &#x27;from&#x27;, &#x27;test&#x27;, &#x27;This&#x27;, &#x27;Andrew&#x27;, &#x27;string&#x27;] len 是内建函数，sorted 函数在排序的时候会用len去获取每个字符串的长度来排序。 有些人可能使用匿名函数 key&#x3D;lambda x: len(x) ，其实是多此一举。 1234&gt;&gt;&gt; chars = [&#x27;Andrew&#x27;, &#x27;This&#x27;, &#x27;a&#x27;, &#x27;from&#x27;, &#x27;is&#x27;, &#x27;string&#x27;, &#x27;test&#x27;]&gt;&gt;&gt; sorted(chars, key=lambda x: len(x))[&#x27;a&#x27;, &#x27;is&#x27;, &#x27;from&#x27;, &#x27;test&#x27;, &#x27;This&#x27;, &#x27;Andrew&#x27;, &#x27;string&#x27;] 复合排序如果是一个复合列表结构，例如：由元组构成的列表，要按照元组中的第二个元素排序，那么可以用 lambda 定义一个匿名函数，这里就是按照第二个元素的字母升序来排列的 123&gt;&gt;&gt; students = [(&#x27;zhang&#x27;, &#x27;A&#x27;), (&#x27;li&#x27;, &#x27;D&#x27;), (&#x27;wang&#x27;, &#x27;C&#x27;)]&gt;&gt;&gt; sorted(students, key=lambda x: x[1])[(&#x27;zhang&#x27;, &#x27;A&#x27;), (&#x27;wang&#x27;, &#x27;C&#x27;), (&#x27;li&#x27;, &#x27;D&#x27;)] 这里将按照字母 A-C-D 的顺序排列。 类的实例对象排序如果要排序的元素是自定义类，例如Student类按照年龄来排序，则可以写成 123456789101112131415&gt;&gt;&gt; class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age))&gt;&gt;&gt; student_objects = [ Student(&#x27;john&#x27;, &#x27;A&#x27;, 15), Student(&#x27;jane&#x27;, &#x27;B&#x27;, 12), Student(&#x27;lily&#x27;, &#x27;A&#x27;, 12), Student(&#x27;dave&#x27;, &#x27;B&#x27;, 10), ]&gt;&gt;&gt; sorted(student_objects, key=lambda t:t.age)[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;lily&#x27;, &#x27;A&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)] 多个值排序和数据库的排序一样，sorted 也可以根据多个字段来排序，例如我有先要根据age排序，如果age相同的则根据grade排序，则可以使用元组： 12&gt;&gt;&gt; sorted(student_objects, key=lambda t:(t.age, t.grade))[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;lily&#x27;, &#x27;A&#x27;, 12), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)] 不可直接比较的值排序前面碰到的排序场景都是建立在两个元素是可以互相比较的前提下，例如数值按大小比较， 字母按ASCII顺序比较，如果遇到本身是不可比较的，需要我们自己来定义比较规则的情况如何处理呢？ 举个简单的例子： 123&gt;&gt;&gt; nums = [2, 1.5, 2.5, &#x27;2&#x27;, &#x27;2.5&#x27;]&gt;&gt;&gt; sorted(nums)TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27; 一个整数列表中，可能有数字，字符串，在Python3中，字符串与数值是不能比较的，而Python2中任何类型都可以比较，这是两个版本中一个很大的区别： 1234567# python2.7&gt;&gt;&gt; &quot;2.5&quot; &gt; 2True# python3.6&gt;&gt;&gt; &quot;2.5&quot; &gt; 2TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27; 我们需要使用 functools 模块中的 cmp_to_key 来指定比较函数是什么。 1234567891011import functoolsdef compare(x1, x2): if isinstance(x1, str): x1 = float(x1) if isinstance(x2, str): x2 = float(x2) return x1 - x2&gt;&gt;&gt;sorted(nums, key=functools.cmp_to_key(compare))[1.5, 2, &#x27;2&#x27;, 2.5, &#x27;2.5&#x27;] 定义com_to_key关于 sorted 函数，Python2和Python3之间的区别是Python2中的sorted 可以指定cmp关键字参数，就是当遇到需要自定义比较操作的数据可以通过 cmp&#x3D;compare 来实现，不需要像Python3中还需要导入functools.cmp_to_key实现。 1234567891011nums = [2, 1.5, 2.5, &#x27;2&#x27;, &#x27;2.5&#x27;]def compare(x1, x2): if isinstance(x1, str): x1 = float(x1) if isinstance(x2, str): x2 = float(x2) return 1 if x1 - x2 &gt; 0 else -1 if x1 - x2 &lt; 0 else 0&gt;&gt;&gt; sorted(nums, cmp=compare)[1.5, 2, &#x27;2&#x27;, 2.5, &#x27;2.5&#x27;] 其实，在Python2中，上面这种情况你不指定cmp，默认也会按照这种方式排序，记住，Python2中，任何东西（不同类型之间）都可以比较，而Python3只有同类型数据可以比较。 优化排序对于集合构成的列表，有一种更高效的方法指定这个key 123&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; sorted(students, key=itemgetter(1))[(&#x27;zhang&#x27;, &#x27;A&#x27;), (&#x27;wang&#x27;, &#x27;C&#x27;), (&#x27;li&#x27;, &#x27;D&#x27;)] 高级排序同样的，对于自定义类，也有一种更高效的方法指定key 123&gt;&gt;&gt; from operator import attrgetter&gt;&gt;&gt; sorted(student_objects, key=attrgetter(&#x27;age&#x27;))[(&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;john&#x27;, &#x27;A&#x27;, 15)] 如果参与排序的字段有两个怎么办，你可以这样： 12&gt;&gt;&gt; sorted(student_objects, key=attrgetter(&#x27;grade&#x27;, &#x27;age&#x27;))[(&#x27;john&#x27;, &#x27;A&#x27;, 15), (&#x27;dave&#x27;, &#x27;B&#x27;, 10), (&#x27;jane&#x27;, &#x27;B&#x27;, 12)] 以上是关于 sorted 函数的全部。","raw":"---\ntitle: Python-sorted函数\ntoc: true\ndate: 2018-12-25 22:48:34\ntags: [python,sorted]\ncategories: [技术]\ndescription:\n---\nsorted 用于对集合进行排序（这里说的集合是对可迭代对象的一个统称，他们可以是列表、字典、set、甚至是字符串），它的功能非常强大，本文将深入浅出地介绍 sorted 的各种使用场景。\n\n# 默认排序\n默认情况，sorted 函数将按列表升序进行排序，并返回一个新列表对象，原列表保持不变，最简单的排序\n```python\n>>> nums = [3,4,5,2,1]\n>>> sorted(nums)\n[1, 2, 3, 4, 5]\n```\n<!--more-->\n\n# 降序排序\n降序排序，如果要按照降序排列，只需指定参数 reverse=True 即可\n```python\n>>> sorted(nums, reverse=True)\n[5, 4, 3, 2, 1]\n```\n\n# 自定义规则排序\n如果要按照某个特定的规则排序，则需指定参数 key， key 是一个函数（或其它可调用对象），例如：一个字符串构成的列表，我想按照字符串的长度来排序\n```python\n>>> chars = ['Andrew', 'This', 'a', 'from', 'is', 'string', 'test']\n>>> sorted(chars, key=len)\n['a', 'is', 'from', 'test', 'This', 'Andrew', 'string']\n```\n\nlen 是内建函数，sorted 函数在排序的时候会用len去获取每个字符串的长度来排序。 有些人可能使用匿名函数 key=lambda x: len(x) ，其实是多此一举。\n```python\n>>> chars = ['Andrew', 'This', 'a', 'from', 'is', 'string', 'test']\n\n>>> sorted(chars, key=lambda x: len(x))\n['a', 'is', 'from', 'test', 'This', 'Andrew', 'string']\n```\n# 复合排序\n如果是一个复合列表结构，例如：由元组构成的列表，要按照元组中的第二个元素排序，那么可以用 lambda 定义一个匿名函数，这里就是按照第二个元素的字母升序来排列的\n```python\n>>> students = [('zhang', 'A'), ('li', 'D'), ('wang', 'C')]\n>>> sorted(students, key=lambda x: x[1])\n[('zhang', 'A'), ('wang', 'C'), ('li', 'D')]\n```\n\n这里将按照字母 A-C-D 的顺序排列。\n\n# 类的实例对象排序\n如果要排序的元素是自定义类，例如Student类按照年龄来排序，则可以写成\n```python\n>>> class Student:\n         def __init__(self, name, grade, age):\n             self.name = name\n             self.grade = grade\n             self.age = age\n         def __repr__(self):\n             return repr((self.name, self.grade, self.age))\n\n>>> student_objects = [\n     Student('john', 'A', 15),\n     Student('jane', 'B', 12),\n     Student('lily', 'A', 12),\n     Student('dave', 'B', 10), ]\n>>> sorted(student_objects, key=lambda t:t.age)\n[('dave', 'B', 10), ('jane', 'B', 12), ('lily', 'A', 12), ('john', 'A', 15)]\n```\n\n# 多个值排序\n和数据库的排序一样，sorted 也可以根据多个字段来排序，例如我有先要根据age排序，如果age相同的则根据grade排序，则可以使用元组：\n```python\n>>> sorted(student_objects, key=lambda t:(t.age, t.grade))\n[('dave', 'B', 10), ('lily', 'A', 12), ('jane', 'B', 12), ('john', 'A', 15)]\n```\n# 不可直接比较的值排序\n前面碰到的排序场景都是建立在两个元素是可以互相比较的前提下，例如数值按大小比较， 字母按ASCII顺序比较，如果遇到本身是不可比较的，需要我们自己来定义比较规则的情况如何处理呢？\n\n举个简单的例子：\n```python\n>>> nums = [2, 1.5, 2.5, '2', '2.5']\n>>> sorted(nums)\nTypeError: '<' not supported between instances of 'str' and 'int'\n```\n\n一个整数列表中，可能有数字，字符串，在Python3中，字符串与数值是不能比较的，而Python2中任何类型都可以比较，这是两个版本中一个很大的区别：\n```python\n# python2.7\n>>> \"2.5\" > 2\nTrue\n\n# python3.6\n>>> \"2.5\" > 2\nTypeError: '>' not supported between instances of 'str' and 'int'\n```\n我们需要使用 functools 模块中的 cmp_to_key 来指定比较函数是什么。\n```python\nimport functools\ndef compare(x1, x2):\n    if isinstance(x1, str):\n        x1 = float(x1)\n    if isinstance(x2, str):\n        x2 = float(x2)\n\n    return x1 - x2\n\n>>>sorted(nums, key=functools.cmp_to_key(compare))\n[1.5, 2, '2', 2.5, '2.5']\n```\n# 定义com_to_key\n关于 sorted 函数，Python2和Python3之间的区别是Python2中的sorted 可以指定cmp关键字参数，就是当遇到需要自定义比较操作的数据可以通过 cmp=compare 来实现，不需要像Python3中还需要导入functools.cmp_to_key实现。\n```python\nnums = [2, 1.5, 2.5, '2', '2.5']\n\ndef compare(x1, x2):\n    if isinstance(x1, str):\n        x1 = float(x1)\n    if isinstance(x2, str):\n        x2 = float(x2)\n    return 1 if x1 - x2 > 0 else -1 if x1 - x2 < 0 else 0\n\n>>> sorted(nums, cmp=compare)\n[1.5, 2, '2', 2.5, '2.5']\n```\n\n其实，在Python2中，上面这种情况你不指定cmp，默认也会按照这种方式排序，记住，Python2中，任何东西（不同类型之间）都可以比较，而Python3只有同类型数据可以比较。\n\n# 优化排序\n对于集合构成的列表，有一种更高效的方法指定这个key\n```python\n>>> from operator import itemgetter\n>>> sorted(students, key=itemgetter(1))\n[('zhang', 'A'), ('wang', 'C'), ('li', 'D')]\n```\n# 高级排序\n同样的，对于自定义类，也有一种更高效的方法指定key\n```python\n>>> from operator import attrgetter\n>>> sorted(student_objects, key=attrgetter('age'))\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n```\n如果参与排序的字段有两个怎么办，你可以这样：\n```python\n>>> sorted(student_objects, key=attrgetter('grade', 'age'))\n[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n```\n以上是关于 sorted 函数的全部。\n","content":"<p>sorted 用于对集合进行排序（这里说的集合是对可迭代对象的一个统称，他们可以是列表、字典、set、甚至是字符串），它的功能非常强大，本文将深入浅出地介绍 sorted 的各种使用场景。</p>\n<h1 id=\"默认排序\"><a href=\"#默认排序\" class=\"headerlink\" title=\"默认排序\"></a>默认排序</h1><p>默认情况，sorted 函数将按列表升序进行排序，并返回一个新列表对象，原列表保持不变，最简单的排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nums = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(nums)</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n\n<h1 id=\"降序排序\"><a href=\"#降序排序\" class=\"headerlink\" title=\"降序排序\"></a>降序排序</h1><p>降序排序，如果要按照降序排列，只需指定参数 reverse&#x3D;True 即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(nums, reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自定义规则排序\"><a href=\"#自定义规则排序\" class=\"headerlink\" title=\"自定义规则排序\"></a>自定义规则排序</h1><p>如果要按照某个特定的规则排序，则需指定参数 key， key 是一个函数（或其它可调用对象），例如：一个字符串构成的列表，我想按照字符串的长度来排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>chars = [<span class=\"string\">&#x27;Andrew&#x27;</span>, <span class=\"string\">&#x27;This&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;from&#x27;</span>, <span class=\"string\">&#x27;is&#x27;</span>, <span class=\"string\">&#x27;string&#x27;</span>, <span class=\"string\">&#x27;test&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(chars, key=<span class=\"built_in\">len</span>)</span><br><span class=\"line\">[<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;is&#x27;</span>, <span class=\"string\">&#x27;from&#x27;</span>, <span class=\"string\">&#x27;test&#x27;</span>, <span class=\"string\">&#x27;This&#x27;</span>, <span class=\"string\">&#x27;Andrew&#x27;</span>, <span class=\"string\">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>len 是内建函数，sorted 函数在排序的时候会用len去获取每个字符串的长度来排序。 有些人可能使用匿名函数 key&#x3D;lambda x: len(x) ，其实是多此一举。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>chars = [<span class=\"string\">&#x27;Andrew&#x27;</span>, <span class=\"string\">&#x27;This&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;from&#x27;</span>, <span class=\"string\">&#x27;is&#x27;</span>, <span class=\"string\">&#x27;string&#x27;</span>, <span class=\"string\">&#x27;test&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(chars, key=<span class=\"keyword\">lambda</span> x: <span class=\"built_in\">len</span>(x))</span><br><span class=\"line\">[<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;is&#x27;</span>, <span class=\"string\">&#x27;from&#x27;</span>, <span class=\"string\">&#x27;test&#x27;</span>, <span class=\"string\">&#x27;This&#x27;</span>, <span class=\"string\">&#x27;Andrew&#x27;</span>, <span class=\"string\">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"复合排序\"><a href=\"#复合排序\" class=\"headerlink\" title=\"复合排序\"></a>复合排序</h1><p>如果是一个复合列表结构，例如：由元组构成的列表，要按照元组中的第二个元素排序，那么可以用 lambda 定义一个匿名函数，这里就是按照第二个元素的字母升序来排列的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>students = [(<span class=\"string\">&#x27;zhang&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>), (<span class=\"string\">&#x27;li&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>), (<span class=\"string\">&#x27;wang&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(students, key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</span><br><span class=\"line\">[(<span class=\"string\">&#x27;zhang&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>), (<span class=\"string\">&#x27;wang&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>), (<span class=\"string\">&#x27;li&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>)]</span><br></pre></td></tr></table></figure>\n\n<p>这里将按照字母 A-C-D 的顺序排列。</p>\n<h1 id=\"类的实例对象排序\"><a href=\"#类的实例对象排序\" class=\"headerlink\" title=\"类的实例对象排序\"></a>类的实例对象排序</h1><p>如果要排序的元素是自定义类，例如Student类按照年龄来排序，则可以写成</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>:</span><br><span class=\"line\">         <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name, grade, age</span>):</span><br><span class=\"line\">             self.name = name</span><br><span class=\"line\">             self.grade = grade</span><br><span class=\"line\">             self.age = age</span><br><span class=\"line\">         <span class=\"keyword\">def</span> <span class=\"title function_\">__repr__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"built_in\">repr</span>((self.name, self.grade, self.age))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>student_objects = [</span><br><span class=\"line\">     Student(<span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">15</span>),</span><br><span class=\"line\">     Student(<span class=\"string\">&#x27;jane&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">12</span>),</span><br><span class=\"line\">     Student(<span class=\"string\">&#x27;lily&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">12</span>),</span><br><span class=\"line\">     Student(<span class=\"string\">&#x27;dave&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">10</span>), ]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(student_objects, key=<span class=\"keyword\">lambda</span> t:t.age)</span><br><span class=\"line\">[(<span class=\"string\">&#x27;dave&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">10</span>), (<span class=\"string\">&#x27;jane&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">12</span>), (<span class=\"string\">&#x27;lily&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">12</span>), (<span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">15</span>)]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"多个值排序\"><a href=\"#多个值排序\" class=\"headerlink\" title=\"多个值排序\"></a>多个值排序</h1><p>和数据库的排序一样，sorted 也可以根据多个字段来排序，例如我有先要根据age排序，如果age相同的则根据grade排序，则可以使用元组：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(student_objects, key=<span class=\"keyword\">lambda</span> t:(t.age, t.grade))</span><br><span class=\"line\">[(<span class=\"string\">&#x27;dave&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">10</span>), (<span class=\"string\">&#x27;lily&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">12</span>), (<span class=\"string\">&#x27;jane&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">12</span>), (<span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">15</span>)]</span><br></pre></td></tr></table></figure>\n<h1 id=\"不可直接比较的值排序\"><a href=\"#不可直接比较的值排序\" class=\"headerlink\" title=\"不可直接比较的值排序\"></a>不可直接比较的值排序</h1><p>前面碰到的排序场景都是建立在两个元素是可以互相比较的前提下，例如数值按大小比较， 字母按ASCII顺序比较，如果遇到本身是不可比较的，需要我们自己来定义比较规则的情况如何处理呢？</p>\n<p>举个简单的例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nums = [<span class=\"number\">2</span>, <span class=\"number\">1.5</span>, <span class=\"number\">2.5</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;2.5&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(nums)</span><br><span class=\"line\">TypeError: <span class=\"string\">&#x27;&lt;&#x27;</span> <span class=\"keyword\">not</span> supported between instances of <span class=\"string\">&#x27;str&#x27;</span> <span class=\"keyword\">and</span> <span class=\"string\">&#x27;int&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>一个整数列表中，可能有数字，字符串，在Python3中，字符串与数值是不能比较的，而Python2中任何类型都可以比较，这是两个版本中一个很大的区别：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python2.7</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">&quot;2.5&quot;</span> &gt; <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># python3.6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">&quot;2.5&quot;</span> &gt; <span class=\"number\">2</span></span><br><span class=\"line\">TypeError: <span class=\"string\">&#x27;&gt;&#x27;</span> <span class=\"keyword\">not</span> supported between instances of <span class=\"string\">&#x27;str&#x27;</span> <span class=\"keyword\">and</span> <span class=\"string\">&#x27;int&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>我们需要使用 functools 模块中的 cmp_to_key 来指定比较函数是什么。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">compare</span>(<span class=\"params\">x1, x2</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(x1, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        x1 = <span class=\"built_in\">float</span>(x1)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(x2, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        x2 = <span class=\"built_in\">float</span>(x2)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x1 - x2</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"built_in\">sorted</span>(nums, key=functools.cmp_to_key(compare))</span><br><span class=\"line\">[<span class=\"number\">1.5</span>, <span class=\"number\">2</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"number\">2.5</span>, <span class=\"string\">&#x27;2.5&#x27;</span>]</span><br></pre></td></tr></table></figure>\n<h1 id=\"定义com-to-key\"><a href=\"#定义com-to-key\" class=\"headerlink\" title=\"定义com_to_key\"></a>定义com_to_key</h1><p>关于 sorted 函数，Python2和Python3之间的区别是Python2中的sorted 可以指定cmp关键字参数，就是当遇到需要自定义比较操作的数据可以通过 cmp&#x3D;compare 来实现，不需要像Python3中还需要导入functools.cmp_to_key实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">2</span>, <span class=\"number\">1.5</span>, <span class=\"number\">2.5</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;2.5&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">compare</span>(<span class=\"params\">x1, x2</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(x1, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        x1 = <span class=\"built_in\">float</span>(x1)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(x2, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        x2 = <span class=\"built_in\">float</span>(x2)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"keyword\">if</span> x1 - x2 &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> -<span class=\"number\">1</span> <span class=\"keyword\">if</span> x1 - x2 &lt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(nums, cmp=compare)</span><br><span class=\"line\">[<span class=\"number\">1.5</span>, <span class=\"number\">2</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"number\">2.5</span>, <span class=\"string\">&#x27;2.5&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>其实，在Python2中，上面这种情况你不指定cmp，默认也会按照这种方式排序，记住，Python2中，任何东西（不同类型之间）都可以比较，而Python3只有同类型数据可以比较。</p>\n<h1 id=\"优化排序\"><a href=\"#优化排序\" class=\"headerlink\" title=\"优化排序\"></a>优化排序</h1><p>对于集合构成的列表，有一种更高效的方法指定这个key</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> itemgetter</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(students, key=itemgetter(<span class=\"number\">1</span>))</span><br><span class=\"line\">[(<span class=\"string\">&#x27;zhang&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>), (<span class=\"string\">&#x27;wang&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>), (<span class=\"string\">&#x27;li&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>)]</span><br></pre></td></tr></table></figure>\n<h1 id=\"高级排序\"><a href=\"#高级排序\" class=\"headerlink\" title=\"高级排序\"></a>高级排序</h1><p>同样的，对于自定义类，也有一种更高效的方法指定key</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> attrgetter</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(student_objects, key=attrgetter(<span class=\"string\">&#x27;age&#x27;</span>))</span><br><span class=\"line\">[(<span class=\"string\">&#x27;dave&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">10</span>), (<span class=\"string\">&#x27;jane&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">12</span>), (<span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">15</span>)]</span><br></pre></td></tr></table></figure>\n<p>如果参与排序的字段有两个怎么办，你可以这样：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(student_objects, key=attrgetter(<span class=\"string\">&#x27;grade&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>))</span><br><span class=\"line\">[(<span class=\"string\">&#x27;john&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"number\">15</span>), (<span class=\"string\">&#x27;dave&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">10</span>), (<span class=\"string\">&#x27;jane&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"number\">12</span>)]</span><br></pre></td></tr></table></figure>\n<p>以上是关于 sorted 函数的全部。</p>\n","slug":"Python-sorted函数","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/25/Python-sorted%E5%87%BD%E6%95%B0/","excerpt":"sorted 用于对集合进行排序（这里说的集合是对可迭代对象的一个统称，他们可以是列表、字典、set、甚至是字符串），它的功能非常强大，本文将深入浅出地介绍 sorted 的各种使用场景。 默认排序默认情况，sorted 函数将按列表升序进行排序，并返回一个新列表对象，原列表保持不变，最简单的排序 123&gt;&gt;&gt; nums = [3,4,5,2,1]&gt;&gt;&gt; sorted(nums)[1, 2, 3, 4, 5]","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"sorted","slug":"sorted","permalink":"http://vwin.github.io/tags/sorted/"}]},{"title":"Python-函数","date":"2018-12-25T14:28:02.000Z","path":"2018/12/25/Python-函数/","text":"正确理解 Python函数，能够帮助我们更好地理解 Python 装饰器、匿名函数（lambda）、函数式编程等高阶技术。 函数（Function）作为程序语言中不可或缺的一部分，太稀松平常了。但函数作为第一类对象（First-Class Object）却是 Python 函数的一大特性。那到底什么是第一类对象（First-Class Object）呢？ 函数是对象在 Python 中万物皆为对象，函数也不例外，函数作为对象可以赋值给一个变量、可以作为元素添加到集合对象中、可作为参数值传递给其它函数，还可以当做函数的返回值，这些特性就是第一类对象所特有的。先来看一个简单的例子 12345&gt;&gt;&gt; def foo(text):... return len(text)...&gt;&gt;&gt; foo(&quot;python&quot;)6 这是一个再简单不过的函数，用于计算参数 text 的长度，调用函数就是函数名后面跟一个括号，再附带一个参数，返回值是一个整数。 函数身为一个对象，拥有对象模型的三个通用属性：id、类型、和值。 123456&gt;&gt;&gt; id(foo)4361313816&gt;&gt;&gt; type(foo)&lt;class &#x27;function&#x27;&gt;&gt;&gt;&gt; foo&lt;function foo at 0x103f45e18&gt; 作为对象，函数可以赋值给一个变量 1&gt;&gt;&gt; bar = foo 赋值给另外一个变量时，函数并不会被调用，仅仅是在函数对象上绑定一个新的名字而已。 12&gt;&gt;&gt; bar(&quot;python&quot;)6 同理，你还可以把该函数赋值给更多的变量，唯一变化的是该函数对象的引用计数不断地增加，本质上这些变量最终指向的都是同一个函数对象。 12345&gt;&gt;&gt; a = foo&gt;&gt;&gt; b = foo&gt;&gt;&gt; c = bar&gt;&gt;&gt; a is b is cTrue 函数可以存储在容器容器对象（list、dict、set等）中可以存放任何对象，包括整数、字符串，函数也可以作存放到容器对象中，例如 123456789&gt;&gt;&gt; funcs = [foo, str, len]&gt;&gt;&gt; funcs[&lt;function foo at 0x103f45e18&gt;, &lt;class &#x27;str&#x27;&gt;, &lt;built-in function len&gt;]&gt;&gt;&gt; for f in funcs:... print(f(&quot;hello&quot;))...5hello5 foo 是我们自定义的函数，str 和 len 是两个内置函数。for 循环逐个地迭代出列表中的每个元素时，函数对象赋值给了 f 变量，调用 f(“hello”) 与 调用 foo(“hello”) 本质是一样的效果，每次 f 都重新指向一个新的函数对象。当然，你也可以使用列表的索引定位到元素来调用函数。 123&gt;&gt;&gt; funcs[0](&quot;Python&quot;)# 等效于 foo(&quot;Python&quot;)6 函数可以作为参数函数还可以作为参数值传递给另外一个函数，例如： 123456&gt;&gt;&gt; def show(func):... size = func(&quot;python&quot;) # 等效于 foo(&quot;Python&quot;) ... print (&quot;length of string is : %s&quot; % size)...&gt;&gt;&gt; show(foo)length of string is : 6 函数可以作为返回值函数作为另外一个函数的返回值，例如： 123456789&gt;&gt;&gt; def nick():... return foo&gt;&gt;&gt; nick&lt;function nick at 0x106b549d8&gt;&gt;&gt;&gt; a = nick()&gt;&gt;&gt; a&lt;function foo at 0x10692ae18&gt;&gt;&gt;&gt; a(&quot;python&quot;)6 还可以简写为 12&gt;&gt;&gt; nick()(&quot;python&quot;)6 函数接受一个或多个函数作为输入或者函数输出（返回）的值是函数时，我们称这样的函数为高阶函数，比如上面的 show 和 nick 都属于高阶函数。 Python内置函数中，典型的高阶函数是 map 函数，map 接受一个函数和一个迭代对象作为参数，调用 map 时，依次迭代把迭代对象的元素作为参数调用该函数。 1234&gt;&gt;&gt; map(foo, [&quot;the&quot;,&quot;map&quot;,&quot;of&quot;,&quot;python&quot;])&gt;&gt;&gt; lens = map(foo, [&quot;the&quot;,&quot;map&quot;,&quot;of&quot;,&quot;python&quot;])&gt;&gt;&gt; list(lens)[3, 3, 2, 6] map 函数的作用相当于： 12&gt;&gt;&gt; [foo(i) for i in [&quot;the&quot;,&quot;map&quot;,&quot;of&quot;,&quot;python&quot;]][3, 3, 2, 6] 只不过 map 的运行效率更快一点。 函数可以嵌套Python还允许函数中定义函数，这种函数叫嵌套函数。 123456789&gt;&gt;&gt; def get_length(text):... def clean(t): # 2... return t[1:]... new_text = clean(text) # 1... return len(new_text)...&gt;&gt;&gt; get_length(&quot;python&quot;)5&gt;&gt;&gt; 这个函数的目的是去除字符串的第一个字符后再计算它的长度，尽管函数本身的意义不大，但能足够说明嵌套函数。get_length 调用时，先执行1处代码，发现有调用 clean 函数，于是接着执行2中的代码，把返回值赋值给了 new_text ，再继续执行后续代码。 1234&gt;&gt;&gt; clean(&quot;python&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;clean&#x27; is not defined 函数中里面嵌套的函数不能在函数外面访问，只能是在函数内部使用，超出了外部函数的做用域就无效了。 实现了 call 的类也可以作为函数对于一个自定义的类，如果实现了 call 方法，那么该类的实例对象的行为就是一个函数，是一个可以被调用（callable)的对象。例如： 123456789class Add: def __init__(self, n): self.n = n def __call__(self, x): return self.n + x&gt;&gt;&gt; add = Add(1)&gt;&gt;&gt; add(4)&gt;&gt;&gt; 5 执行 add(4) 相当于调用 Add.call_(add, 4)，self 就是实例对象 add，self.n 等于 1，所以返回值为 1+4 12345add(4) ||Add(1)(4) ||Add.__call__(add, 4) 确定对象是否为可调用对象可以用内置函数callable来判断。 123456&gt;&gt;&gt; callable(foo)True&gt;&gt;&gt; callable(1)False&gt;&gt;&gt; callable(int)True 总结Python中包含函数在内的一切皆为对象，函数作为第一类对象，支持赋值给变量，作为参数传递给其它函数，作为其它函数的返回值，支持函数的嵌套，实现了__call__方法的类实例对象也可以当做函数被调用。","raw":"---\ntitle: Python-函数\ntoc: true\ndate: 2018-12-25 22:28:02\ntags: [函数,python]\ncategories: [技术]\ndescription:\n---\n正确理解 Python函数，能够帮助我们更好地理解 Python 装饰器、匿名函数（lambda）、函数式编程等高阶技术。\n\n函数（Function）作为程序语言中不可或缺的一部分，太稀松平常了。但函数作为第一类对象（First-Class Object）却是 Python 函数的一大特性。那到底什么是第一类对象（First-Class Object）呢？\n\n<!--more-->\n\n# 函数是对象\n在 Python 中万物皆为对象，函数也不例外，函数作为对象可以赋值给一个变量、可以作为元素添加到集合对象中、可作为参数值传递给其它函数，还可以当做函数的返回值，这些特性就是第一类对象所特有的。\n先来看一个简单的例子\n```python\n>>> def foo(text):\n...     return len(text)\n...\n>>> foo(\"python\")\n6\n```\n\n这是一个再简单不过的函数，用于计算参数 text 的长度，调用函数就是函数名后面跟一个括号，再附带一个参数，返回值是一个整数。\n\n函数身为一个对象，拥有对象模型的三个通用属性：id、类型、和值。\n\n```python\n>>> id(foo)\n4361313816\n>>> type(foo)\n<class 'function'>\n>>> foo\n<function foo at 0x103f45e18>\n```\n\n作为对象，函数可以赋值给一个变量\n\n```python\n>>> bar = foo\n```\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fyjznyxpgaj308w052t8v.jpg)\n\n赋值给另外一个变量时，函数并不会被调用，仅仅是在函数对象上绑定一个新的名字而已。\n\n```python\n>>> bar(\"python\")\n6\n```\n\n同理，你还可以把该函数赋值给更多的变量，唯一变化的是该函数对象的引用计数不断地增加，本质上这些变量最终指向的都是同一个函数对象。\n\n```python\n>>> a = foo\n>>> b = foo\n>>> c = bar\n>>> a is b is c\nTrue\n```\n\n# 函数可以存储在容器\n容器对象（list、dict、set等）中可以存放任何对象，包括整数、字符串，函数也可以作存放到容器对象中，例如\n```python\n>>> funcs = [foo, str, len]\n>>> funcs\n[<function foo at 0x103f45e18>, <class 'str'>, <built-in function len>]\n>>> for f in funcs:\n...     print(f(\"hello\"))\n...\n5\nhello\n5\n```\n\nfoo 是我们自定义的函数，str 和 len 是两个内置函数。for 循环逐个地迭代出列表中的每个元素时，函数对象赋值给了 f 变量，调用 f(“hello”) 与 调用 foo(“hello”) 本质是一样的效果，每次 f 都重新指向一个新的函数对象。当然，你也可以使用列表的索引定位到元素来调用函数。\n```python\n>>> funcs[0](\"Python\")\n# 等效于 foo(\"Python\")\n6\n```\n# 函数可以作为参数\n函数还可以作为参数值传递给另外一个函数，例如：\n```python\n>>> def show(func):\n...     size = func(\"python\") # 等效于 foo(\"Python\") \n...     print (\"length of string is : %s\" % size)\n...\n>>> show(foo)\nlength of string is : 6\n```\n\n# 函数可以作为返回值\n函数作为另外一个函数的返回值，例如：\n```python\n>>> def nick():\n...     return foo\n>>> nick\n<function nick at 0x106b549d8>\n>>> a = nick()\n>>> a\n<function foo at 0x10692ae18>\n>>> a(\"python\")\n6\n```\n还可以简写为\n```python\n>>> nick()(\"python\")\n6\n```\n函数接受一个或多个函数作为输入或者函数输出（返回）的值是函数时，我们称这样的函数为高阶函数，比如上面的 show 和 nick 都属于高阶函数。\n\nPython内置函数中，典型的高阶函数是 map 函数，map 接受一个函数和一个迭代对象作为参数，调用 map 时，依次迭代把迭代对象的元素作为参数调用该函数。\n```python\n>>> map(foo, [\"the\",\"map\",\"of\",\"python\"])\n>>> lens = map(foo, [\"the\",\"map\",\"of\",\"python\"])\n>>> list(lens)\n[3, 3, 2, 6]\n```\nmap 函数的作用相当于：\n```python\n>>> [foo(i) for i in [\"the\",\"map\",\"of\",\"python\"]]\n[3, 3, 2, 6]\n```\n只不过 map 的运行效率更快一点。\n\n# 函数可以嵌套\nPython还允许函数中定义函数，这种函数叫嵌套函数。\n```python\n>>> def get_length(text):\n...     def clean(t):           # 2\n...         return t[1:]\n...     new_text = clean(text)  # 1\n...     return len(new_text)\n...\n>>> get_length(\"python\")\n5\n>>>\n```\n这个函数的目的是去除字符串的第一个字符后再计算它的长度，尽管函数本身的意义不大，但能足够说明嵌套函数。get_length 调用时，先执行1处代码，发现有调用 clean 函数，于是接着执行2中的代码，把返回值赋值给了 new_text ，再继续执行后续代码。\n```python\n>>> clean(\"python\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'clean' is not defined\n```\n函数中里面嵌套的函数不能在函数外面访问，只能是在函数内部使用，超出了外部函数的做用域就无效了。\n\n# 实现了 __call__ 的类也可以作为函数\n对于一个自定义的类，如果实现了 __call__ 方法，那么该类的实例对象的行为就是一个函数，是一个可以被调用（callable)的对象。例如：\n```python\nclass Add:\n    def __init__(self, n):\n         self.n = n\n    def __call__(self, x):\n        return self.n + x\n\n>>> add = Add(1)\n>>> add(4)\n>>> 5\n```\n执行 add(4) 相当于调用 Add._call__(add, 4)，self 就是实例对象 add，self.n 等于 1，所以返回值为 1+4\n```python\nadd(4)\n  ||\nAdd(1)(4)\n  ||\nAdd.__call__(add, 4)\n```\n确定对象是否为可调用对象可以用内置函数callable来判断。\n```python\n>>> callable(foo)\nTrue\n>>> callable(1)\nFalse\n>>> callable(int)\nTrue\n```\n# 总结\nPython中包含函数在内的一切皆为对象，函数作为第一类对象，支持赋值给变量，作为参数传递给其它函数，作为其它函数的返回值，支持函数的嵌套，实现了__call__方法的类实例对象也可以当做函数被调用。\n\n","content":"<p>正确理解 Python函数，能够帮助我们更好地理解 Python 装饰器、匿名函数（lambda）、函数式编程等高阶技术。</p>\n<p>函数（Function）作为程序语言中不可或缺的一部分，太稀松平常了。但函数作为第一类对象（First-Class Object）却是 Python 函数的一大特性。那到底什么是第一类对象（First-Class Object）呢？</p>\n<span id=\"more\"></span>\n\n<h1 id=\"函数是对象\"><a href=\"#函数是对象\" class=\"headerlink\" title=\"函数是对象\"></a>函数是对象</h1><p>在 Python 中万物皆为对象，函数也不例外，函数作为对象可以赋值给一个变量、可以作为元素添加到集合对象中、可作为参数值传递给其它函数，还可以当做函数的返回值，这些特性就是第一类对象所特有的。<br>先来看一个简单的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">foo</span>(<span class=\"params\">text</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(text)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo(<span class=\"string\">&quot;python&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<p>这是一个再简单不过的函数，用于计算参数 text 的长度，调用函数就是函数名后面跟一个括号，再附带一个参数，返回值是一个整数。</p>\n<p>函数身为一个对象，拥有对象模型的三个通用属性：id、类型、和值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(foo)</span><br><span class=\"line\"><span class=\"number\">4361313816</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(foo)</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;function&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo</span><br><span class=\"line\">&lt;function foo at <span class=\"number\">0x103f45e18</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>作为对象，函数可以赋值给一个变量</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bar = foo</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fyjznyxpgaj308w052t8v.jpg\"></p>\n<p>赋值给另外一个变量时，函数并不会被调用，仅仅是在函数对象上绑定一个新的名字而已。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bar(<span class=\"string\">&quot;python&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<p>同理，你还可以把该函数赋值给更多的变量，唯一变化的是该函数对象的引用计数不断地增加，本质上这些变量最终指向的都是同一个函数对象。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = foo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = foo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = bar</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b <span class=\"keyword\">is</span> c</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数可以存储在容器\"><a href=\"#函数可以存储在容器\" class=\"headerlink\" title=\"函数可以存储在容器\"></a>函数可以存储在容器</h1><p>容器对象（list、dict、set等）中可以存放任何对象，包括整数、字符串，函数也可以作存放到容器对象中，例如</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>funcs = [foo, <span class=\"built_in\">str</span>, <span class=\"built_in\">len</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>funcs</span><br><span class=\"line\">[&lt;function foo at <span class=\"number\">0x103f45e18</span>&gt;, &lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;str&#x27;</span>&gt;, &lt;built-<span class=\"keyword\">in</span> function <span class=\"built_in\">len</span>&gt;]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> funcs:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(f(<span class=\"string\">&quot;hello&quot;</span>))</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p>foo 是我们自定义的函数，str 和 len 是两个内置函数。for 循环逐个地迭代出列表中的每个元素时，函数对象赋值给了 f 变量，调用 f(“hello”) 与 调用 foo(“hello”) 本质是一样的效果，每次 f 都重新指向一个新的函数对象。当然，你也可以使用列表的索引定位到元素来调用函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>funcs[<span class=\"number\">0</span>](<span class=\"string\">&quot;Python&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 等效于 foo(&quot;Python&quot;)</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"函数可以作为参数\"><a href=\"#函数可以作为参数\" class=\"headerlink\" title=\"函数可以作为参数\"></a>函数可以作为参数</h1><p>函数还可以作为参数值传递给另外一个函数，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    size = func(<span class=\"string\">&quot;python&quot;</span>) <span class=\"comment\"># 等效于 foo(&quot;Python&quot;) </span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span> (<span class=\"string\">&quot;length of string is : %s&quot;</span> % size)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>show(foo)</span><br><span class=\"line\">length of string <span class=\"keyword\">is</span> : <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数可以作为返回值\"><a href=\"#函数可以作为返回值\" class=\"headerlink\" title=\"函数可以作为返回值\"></a>函数可以作为返回值</h1><p>函数作为另外一个函数的返回值，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">nick</span>():</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> foo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nick</span><br><span class=\"line\">&lt;function nick at <span class=\"number\">0x106b549d8</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = nick()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">&lt;function foo at <span class=\"number\">0x10692ae18</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a(<span class=\"string\">&quot;python&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>还可以简写为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nick()(<span class=\"string\">&quot;python&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>函数接受一个或多个函数作为输入或者函数输出（返回）的值是函数时，我们称这样的函数为高阶函数，比如上面的 show 和 nick 都属于高阶函数。</p>\n<p>Python内置函数中，典型的高阶函数是 map 函数，map 接受一个函数和一个迭代对象作为参数，调用 map 时，依次迭代把迭代对象的元素作为参数调用该函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">map</span>(foo, [<span class=\"string\">&quot;the&quot;</span>,<span class=\"string\">&quot;map&quot;</span>,<span class=\"string\">&quot;of&quot;</span>,<span class=\"string\">&quot;python&quot;</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lens = <span class=\"built_in\">map</span>(foo, [<span class=\"string\">&quot;the&quot;</span>,<span class=\"string\">&quot;map&quot;</span>,<span class=\"string\">&quot;of&quot;</span>,<span class=\"string\">&quot;python&quot;</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(lens)</span><br><span class=\"line\">[<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>map 函数的作用相当于：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[foo(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"string\">&quot;the&quot;</span>,<span class=\"string\">&quot;map&quot;</span>,<span class=\"string\">&quot;of&quot;</span>,<span class=\"string\">&quot;python&quot;</span>]]</span><br><span class=\"line\">[<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>只不过 map 的运行效率更快一点。</p>\n<h1 id=\"函数可以嵌套\"><a href=\"#函数可以嵌套\" class=\"headerlink\" title=\"函数可以嵌套\"></a>函数可以嵌套</h1><p>Python还允许函数中定义函数，这种函数叫嵌套函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">get_length</span>(<span class=\"params\">text</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">def</span> <span class=\"title function_\">clean</span>(<span class=\"params\">t</span>):           <span class=\"comment\"># 2</span></span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> t[<span class=\"number\">1</span>:]</span><br><span class=\"line\"><span class=\"meta\">... </span>    new_text = clean(text)  <span class=\"comment\"># 1</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(new_text)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>get_length(<span class=\"string\">&quot;python&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>这个函数的目的是去除字符串的第一个字符后再计算它的长度，尽管函数本身的意义不大，但能足够说明嵌套函数。get_length 调用时，先执行1处代码，发现有调用 clean 函数，于是接着执行2中的代码，把返回值赋值给了 new_text ，再继续执行后续代码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>clean(<span class=\"string\">&quot;python&quot;</span>)</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">NameError: name <span class=\"string\">&#x27;clean&#x27;</span> <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> defined</span><br></pre></td></tr></table></figure>\n<p>函数中里面嵌套的函数不能在函数外面访问，只能是在函数内部使用，超出了外部函数的做用域就无效了。</p>\n<h1 id=\"实现了-call-的类也可以作为函数\"><a href=\"#实现了-call-的类也可以作为函数\" class=\"headerlink\" title=\"实现了 call 的类也可以作为函数\"></a>实现了 <strong>call</strong> 的类也可以作为函数</h1><p>对于一个自定义的类，如果实现了 <strong>call</strong> 方法，那么该类的实例对象的行为就是一个函数，是一个可以被调用（callable)的对象。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Add</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, n</span>):</span><br><span class=\"line\">         self.n = n</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self, x</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.n + x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add = Add(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>执行 add(4) 相当于调用 Add.<em>call</em>_(add, 4)，self 就是实例对象 add，self.n 等于 1，所以返回值为 1+4</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">4</span>)</span><br><span class=\"line\">  ||</span><br><span class=\"line\">Add(<span class=\"number\">1</span>)(<span class=\"number\">4</span>)</span><br><span class=\"line\">  ||</span><br><span class=\"line\">Add.__call__(add, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>确定对象是否为可调用对象可以用内置函数callable来判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">callable</span>(foo)</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">callable</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">callable</span>(<span class=\"built_in\">int</span>)</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Python中包含函数在内的一切皆为对象，函数作为第一类对象，支持赋值给变量，作为参数传递给其它函数，作为其它函数的返回值，支持函数的嵌套，实现了__call__方法的类实例对象也可以当做函数被调用。</p>\n","slug":"Python-函数","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/25/Python-%E5%87%BD%E6%95%B0/","excerpt":"正确理解 Python函数，能够帮助我们更好地理解 Python 装饰器、匿名函数（lambda）、函数式编程等高阶技术。 函数（Function）作为程序语言中不可或缺的一部分，太稀松平常了。但函数作为第一类对象（First-Class Object）却是 Python 函数的一大特性。那到底什么是第一类对象（First-Class Object）呢？","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"函数","slug":"函数","permalink":"http://vwin.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"Python实现斐波那契数列","date":"2018-12-24T21:29:42.000Z","path":"2018/12/24/Python实现斐波那契数列/","text":"斐波那契数列（Fibonacci）最早由印度数学家Gopala提出，而第一个真正研究斐波那契数列的是意大利数学家 Leonardo Fibonacci，斐波那契数列的定义很简单，用数学函数可表示为：数列从0和1开始，之后的数由前两个数相加而得出，例如斐波那契数列的前10个数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34。 用 Python 实现斐波那契数列常见的写法有三种，各算法的执行效率也有很大差别，在面试中也会偶尔会被问到，通常面试的时候不是让你简单的用递归写写就完了，还会问你时间复杂度怎样，空间复杂度怎样，有没有可改进的地方。 递归所谓递归就是指函数的定义中使用了函数自身的方法 12345678910def fib_recur(n): assert n &gt;= 0 if n in (0, 1): return n return fib_recur(n - 1) + fib_recur(n - 2)for i in range(20): print(fib_recur(i), end=&quot; &quot;)&gt;&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 递归是一种代码最简洁的方法，但它是效率非常低，因为会出现大量的重复计算，时间复杂度是：O(1.618 ^ n)，1.618是黄金分割。同时受限于 Python 中递归的最大深度是 1000，所以用递归来求解并不是一种可取的办法。 递推法递推法就是从0和1开始，前两项相加逐个求出第3、第4个数，直到求出第n个数的值 12345678910def fib_loop(n): a, b = 0, 1 for i in range(n): a, b = b, a + b return afor i in range(20): print(fib_loop(i), end=&quot; &quot;)&gt;&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 这种算法的时间复杂是O(n)，呈线性增长，如果数据量巨大，速度越到后面会越慢。 上面两种方式都是使用分而治之的思想，就是把一个大的问题化小，然后利用小问题的求解得到目标问题的答案。 矩阵《线性代数》是大学计算机专业低年级的课程，这门课教的就是矩阵，那时候觉得这东西学起来很枯燥，没什么用处，工作后你才发现搞机器学习、数据分析、数据建模时大有用处，书到用时方恨少。其实矩阵的本质就是线性方程式。 斐波那契数列中两个相邻的项分别为：F(n) 和 F(n - 1)，如果把这两个数当作一个2行1列的矩阵可表示为： 因为 F(n) &#x3D; F(n-1)+F(n-2)，所以就有： 通过反推，其实它是两个矩阵的乘积得来的 依此类推： 最后可推出： 因此想要求出F(n)的值，只要能求出右边矩阵的n-1次方的值，最后求得两矩阵乘积，取新矩阵的第一行的第一列的值即可，比如n&#x3D;3时，​可以得知F(3)的值2，F(2)的值为1，因为幂运算可以使用二分加速，所以矩阵法的时间复杂度为 O(log n) 我们可以用科学计算包 numpy 来实现矩阵法： 123456789import numpydef fib_matr(n): return (numpy.matrix([[1, 1], [1, 0]]) ** (n - 1) * numpy.matrix([[1], [0]]))[0, 0]for i in range(20): print(int(fib_matr(i)), end=&quot; &quot;)&gt;&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 3中不同的算法效率对比： 从上面图可以看出递归法效率惊人的低，矩阵法在数据量比较大的时候才突显出它的优势，递推法随着数据的变大，所花的时间也越来越大。 参考链接： https://www.ted.com/talks/arthur_benjamin_the_magic_of_fibonacci_numbers?language=zh-cn#t-364274https://www.zhihu.com/question/28062458https://www.nayuki.io/page/fast-fibonacci-algorithmshttp://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html","raw":"---\ntitle: Python实现斐波那契数列\ntoc: true\ndate: 2018-12-25 05:29:42\ntags: [斐波那契数列,python,矩阵,递归]\ncategories: [技术]\ndescription:\n---\n斐波那契数列（Fibonacci）最早由印度数学家Gopala提出，而第一个真正研究斐波那契数列的是意大利数学家 Leonardo Fibonacci，斐波那契数列的定义很简单，用数学函数可表示为：\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fyj65lb4mcj30qo0550t0.jpg)\n数列从0和1开始，之后的数由前两个数相加而得出，例如斐波那契数列的前10个数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34。\n\n用 Python 实现斐波那契数列常见的写法有三种，各算法的执行效率也有很大差别，在面试中也会偶尔会被问到，通常面试的时候不是让你简单的用递归写写就完了，还会问你时间复杂度怎样，空间复杂度怎样，有没有可改进的地方。\n\n<!--more-->\n# 递归\n所谓递归就是指函数的定义中使用了函数自身的方法\n```python\ndef fib_recur(n):\n    assert n >= 0\n    if n in (0, 1):\n        return n\n    return fib_recur(n - 1) + fib_recur(n - 2)\n\nfor i in range(20):\n    print(fib_recur(i), end=\" \")\n\n>>> 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 \n```\n递归是一种代码最简洁的方法，但它是效率非常低，因为会出现大量的重复计算，时间复杂度是：O(1.618 ^ n)，1.618是黄金分割。同时受限于 Python 中递归的最大深度是 1000，所以用递归来求解并不是一种可取的办法。\n\n# 递推法\n递推法就是从0和1开始，前两项相加逐个求出第3、第4个数，直到求出第n个数的值\n```python\ndef fib_loop(n):\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a\n\nfor i in range(20):\n    print(fib_loop(i), end=\" \")\n\n>>> 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 \n```\n这种算法的时间复杂是O(n)，呈线性增长，如果数据量巨大，速度越到后面会越慢。\n\n上面两种方式都是使用分而治之的思想，就是把一个大的问题化小，然后利用小问题的求解得到目标问题的答案。\n\n# 矩阵\n《线性代数》是大学计算机专业低年级的课程，这门课教的就是矩阵，那时候觉得这东西学起来很枯燥，没什么用处，工作后你才发现搞机器学习、数据分析、数据建模时大有用处，书到用时方恨少。其实矩阵的本质就是线性方程式。\n\n斐波那契数列中两个相邻的项分别为：F(n) 和 F(n - 1)，如果把这两个数当作一个2行1列的矩阵可表示为：\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fyj676gq2oj302201r0sp.jpg)\n\n因为 F(n) = F(n-1)+F(n-2)，所以就有：\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fyj67kwsswj306c01wmx7.jpg)\n\n通过反推，其实它是两个矩阵的乘积得来的\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyj67tupb5j30i002cdg3.jpg)\n依此类推：\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fyj682o3ouj30hy024mxe.jpg)\n最后可推出：\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fyj68eckjcj30d102p0sv.jpg)\n因此想要求出F(n)的值，只要能求出右边矩阵的n-1次方的值，最后求得两矩阵乘积，取新矩阵的第一行的第一列的值即可，比如n=3时，\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fyj68s0trpj30ch022q32.jpg)\n​可以得知F(3)的值2，F(2)的值为1，因为幂运算可以使用二分加速，所以矩阵法的时间复杂度为 O(log n)\n\n我们可以用科学计算包 numpy 来实现矩阵法：\n\n```python\nimport numpy\n\ndef fib_matr(n):\n    return (numpy.matrix([[1, 1], [1, 0]]) ** (n - 1) * numpy.matrix([[1], [0]]))[0, 0]\n\nfor i in range(20):\n    print(int(fib_matr(i)), end=\" \")\n\n>>> 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181\n```\n3中不同的算法效率对比：\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyj69fgfkvj30f70a0mxv.jpg)\n\n从上面图可以看出递归法效率惊人的低，矩阵法在数据量比较大的时候才突显出它的优势，递推法随着数据的变大，所花的时间也越来越大。\n\n参考链接：\n\nhttps://www.ted.com/talks/arthur_benjamin_the_magic_of_fibonacci_numbers?language=zh-cn#t-364274\nhttps://www.zhihu.com/question/28062458\nhttps://www.nayuki.io/page/fast-fibonacci-algorithms\nhttp://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html\n","content":"<p>斐波那契数列（Fibonacci）最早由印度数学家Gopala提出，而第一个真正研究斐波那契数列的是意大利数学家 Leonardo Fibonacci，斐波那契数列的定义很简单，用数学函数可表示为：<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fyj65lb4mcj30qo0550t0.jpg\"><br>数列从0和1开始，之后的数由前两个数相加而得出，例如斐波那契数列的前10个数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34。</p>\n<p>用 Python 实现斐波那契数列常见的写法有三种，各算法的执行效率也有很大差别，在面试中也会偶尔会被问到，通常面试的时候不是让你简单的用递归写写就完了，还会问你时间复杂度怎样，空间复杂度怎样，有没有可改进的地方。</p>\n<span id=\"more\"></span>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>所谓递归就是指函数的定义中使用了函数自身的方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fib_recur</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> n &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n <span class=\"keyword\">in</span> (<span class=\"number\">0</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib_recur(n - <span class=\"number\">1</span>) + fib_recur(n - <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">20</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(fib_recur(i), end=<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">5</span> <span class=\"number\">8</span> <span class=\"number\">13</span> <span class=\"number\">21</span> <span class=\"number\">34</span> <span class=\"number\">55</span> <span class=\"number\">89</span> <span class=\"number\">144</span> <span class=\"number\">233</span> <span class=\"number\">377</span> <span class=\"number\">610</span> <span class=\"number\">987</span> <span class=\"number\">1597</span> <span class=\"number\">2584</span> <span class=\"number\">4181</span> </span><br></pre></td></tr></table></figure>\n<p>递归是一种代码最简洁的方法，但它是效率非常低，因为会出现大量的重复计算，时间复杂度是：O(1.618 ^ n)，1.618是黄金分割。同时受限于 Python 中递归的最大深度是 1000，所以用递归来求解并不是一种可取的办法。</p>\n<h1 id=\"递推法\"><a href=\"#递推法\" class=\"headerlink\" title=\"递推法\"></a>递推法</h1><p>递推法就是从0和1开始，前两项相加逐个求出第3、第4个数，直到求出第n个数的值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fib_loop</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">    a, b = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        a, b = b, a + b</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">20</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(fib_loop(i), end=<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">5</span> <span class=\"number\">8</span> <span class=\"number\">13</span> <span class=\"number\">21</span> <span class=\"number\">34</span> <span class=\"number\">55</span> <span class=\"number\">89</span> <span class=\"number\">144</span> <span class=\"number\">233</span> <span class=\"number\">377</span> <span class=\"number\">610</span> <span class=\"number\">987</span> <span class=\"number\">1597</span> <span class=\"number\">2584</span> <span class=\"number\">4181</span> </span><br></pre></td></tr></table></figure>\n<p>这种算法的时间复杂是O(n)，呈线性增长，如果数据量巨大，速度越到后面会越慢。</p>\n<p>上面两种方式都是使用分而治之的思想，就是把一个大的问题化小，然后利用小问题的求解得到目标问题的答案。</p>\n<h1 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h1><p>《线性代数》是大学计算机专业低年级的课程，这门课教的就是矩阵，那时候觉得这东西学起来很枯燥，没什么用处，工作后你才发现搞机器学习、数据分析、数据建模时大有用处，书到用时方恨少。其实矩阵的本质就是线性方程式。</p>\n<p>斐波那契数列中两个相邻的项分别为：F(n) 和 F(n - 1)，如果把这两个数当作一个2行1列的矩阵可表示为：<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fyj676gq2oj302201r0sp.jpg\"></p>\n<p>因为 F(n) &#x3D; F(n-1)+F(n-2)，所以就有：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fyj67kwsswj306c01wmx7.jpg\"></p>\n<p>通过反推，其实它是两个矩阵的乘积得来的</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyj67tupb5j30i002cdg3.jpg\"><br>依此类推：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fyj682o3ouj30hy024mxe.jpg\"><br>最后可推出：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fyj68eckjcj30d102p0sv.jpg\"><br>因此想要求出F(n)的值，只要能求出右边矩阵的n-1次方的值，最后求得两矩阵乘积，取新矩阵的第一行的第一列的值即可，比如n&#x3D;3时，<br><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fyj68s0trpj30ch022q32.jpg\"><br>​可以得知F(3)的值2，F(2)的值为1，因为幂运算可以使用二分加速，所以矩阵法的时间复杂度为 O(log n)</p>\n<p>我们可以用科学计算包 numpy 来实现矩阵法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fib_matr</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (numpy.matrix([[<span class=\"number\">1</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">0</span>]]) ** (n - <span class=\"number\">1</span>) * numpy.matrix([[<span class=\"number\">1</span>], [<span class=\"number\">0</span>]]))[<span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">20</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(fib_matr(i)), end=<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">5</span> <span class=\"number\">8</span> <span class=\"number\">13</span> <span class=\"number\">21</span> <span class=\"number\">34</span> <span class=\"number\">55</span> <span class=\"number\">89</span> <span class=\"number\">144</span> <span class=\"number\">233</span> <span class=\"number\">377</span> <span class=\"number\">610</span> <span class=\"number\">987</span> <span class=\"number\">1597</span> <span class=\"number\">2584</span> <span class=\"number\">4181</span></span><br></pre></td></tr></table></figure>\n<p>3中不同的算法效率对比：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyj69fgfkvj30f70a0mxv.jpg\"></p>\n<p>从上面图可以看出递归法效率惊人的低，矩阵法在数据量比较大的时候才突显出它的优势，递推法随着数据的变大，所花的时间也越来越大。</p>\n<p>参考链接：</p>\n<p><a href=\"https://www.ted.com/talks/arthur_benjamin_the_magic_of_fibonacci_numbers?language=zh-cn#t-364274\">https://www.ted.com/talks/arthur_benjamin_the_magic_of_fibonacci_numbers?language=zh-cn#t-364274</a><br><a href=\"https://www.zhihu.com/question/28062458\">https://www.zhihu.com/question/28062458</a><br><a href=\"https://www.nayuki.io/page/fast-fibonacci-algorithms\">https://www.nayuki.io/page/fast-fibonacci-algorithms</a><br><a href=\"http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html\">http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html</a></p>\n","slug":"Python实现斐波那契数列","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/24/Python%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"斐波那契数列（Fibonacci）最早由印度数学家Gopala提出，而第一个真正研究斐波那契数列的是意大利数学家 Leonardo Fibonacci，斐波那契数列的定义很简单，用数学函数可表示为：数列从0和1开始，之后的数由前两个数相加而得出，例如斐波那契数列的前10个数是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34。 用 Python 实现斐波那契数列常见的写法有三种，各算法的执行效率也有很大差别，在面试中也会偶尔会被问到，通常面试的时候不是让你简单的用递归写写就完了，还会问你时间复杂度怎样，空间复杂度怎样，有没有可改进的地方。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"http://vwin.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"矩阵","slug":"矩阵","permalink":"http://vwin.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"递归","slug":"递归","permalink":"http://vwin.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"Python与设计模式 - 责任链模式","date":"2018-12-23T20:57:14.000Z","path":"2018/12/23/Python与设计模式-责任链模式/","text":"责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 举个例子说明责任链模式在Python中的使用 场景一比如我们还在读书的时候，考试的分数都是几个档次，比如90-100分，80-90分，好吧我想做一个根据分数打印你的学习成绩的反馈， 比如90-100就是A+，80-90就是A，70-80就是B+… 当然你可以用很多种方法实现，我这里就来实现一个Chain模式:用一系列的类来响应， 但只有遇到适合处理它的类才会处理，类似与case和switch的作用 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445class BaseHandler: # 它起到了链的作用 def successor(self, successor): self.successor = successorclass ScoreHandler1(BaseHandler): def handle(self, request): if request &gt; 90 and request &lt;= 100: return &quot;A+&quot; else: # 否则传给下一个链，下同，但是我是要return回结果的 return self.successor.handle(request)class ScoreHandler2(BaseHandler): def handle(self, request): if request &gt; 80 and request &lt;= 90: return &quot;A&quot; else: return self.successor.handle(request)class ScoreHandler3(BaseHandler): def handle(self, request): if request &gt; 70 and request &lt;= 80: return &quot;B+&quot; else: return &quot;unsatisfactory result&quot;class Client: def __init__(self): h1 = ScoreHandler1() h2 = ScoreHandler2() h3 = ScoreHandler3() # 注意这个顺序，h3包含一个类似于default结果的东西，是要放在最后的，其他的顺序是无所谓的，比如h1和h2 h1.successor(h2) h2.successor(h3) requests = &#123;&#x27;zhangsan&#x27;: 78, &#x27;lisi&#x27;: 98, &#x27;wangwu&#x27;: 82, &#x27;zhaoliu&#x27;: 60&#125; for name, score in requests.iteritems(): print &#x27;&#123;&#125; is &#123;&#125;&#x27;.format(name, h1.handle(score))if __name__== &quot;__main__&quot;: client = Client() 场景二假设有这么一个请假系统：员工若想要请3天以内（包括3天的假），只需要直属经理批准就可以了；如果想请3-7天，不仅需要直属经理批准，部门经理需要最终批准；如果请假大于7天，不光要前两个经理批准，也需要总经理最终批准。类似的系统相信大家都遇到过，那么该如何实现呢？首先想到的当然是if…else…，但一旦遇到需求变动，其臃肿的代码和复杂的耦合缺点都显现出来。简单分析下需求，“假条”在三个经理间是单向传递关系，像一条链条一样，因而，我们可以用一条“链”把他们进行有序连接。 Python实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class manager(): successor = None name = &#x27;&#x27; def __init__(self, name): self.name = name def setSuccessor(self, successor): self.successor = successor def handleRequest(self, request): passclass lineManager(manager): def handleRequest(self, request): if request.requestType == &#x27;DaysOff&#x27; and request.number &lt;= 3: print &#x27;%s:%s Num:%d Accepted OVER&#x27; % (self.name, request.requestContent, request.number) else: print &#x27;%s:%s Num:%d Accepted CONTINUE&#x27; % (self.name, request.requestContent, request.number) if self.successor != None: self.successor.handleRequest(request)class departmentManager(manager): def handleRequest(self, request): if request.requestType == &#x27;DaysOff&#x27; and request.number &lt;= 7: print &#x27;%s:%s Num:%d Accepted OVER&#x27; % (self.name, request.requestContent, request.number) else: print &#x27;%s:%s Num:%d Accepted CONTINUE&#x27; % (self.name, request.requestContent, request.number) if self.successor != None: self.successor.handleRequest(request)class generalManager(manager): def handleRequest(self, request): if request.requestType == &#x27;DaysOff&#x27;: print &#x27;%s:%s Num:%d Accepted OVER&#x27; % (self.name, request.requestContent, request.number)class request(): requestType = &#x27;&#x27; requestContent = &#x27;&#x27; number = 0#request类封装了假期请求。在具体的经理类中，可以通过setSuccessor接口来构建“责任链”，并在handleRequest接口中实现逻辑。场景类中实现如下：if __name__==&quot;__main__&quot;: line_manager = lineManager(&#x27;LINE MANAGER&#x27;) department_manager = departmentManager(&#x27;DEPARTMENT MANAGER&#x27;) general_manager = generalManager(&#x27;GENERAL MANAGER&#x27;) line_manager.setSuccessor(department_manager) department_manager.setSuccessor(general_manager) req = request() req.requestType = &#x27;DaysOff&#x27; req.requestContent = &#x27;Ask 1 day off&#x27; req.number = 1 line_manager.handleRequest(req) req.requestType = &#x27;DaysOff&#x27; req.requestContent = &#x27;Ask 5 days off&#x27; req.number = 5 line_manager.handleRequest(req) req.requestType = &#x27;DaysOff&#x27; req.requestContent = &#x27;Ask 10 days off&#x27; req.number = 10 line_manager.handleRequest(req) 责任链模式责任链模式的定义如下：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 需要说明的是，责任链模式中的应该只有一个处理者，也就是说，本例中的“最终批准”为该对象所谓的“请求处理”。 责任链模式的优缺点和应用场景优点 将请求者与处理者分离，请求者并不知道请求是被哪个处理者所处理，易于扩展。 应用场景 若一个请求可能由一个对请求有链式优先级的处理群所处理时，可以考虑责任链模式。除本例外，银行的客户请求处理系统也可以用责任链模式实现（VIP客户和普通用户处理方式当然会有不同）。 缺点 如果责任链比较长，会有比较大的性能问题； 如果责任链比较长，若业务出现问题，比较难定位是哪个处理者的问题。 参考：https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html","raw":"---\ntitle: Python与设计模式 - 责任链模式\ntoc: true\ndate: 2018-12-24 04:57:14\ntags: [设计模式,责任链模式]\ncategories: [技术]\ndescription:\n---\n责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。\n\n<!--more-->\n举个例子说明责任链模式在Python中的使用\n# 场景一\n比如我们还在读书的时候，考试的分数都是几个档次，比如90-100分，80-90分，好吧我想做一个根据分数打印你的学习成绩的反馈， 比如90-100就是A+，80-90就是A，70-80就是B+… 当然你可以用很多种方法实现，我这里就来实现一个Chain模式:用一系列的类来响应， 但只有遇到适合处理它的类才会处理，类似与case和switch的作用\n## Python实现\n```python\nclass BaseHandler:\n    # 它起到了链的作用\n    def successor(self, successor):\n        self.successor = successor\n\nclass ScoreHandler1(BaseHandler):\n    def handle(self, request):\n        if request > 90 and request <= 100:\n            return \"A+\"\n        else:\n            # 否则传给下一个链，下同，但是我是要return回结果的\n            return self.successor.handle(request)\n\nclass ScoreHandler2(BaseHandler):\n    def handle(self, request):\n        if request > 80 and request <= 90:\n            return \"A\"\n        else:\n            return self.successor.handle(request)\n\nclass ScoreHandler3(BaseHandler):\n    def handle(self, request):\n        if request > 70 and request <= 80:\n            return \"B+\"\n        else:\n            return \"unsatisfactory result\"\n\nclass Client:\n    def __init__(self):\n        h1 = ScoreHandler1()\n        h2 = ScoreHandler2()\n        h3 = ScoreHandler3()\n        # 注意这个顺序，h3包含一个类似于default结果的东西，是要放在最后的，其他的顺序是无所谓的，比如h1和h2\n        h1.successor(h2)\n        h2.successor(h3)\n\n        requests =  {'zhangsan': 78,\n                    'lisi': 98,\n                    'wangwu': 82,\n                    'zhaoliu': 60}\n        for name, score in requests.iteritems():\n            print '{} is {}'.format(name, h1.handle(score))\n\nif __name__== \"__main__\":\n    client = Client()\n```\n\n# 场景二\n假设有这么一个请假系统：员工若想要请3天以内（包括3天的假），只需要直属经理批准就可以了；如果想请3-7天，不仅需要直属经理批准，部门经理需要最终批准；如果请假大于7天，不光要前两个经理批准，也需要总经理最终批准。类似的系统相信大家都遇到过，那么该如何实现呢？首先想到的当然是if…else…，但一旦遇到需求变动，其臃肿的代码和复杂的耦合缺点都显现出来。简单分析下需求，“假条”在三个经理间是单向传递关系，像一条链条一样，因而，我们可以用一条“链”把他们进行有序连接。\n\n## Python实现\n```python\nclass manager():\n    successor = None\n    name = ''\n    def __init__(self, name):\n        self.name = name\n    def setSuccessor(self, successor):\n        self.successor = successor\n    def handleRequest(self, request):\n        pass\nclass lineManager(manager):\n    def handleRequest(self, request):\n        if request.requestType == 'DaysOff' and request.number <= 3:\n            print '%s:%s Num:%d Accepted OVER' % (self.name, request.requestContent, request.number)\n        else:\n            print '%s:%s Num:%d Accepted CONTINUE' % (self.name, request.requestContent, request.number)\n            if self.successor != None:\n                self.successor.handleRequest(request)\nclass departmentManager(manager):\n    def handleRequest(self, request):\n        if request.requestType == 'DaysOff' and request.number <= 7:\n            print '%s:%s Num:%d Accepted OVER' % (self.name, request.requestContent, request.number)\n        else:\n            print '%s:%s Num:%d Accepted CONTINUE' % (self.name, request.requestContent, request.number)\n            if self.successor != None:\n                self.successor.handleRequest(request)\nclass generalManager(manager):\n    def handleRequest(self, request):\n        if request.requestType == 'DaysOff':\n            print '%s:%s Num:%d Accepted OVER' % (self.name, request.requestContent, request.number)\nclass request():\n    requestType = ''\n    requestContent = ''\n    number = 0\n\n#request类封装了假期请求。在具体的经理类中，可以通过setSuccessor接口来构建“责任链”，并在handleRequest接口中实现逻辑。场景类中实现如下：\n\nif  __name__==\"__main__\":\n    line_manager = lineManager('LINE MANAGER')\n    department_manager = departmentManager('DEPARTMENT MANAGER')\n    general_manager = generalManager('GENERAL MANAGER')\n\n    line_manager.setSuccessor(department_manager)\n    department_manager.setSuccessor(general_manager)\n\n    req = request()\n    req.requestType = 'DaysOff'\n    req.requestContent = 'Ask 1 day off'\n    req.number = 1\n    line_manager.handleRequest(req)\n\n    req.requestType = 'DaysOff'\n    req.requestContent = 'Ask 5 days off'\n    req.number = 5\n    line_manager.handleRequest(req)\n\n    req.requestType = 'DaysOff'\n    req.requestContent = 'Ask 10 days off'\n    req.number = 10\n    line_manager.handleRequest(req)\n```\n\n# 责任链模式\n责任链模式的定义如下：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyi0dpyqabj30bs06bgm3.jpg)\n\n需要说明的是，责任链模式中的应该只有一个处理者，也就是说，本例中的“最终批准”为该对象所谓的“请求处理”。\n\n# 责任链模式的优缺点和应用场景\n\n## 优点\n- 将请求者与处理者分离，请求者并不知道请求是被哪个处理者所处理，易于扩展。\n\n## 应用场景\n- 若一个请求可能由一个对请求有链式优先级的处理群所处理时，可以考虑责任链模式。除本例外，银行的客户请求处理系统也可以用责任链模式实现（VIP客户和普通用户处理方式当然会有不同）。\n\n## 缺点\n- 如果责任链比较长，会有比较大的性能问题；\n- 如果责任链比较长，若业务出现问题，比较难定位是哪个处理者的问题。\n\n参考：https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html","content":"<p>责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>\n<span id=\"more\"></span>\n<p>举个例子说明责任链模式在Python中的使用</p>\n<h1 id=\"场景一\"><a href=\"#场景一\" class=\"headerlink\" title=\"场景一\"></a>场景一</h1><p>比如我们还在读书的时候，考试的分数都是几个档次，比如90-100分，80-90分，好吧我想做一个根据分数打印你的学习成绩的反馈， 比如90-100就是A+，80-90就是A，70-80就是B+… 当然你可以用很多种方法实现，我这里就来实现一个Chain模式:用一系列的类来响应， 但只有遇到适合处理它的类才会处理，类似与case和switch的作用</p>\n<h2 id=\"Python实现\"><a href=\"#Python实现\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseHandler</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 它起到了链的作用</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">successor</span>(<span class=\"params\">self, successor</span>):</span><br><span class=\"line\">        self.successor = successor</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ScoreHandler1</span>(<span class=\"title class_ inherited__\">BaseHandler</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">handle</span>(<span class=\"params\">self, request</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> request &gt; <span class=\"number\">90</span> <span class=\"keyword\">and</span> request &lt;= <span class=\"number\">100</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;A+&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 否则传给下一个链，下同，但是我是要return回结果的</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.successor.handle(request)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ScoreHandler2</span>(<span class=\"title class_ inherited__\">BaseHandler</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">handle</span>(<span class=\"params\">self, request</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> request &gt; <span class=\"number\">80</span> <span class=\"keyword\">and</span> request &lt;= <span class=\"number\">90</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;A&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.successor.handle(request)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ScoreHandler3</span>(<span class=\"title class_ inherited__\">BaseHandler</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">handle</span>(<span class=\"params\">self, request</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> request &gt; <span class=\"number\">70</span> <span class=\"keyword\">and</span> request &lt;= <span class=\"number\">80</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;B+&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;unsatisfactory result&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Client</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        h1 = ScoreHandler1()</span><br><span class=\"line\">        h2 = ScoreHandler2()</span><br><span class=\"line\">        h3 = ScoreHandler3()</span><br><span class=\"line\">        <span class=\"comment\"># 注意这个顺序，h3包含一个类似于default结果的东西，是要放在最后的，其他的顺序是无所谓的，比如h1和h2</span></span><br><span class=\"line\">        h1.successor(h2)</span><br><span class=\"line\">        h2.successor(h3)</span><br><span class=\"line\"></span><br><span class=\"line\">        requests =  &#123;<span class=\"string\">&#x27;zhangsan&#x27;</span>: <span class=\"number\">78</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;lisi&#x27;</span>: <span class=\"number\">98</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;wangwu&#x27;</span>: <span class=\"number\">82</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;zhaoliu&#x27;</span>: <span class=\"number\">60</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name, score <span class=\"keyword\">in</span> requests.iteritems():</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;&#123;&#125; is &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, h1.handle(score))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__== <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    client = Client()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"场景二\"><a href=\"#场景二\" class=\"headerlink\" title=\"场景二\"></a>场景二</h1><p>假设有这么一个请假系统：员工若想要请3天以内（包括3天的假），只需要直属经理批准就可以了；如果想请3-7天，不仅需要直属经理批准，部门经理需要最终批准；如果请假大于7天，不光要前两个经理批准，也需要总经理最终批准。类似的系统相信大家都遇到过，那么该如何实现呢？首先想到的当然是if…else…，但一旦遇到需求变动，其臃肿的代码和复杂的耦合缺点都显现出来。简单分析下需求，“假条”在三个经理间是单向传递关系，像一条链条一样，因而，我们可以用一条“链”把他们进行有序连接。</p>\n<h2 id=\"Python实现-1\"><a href=\"#Python实现-1\" class=\"headerlink\" title=\"Python实现\"></a>Python实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">manager</span>():</span><br><span class=\"line\">    successor = <span class=\"literal\">None</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">setSuccessor</span>(<span class=\"params\">self, successor</span>):</span><br><span class=\"line\">        self.successor = successor</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\">self, request</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">lineManager</span>(<span class=\"title class_ inherited__\">manager</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\">self, request</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> request.requestType == <span class=\"string\">&#x27;DaysOff&#x27;</span> <span class=\"keyword\">and</span> request.number &lt;= <span class=\"number\">3</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;%s:%s Num:%d Accepted OVER&#x27;</span> % (self.name, request.requestContent, request.number)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;%s:%s Num:%d Accepted CONTINUE&#x27;</span> % (self.name, request.requestContent, request.number)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.successor != <span class=\"literal\">None</span>:</span><br><span class=\"line\">                self.successor.handleRequest(request)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">departmentManager</span>(<span class=\"title class_ inherited__\">manager</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\">self, request</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> request.requestType == <span class=\"string\">&#x27;DaysOff&#x27;</span> <span class=\"keyword\">and</span> request.number &lt;= <span class=\"number\">7</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;%s:%s Num:%d Accepted OVER&#x27;</span> % (self.name, request.requestContent, request.number)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;%s:%s Num:%d Accepted CONTINUE&#x27;</span> % (self.name, request.requestContent, request.number)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.successor != <span class=\"literal\">None</span>:</span><br><span class=\"line\">                self.successor.handleRequest(request)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">generalManager</span>(<span class=\"title class_ inherited__\">manager</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\">self, request</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> request.requestType == <span class=\"string\">&#x27;DaysOff&#x27;</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;%s:%s Num:%d Accepted OVER&#x27;</span> % (self.name, request.requestContent, request.number)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">request</span>():</span><br><span class=\"line\">    requestType = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    requestContent = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    number = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#request类封装了假期请求。在具体的经理类中，可以通过setSuccessor接口来构建“责任链”，并在handleRequest接口中实现逻辑。场景类中实现如下：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>  __name__==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    line_manager = lineManager(<span class=\"string\">&#x27;LINE MANAGER&#x27;</span>)</span><br><span class=\"line\">    department_manager = departmentManager(<span class=\"string\">&#x27;DEPARTMENT MANAGER&#x27;</span>)</span><br><span class=\"line\">    general_manager = generalManager(<span class=\"string\">&#x27;GENERAL MANAGER&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    line_manager.setSuccessor(department_manager)</span><br><span class=\"line\">    department_manager.setSuccessor(general_manager)</span><br><span class=\"line\"></span><br><span class=\"line\">    req = request()</span><br><span class=\"line\">    req.requestType = <span class=\"string\">&#x27;DaysOff&#x27;</span></span><br><span class=\"line\">    req.requestContent = <span class=\"string\">&#x27;Ask 1 day off&#x27;</span></span><br><span class=\"line\">    req.number = <span class=\"number\">1</span></span><br><span class=\"line\">    line_manager.handleRequest(req)</span><br><span class=\"line\"></span><br><span class=\"line\">    req.requestType = <span class=\"string\">&#x27;DaysOff&#x27;</span></span><br><span class=\"line\">    req.requestContent = <span class=\"string\">&#x27;Ask 5 days off&#x27;</span></span><br><span class=\"line\">    req.number = <span class=\"number\">5</span></span><br><span class=\"line\">    line_manager.handleRequest(req)</span><br><span class=\"line\"></span><br><span class=\"line\">    req.requestType = <span class=\"string\">&#x27;DaysOff&#x27;</span></span><br><span class=\"line\">    req.requestContent = <span class=\"string\">&#x27;Ask 10 days off&#x27;</span></span><br><span class=\"line\">    req.number = <span class=\"number\">10</span></span><br><span class=\"line\">    line_manager.handleRequest(req)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h1><p>责任链模式的定义如下：使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyi0dpyqabj30bs06bgm3.jpg\"></p>\n<p>需要说明的是，责任链模式中的应该只有一个处理者，也就是说，本例中的“最终批准”为该对象所谓的“请求处理”。</p>\n<h1 id=\"责任链模式的优缺点和应用场景\"><a href=\"#责任链模式的优缺点和应用场景\" class=\"headerlink\" title=\"责任链模式的优缺点和应用场景\"></a>责任链模式的优缺点和应用场景</h1><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>将请求者与处理者分离，请求者并不知道请求是被哪个处理者所处理，易于扩展。</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>若一个请求可能由一个对请求有链式优先级的处理群所处理时，可以考虑责任链模式。除本例外，银行的客户请求处理系统也可以用责任链模式实现（VIP客户和普通用户处理方式当然会有不同）。</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>如果责任链比较长，会有比较大的性能问题；</li>\n<li>如果责任链比较长，若业务出现问题，比较难定位是哪个处理者的问题。</li>\n</ul>\n<p>参考：<a href=\"https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html\">https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html</a></p>\n","slug":"Python与设计模式-责任链模式","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/23/Python%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://vwin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"责任链模式","slug":"责任链模式","permalink":"http://vwin.github.io/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"}]},{"title":"Python与设计模式 - 单例模式","date":"2018-12-23T20:57:03.000Z","path":"2018/12/23/Python与设计模式-单例模式/","text":"单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。 比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。 在 Python 中，我们可以用多种方法来实现单例模式。 实现单例模式的几种方式使用模块其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做： 12345mysingleton.pyclass Singleton(object): def foo(self): passsingleton = Singleton() 将上面的代码保存在文件 mysingleton.py 中，要使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象 1from a import singleton 使用装饰器方法一：1234567891011121314151617181920def Singleton(cls): _instance = &#123;&#125; def _singleton(*args, **kargs): if cls not in _instance: _instance[cls] = cls(*args, **kargs) return _instance[cls] return _singleton@Singletonclass A: a = 1 def __init__(self, x=0): self.x = xa1 = A(2)a2 = A(3) 方法二：该方法解决了多线程的问题。 1234567891011121314151617181920212223# coding:utf-8import threadingdef synchronized(func): func.__lock__ = threading.Lock() def lock_func(*args, **kwargs): with func.__lock__: return func(*args, **kwargs) return lock_funcclass Singleton(object): &quot;&quot;&quot; 单例模式 &quot;&quot;&quot; instance = None @synchronized def __new__(cls, *args, **kwargs): if cls.instance is None: cls.instance = object.__new__(cls, *args, **kwargs) return cls.instance 使用类12345678910class Singleton(object): def __init__(self): pass @classmethod def instance(cls, *args, **kwargs): if not hasattr(Singleton, &quot;_instance&quot;): Singleton._instance = Singleton(*args, **kwargs) return Singleton._instance 但是这样当使用多线程时会存在问题! 多线程使用问题1234567891011121314151617181920class Singleton(object): def __init__(self): pass @classmethod def instance(cls, *args, **kwargs): if not hasattr(Singleton, &quot;_instance&quot;): Singleton._instance = Singleton(*args, **kwargs) return Singleton._instanceimport threadingdef task(arg): obj = Singleton.instance() print(obj)for i in range(10): t = threading.Thread(target=task,args=[i,]) t.start() 程序执行后，打印结果如下： 12345678910&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt;&lt;__main__.Singleton object at 0x02C933D0&gt; 看起来也没有问题，那是因为执行速度过快，如果在init方法中有一些IO操作，就会发现问题了，下面我们通过time.sleep模拟 我们在上面__init__方法中加入以下代码： 123def __init__(self): import time time.sleep(1) 重新执行程序后，结果如下 12345678910&lt;__main__.Singleton object at 0x034A3410&gt;&lt;__main__.Singleton object at 0x034BB990&gt;&lt;__main__.Singleton object at 0x034BB910&gt;&lt;__main__.Singleton object at 0x034ADED0&gt;&lt;__main__.Singleton object at 0x034E6BD0&gt;&lt;__main__.Singleton object at 0x034E6C10&gt;&lt;__main__.Singleton object at 0x034E6B90&gt;&lt;__main__.Singleton object at 0x034BBA30&gt;&lt;__main__.Singleton object at 0x034F6B90&gt;&lt;__main__.Singleton object at 0x034E6A90&gt; 问题出现了！按照以上方式创建的单例，无法支持多线程 解决办法：加锁！未加锁部分并发执行,加锁部分串行执行,速度降低,但是保证了数据安全 多线程加锁12345678910111213141516171819202122232425import timeimport threadingclass Singleton(object): _instance_lock = threading.Lock() def __init__(self): time.sleep(1) @classmethod def instance(cls, *args, **kwargs): with Singleton._instance_lock: if not hasattr(Singleton, &quot;_instance&quot;): Singleton._instance = Singleton(*args, **kwargs) return Singleton._instancedef task(arg): obj = Singleton.instance() print(obj)for i in range(10): t = threading.Thread(target=task,args=[i,]) t.start()time.sleep(20)obj = Singleton.instance()print(obj) 打印结果如下： 12345678910&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt;&lt;__main__.Singleton object at 0x02D6B110&gt; 这样就差不多了，但是还是有一点小问题，就是当程序执行时，执行了time.sleep(20)后，下面实例化对象时，此时已经是单例模式了，但我们还是加了锁，这样不太好，再进行一些优化，把intance方法，改成下面的这样就行： 1234567@classmethoddef instance(cls, *args, **kwargs): if not hasattr(Singleton, &quot;_instance&quot;): with Singleton._instance_lock: if not hasattr(Singleton, &quot;_instance&quot;): Singleton._instance = Singleton(*args, **kwargs) return Singleton._instance 支持多线程的单例模式1234567891011121314151617181920212223242526import timeimport threadingclass Singleton(object): _instance_lock = threading.Lock() def __init__(self): time.sleep(1) @classmethod def instance(cls, *args, **kwargs): if not hasattr(Singleton, &quot;_instance&quot;): with Singleton._instance_lock: if not hasattr(Singleton, &quot;_instance&quot;): Singleton._instance = Singleton(*args, **kwargs) return Singleton._instancedef task(arg): obj = Singleton.instance() print(obj)for i in range(10): t = threading.Thread(target=task,args=[i,]) t.start()time.sleep(20)obj = Singleton.instance()print(obj) 这种方式实现的单例模式，使用时会有限制，以后实例化必须通过 obj &#x3D; Singleton.instance() ;如果用 obj&#x3D;Singleton() ,这种方式得到的不是单例 基于__new__ 创建通过上面例子，我们可以知道，当我们实现单例时，为了保证线程安全需要在内部加入锁 我们知道，当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__），实例化对象；然后再执行类的__init__方法，对这个对象进行初始化，所有我们可以基于这个，实现单例模式 1234567891011121314151617181920212223242526import threadingclass Singleton(object): _instance_lock = threading.Lock() def __init__(self): pass def __new__(cls, *args, **kwargs): if not hasattr(Singleton, &quot;_instance&quot;): with Singleton._instance_lock: if not hasattr(Singleton, &quot;_instance&quot;): Singleton._instance = object.__new__(cls) return Singleton._instanceobj1 = Singleton()obj2 = Singleton()print(obj1,obj2)def task(arg): obj = Singleton() print(obj)for i in range(10): t = threading.Thread(target=task,args=[i,]) t.start() 打印结果如下： 1234567891011&lt;__main__.Singleton object at 0x038B33D0&gt; &lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt;&lt;__main__.Singleton object at 0x038B33D0&gt; 采用这种方式的单例模式，以后实例化对象时，和平时实例化对象的方法一样 obj &#x3D; Singleton() 基于metaclass方式实现 1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 call 方法例子： 1234567891011class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): passobj = Foo()# 执行type的 __call__ 方法，调用 Foo类（是type的对象）的 __new__方法，用于创建对象，然后调用 Foo类（是type的对象）的 __init__方法，用于对对象初始化。obj() # 执行Foo的 __call__ 方法 元类的使用1234567891011121314151617class SingletonType(type): def __init__(self,*args,**kwargs): super(SingletonType,self).__init__(*args,**kwargs) def __call__(cls, *args, **kwargs): # 这里的cls，即Foo类 print(&#x27;cls&#x27;,cls) obj = cls.__new__(cls,*args, **kwargs) cls.__init__(obj,*args, **kwargs) # Foo.__init__(obj) return objclass Foo(metaclass=SingletonType): # 指定创建Foo的type为SingletonType def __init__(self，name): self.name = name def __new__(cls, *args, **kwargs): return object.__new__(cls)obj = Foo(&#x27;xx&#x27;) 实现单例模式12345678910111213141516171819import threadingclass SingletonType(type): _instance_lock = threading.Lock() def __call__(cls, *args, **kwargs): if not hasattr(cls, &quot;_instance&quot;): with SingletonType._instance_lock: if not hasattr(cls, &quot;_instance&quot;): cls._instance = super(SingletonType,cls).__call__(*args, **kwargs) return cls._instanceclass Foo(metaclass=SingletonType): def __init__(self,name): self.name = nameobj1 = Foo(&#x27;name&#x27;)obj2 = Foo(&#x27;name&#x27;)print(obj1,obj2)","raw":"---\ntitle: Python与设计模式 - 单例模式\ntoc: true\ndate: 2018-12-24 04:57:03\ntags: [设计模式,单例模式]\ncategories: [技术]\ndescription:\n---\n# 单例模式\n单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。\n\n比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。\n\n在 Python 中，我们可以用多种方法来实现单例模式。\n<!--more-->\n# 实现单例模式的几种方式\n## 使用模块\n其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：\n```python\nmysingleton.py\nclass Singleton(object):\n    def foo(self):\n        pass\nsingleton = Singleton()\n```\n将上面的代码保存在文件 mysingleton.py 中，要使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象\n```python\nfrom a import singleton\n```\n## 使用装饰器\n### 方法一：\n```python\ndef Singleton(cls):\n    _instance = {}\n\n    def _singleton(*args, **kargs):\n        if cls not in _instance:\n            _instance[cls] = cls(*args, **kargs)\n        return _instance[cls]\n\n    return _singleton\n\n\n@Singleton\nclass A:\n    a = 1\n\n    def __init__(self, x=0):\n        self.x = x\n\na1 = A(2)\na2 = A(3)\n```\n### 方法二：\n该方法解决了多线程的问题。\n```python\n# coding:utf-8\nimport threading\ndef synchronized(func):\n\n    func.__lock__ = threading.Lock()\n\n    def lock_func(*args, **kwargs):\n        with func.__lock__:\n            return func(*args, **kwargs)\n    return lock_func\n\n\nclass Singleton(object):\n    \"\"\"\n    单例模式\n    \"\"\"\n    instance = None\n\n    @synchronized\n    def __new__(cls, *args, **kwargs):\n        if cls.instance is None:\n            cls.instance = object.__new__(cls, *args, **kwargs)\n        return cls.instance\n```\n\n## 使用类\n```python\nclass Singleton(object):\n\n    def __init__(self):\n        pass\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, \"_instance\"):\n            Singleton._instance = Singleton(*args, **kwargs)\n        return Singleton._instance\n```\n\n<font color=red>但是这样当使用多线程时会存在问题!</font>\n## 多线程使用问题\n```python\nclass Singleton(object):\n\n    def __init__(self):\n        pass\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, \"_instance\"):\n            Singleton._instance = Singleton(*args, **kwargs)\n        return Singleton._instance\n\nimport threading\n\ndef task(arg):\n    obj = Singleton.instance()\n    print(obj)\n\nfor i in range(10):\n    t = threading.Thread(target=task,args=[i,])\n    t.start()\n```\n程序执行后，打印结果如下：\n```shell\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n<__main__.Singleton object at 0x02C933D0>\n```\n\n看起来也没有问题，那是因为执行速度过快，如果在init方法中有一些IO操作，就会发现问题了，下面我们通过time.sleep模拟\n\n我们在上面__init__方法中加入以下代码：\n```python\ndef __init__(self):\n        import time\n        time.sleep(1)\n```\n重新执行程序后，结果如下\n```shell\n<__main__.Singleton object at 0x034A3410>\n<__main__.Singleton object at 0x034BB990>\n<__main__.Singleton object at 0x034BB910>\n<__main__.Singleton object at 0x034ADED0>\n<__main__.Singleton object at 0x034E6BD0>\n<__main__.Singleton object at 0x034E6C10>\n<__main__.Singleton object at 0x034E6B90>\n<__main__.Singleton object at 0x034BBA30>\n<__main__.Singleton object at 0x034F6B90>\n<__main__.Singleton object at 0x034E6A90>\n```\n<font color=red>问题出现了！按照以上方式创建的单例，无法支持多线程</font>\n\n解决办法：加锁！未加锁部分并发执行,加锁部分串行执行,速度降低,但是保证了数据安全\n\n## 多线程加锁\n```python\nimport time\nimport threading\nclass Singleton(object):\n    _instance_lock = threading.Lock()\n\n    def __init__(self):\n        time.sleep(1)\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        with Singleton._instance_lock:\n            if not hasattr(Singleton, \"_instance\"):\n                Singleton._instance = Singleton(*args, **kwargs)\n        return Singleton._instance\n\n\ndef task(arg):\n    obj = Singleton.instance()\n    print(obj)\nfor i in range(10):\n    t = threading.Thread(target=task,args=[i,])\n    t.start()\ntime.sleep(20)\nobj = Singleton.instance()\nprint(obj)\n```\n打印结果如下：\n\n```shell\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n<__main__.Singleton object at 0x02D6B110>\n```\n这样就差不多了，但是还是有一点小问题，就是当程序执行时，执行了time.sleep(20)后，下面实例化对象时，此时已经是单例模式了，但我们还是加了锁，这样不太好，再进行一些优化，把intance方法，改成下面的这样就行：\n```python\n@classmethod\ndef instance(cls, *args, **kwargs):\n    if not hasattr(Singleton, \"_instance\"):\n        with Singleton._instance_lock:\n            if not hasattr(Singleton, \"_instance\"):\n                Singleton._instance = Singleton(*args, **kwargs)\n    return Singleton._instance\n```\n## 支持多线程的单例模式\n```python\nimport time\nimport threading\nclass Singleton(object):\n    _instance_lock = threading.Lock()\n\n    def __init__(self):\n        time.sleep(1)\n\n    @classmethod\n    def instance(cls, *args, **kwargs):\n        if not hasattr(Singleton, \"_instance\"):\n            with Singleton._instance_lock:\n                if not hasattr(Singleton, \"_instance\"):\n                    Singleton._instance = Singleton(*args, **kwargs)\n        return Singleton._instance\n\n\ndef task(arg):\n    obj = Singleton.instance()\n    print(obj)\nfor i in range(10):\n    t = threading.Thread(target=task,args=[i,])\n    t.start()\ntime.sleep(20)\nobj = Singleton.instance()\nprint(obj)\n```\n<font color=red>这种方式实现的单例模式，使用时会有限制，以后实例化必须通过 obj = Singleton.instance() ;如果用 obj=Singleton() ,这种方式得到的不是单例</font>\n\n## 基于__new__ 创建\n通过上面例子，我们可以知道，当我们实现单例时，为了保证线程安全需要在内部加入锁\n\n我们知道，当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__），实例化对象；然后再执行类的__init__方法，对这个对象进行初始化，所有我们可以基于这个，实现单例模式\n```python\nimport threading\nclass Singleton(object):\n    _instance_lock = threading.Lock()\n\n    def __init__(self):\n        pass\n\n\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(Singleton, \"_instance\"):\n            with Singleton._instance_lock:\n                if not hasattr(Singleton, \"_instance\"):\n                    Singleton._instance = object.__new__(cls)  \n        return Singleton._instance\n\nobj1 = Singleton()\nobj2 = Singleton()\nprint(obj1,obj2)\n\ndef task(arg):\n    obj = Singleton()\n    print(obj)\n\nfor i in range(10):\n    t = threading.Thread(target=task,args=[i,])\n    t.start()\n```\n打印结果如下：\n\n```shelll\n<__main__.Singleton object at 0x038B33D0> <__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n<__main__.Singleton object at 0x038B33D0>\n``` \n采用这种方式的单例模式，以后实例化对象时，和平时实例化对象的方法一样 obj = Singleton() \n\n## 基于metaclass方式实现\n> 1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)\n> 2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法\n例子：\n```python\nclass Foo:\n    def __init__(self):\n        pass\n\n    def __call__(self, *args, **kwargs):\n        pass\n\nobj = Foo()\n# 执行type的 __call__ 方法，调用 Foo类（是type的对象）的 __new__方法，用于创建对象，然后调用 Foo类（是type的对象）的 __init__方法，用于对对象初始化。\n\nobj() # 执行Foo的 __call__ 方法    \n```\n\n### 元类的使用\n```python\nclass SingletonType(type):\n    def __init__(self,*args,**kwargs):\n        super(SingletonType,self).__init__(*args,**kwargs)\n\n    def __call__(cls, *args, **kwargs): # 这里的cls，即Foo类\n        print('cls',cls)\n        obj = cls.__new__(cls,*args, **kwargs)\n        cls.__init__(obj,*args, **kwargs) # Foo.__init__(obj)\n        return obj\n\nclass Foo(metaclass=SingletonType): # 指定创建Foo的type为SingletonType\n    def __init__(self，name):\n        self.name = name\n    def __new__(cls, *args, **kwargs):\n        return object.__new__(cls)\n\nobj = Foo('xx')\n```\n\n### 实现单例模式\n```python\nimport threading\n\nclass SingletonType(type):\n    _instance_lock = threading.Lock()\n    def __call__(cls, *args, **kwargs):\n        if not hasattr(cls, \"_instance\"):\n            with SingletonType._instance_lock:\n                if not hasattr(cls, \"_instance\"):\n                    cls._instance = super(SingletonType,cls).__call__(*args, **kwargs)\n        return cls._instance\n\nclass Foo(metaclass=SingletonType):\n    def __init__(self,name):\n        self.name = name\n\n\nobj1 = Foo('name')\nobj2 = Foo('name')\nprint(obj1,obj2)\n```\n","content":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>\n<p>比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。</p>\n<p>在 Python 中，我们可以用多种方法来实现单例模式。</p>\n<span id=\"more\"></span>\n<h1 id=\"实现单例模式的几种方式\"><a href=\"#实现单例模式的几种方式\" class=\"headerlink\" title=\"实现单例模式的几种方式\"></a>实现单例模式的几种方式</h1><h2 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h2><p>其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysingleton.py</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">foo</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">singleton = Singleton()</span><br></pre></td></tr></table></figure>\n<p>将上面的代码保存在文件 mysingleton.py 中，要使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> a <span class=\"keyword\">import</span> singleton</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用装饰器\"><a href=\"#使用装饰器\" class=\"headerlink\" title=\"使用装饰器\"></a>使用装饰器</h2><h3 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Singleton</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">    _instance = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">_singleton</span>(<span class=\"params\">*args, **kargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> _instance:</span><br><span class=\"line\">            _instance[cls] = cls(*args, **kargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _instance[cls]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _singleton</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Singleton</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, x=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">        self.x = x</span><br><span class=\"line\"></span><br><span class=\"line\">a1 = A(<span class=\"number\">2</span>)</span><br><span class=\"line\">a2 = A(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><p>该方法解决了多线程的问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding:utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">synchronized</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    func.__lock__ = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">lock_func</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> func.__lock__:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lock_func</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    单例模式</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    instance = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @synchronized</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls.instance <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            cls.instance = <span class=\"built_in\">object</span>.__new__(cls, *args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls.instance</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用类\"><a href=\"#使用类\" class=\"headerlink\" title=\"使用类\"></a>使用类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">instance</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\">但是这样当使用多线程时会存在问题!</font></p>\n<h2 id=\"多线程使用问题\"><a href=\"#多线程使用问题\" class=\"headerlink\" title=\"多线程使用问题\"></a>多线程使用问题</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">instance</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton._instance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>(<span class=\"params\">arg</span>):</span><br><span class=\"line\">    obj = Singleton.instance()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = threading.Thread(target=task,args=[i,])</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure>\n<p>程序执行后，打印结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02C933D0&gt;</span><br></pre></td></tr></table></figure>\n\n<p>看起来也没有问题，那是因为执行速度过快，如果在init方法中有一些IO操作，就会发现问题了，下面我们通过time.sleep模拟</p>\n<p>我们在上面__init__方法中加入以下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">import</span> time</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>重新执行程序后，结果如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;__main__.Singleton object at 0x034A3410&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034BB990&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034BB910&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034ADED0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034E6BD0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034E6C10&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034E6B90&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034BBA30&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034F6B90&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x034E6A90&gt;</span><br></pre></td></tr></table></figure>\n<p><font color=\"red\">问题出现了！按照以上方式创建的单例，无法支持多线程</font></p>\n<p>解决办法：加锁！未加锁部分并发执行,加锁部分串行执行,速度降低,但是保证了数据安全</p>\n<h2 id=\"多线程加锁\"><a href=\"#多线程加锁\" class=\"headerlink\" title=\"多线程加锁\"></a>多线程加锁</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    _instance_lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">instance</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> Singleton._instance_lock:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">                Singleton._instance = Singleton(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton._instance</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>(<span class=\"params\">arg</span>):</span><br><span class=\"line\">    obj = Singleton.instance()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(obj)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = threading.Thread(target=task,args=[i,])</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\">time.sleep(<span class=\"number\">20</span>)</span><br><span class=\"line\">obj = Singleton.instance()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(obj)</span><br></pre></td></tr></table></figure>\n<p>打印结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x02D6B110&gt;</span><br></pre></td></tr></table></figure>\n<p>这样就差不多了，但是还是有一点小问题，就是当程序执行时，执行了time.sleep(20)后，下面实例化对象时，此时已经是单例模式了，但我们还是加了锁，这样不太好，再进行一些优化，把intance方法，改成下面的这样就行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@classmethod</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">instance</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> Singleton._instance_lock:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">                Singleton._instance = Singleton(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Singleton._instance</span><br></pre></td></tr></table></figure>\n<h2 id=\"支持多线程的单例模式\"><a href=\"#支持多线程的单例模式\" class=\"headerlink\" title=\"支持多线程的单例模式\"></a>支持多线程的单例模式</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    _instance_lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">instance</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">with</span> Singleton._instance_lock:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">                    Singleton._instance = Singleton(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton._instance</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>(<span class=\"params\">arg</span>):</span><br><span class=\"line\">    obj = Singleton.instance()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(obj)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = threading.Thread(target=task,args=[i,])</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\">time.sleep(<span class=\"number\">20</span>)</span><br><span class=\"line\">obj = Singleton.instance()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(obj)</span><br></pre></td></tr></table></figure>\n<p><font color=\"red\">这种方式实现的单例模式，使用时会有限制，以后实例化必须通过 obj &#x3D; Singleton.instance() ;如果用 obj&#x3D;Singleton() ,这种方式得到的不是单例</font></p>\n<h2 id=\"基于-new-创建\"><a href=\"#基于-new-创建\" class=\"headerlink\" title=\"基于__new__ 创建\"></a>基于__new__ 创建</h2><p>通过上面例子，我们可以知道，当我们实现单例时，为了保证线程安全需要在内部加入锁</p>\n<p>我们知道，当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__），实例化对象；然后再执行类的__init__方法，对这个对象进行初始化，所有我们可以基于这个，实现单例模式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    _instance_lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">with</span> Singleton._instance_lock:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(Singleton, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">                    Singleton._instance = <span class=\"built_in\">object</span>.__new__(cls)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton._instance</span><br><span class=\"line\"></span><br><span class=\"line\">obj1 = Singleton()</span><br><span class=\"line\">obj2 = Singleton()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(obj1,obj2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>(<span class=\"params\">arg</span>):</span><br><span class=\"line\">    obj = Singleton()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    t = threading.Thread(target=task,args=[i,])</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure>\n<p>打印结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt; &lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br><span class=\"line\">&lt;__main__.Singleton object at 0x038B33D0&gt;</span><br></pre></td></tr></table></figure>\n<p>采用这种方式的单例模式，以后实例化对象时，和平时实例化对象的方法一样 obj &#x3D; Singleton() </p>\n<h2 id=\"基于metaclass方式实现\"><a href=\"#基于metaclass方式实现\" class=\"headerlink\" title=\"基于metaclass方式实现\"></a>基于metaclass方式实现</h2><blockquote>\n<p>1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)<br>2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 <strong>call</strong> 方法<br>例子：</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj = Foo()</span><br><span class=\"line\"><span class=\"comment\"># 执行type的 __call__ 方法，调用 Foo类（是type的对象）的 __new__方法，用于创建对象，然后调用 Foo类（是type的对象）的 __init__方法，用于对对象初始化。</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj() <span class=\"comment\"># 执行Foo的 __call__ 方法    </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"元类的使用\"><a href=\"#元类的使用\" class=\"headerlink\" title=\"元类的使用\"></a>元类的使用</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingletonType</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,*args,**kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(SingletonType,self).__init__(*args,**kwargs)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">cls, *args, **kwargs</span>): <span class=\"comment\"># 这里的cls，即Foo类</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;cls&#x27;</span>,cls)</span><br><span class=\"line\">        obj = cls.__new__(cls,*args, **kwargs)</span><br><span class=\"line\">        cls.__init__(obj,*args, **kwargs) <span class=\"comment\"># Foo.__init__(obj)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(metaclass=SingletonType): <span class=\"comment\"># 指定创建Foo的type为SingletonType</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self，name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">object</span>.__new__(cls)</span><br><span class=\"line\"></span><br><span class=\"line\">obj = Foo(<span class=\"string\">&#x27;xx&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现单例模式\"><a href=\"#实现单例模式\" class=\"headerlink\" title=\"实现单例模式\"></a>实现单例模式</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingletonType</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    _instance_lock = threading.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(cls, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">with</span> SingletonType._instance_lock:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(cls, <span class=\"string\">&quot;_instance&quot;</span>):</span><br><span class=\"line\">                    cls._instance = <span class=\"built_in\">super</span>(SingletonType,cls).__call__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(metaclass=SingletonType):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">obj1 = Foo(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\">obj2 = Foo(<span class=\"string\">&#x27;name&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(obj1,obj2)</span><br></pre></td></tr></table></figure>\n","slug":"Python与设计模式-单例模式","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/23/Python%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"单例模式单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。 比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。 在 Python 中，我们可以用多种方法来实现单例模式。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://vwin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"http://vwin.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"大数据测试开发-3：大数据产品的测试方法和实现","date":"2018-12-23T18:53:19.000Z","path":"2018/12/23/大数据测试开发-3：大数据产品的测试方法和实现/","text":"参考：https://testerhome.com/topics/17092","raw":"---\ntitle: 大数据测试开发-3：大数据产品的测试方法和实现\ntoc: true\ndate: 2018-12-24 02:53:19\ntags: [大数据,spark]\ncategories: [测试]\ndescription:\n---\n参考：https://testerhome.com/topics/17092\n","content":"<p>参考：<a href=\"https://testerhome.com/topics/17092\">https://testerhome.com/topics/17092</a></p>\n","slug":"大数据测试开发-3：大数据产品的测试方法和实现","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91-3%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BA%A7%E5%93%81%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/","excerpt":"","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://vwin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"http://vwin.github.io/tags/spark/"}]},{"title":"大数据测试开发-2：Shuffle 以及性能测试","date":"2018-12-23T18:35:24.000Z","path":"2018/12/23/大数据测试开发-2：Shuffle-以及性能测试/","text":"参考：https://testerhome.com/topics/8120","raw":"---\ntitle: 大数据测试开发-2：Shuffle 以及性能测试\ntoc: true\ndate: 2018-12-24 02:35:24\ntags: [大数据,spark]\ncategories: [测试]\ndescription:\n---\n参考：https://testerhome.com/topics/8120\n","content":"<p>参考：<a href=\"https://testerhome.com/topics/8120\">https://testerhome.com/topics/8120</a></p>\n","slug":"大数据测试开发-2：Shuffle-以及性能测试","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91-2%EF%BC%9AShuffle-%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","excerpt":"","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://vwin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"http://vwin.github.io/tags/spark/"}]},{"title":"大数据测试开发-1：Spark基础操作","date":"2018-12-23T18:09:12.000Z","path":"2018/12/23/大数据测试开发-1：Spark基础操作/","text":"参考：https://testerhome.com/topics/8040","raw":"---\ntitle: 大数据测试开发-1：Spark基础操作\ntoc: true\ndate: 2018-12-24 02:09:12\ntags: [大数据,spark]\ncategories: [测试]\ndescription:\n---\n参考：https://testerhome.com/topics/8040","content":"<p>参考：<a href=\"https://testerhome.com/topics/8040\">https://testerhome.com/topics/8040</a></p>\n","slug":"大数据测试开发-1：Spark基础操作","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91-1%EF%BC%9ASpark%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","excerpt":"","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://vwin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"http://vwin.github.io/tags/spark/"}]},{"title":"Hadoop Spark简单理解","date":"2018-12-23T17:19:17.000Z","path":"2018/12/23/Hadoop-Spark简单理解/","text":"hadoop和Spark是两种不同的大数据处理框架，他们的组件都非常多。下面是两种框架使用到的一些组件整理蓝色部分，是Hadoop生态系统组件，黄色部分是Spark生态组件。虽然他们是两种不同的大数据处理框架，但它们不是互斥的，Spark与hadoop 中的MapReduce是一种相互共生的关系。Hadoop提供了Spark许多没有的功能，比如分布式文件系统，而Spark 提供了实时内存计算，速度非常快。有一点大家要注意，Spark并不是一定要依附于Hadoop才能生存，除了Hadoop的HDFS，还可以基于其他的云平台，当然啦，大家一致认为Spark与Hadoop配合默契最好罢了。 Hadoop包括HDFS、Mapreduce、YARN三大核心组件，Spark主要解决计算问题，也就是主要用来替代Mapreduce的功能，底层存储和资源调度仍然使用HDFS、YARN来承载. Hadoop &#x3D; HDFS + YARN + MapReduce HDFS负责存储，已然成为业内的分布式存储的标配，算是行业标准了。 YARN负责资源调度，依然发挥重要作用，不可获取的重要组件之一，Spark也可以跑在它上面，相比Mesos（C++），YARN是Hadoop自带的，用起来比较方便。 MapReduce计算框架，在Spark面前已失去性能及速度优势，基本面临淘汰。 参考： https://www.zhihu.com/question/26568496/answer/41608400","raw":"---\ntitle: Hadoop Spark简单理解\ntoc: true\ndate: 2018-12-24 01:19:17\ntags: [大数据,hadoop,spark]\ncategories: [技术]\ndescription:\n---\nhadoop和Spark是两种不同的大数据处理框架，他们的组件都非常多。\n下面是两种框架使用到的一些组件整理\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fyhtbtncdrj30k00ctq5z.jpg)\n蓝色部分，是Hadoop生态系统组件，黄色部分是Spark生态组件。\n虽然他们是两种不同的大数据处理框架，但它们不是互斥的，Spark与hadoop 中的MapReduce是一种相互共生的关系。\nHadoop提供了Spark许多没有的功能，比如分布式文件系统，而Spark 提供了实时内存计算，速度非常快。有一点大家要注意，Spark并不是一定要依附于Hadoop才能生存，除了Hadoop的HDFS，还可以基于其他的云平台，当然啦，大家一致认为Spark与Hadoop配合默契最好罢了。\n<!--more-->\n- Hadoop包括HDFS、Mapreduce、YARN三大核心组件，Spark主要解决计算问题，也就是主要用来替代Mapreduce的功能，底层存储和资源调度仍然使用HDFS、YARN来承载.\n- <font color=red><b>Hadoop = HDFS + YARN + MapReduce</b></font>\n- HDFS负责存储，已然成为业内的分布式存储的标配，算是行业标准了。\n- YARN负责资源调度，依然发挥重要作用，不可获取的重要组件之一，Spark也可以跑在它上面，相比Mesos（C++），YARN是Hadoop自带的，用起来比较方便。\n- MapReduce计算框架，在Spark面前已失去性能及速度优势，基本面临淘汰。\n\n\n\n参考：\n- https://www.zhihu.com/question/26568496/answer/41608400","content":"<p>hadoop和Spark是两种不同的大数据处理框架，他们的组件都非常多。<br>下面是两种框架使用到的一些组件整理<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fyhtbtncdrj30k00ctq5z.jpg\"><br>蓝色部分，是Hadoop生态系统组件，黄色部分是Spark生态组件。<br>虽然他们是两种不同的大数据处理框架，但它们不是互斥的，Spark与hadoop 中的MapReduce是一种相互共生的关系。<br>Hadoop提供了Spark许多没有的功能，比如分布式文件系统，而Spark 提供了实时内存计算，速度非常快。有一点大家要注意，Spark并不是一定要依附于Hadoop才能生存，除了Hadoop的HDFS，还可以基于其他的云平台，当然啦，大家一致认为Spark与Hadoop配合默契最好罢了。</p>\n<span id=\"more\"></span>\n<ul>\n<li>Hadoop包括HDFS、Mapreduce、YARN三大核心组件，Spark主要解决计算问题，也就是主要用来替代Mapreduce的功能，底层存储和资源调度仍然使用HDFS、YARN来承载.</li>\n<li><font color=\"red\"><b>Hadoop &#x3D; HDFS + YARN + MapReduce</b></font></li>\n<li>HDFS负责存储，已然成为业内的分布式存储的标配，算是行业标准了。</li>\n<li>YARN负责资源调度，依然发挥重要作用，不可获取的重要组件之一，Spark也可以跑在它上面，相比Mesos（C++），YARN是Hadoop自带的，用起来比较方便。</li>\n<li>MapReduce计算框架，在Spark面前已失去性能及速度优势，基本面临淘汰。</li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/26568496/answer/41608400\">https://www.zhihu.com/question/26568496/answer/41608400</a></li>\n</ul>\n","slug":"Hadoop-Spark简单理解","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/23/Hadoop-Spark%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/","excerpt":"hadoop和Spark是两种不同的大数据处理框架，他们的组件都非常多。下面是两种框架使用到的一些组件整理蓝色部分，是Hadoop生态系统组件，黄色部分是Spark生态组件。虽然他们是两种不同的大数据处理框架，但它们不是互斥的，Spark与hadoop 中的MapReduce是一种相互共生的关系。Hadoop提供了Spark许多没有的功能，比如分布式文件系统，而Spark 提供了实时内存计算，速度非常快。有一点大家要注意，Spark并不是一定要依附于Hadoop才能生存，除了Hadoop的HDFS，还可以基于其他的云平台，当然啦，大家一致认为Spark与Hadoop配合默契最好罢了。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://vwin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop","slug":"hadoop","permalink":"http://vwin.github.io/tags/hadoop/"},{"name":"spark","slug":"spark","permalink":"http://vwin.github.io/tags/spark/"}]},{"title":"大数据测试开发-0：大数据介绍","date":"2018-12-20T20:38:12.000Z","path":"2018/12/20/大数据测试开发-0：大数据介绍/","text":"从上一篇文章我们了解到人工智能&#x3D;大数据+算法 或者 人工智能&#x3D;大数据+机器学习，总之，人工智能和大数据是密不可分的。那么对大数据必须要有一定的了解才可以 背景我们接下来讲讲Spark，为什么要讲Spark呢，因为我们性能测试的需求要造10亿级甚至更多的数据。普通的方式肯定不行了，得用到spark提交到yarn上运行才跑的动。所以现在我们来谈论谈论大数据方面的东西。同时大数据也是人工智能的基础，现在搞搞大数据的东西，也为以后讨论人工智能方面的测试做做铺垫吧。 起源万事开头难，我刚接触大数据的那会是天天的一脸懵逼。因为以前只跟数据库打过交道，对于hadoop生态圈完全是没听过的状态。看资料的时候也根本看不懂。所以我先介绍一下基础的概念吧。大数据，首先要能存的下大数据。 传统的数据库虽然衍生了主从，分片。但是他们在存储上也无法应对TB甚至PB的数据量，尤其是在计算处理上他们更无法突破单机计算的桎梏。因为我们传统的文件系统是单机的，不能横跨不同的机器。在前些年的时候随着互联网的崛起，我们进入了数据爆炸的时代。传统的数据存储方式不论在存储量上还是计算性能上都已经越来越跟不上数据发展的速度了。当时开发一个新的方式处理数据在业界呼声很高。之后在04年(好像是吧，记不清了）Google发表了论文–MapReduce，详细讲述了Google的分布式计算原理。这时候业界才发现原来数据还可以这么玩，但是Google的良心大大滴坏，他只发了论文但是没有开源，这把一干人等急的抓耳挠腮，后来Apache组织了一帮人根据Google的论文糊出了一个hadoop。直到现在hadoop生态已经发展了10余年(是的没错，我们现在看的很高大上的hadoop技术是人家Google玩剩下的)。 Hadoop 的出现先前说我们传统的文件系统是单机的，无法横跨不同的机器。而HDFS的出现(Hadoop Distributed FileSystem)，打破了我们单机的限制。HDFS是Apache专门研发的分布式文件系统。设计本质上是为了大量的数据能横跨成百上千台机器，但是你看到的是一个文件系统而不是多个。比如说我要取&#x2F;hdfs&#x2F;gaofei&#x2F;file1上的数据。你引用的是一个文件路径，但是实际的数据是存放在很多个不同的机器上的。作为用户，我们不知道实际的物理存储结构，我们知道的只要暴露给我们的逻辑路径。那么在我们有能力存在这么大的数据后，就开始考虑怎么处理数据了。 虽然HDFS帮助我们管理不同机器上的数据并抽象一个统一接口给我们。但是这仍然改变不了这些数据非常大的事实。 如果我们仍然是在一台机器上处理这海量的数据，那性能上仍然是不可接受的。那么如果我们要在多台机器上同时处理这些数据，就面临了一个机器之间如何通信和调度的问题。 这就是MapReduce&#x2F;Spark的功能。MapReduce是第一代的产物，Apache研发的hadoop就是基于MapReduce框架(根据Google的论文而来)。Spark是第二代。 MapReduce采用了很简化的模型，只有Map和Reduce两个计算过程（中间用shuffle串联）。 MapReduce那什么是MapReduce呢， 举个最常用的wordcount的例子。 假如你需要统计一个巨大的文件中所有单词出现的词频。 首先你需要很多台机器同时并发的读取这个文件的各个部分，分别把自己读到的部分进行第一步计算。 假如在这台机器上，我读取了一部分数据，对这些数据统计出了类似（Hello–100次）（word–1000次）这样的结果。 每台机器都读取了部分数据并做了相同的操作。这就是MapReduce中的Map阶段(额，中间其实还有别的操作，恕我学艺不精，解释不清了)。然后我们进入Reduce阶段，这个阶段也会并发启动很多的机器，框架会将Map机器上的数据按一定规则分别放到这些Reduce机器上进行计算。 例如我们把所有Hello这个单词的放在ReduceA上，把所有word这个单词的数据放到ReduceB上。然后ReduceA汇总所有的Map数据中的Hello这个单词的结果，计算出这个单词在数据中出现的词频为1000次。 ReduceB汇总所有Word这个单词并计算出它在数据中出现的词频为1000次。这样我们就统计出了这个巨大文件的词频了。 这就是MapReduce， 可以简单理解为Map阶段并发机器读取不同的数据块做第一步处理，然后Reduce阶段并发机器按规则汇总Map阶段的数据做第二部处理。中间有个很重要的过程是shuffle，暂时可以理解为这个shuffle就是哪些Map的数据放到哪个Reduce上的规则过程。详细的不表示了，shuffle这个东西有点复杂，我们之后再讲。 SparkMapReduce的模型简单暴力，但是程序写起来真麻烦。因为全靠程序员编码，框架只是提供了Map和Reduce的函数，至于里面什么逻辑全靠你自己写。于是有了pig和Hive。Pig我没怎么了解过，Hive是基于SQL的，它们把SQL翻译成的MapReduce程序。有了Hive以后，大家发现Sql实在太容易写了，这比写java代码方便太多了。例如我司的产品中，专门有一个算子是sql，可以让业务人员也sql做拼表的动作。但是我们发现Hive在MapReduce上跑的特别慢，这个实在让人接受不了。 于是中间又经过了几个引擎的进化，Spark和SparkSQL应运而生。Spark不仅拥有新一代的计算引擎(跑的更快)，而且内置了很多的方法供你操作数据，我们编写起程序来现在变的更快更简单。假如我们有这么一个需求，统计一个文件中a，b这两个字母出现的单词有多少个。 可以像下面这样写： 12345678from pyspark import SparkConf, SparkContextconf = SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;My App&quot;)sc = SparkContext(conf=conf)logFile = &quot;/Users/sungaofei/Documents/spark/README.md&quot;logData = sc.textFile(logFile).cache()numAs = logData.filter(lambda s: &#x27;a&#x27; in s).count()numBs = logData.filter(lambda s: &#x27;b&#x27; in s).count() numAs和numBs就是我们统计的结果。可以看到spark提供了filter这种过滤函数和count这种内置的统计数量函数。 我们不再像以前MapReduce一样要写那么多的逻辑。 同时SparkSQL也支持了我们把SQL翻译成代码的功能。 总结恩，我只是简单介绍了Haoop和Spark的历史和做用。其实Haoop生态圈里还有一些其他的框架，像什么Hbase，Hive on tze。但是我这个水平的就不了解那么多了。 这里只是简单的给大家有一个概念上的了解。起码知道大数据到底是怎么回事。大数据看起来高不可攀，但是其实懂了原理以后，我们也可以做一些事情。 下一篇我们演示一下如何搭建一个spark的学习环境以及一些spark的基础介绍。","raw":"---\ntitle: '大数据测试开发-0：大数据介绍'\ntoc: true\ndate: 2018-12-21 04:38:12\ntags: [大数据,spark]\ncategories: [测试]\ndescription:\n---\n从上一篇文章我们了解到人工智能=大数据+算法 或者 人工智能=大数据+机器学习，总之，人工智能和大数据是密不可分的。那么对大数据必须要有一定的了解才可以\n### 背景\n我们接下来讲讲Spark，为什么要讲Spark呢，因为我们性能测试的需求要造10亿级甚至更多的数据。普通的方式肯定不行了，得用到spark提交到yarn上运行才跑的动。所以现在我们来谈论谈论大数据方面的东西。同时大数据也是人工智能的基础，现在搞搞大数据的东西，也为以后讨论人工智能方面的测试做做铺垫吧。\n<!--more-->\n\n### 起源\n万事开头难，我刚接触大数据的那会是天天的一脸懵逼。因为以前只跟数据库打过交道，对于hadoop生态圈完全是没听过的状态。看资料的时候也根本看不懂。所以我先介绍一下基础的概念吧。\n大数据，首先要能存的下大数据。 传统的数据库虽然衍生了主从，分片。但是他们在存储上也无法应对TB甚至PB的数据量，尤其是在计算处理上他们更无法突破单机计算的桎梏。因为我们传统的文件系统是单机的，不能横跨不同的机器。在前些年的时候随着互联网的崛起，我们进入了数据爆炸的时代。传统的数据存储方式不论在存储量上还是计算性能上都已经越来越跟不上数据发展的速度了。当时开发一个新的方式处理数据在业界呼声很高。之后在04年(好像是吧，记不清了）Google发表了论文--MapReduce，详细讲述了Google的分布式计算原理。这时候业界才发现原来数据还可以这么玩，但是Google的良心大大滴坏，他只发了论文但是没有开源，这把一干人等急的抓耳挠腮，后来Apache组织了一帮人根据Google的论文糊出了一个hadoop。直到现在hadoop生态已经发展了10余年(是的没错，我们现在看的很高大上的hadoop技术是人家Google玩剩下的)。\n\n# Hadoop 的出现\n先前说我们传统的文件系统是单机的，无法横跨不同的机器。而HDFS的出现(Hadoop Distributed FileSystem)，打破了我们单机的限制。HDFS是Apache专门研发的分布式文件系统。设计本质上是为了大量的数据能横跨成百上千台机器，但是你看到的是一个文件系统而不是多个。比如说我要取/hdfs/gaofei/file1上的数据。你引用的是一个文件路径，但是实际的数据是存放在很多个不同的机器上的。作为用户，我们不知道实际的物理存储结构，我们知道的只要暴露给我们的逻辑路径。那么在我们有能力存在这么大的数据后，就开始考虑怎么处理数据了。 虽然HDFS帮助我们管理不同机器上的数据并抽象一个统一接口给我们。但是这仍然改变不了这些数据非常大的事实。 如果我们仍然是在一台机器上处理这海量的数据，那性能上仍然是不可接受的。那么如果我们要在多台机器上同时处理这些数据，就面临了一个机器之间如何通信和调度的问题。 这就是MapReduce/Spark的功能。MapReduce是第一代的产物，Apache研发的hadoop就是基于MapReduce框架(根据Google的论文而来)。Spark是第二代。 MapReduce采用了很简化的模型，只有Map和Reduce两个计算过程（中间用shuffle串联）。\n\n# MapReduce\n那什么是MapReduce呢， 举个最常用的wordcount的例子。 假如你需要统计一个巨大的文件中所有单词出现的词频。 首先你需要很多台机器同时并发的读取这个文件的各个部分，分别把自己读到的部分进行第一步计算。 假如在这台机器上，我读取了一部分数据，对这些数据统计出了类似（Hello--100次）（word--1000次）这样的结果。 每台机器都读取了部分数据并做了相同的操作。这就是MapReduce中的Map阶段(额，中间其实还有别的操作，恕我学艺不精，解释不清了)。然后我们进入Reduce阶段，这个阶段也会并发启动很多的机器，框架会将Map机器上的数据按一定规则分别放到这些Reduce机器上进行计算。 例如我们把所有Hello这个单词的放在ReduceA上，把所有word这个单词的数据放到ReduceB上。然后ReduceA汇总所有的Map数据中的Hello这个单词的结果，计算出这个单词在数据中出现的词频为1000次。 ReduceB汇总所有Word这个单词并计算出它在数据中出现的词频为1000次。这样我们就统计出了这个巨大文件的词频了。 这就是MapReduce， 可以简单理解为Map阶段并发机器读取不同的数据块做第一步处理，然后Reduce阶段并发机器按规则汇总Map阶段的数据做第二部处理。中间有个很重要的过程是shuffle，暂时可以理解为这个shuffle就是哪些Map的数据放到哪个Reduce上的规则过程。详细的不表示了，shuffle这个东西有点复杂，我们之后再讲。\n\n# Spark\nMapReduce的模型简单暴力，但是程序写起来真麻烦。因为全靠程序员编码，框架只是提供了Map和Reduce的函数，至于里面什么逻辑全靠你自己写。于是有了pig和Hive。Pig我没怎么了解过，Hive是基于SQL的，它们把SQL翻译成的MapReduce程序。有了Hive以后，大家发现Sql实在太容易写了，这比写java代码方便太多了。例如我司的产品中，专门有一个算子是sql，可以让业务人员也sql做拼表的动作。但是我们发现Hive在MapReduce上跑的特别慢，这个实在让人接受不了。 于是中间又经过了几个引擎的进化，Spark和SparkSQL应运而生。Spark不仅拥有新一代的计算引擎(跑的更快)，而且内置了很多的方法供你操作数据，我们编写起程序来现在变的更快更简单。假如我们有这么一个需求，统计一个文件中a，b这两个字母出现的单词有多少个。 可以像下面这样写：\n```python\nfrom pyspark import SparkConf, SparkContext\nconf = SparkConf().setMaster(\"local\").setAppName(\"My App\")\nsc = SparkContext(conf=conf)\nlogFile = \"/Users/sungaofei/Documents/spark/README.md\"\nlogData = sc.textFile(logFile).cache()\n\nnumAs = logData.filter(lambda s: 'a' in s).count()\nnumBs = logData.filter(lambda s: 'b' in s).count()\n```\n\nnumAs和numBs就是我们统计的结果。可以看到spark提供了filter这种过滤函数和count这种内置的统计数量函数。 我们不再像以前MapReduce一样要写那么多的逻辑。 同时SparkSQL也支持了我们把SQL翻译成代码的功能。\n\n# 总结\n恩，我只是简单介绍了Haoop和Spark的历史和做用。其实Haoop生态圈里还有一些其他的框架，像什么Hbase，Hive on tze。但是我这个水平的就不了解那么多了。 这里只是简单的给大家有一个概念上的了解。起码知道大数据到底是怎么回事。大数据看起来高不可攀，但是其实懂了原理以后，我们也可以做一些事情。 下一篇我们演示一下如何搭建一个spark的学习环境以及一些spark的基础介绍。","content":"<p>从上一篇文章我们了解到人工智能&#x3D;大数据+算法 或者 人工智能&#x3D;大数据+机器学习，总之，人工智能和大数据是密不可分的。那么对大数据必须要有一定的了解才可以</p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>我们接下来讲讲Spark，为什么要讲Spark呢，因为我们性能测试的需求要造10亿级甚至更多的数据。普通的方式肯定不行了，得用到spark提交到yarn上运行才跑的动。所以现在我们来谈论谈论大数据方面的东西。同时大数据也是人工智能的基础，现在搞搞大数据的东西，也为以后讨论人工智能方面的测试做做铺垫吧。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><p>万事开头难，我刚接触大数据的那会是天天的一脸懵逼。因为以前只跟数据库打过交道，对于hadoop生态圈完全是没听过的状态。看资料的时候也根本看不懂。所以我先介绍一下基础的概念吧。<br>大数据，首先要能存的下大数据。 传统的数据库虽然衍生了主从，分片。但是他们在存储上也无法应对TB甚至PB的数据量，尤其是在计算处理上他们更无法突破单机计算的桎梏。因为我们传统的文件系统是单机的，不能横跨不同的机器。在前些年的时候随着互联网的崛起，我们进入了数据爆炸的时代。传统的数据存储方式不论在存储量上还是计算性能上都已经越来越跟不上数据发展的速度了。当时开发一个新的方式处理数据在业界呼声很高。之后在04年(好像是吧，记不清了）Google发表了论文–MapReduce，详细讲述了Google的分布式计算原理。这时候业界才发现原来数据还可以这么玩，但是Google的良心大大滴坏，他只发了论文但是没有开源，这把一干人等急的抓耳挠腮，后来Apache组织了一帮人根据Google的论文糊出了一个hadoop。直到现在hadoop生态已经发展了10余年(是的没错，我们现在看的很高大上的hadoop技术是人家Google玩剩下的)。</p>\n<h1 id=\"Hadoop-的出现\"><a href=\"#Hadoop-的出现\" class=\"headerlink\" title=\"Hadoop 的出现\"></a>Hadoop 的出现</h1><p>先前说我们传统的文件系统是单机的，无法横跨不同的机器。而HDFS的出现(Hadoop Distributed FileSystem)，打破了我们单机的限制。HDFS是Apache专门研发的分布式文件系统。设计本质上是为了大量的数据能横跨成百上千台机器，但是你看到的是一个文件系统而不是多个。比如说我要取&#x2F;hdfs&#x2F;gaofei&#x2F;file1上的数据。你引用的是一个文件路径，但是实际的数据是存放在很多个不同的机器上的。作为用户，我们不知道实际的物理存储结构，我们知道的只要暴露给我们的逻辑路径。那么在我们有能力存在这么大的数据后，就开始考虑怎么处理数据了。 虽然HDFS帮助我们管理不同机器上的数据并抽象一个统一接口给我们。但是这仍然改变不了这些数据非常大的事实。 如果我们仍然是在一台机器上处理这海量的数据，那性能上仍然是不可接受的。那么如果我们要在多台机器上同时处理这些数据，就面临了一个机器之间如何通信和调度的问题。 这就是MapReduce&#x2F;Spark的功能。MapReduce是第一代的产物，Apache研发的hadoop就是基于MapReduce框架(根据Google的论文而来)。Spark是第二代。 MapReduce采用了很简化的模型，只有Map和Reduce两个计算过程（中间用shuffle串联）。</p>\n<h1 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h1><p>那什么是MapReduce呢， 举个最常用的wordcount的例子。 假如你需要统计一个巨大的文件中所有单词出现的词频。 首先你需要很多台机器同时并发的读取这个文件的各个部分，分别把自己读到的部分进行第一步计算。 假如在这台机器上，我读取了一部分数据，对这些数据统计出了类似（Hello–100次）（word–1000次）这样的结果。 每台机器都读取了部分数据并做了相同的操作。这就是MapReduce中的Map阶段(额，中间其实还有别的操作，恕我学艺不精，解释不清了)。然后我们进入Reduce阶段，这个阶段也会并发启动很多的机器，框架会将Map机器上的数据按一定规则分别放到这些Reduce机器上进行计算。 例如我们把所有Hello这个单词的放在ReduceA上，把所有word这个单词的数据放到ReduceB上。然后ReduceA汇总所有的Map数据中的Hello这个单词的结果，计算出这个单词在数据中出现的词频为1000次。 ReduceB汇总所有Word这个单词并计算出它在数据中出现的词频为1000次。这样我们就统计出了这个巨大文件的词频了。 这就是MapReduce， 可以简单理解为Map阶段并发机器读取不同的数据块做第一步处理，然后Reduce阶段并发机器按规则汇总Map阶段的数据做第二部处理。中间有个很重要的过程是shuffle，暂时可以理解为这个shuffle就是哪些Map的数据放到哪个Reduce上的规则过程。详细的不表示了，shuffle这个东西有点复杂，我们之后再讲。</p>\n<h1 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h1><p>MapReduce的模型简单暴力，但是程序写起来真麻烦。因为全靠程序员编码，框架只是提供了Map和Reduce的函数，至于里面什么逻辑全靠你自己写。于是有了pig和Hive。Pig我没怎么了解过，Hive是基于SQL的，它们把SQL翻译成的MapReduce程序。有了Hive以后，大家发现Sql实在太容易写了，这比写java代码方便太多了。例如我司的产品中，专门有一个算子是sql，可以让业务人员也sql做拼表的动作。但是我们发现Hive在MapReduce上跑的特别慢，这个实在让人接受不了。 于是中间又经过了几个引擎的进化，Spark和SparkSQL应运而生。Spark不仅拥有新一代的计算引擎(跑的更快)，而且内置了很多的方法供你操作数据，我们编写起程序来现在变的更快更简单。假如我们有这么一个需求，统计一个文件中a，b这两个字母出现的单词有多少个。 可以像下面这样写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pyspark <span class=\"keyword\">import</span> SparkConf, SparkContext</span><br><span class=\"line\">conf = SparkConf().setMaster(<span class=\"string\">&quot;local&quot;</span>).setAppName(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">sc = SparkContext(conf=conf)</span><br><span class=\"line\">logFile = <span class=\"string\">&quot;/Users/sungaofei/Documents/spark/README.md&quot;</span></span><br><span class=\"line\">logData = sc.textFile(logFile).cache()</span><br><span class=\"line\"></span><br><span class=\"line\">numAs = logData.<span class=\"built_in\">filter</span>(<span class=\"keyword\">lambda</span> s: <span class=\"string\">&#x27;a&#x27;</span> <span class=\"keyword\">in</span> s).count()</span><br><span class=\"line\">numBs = logData.<span class=\"built_in\">filter</span>(<span class=\"keyword\">lambda</span> s: <span class=\"string\">&#x27;b&#x27;</span> <span class=\"keyword\">in</span> s).count()</span><br></pre></td></tr></table></figure>\n\n<p>numAs和numBs就是我们统计的结果。可以看到spark提供了filter这种过滤函数和count这种内置的统计数量函数。 我们不再像以前MapReduce一样要写那么多的逻辑。 同时SparkSQL也支持了我们把SQL翻译成代码的功能。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>恩，我只是简单介绍了Haoop和Spark的历史和做用。其实Haoop生态圈里还有一些其他的框架，像什么Hbase，Hive on tze。但是我这个水平的就不了解那么多了。 这里只是简单的给大家有一个概念上的了解。起码知道大数据到底是怎么回事。大数据看起来高不可攀，但是其实懂了原理以后，我们也可以做一些事情。 下一篇我们演示一下如何搭建一个spark的学习环境以及一些spark的基础介绍。</p>\n","slug":"大数据测试开发-0：大数据介绍","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91-0%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%8B%E7%BB%8D/","excerpt":"从上一篇文章我们了解到人工智能&#x3D;大数据+算法 或者 人工智能&#x3D;大数据+机器学习，总之，人工智能和大数据是密不可分的。那么对大数据必须要有一定的了解才可以 背景我们接下来讲讲Spark，为什么要讲Spark呢，因为我们性能测试的需求要造10亿级甚至更多的数据。普通的方式肯定不行了，得用到spark提交到yarn上运行才跑的动。所以现在我们来谈论谈论大数据方面的东西。同时大数据也是人工智能的基础，现在搞搞大数据的东西，也为以后讨论人工智能方面的测试做做铺垫吧。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://vwin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"http://vwin.github.io/tags/spark/"}]},{"title":"主流分布式文件系统","date":"2018-12-17T22:14:43.000Z","path":"2018/12/17/主流分布式文件系统/","text":"转载自：http://leanote.com/blog/post/5aa5dd21ab644109fa0005a6","raw":"---\ntitle: 主流分布式文件系统\ntoc: true\ndate: 2018-12-18 06:14:43\ntags: [mfs,seaweedfs]\ncategories: [技术]\ndescription:\n---\n转载自：http://leanote.com/blog/post/5aa5dd21ab644109fa0005a6\n","content":"<p>转载自：<a href=\"http://leanote.com/blog/post/5aa5dd21ab644109fa0005a6\">http://leanote.com/blog/post/5aa5dd21ab644109fa0005a6</a></p>\n","slug":"主流分布式文件系统","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/17/%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"mfs","slug":"mfs","permalink":"http://vwin.github.io/tags/mfs/"},{"name":"seaweedfs","slug":"seaweedfs","permalink":"http://vwin.github.io/tags/seaweedfs/"}]},{"title":"Go 语言学习教程整理","date":"2018-12-17T19:28:43.000Z","path":"2018/12/17/Go-语言学习教程整理/","text":"区块链开发语言之go语言学习线路指导 http://www.aboutyun.com/thread-24344-1-1.html Go语言实战 中文pdf扫描版http://qunying.jb51.net:81/201706/books/Goyysz.rar Go语言教程 中文PDF版 http://qunying.jb51.net:81/201610/books/goyuyanjiaoch_jb51.rar android手机PDF阅读器(RepliGo Reader) 已付费版 v4.0.0http://qunying.jb51.net:81/201205/tools/RepliGoReader_jb51.rar Go语言学习笔记 (雨痕) 中文pdf扫描版[37MB]https://pan.baidu.com/s/18MBu7f0M09OBeoGdd-8U8g Go语言圣经(The Go Programming Language) 中文pdf版http://qunying.jb51.net:81/201706/books/Goyysj.rar Go程序设计语言 中文版 (艾伦A. A. 多诺万) 完整pdf高清版[99MB]https://pan.baidu.com/s/1lxffWEfik2-PgNEnA5gaTQ Go并发编程实战 完整版 (郝林) 高清pdf扫描版[86MB]http://qunying.jb51.net:81/201512/books/Gobfbcsz(jb51.net).rar Go语言标准库 中文版 高清pdf完整版[20MB]https://pan.baidu.com/s/1bpbGV4j Go并发编程实战（第2版）完整版PDF[42MB]https://pan.baidu.com/s/1qGL8wvXiQu-fp6ElZZyaPg Go语言程序设计(Mark Summerfield 著)高清扫描带书签完整版PDFhttp://pan.baidu.com/s/1kVOPaJH Go Web编程 PDF扫描版[5MB]http://pan.baidu.com/s/1pJ1bQ2J Django Web开发指南 中文pdf版(徐旭铭 等译)http://qunying.jb51.net:81/201303/books/DjangoWebkfzn_jb51.net.rar Cloud Native Go：构建基于Go和React的云原生Web应用与微服务 中文pdf扫描版[168MB]https://pan.baidu.com/s/1hicP7exhMGSsoa7bCzG63g Go语言编程高清完整版电子书 pdf版(许式伟 吕桂华)http://qunying.jb51.net:81/201601/books/go_yybc(jb51.net).rar","raw":"---\ntitle: Go 语言学习教程整理\ntoc: true\ndate: 2018-12-18 03:28:43\ntags: [Go,教程,pdf,百度网盘]\ncategories: [技术]\ndescription:\n---\n0. 区块链开发语言之go语言学习线路指导 http://www.aboutyun.com/thread-24344-1-1.html \n1. Go语言实战 中文pdf扫描版 \nhttp://qunying.jb51.net:81/201706/books/Goyysz.rar\n2. Go语言教程 中文PDF版 http://qunying.jb51.net:81/201610/books/goyuyanjiaoch_jb51.rar\n3. android手机PDF阅读器(RepliGo Reader) 已付费版 v4.0.0\nhttp://qunying.jb51.net:81/201205/tools/RepliGoReader_jb51.rar\n4. Go语言学习笔记 (雨痕) 中文pdf扫描版[37MB]\nhttps://pan.baidu.com/s/18MBu7f0M09OBeoGdd-8U8g\n5. Go语言圣经(The Go Programming Language) 中文pdf版\nhttp://qunying.jb51.net:81/201706/books/Goyysj.rar\n6. Go程序设计语言 中文版 (艾伦A. A. 多诺万) 完整pdf高清版[99MB]\nhttps://pan.baidu.com/s/1lxffWEfik2-PgNEnA5gaTQ\n7. Go并发编程实战 完整版 (郝林) 高清pdf扫描版[86MB]\nhttp://qunying.jb51.net:81/201512/books/Gobfbcsz(jb51.net).rar\n9. Go语言标准库 中文版 高清pdf完整版[20MB]\nhttps://pan.baidu.com/s/1bpbGV4j\n10. Go并发编程实战（第2版）完整版PDF[42MB]\nhttps://pan.baidu.com/s/1qGL8wvXiQu-fp6ElZZyaPg\n11. Go语言程序设计(Mark Summerfield 著)高清扫描带书签完整版PDF\nhttp://pan.baidu.com/s/1kVOPaJH\n12. Go Web编程 PDF扫描版[5MB]\nhttp://pan.baidu.com/s/1pJ1bQ2J\n13. Django Web开发指南 中文pdf版(徐旭铭 等译)\nhttp://qunying.jb51.net:81/201303/books/DjangoWebkfzn_jb51.net.rar\n14. Cloud Native Go：构建基于Go和React的云原生Web应用与微服务 中文pdf扫描版[168MB]\nhttps://pan.baidu.com/s/1hicP7exhMGSsoa7bCzG63g\n15. Go语言编程高清完整版电子书 pdf版(许式伟 吕桂华)\nhttp://qunying.jb51.net:81/201601/books/go_yybc(jb51.net).rar\n","content":"<ol start=\"0\">\n<li>区块链开发语言之go语言学习线路指导 <a href=\"http://www.aboutyun.com/thread-24344-1-1.html\">http://www.aboutyun.com/thread-24344-1-1.html</a> </li>\n<li>Go语言实战 中文pdf扫描版<br><a href=\"http://qunying.jb51.net:81/201706/books/Goyysz.rar\">http://qunying.jb51.net:81/201706/books/Goyysz.rar</a></li>\n<li>Go语言教程 中文PDF版 <a href=\"http://qunying.jb51.net:81/201610/books/goyuyanjiaoch_jb51.rar\">http://qunying.jb51.net:81/201610/books/goyuyanjiaoch_jb51.rar</a></li>\n<li>android手机PDF阅读器(RepliGo Reader) 已付费版 v4.0.0<br><a href=\"http://qunying.jb51.net:81/201205/tools/RepliGoReader_jb51.rar\">http://qunying.jb51.net:81/201205/tools/RepliGoReader_jb51.rar</a></li>\n<li>Go语言学习笔记 (雨痕) 中文pdf扫描版[37MB]<br><a href=\"https://pan.baidu.com/s/18MBu7f0M09OBeoGdd-8U8g\">https://pan.baidu.com/s/18MBu7f0M09OBeoGdd-8U8g</a></li>\n<li>Go语言圣经(The Go Programming Language) 中文pdf版<br><a href=\"http://qunying.jb51.net:81/201706/books/Goyysj.rar\">http://qunying.jb51.net:81/201706/books/Goyysj.rar</a></li>\n<li>Go程序设计语言 中文版 (艾伦A. A. 多诺万) 完整pdf高清版[99MB]<br><a href=\"https://pan.baidu.com/s/1lxffWEfik2-PgNEnA5gaTQ\">https://pan.baidu.com/s/1lxffWEfik2-PgNEnA5gaTQ</a></li>\n<li>Go并发编程实战 完整版 (郝林) 高清pdf扫描版[86MB]<br><a href=\"http://qunying.jb51.net:81/201512/books/Gobfbcsz(jb51.net).rar\">http://qunying.jb51.net:81/201512/books/Gobfbcsz(jb51.net).rar</a></li>\n<li>Go语言标准库 中文版 高清pdf完整版[20MB]<br><a href=\"https://pan.baidu.com/s/1bpbGV4j\">https://pan.baidu.com/s/1bpbGV4j</a></li>\n<li>Go并发编程实战（第2版）完整版PDF[42MB]<br><a href=\"https://pan.baidu.com/s/1qGL8wvXiQu-fp6ElZZyaPg\">https://pan.baidu.com/s/1qGL8wvXiQu-fp6ElZZyaPg</a></li>\n<li>Go语言程序设计(Mark Summerfield 著)高清扫描带书签完整版PDF<br><a href=\"http://pan.baidu.com/s/1kVOPaJH\">http://pan.baidu.com/s/1kVOPaJH</a></li>\n<li>Go Web编程 PDF扫描版[5MB]<br><a href=\"http://pan.baidu.com/s/1pJ1bQ2J\">http://pan.baidu.com/s/1pJ1bQ2J</a></li>\n<li>Django Web开发指南 中文pdf版(徐旭铭 等译)<br><a href=\"http://qunying.jb51.net:81/201303/books/DjangoWebkfzn_jb51.net.rar\">http://qunying.jb51.net:81/201303/books/DjangoWebkfzn_jb51.net.rar</a></li>\n<li>Cloud Native Go：构建基于Go和React的云原生Web应用与微服务 中文pdf扫描版[168MB]<br><a href=\"https://pan.baidu.com/s/1hicP7exhMGSsoa7bCzG63g\">https://pan.baidu.com/s/1hicP7exhMGSsoa7bCzG63g</a></li>\n<li>Go语言编程高清完整版电子书 pdf版(许式伟 吕桂华)<br><a href=\"http://qunying.jb51.net:81/201601/books/go_yybc(jb51.net).rar\">http://qunying.jb51.net:81/201601/books/go_yybc(jb51.net).rar</a></li>\n</ol>\n","slug":"Go-语言学习教程整理","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/17/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://vwin.github.io/tags/Go/"},{"name":"教程","slug":"教程","permalink":"http://vwin.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"pdf","slug":"pdf","permalink":"http://vwin.github.io/tags/pdf/"},{"name":"百度网盘","slug":"百度网盘","permalink":"http://vwin.github.io/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"}]},{"title":"Devops 理解","date":"2018-12-12T17:32:32.000Z","path":"2018/12/12/Devops-理解/","text":"Devops 理解转载自：https://yq.aliyun.com/articles/82647?spm=a2c4e.11153940.blogcont64970.23.1129413eK8hAqL","raw":"---\ntitle: Devops 理解\ntoc: true\ndate: 2018-12-13 01:32:32\ntags: [Devops,Derrick]\ncategories: [测试]\ndescription:\n---\nDevops 理解\n转载自：https://yq.aliyun.com/articles/82647?spm=a2c4e.11153940.blogcont64970.23.1129413eK8hAqL\n<!--more-->\n\n","content":"<p>Devops 理解<br>转载自：<a href=\"https://yq.aliyun.com/articles/82647?spm=a2c4e.11153940.blogcont64970.23.1129413eK8hAqL\">https://yq.aliyun.com/articles/82647?spm=a2c4e.11153940.blogcont64970.23.1129413eK8hAqL</a></p>\n<span id=\"more\"></span>\n\n","slug":"Devops-理解","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/12/Devops-%E7%90%86%E8%A7%A3/","excerpt":"Devops 理解转载自：https://yq.aliyun.com/articles/82647?spm=a2c4e.11153940.blogcont64970.23.1129413eK8hAqL","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Devops","slug":"Devops","permalink":"http://vwin.github.io/tags/Devops/"},{"name":"Derrick","slug":"Derrick","permalink":"http://vwin.github.io/tags/Derrick/"}]},{"title":"npm 换源","date":"2018-12-11T19:26:25.000Z","path":"2018/12/11/npm-换源/","text":"NPM 换源 使用淘宝镜像1.临时使用 1npm --registry https://registry.npm.taobao.org install express 2.持久使用 1npm config set registry https://registry.npm.taobao.org 3.通过cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 使用官方镜像1npm config set registry https://registry.npmjs.org/ 查看npm源地址1npm config get registry","raw":"---\ntitle: npm 换源\ntoc: true\ndate: 2018-12-12 03:26:25\ntags: [npm,cnpm]\ncategories: [技术]\ndescription:\n---\nNPM 换源\n\n<!--more-->\n# 使用淘宝镜像\n1.临时使用\n```shell\nnpm --registry https://registry.npm.taobao.org install express\n```\n2.持久使用\n```shell\nnpm config set registry https://registry.npm.taobao.org\n```\n3.通过cnpm\n```shell\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n# 使用官方镜像\n```shell\nnpm config set registry https://registry.npmjs.org/\n```\n# 查看npm源地址\n```shell\nnpm config get registry\n```\n","content":"<p>NPM 换源</p>\n<span id=\"more\"></span>\n<h1 id=\"使用淘宝镜像\"><a href=\"#使用淘宝镜像\" class=\"headerlink\" title=\"使用淘宝镜像\"></a>使用淘宝镜像</h1><p>1.临时使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure>\n<p>2.持久使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>3.通过cnpm</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用官方镜像\"><a href=\"#使用官方镜像\" class=\"headerlink\" title=\"使用官方镜像\"></a>使用官方镜像</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>\n<h1 id=\"查看npm源地址\"><a href=\"#查看npm源地址\" class=\"headerlink\" title=\"查看npm源地址\"></a>查看npm源地址</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n","slug":"npm-换源","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/11/npm-%E6%8D%A2%E6%BA%90/","excerpt":"NPM 换源","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://vwin.github.io/tags/npm/"},{"name":"cnpm","slug":"cnpm","permalink":"http://vwin.github.io/tags/cnpm/"}]},{"title":"Ubuntu 16.04安装mysql","date":"2018-12-11T18:48:25.000Z","path":"2018/12/11/Ubuntu-16-04安装mysql/","text":"Ubuntu 16.04安装MySQL 安装123sudo apt-get install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-dev 测试1sudo netstat -tap | grep mysql 出现 则表示安装成功 进入1mysql -uroot -p你的密码 运行远程访问12编辑mysqld.cnf文件sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉：bind-address:127.0.0.1 123mysql -uroot -pgrant all on *.* to root@&#x27;%&#x27; identified by &#x27;你的密码&#x27; with grant option;flush privileges; 然后执行quit命令退出mysql服务，执行如下命令重启mysql： 1sudo service mysql restart","raw":"---\ntitle: Ubuntu 16.04安装mysql\ntoc: true\ndate: 2018-12-12 02:48:25\ntags: [ubuntu,mysql,linux]\ncategories: [技术]\ndescription:\n---\n\nUbuntu 16.04安装MySQL\n\n<!--more-->\n# 安装\n```shell\nsudo apt-get install mysql-server\nsudo apt install mysql-client\nsudo apt install libmysqlclient-dev\n```\n\n# 测试\n```shell\nsudo netstat -tap | grep mysql\n```\n出现 ![](https://ws2.sinaimg.cn/large/006tNbRwly1fy40h11flzj30j8023wez.jpg) 则表示安装成功\n\n# 进入\n```shell\nmysql -uroot -p你的密码\n```\n\n# 运行远程访问\n```shell\n编辑mysqld.cnf文件\nsudo vi /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n注释掉：bind-address:127.0.0.1\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fy40iks7b6j30kf0blmyw.jpg)\n\n```shell\nmysql -uroot -p\ngrant all on *.* to root@'%' identified by '你的密码' with grant option;\nflush privileges;\n```\n然后执行quit命令退出mysql服务，执行如下命令重启mysql：\n```shell\nsudo service mysql restart\n```\n","content":"<p>Ubuntu 16.04安装MySQL</p>\n<span id=\"more\"></span>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server</span><br><span class=\"line\">sudo apt install mysql-client</span><br><span class=\"line\">sudo apt install libmysqlclient-dev</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure>\n<p>出现 <img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fy40h11flzj30j8023wez.jpg\"> 则表示安装成功</p>\n<h1 id=\"进入\"><a href=\"#进入\" class=\"headerlink\" title=\"进入\"></a>进入</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -p你的密码</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"运行远程访问\"><a href=\"#运行远程访问\" class=\"headerlink\" title=\"运行远程访问\"></a>运行远程访问</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编辑mysqld.cnf文件</span><br><span class=\"line\">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>\n<p>注释掉：bind-address:127.0.0.1<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fy40iks7b6j30kf0blmyw.jpg\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -uroot -p</span><br><span class=\"line\">grant all on *.* to root@&#x27;%&#x27; identified by &#x27;你的密码&#x27; with grant option;</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n<p>然后执行quit命令退出mysql服务，执行如下命令重启mysql：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br></pre></td></tr></table></figure>\n","slug":"Ubuntu-16-04安装mysql","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/11/Ubuntu-16-04%E5%AE%89%E8%A3%85mysql/","excerpt":"Ubuntu 16.04安装MySQL","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://vwin.github.io/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"http://vwin.github.io/tags/mysql/"}]},{"title":"深入理解Python中的元类(metaclass)","date":"2018-12-03T17:47:47.000Z","path":"2018/12/03/深入理解Python中的元类-metaclass/","text":"转载自深入理解Python中的元类 译注：这是一篇在Stack overflow上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复（提示：非常长） 类也是对象在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立： 12345678910111213&gt;&gt;&gt; class ObjectCreator(object):… pass…&gt;&gt;&gt; my_object = ObjectCreator()&gt;&gt;&gt; print my_object&lt;__main__.ObjectCreator object at 0x8974f2c&gt;&gt;&gt;&gt; class ObjectCreator(object):… pass…&gt;&gt;&gt; my_object = ObjectCreator()&gt;&gt;&gt; print my_object&lt;__main__.ObjectCreator object at 0x8974f2c&gt; 但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段： 12345678&gt;&gt;&gt; class ObjectCreator(object):… pass…&gt;&gt;&gt; class ObjectCreator(object):… pass… 将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作： 你可以将它赋值给一个变量 你可以拷贝它 你可以为它增加属性 你可以将它作为函数参数进行传递 下面是示例： 123456789101112131415161718&gt;&gt;&gt; print ObjectCreator # 你可以打印一个类，因为它其实也是一个对象&lt;class &#x27;__main__.ObjectCreator&#x27;&gt;&gt;&gt;&gt; def echo(o):… print o…&gt;&gt;&gt; echo(ObjectCreator) # 你可以将类做为参数传给函数&lt;class &#x27;__main__.ObjectCreator&#x27;&gt;&gt;&gt;&gt; print hasattr(ObjectCreator, &#x27;new_attribute&#x27;)Fasle&gt;&gt;&gt; ObjectCreator.new_attribute = &#x27;foo&#x27; # 你可以为类增加属性&gt;&gt;&gt; print hasattr(ObjectCreator, &#x27;new_attribute&#x27;)True&gt;&gt;&gt; print ObjectCreator.new_attributefoo&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量&gt;&gt;&gt; print ObjectCreatorMirror()&lt;__main__.ObjectCreator object at 0x8997b4c&gt; 1234567891011121314151617&gt;&gt;&gt; print ObjectCreator # 你可以打印一个类，因为它其实也是一个对象&lt;class &#x27;__main__.ObjectCreator&#x27;&gt;&gt;&gt;&gt; def echo(o):… print o…&gt;&gt;&gt; echo(ObjectCreator) # 你可以将类做为参数传给函数&lt;class &#x27;__main__.ObjectCreator&#x27;&gt;&gt;&gt;&gt; print hasattr(ObjectCreator, &#x27;new_attribute&#x27;)Fasle&gt;&gt;&gt; ObjectCreator.new_attribute = &#x27;foo&#x27; # 你可以为类增加属性&gt;&gt;&gt; print hasattr(ObjectCreator, &#x27;new_attribute&#x27;)True&gt;&gt;&gt; print ObjectCreator.new_attributefoo&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量&gt;&gt;&gt; print ObjectCreatorMirror()&lt;__main__.ObjectCreator object at 0x8997b4c&gt; 动态地创建类 因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。 12345678910111213141516&gt;&gt;&gt; def choose_class(name):… if name == &#x27;foo&#x27;:… class Foo(object):… pass… return Foo # 返回的是类，不是类的实例… else:… class Bar(object):… pass… return Bar…&gt;&gt;&gt; MyClass = choose_class(&#x27;foo&#x27;)&gt;&gt;&gt; print MyClass # 函数返回的是类，不是类的实例&lt;class &#x27;__main__&#x27;.Foo&gt;&gt;&gt;&gt; print MyClass() # 你可以通过这个类创建类实例，也就是对象&lt;__main__.Foo object at 0x89c6d4c&gt; 123456789101112131415&gt;&gt;&gt; def choose_class(name):… if name == &#x27;foo&#x27;:… class Foo(object):… pass… return Foo # 返回的是类，不是类的实例… else:… class Bar(object):… pass… return Bar…&gt;&gt;&gt; MyClass = choose_class(&#x27;foo&#x27;)&gt;&gt;&gt; print MyClass # 函数返回的是类，不是类的实例&lt;class &#x27;__main__&#x27;.Foo&gt;&gt;&gt;&gt; print MyClass() # 你可以通过这个类创建类实例，也就是对象&lt;__main__.Foo object at 0x89c6d4c&gt; 但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样： 123456789&gt;&gt;&gt; print type(1)&lt;type &#x27;int&#x27;&gt;&gt;&gt;&gt; print type(&quot;1&quot;)&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; print type(ObjectCreator)&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; print type(ObjectCreator())&lt;class &#x27;__main__.ObjectCreator&#x27;&gt; 12345678&gt;&gt;&gt; print type(1)&lt;type &#x27;int&#x27;&gt;&gt;&gt;&gt; print type(&quot;1&quot;)&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; print type(ObjectCreator)&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; print type(ObjectCreator())&lt;class &#x27;__main__.ObjectCreator&#x27;&gt; 这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性） type可以像这样工作： 1234567891011121314type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)````type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)比如下面的代码：```Python&gt;&gt;&gt; class MyShinyClass(object):… pass&gt;&gt;&gt; class MyShinyClass(object):… pass 可以手动像这样创建： 123456&gt;&gt;&gt; MyShinyClass = type(&#x27;MyShinyClass&#x27;, (), &#123;&#125;) # 返回一个类对象&gt;&gt;&gt; print MyShinyClass&lt;class &#x27;__main__.MyShinyClass&#x27;&gt;&gt;&gt;&gt; print MyShinyClass() # 创建一个该类的实例&lt;__main__.MyShinyClass object at 0x8997cec&gt; 12345&gt;&gt;&gt; MyShinyClass = type(&#x27;MyShinyClass&#x27;, (), &#123;&#125;) # 返回一个类对象&gt;&gt;&gt; print MyShinyClass&lt;class &#x27;__main__.MyShinyClass&#x27;&gt;&gt;&gt;&gt; print MyShinyClass() # 创建一个该类的实例&lt;__main__.MyShinyClass object at 0x8997cec&gt; 你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。 type 接受一个字典来为类定义属性，因此 12345&gt;&gt;&gt; class Foo(object):… bar = True&gt;&gt;&gt; class Foo(object):… bar = True 可以翻译为： 123&gt;&gt;&gt; Foo = type(&#x27;Foo&#x27;, (), &#123;&#x27;bar&#x27;:True&#125;)&gt;&gt;&gt; Foo = type(&#x27;Foo&#x27;, (), &#123;&#x27;bar&#x27;:True&#125;) 并且可以将Foo当成一个普通的类一样使用： 123456789101112131415161718&gt;&gt;&gt; print Foo&lt;class &#x27;__main__.Foo&#x27;&gt;&gt;&gt;&gt; print Foo.barTrue&gt;&gt;&gt; f = Foo()&gt;&gt;&gt; print f&lt;__main__.Foo object at 0x8a9b84c&gt;&gt;&gt;&gt; print f.barTrue&gt;&gt;&gt; print Foo&lt;class &#x27;__main__.Foo&#x27;&gt;&gt;&gt;&gt; print Foo.barTrue&gt;&gt;&gt; f = Foo()&gt;&gt;&gt; print f&lt;__main__.Foo object at 0x8a9b84c&gt;&gt;&gt;&gt; print f.barTrue 当然，你可以向这个类继承，所以，如下的代码： 12345&gt;&gt;&gt; class FooChild(Foo):… pass&gt;&gt;&gt; class FooChild(Foo):… pass 就可以写成： 1234567891011&gt;&gt;&gt; FooChild = type(&#x27;FooChild&#x27;, (Foo,),&#123;&#125;)&gt;&gt;&gt; print FooChild&lt;class &#x27;__main__.FooChild&#x27;&gt;&gt;&gt;&gt; print FooChild.bar # bar属性是由Foo继承而来True&gt;&gt;&gt; FooChild = type(&#x27;FooChild&#x27;, (Foo,),&#123;&#125;)&gt;&gt;&gt; print FooChild&lt;class &#x27;__main__.FooChild&#x27;&gt;&gt;&gt;&gt; print FooChild.bar # bar属性是由Foo继承而来True 最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。 1234567891011121314151617181920212223&gt;&gt;&gt; def echo_bar(self):… print self.bar…&gt;&gt;&gt; FooChild = type(&#x27;FooChild&#x27;, (Foo,), &#123;&#x27;echo_bar&#x27;: echo_bar&#125;)&gt;&gt;&gt; hasattr(Foo, &#x27;echo_bar&#x27;)False&gt;&gt;&gt; hasattr(FooChild, &#x27;echo_bar&#x27;)True&gt;&gt;&gt; my_foo = FooChild()&gt;&gt;&gt; my_foo.echo_bar()True&gt;&gt;&gt; def echo_bar(self):… print self.bar…&gt;&gt;&gt; FooChild = type(&#x27;FooChild&#x27;, (Foo,), &#123;&#x27;echo_bar&#x27;: echo_bar&#125;)&gt;&gt;&gt; hasattr(Foo, &#x27;echo_bar&#x27;)False&gt;&gt;&gt; hasattr(FooChild, &#x27;echo_bar&#x27;)True&gt;&gt;&gt; my_foo = FooChild()&gt;&gt;&gt; my_foo.echo_bar()True 你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。 到底什么是元类（终于到主题了） 元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为： 12345MyClass = MetaClass()MyObject = MyClass()MyClass = MetaClass()MyObject = MyClass() 你已经看到了type可以让你像这样做： 123MyClass = type(&#x27;MyClass&#x27;, (), &#123;&#125;)MyClass = type(&#x27;MyClass&#x27;, (), &#123;&#125;) 这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。 123456789101112131415161718192021222324252627&gt;&gt;&gt; age = 35&gt;&gt;&gt; age.__class__&lt;type &#x27;int&#x27;&gt;&gt;&gt;&gt; name = &#x27;bob&#x27;&gt;&gt;&gt; name.__class__&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; def foo(): pass&gt;&gt;&gt;foo.__class__&lt;type &#x27;function&#x27;&gt;&gt;&gt;&gt; class Bar(object): pass&gt;&gt;&gt; b = Bar()&gt;&gt;&gt; b.__class__&lt;class &#x27;__main__.Bar&#x27;&gt;&gt;&gt;&gt; age = 35&gt;&gt;&gt; age.__class__&lt;type &#x27;int&#x27;&gt;&gt;&gt;&gt; name = &#x27;bob&#x27;&gt;&gt;&gt; name.__class__&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; def foo(): pass&gt;&gt;&gt;foo.__class__&lt;type &#x27;function&#x27;&gt;&gt;&gt;&gt; class Bar(object): pass&gt;&gt;&gt; b = Bar()&gt;&gt;&gt; b.__class__&lt;class &#x27;__main__.Bar&#x27;&gt; 现在，对于任何一个__class__的__class__属性又是什么呢？ 1234567891011121314151617&gt;&gt;&gt; a.__class__.__class__&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; age.__class__.__class__&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; foo.__class__.__class__&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; b.__class__.__class__&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; a.__class__.__class__&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; age.__class__.__class__&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; foo.__class__.__class__&lt;type &#x27;type&#x27;&gt;&gt;&gt;&gt; b.__class__.__class__&lt;type &#x27;type&#x27;&gt; 因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。 __metaclass__属性 你可以在写一个类的时候为其添加__metaclass__属性。 1234567class Foo(object): __metaclass__ = something…[…]class Foo(object): __metaclass__ = something…[…] 如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 : 12345class Foo(Bar): passclass Foo(Bar): pass Python做了如下的操作： Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。 现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。 自定义元类 元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。 幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。 1234567891011# 元类会自动将你通常传给‘type’的参数作为自己的参数传入def upper_attr(future_class_name, future_class_parents, future_class_attr): &#x27;&#x27;&#x27;返回一个类对象，将属性都转为大写形式&#x27;&#x27;&#x27; # 选择所有不以&#x27;__&#x27;开头的属性 attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(&#x27;__&#x27;))# 元类会自动将你通常传给‘type’的参数作为自己的参数传入def upper_attr(future_class_name, future_class_parents, future_class_attr): &#x27;&#x27;&#x27;返回一个类对象，将属性都转为大写形式&#x27;&#x27;&#x27; # 选择所有不以&#x27;__&#x27;开头的属性 attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(&#x27;__&#x27;)) 1234567891011121314151617181920212223 # 将它们转为大写形式 uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 通过&#x27;type&#x27;来做类对象的创建 return type(future_class_name, future_class_parents, uppercase_attr)__metaclass__ = upper_attr # 这会作用到这个模块中的所有类class Foo(object): # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中 bar = &#x27;bip&#x27; # 将它们转为大写形式 uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 通过&#x27;type&#x27;来做类对象的创建 return type(future_class_name, future_class_parents, uppercase_attr) __metaclass__ = upper_attr # 这会作用到这个模块中的所有类 class Foo(object): # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中 bar = &#x27;bip&#x27; 123456789101112131415161718print hasattr(Foo, &#x27;bar&#x27;)# 输出: Falseprint hasattr(Foo, &#x27;BAR&#x27;)# 输出:Truef = Foo()print f.BAR# 输出:&#x27;bip&#x27;print hasattr(Foo, &#x27;bar&#x27;)# 输出: Falseprint hasattr(Foo, &#x27;BAR&#x27;)# 输出:True f = Foo()print f.BAR# 输出:&#x27;bip&#x27; 现在让我们再做一次，这一次用一个真正的class来当做元类。 1234567891011121314151617181920212223242526272829# 请记住，&#x27;type&#x27;实际上是一个类，就像&#x27;str&#x27;和&#x27;int&#x27;一样# 所以，你可以从type继承class UpperAttrMetaClass(type): # __new__ 是在__init__之前被调用的特殊方法 # __new__是用来创建对象并返回之的方法 # 而__init__只是用来将传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(&#x27;__&#x27;)) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return type(future_class_name, future_class_parents, uppercase_attr)# 请记住，&#x27;type&#x27;实际上是一个类，就像&#x27;str&#x27;和&#x27;int&#x27;一样# 所以，你可以从type继承class UpperAttrMetaClass(type): # __new__ 是在__init__之前被调用的特殊方法 # __new__是用来创建对象并返回之的方法 # 而__init__只是用来将传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(&#x27;__&#x27;)) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return type(future_class_name, future_class_parents, uppercase_attr) 但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理: 1234567891011121314151617class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(&#x27;__&#x27;)) uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 复用type.__new__方法 # 这就是基本的OOP编程，没什么魔法 return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith(&#x27;__&#x27;)) uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 复用type.__new__方法 # 这就是基本的OOP编程，没什么魔法 return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr) 你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的： 1234567891011class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith(&#x27;__&#x27;) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return type.__new__(cls, name, bases, uppercase_attr)class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith(&#x27;__&#x27;) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return type.__new__(cls, name, bases, uppercase_attr) 如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承） 1234567891011class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith(&#x27;__&#x27;)) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith(&#x27;__&#x27;)) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr) 就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的： 拦截类的创建 修改类 返回修改之后的类 为什么要用metaclass类而不是函数? 由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因： 1） 意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。 2） 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。 3） 你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。 4） 你可以使用__new__, __init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。 5） 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！ 究竟为什么要使用元类？ 现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它： “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters 元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义： 12345678class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField()class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() 但是如果你像这样做的话： 12345guy = Person(name=&#x27;bob&#x27;, age=&#x27;35&#x27;)print guy.ageguy = Person(name=&#x27;bob&#x27;, age=&#x27;35&#x27;)print guy.age 这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。 结语 首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。 12345678&gt;&gt;&gt;class Foo(object): pass&gt;&gt;&gt; id(Foo)142630324&gt;&gt;&gt;class Foo(object): pass&gt;&gt;&gt; id(Foo)142630324 Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类： 1） Monkey patching class decorators 当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D","raw":"---\ntitle: 深入理解Python中的元类(metaclass)\ntoc: true\ndate: 2018-12-04 01:47:47\ntags: [metaclass,python]\ncategories: [技术]\ndescription:\n---\n\n转载自[深入理解Python中的元类](http://blog.jobbole.com/21351/)\n\n<!--more-->\n译注：这是一篇在Stack overflow上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复（提示：非常长）\n\n\n\n# 类也是对象\n\n在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：\n\n```python\n>>> class ObjectCreator(object):\n…       pass\n…\n>>> my_object = ObjectCreator()\n>>> print my_object\n<__main__.ObjectCreator object at 0x8974f2c>\n\n>>> class ObjectCreator(object):\n…       pass\n…\n>>> my_object = ObjectCreator()\n>>> print my_object\n<__main__.ObjectCreator object at 0x8974f2c>\n```\n\n但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段：\n\n```python\n\n>>> class ObjectCreator(object):\n…       pass\n…\n\n>>> class ObjectCreator(object):\n…       pass\n…\n```\n\n将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：\n\n1)   你可以将它赋值给一个变量\n\n2)   你可以拷贝它\n\n3)   你可以为它增加属性\n\n4)   你可以将它作为函数参数进行传递\n\n下面是示例：\n\n```Python\n\n>>> print ObjectCreator     # 你可以打印一个类，因为它其实也是一个对象\n<class '__main__.ObjectCreator'>\n>>> def echo(o):\n…       print o\n…\n>>> echo(ObjectCreator)                 # 你可以将类做为参数传给函数\n<class '__main__.ObjectCreator'>\n>>> print hasattr(ObjectCreator, 'new_attribute')\nFasle\n>>> ObjectCreator.new_attribute = 'foo' #  你可以为类增加属性\n>>> print hasattr(ObjectCreator, 'new_attribute')\nTrue\n>>> print ObjectCreator.new_attribute\nfoo\n>>> ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量\n>>> print ObjectCreatorMirror()\n<__main__.ObjectCreator object at 0x8997b4c>\n```\n\n```python\n>>> print ObjectCreator     # 你可以打印一个类，因为它其实也是一个对象\n<class '__main__.ObjectCreator'>\n>>> def echo(o):\n…       print o\n…\n>>> echo(ObjectCreator)                 # 你可以将类做为参数传给函数\n<class '__main__.ObjectCreator'>\n>>> print hasattr(ObjectCreator, 'new_attribute')\nFasle\n>>> ObjectCreator.new_attribute = 'foo' #  你可以为类增加属性\n>>> print hasattr(ObjectCreator, 'new_attribute')\nTrue\n>>> print ObjectCreator.new_attribute\nfoo\n>>> ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量\n>>> print ObjectCreatorMirror()\n<__main__.ObjectCreator object at 0x8997b4c>\n```\n\n动态地创建类\n\n因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。\n\n```Python\n\n>>> def choose_class(name):\n…       if name == 'foo':\n…           class Foo(object):\n…               pass\n…           return Foo     # 返回的是类，不是类的实例\n…       else:\n…           class Bar(object):\n…               pass\n…           return Bar\n…\n>>> MyClass = choose_class('foo')\n>>> print MyClass              # 函数返回的是类，不是类的实例\n<class '__main__'.Foo>\n>>> print MyClass()            # 你可以通过这个类创建类实例，也就是对象\n<__main__.Foo object at 0x89c6d4c>\n```\n\n```python\n>>> def choose_class(name):\n…       if name == 'foo':\n…           class Foo(object):\n…               pass\n…           return Foo     # 返回的是类，不是类的实例\n…       else:\n…           class Bar(object):\n…               pass\n…           return Bar\n…\n>>> MyClass = choose_class('foo')\n>>> print MyClass              # 函数返回的是类，不是类的实例\n<class '__main__'.Foo>\n>>> print MyClass()            # 你可以通过这个类创建类实例，也就是对象\n<__main__.Foo object at 0x89c6d4c>\n```\n\n但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：\n\n```Python\n\n>>> print type(1)\n<type 'int'>\n>>> print type(\"1\")\n<type 'str'>\n>>> print type(ObjectCreator)\n<type 'type'>\n>>> print type(ObjectCreator())\n<class '__main__.ObjectCreator'>\n```\n\n```python\n>>> print type(1)\n<type 'int'>\n>>> print type(\"1\")\n<type 'str'>\n>>> print type(ObjectCreator)\n<type 'type'>\n>>> print type(ObjectCreator())\n<class '__main__.ObjectCreator'>\n```\n\n这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）\n\ntype可以像这样工作：\n\n```Python\n\ntype(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)\n````\n\ntype(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)\n比如下面的代码：\n\n```Python\n\n>>> class MyShinyClass(object):\n…       pass\n\n>>> class MyShinyClass(object):\n…       pass\n```\n可以手动像这样创建：\n\n```Python\n\n>>> MyShinyClass = type('MyShinyClass', (), {})  # 返回一个类对象\n>>> print MyShinyClass\n<class '__main__.MyShinyClass'>\n>>> print MyShinyClass()  #  创建一个该类的实例\n<__main__.MyShinyClass object at 0x8997cec>\n```\n```python\n>>> MyShinyClass = type('MyShinyClass', (), {})  # 返回一个类对象\n>>> print MyShinyClass\n<class '__main__.MyShinyClass'>\n>>> print MyShinyClass()  #  创建一个该类的实例\n<__main__.MyShinyClass object at 0x8997cec>\n```\n你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。\n\ntype 接受一个字典来为类定义属性，因此\n\n```Python\n\n>>> class Foo(object):\n…       bar = True\n>>> class Foo(object):\n…       bar = True\n```\n可以翻译为：\n\n```Python\n\n>>> Foo = type('Foo', (), {'bar':True})\n>>> Foo = type('Foo', (), {'bar':True})\n```\n并且可以将Foo当成一个普通的类一样使用：\n\n```Python\n>>> print Foo\n<class '__main__.Foo'>\n>>> print Foo.bar\nTrue\n>>> f = Foo()\n>>> print f\n<__main__.Foo object at 0x8a9b84c>\n>>> print f.bar\nTrue\n>>> print Foo\n<class '__main__.Foo'>\n>>> print Foo.bar\nTrue\n>>> f = Foo()\n>>> print f\n<__main__.Foo object at 0x8a9b84c>\n>>> print f.bar\nTrue\n```\n当然，你可以向这个类继承，所以，如下的代码：\n\n```Python\n\n>>> class FooChild(Foo):\n…       pass\n>>> class FooChild(Foo):\n…       pass\n```\n就可以写成：\n\n```Python\n\n>>> FooChild = type('FooChild', (Foo,),{})\n>>> print FooChild\n<class '__main__.FooChild'>\n>>> print FooChild.bar   # bar属性是由Foo继承而来\nTrue\n>>> FooChild = type('FooChild', (Foo,),{})\n>>> print FooChild\n<class '__main__.FooChild'>\n>>> print FooChild.bar   # bar属性是由Foo继承而来\nTrue\n```\n最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。\n\n```Python\n\n>>> def echo_bar(self):\n…       print self.bar\n…\n>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n>>> hasattr(Foo, 'echo_bar')\nFalse\n>>> hasattr(FooChild, 'echo_bar')\nTrue\n>>> my_foo = FooChild()\n>>> my_foo.echo_bar()\nTrue\n>>> def echo_bar(self):\n…       print self.bar\n…\n>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n>>> hasattr(Foo, 'echo_bar')\nFalse\n>>> hasattr(FooChild, 'echo_bar')\nTrue\n>>> my_foo = FooChild()\n>>> my_foo.echo_bar()\nTrue\n```\n\n你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。\n\n \n\n到底什么是元类（终于到主题了）\n\n元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为：\n\n```Python\n\nMyClass = MetaClass()\nMyObject = MyClass()\nMyClass = MetaClass()\nMyObject = MyClass()\n```\n你已经看到了type可以让你像这样做：\n\n```Python\n\nMyClass = type('MyClass', (), {})\nMyClass = type('MyClass', (), {})\n```\n这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。\n\n```Python\n\n>>> age = 35\n>>> age.__class__\n<type 'int'>\n>>> name = 'bob'\n>>> name.__class__\n<type 'str'>\n>>> def foo(): pass\n>>>foo.__class__\n<type 'function'>\n>>> class Bar(object): pass\n>>> b = Bar()\n>>> b.__class__\n<class '__main__.Bar'>\n>>> age = 35\n>>> age.__class__\n<type 'int'>\n>>> name = 'bob'\n>>> name.__class__\n<type 'str'>\n>>> def foo(): pass\n>>>foo.__class__\n<type 'function'>\n>>> class Bar(object): pass\n>>> b = Bar()\n>>> b.__class__\n<class '__main__.Bar'>\n```\n现在，对于任何一个__class__的__class__属性又是什么呢？\n\n```Python\n\n>>> a.__class__.__class__\n<type 'type'>\n>>> age.__class__.__class__\n<type 'type'>\n>>> foo.__class__.__class__\n<type 'type'>\n>>> b.__class__.__class__\n<type 'type'>\n>>> a.__class__.__class__\n<type 'type'>\n>>> age.__class__.__class__\n<type 'type'>\n>>> foo.__class__.__class__\n<type 'type'>\n>>> b.__class__.__class__\n<type 'type'>\n```\n因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。\n\n \n\n__metaclass__属性\n\n你可以在写一个类的时候为其添加__metaclass__属性。\n\n```Python\n\nclass Foo(object):\n\t__metaclass__ = something…\n[…]\nclass Foo(object):\n\t__metaclass__ = something…\n[…]\n```\n如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :\n\n```Python\n\nclass Foo(Bar):\n    pass\nclass Foo(Bar):\n    pass\n```\nPython做了如下的操作：\n\nFoo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。\n\n现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。\n\n \n\n自定义元类\n\n元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。\n\n幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。\n\n```Python\n\n# 元类会自动将你通常传给‘type’的参数作为自己的参数传入\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n    '''返回一个类对象，将属性都转为大写形式'''\n    #  选择所有不以'__'开头的属性\n    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n# 元类会自动将你通常传给‘type’的参数作为自己的参数传入\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n    '''返回一个类对象，将属性都转为大写形式'''\n    #  选择所有不以'__'开头的属性\n    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n```\n```Python\n\n    # 将它们转为大写形式\n    uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n    # 通过'type'来做类对象的创建\n    return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr  #  这会作用到这个模块中的所有类\n\nclass Foo(object):\n    # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中\n    bar = 'bip'\n    # 将它们转为大写形式\n    uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n \n    # 通过'type'来做类对象的创建\n    return type(future_class_name, future_class_parents, uppercase_attr)\n \n__metaclass__ = upper_attr  #  这会作用到这个模块中的所有类\n \nclass Foo(object):\n    # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中\n    bar = 'bip'\n```\n\n```Python\n\nprint hasattr(Foo, 'bar')\n# 输出: False\nprint hasattr(Foo, 'BAR')\n# 输出:True\n\nf = Foo()\nprint f.BAR\n# 输出:'bip'\n\nprint hasattr(Foo, 'bar')\n# 输出: False\nprint hasattr(Foo, 'BAR')\n# 输出:True\n \nf = Foo()\nprint f.BAR\n# 输出:'bip'\n```\n现在让我们再做一次，这一次用一个真正的class来当做元类。\n\n```Python\n\n# 请记住，'type'实际上是一个类，就像'str'和'int'一样\n# 所以，你可以从type继承\nclass UpperAttrMetaClass(type):\n    # __new__ 是在__init__之前被调用的特殊方法\n    # __new__是用来创建对象并返回之的方法\n    # 而__init__只是用来将传入的参数初始化给对象\n    # 你很少用到__new__，除非你希望能够控制对象的创建\n    # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__\n    # 如果你希望的话，你也可以在__init__中做些事情\n    # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用\n    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n        return type(future_class_name, future_class_parents, uppercase_attr)\n# 请记住，'type'实际上是一个类，就像'str'和'int'一样\n# 所以，你可以从type继承\nclass UpperAttrMetaClass(type):\n    # __new__ 是在__init__之前被调用的特殊方法\n    # __new__是用来创建对象并返回之的方法\n    # 而__init__只是用来将传入的参数初始化给对象\n    # 你很少用到__new__，除非你希望能够控制对象的创建\n    # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__\n    # 如果你希望的话，你也可以在__init__中做些事情\n    # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用\n    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n        return type(future_class_name, future_class_parents, uppercase_attr)\n```\n但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理:\n\n```Python\n\nclass UpperAttrMetaclass(type):\n    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n        # 复用type.__new__方法\n        # 这就是基本的OOP编程，没什么魔法\n        return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)\nclass UpperAttrMetaclass(type):\n    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n \n        # 复用type.__new__方法\n        # 这就是基本的OOP编程，没什么魔法\n        return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)\n```\n你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：\n\n```Python\n\nclass UpperAttrMetaclass(type):\n    def __new__(cls, name, bases, dct):\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__')\n        uppercase_attr  = dict((name.upper(), value) for name, value in attrs)\n        return type.__new__(cls, name, bases, uppercase_attr)\nclass UpperAttrMetaclass(type):\n    def __new__(cls, name, bases, dct):\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__')\n        uppercase_attr  = dict((name.upper(), value) for name, value in attrs)\n        return type.__new__(cls, name, bases, uppercase_attr)\n```\n如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）\n\n```Python\n\nclass UpperAttrMetaclass(type):\n    def __new__(cls, name, bases, dct):\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)\nclass UpperAttrMetaclass(type):\n    def __new__(cls, name, bases, dct):\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)\n```\n就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：\n\n1)   拦截类的创建\n\n2)   修改类\n\n3)   返回修改之后的类\n\n \n\n为什么要用metaclass类而不是函数?\n\n由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因：\n\n1）  意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。\n\n2） 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。\n\n3）  你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。\n\n4） 你可以使用__new__, __init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。\n\n5） 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！\n\n \n\n究竟为什么要使用元类？\n\n现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：\n\n“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters\n\n元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义：\n\n```Python\n\nclass Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n\nclass Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n```\n但是如果你像这样做的话：\n\n```Python\n\nguy  = Person(name='bob', age='35')\nprint guy.age\nguy  = Person(name='bob', age='35')\nprint guy.age\n```\n这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。\n\n \n\n结语\n\n首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。\n\n```Python\n\n>>>class Foo(object): pass\n>>> id(Foo)\n142630324\n\n>>>class Foo(object): pass\n>>> id(Foo)\n142630324\n```\nPython中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：\n\n1） Monkey patching\n\n2)  class decorators\n\n当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D","content":"<p>转载自<a href=\"http://blog.jobbole.com/21351/\">深入理解Python中的元类</a></p>\n<span id=\"more\"></span>\n<p>译注：这是一篇在Stack overflow上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复（提示：非常长）</p>\n<h1 id=\"类也是对象\"><a href=\"#类也是对象\" class=\"headerlink\" title=\"类也是对象\"></a>类也是对象</h1><p>在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectCreator</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> my_object</span><br><span class=\"line\">&lt;__main__.ObjectCreator <span class=\"built_in\">object</span> at <span class=\"number\">0x8974f2c</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectCreator</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> my_object</span><br><span class=\"line\">&lt;__main__.ObjectCreator <span class=\"built_in\">object</span> at <span class=\"number\">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectCreator</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br><span class=\"line\">…</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">ObjectCreator</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br><span class=\"line\">…</span><br></pre></td></tr></table></figure>\n\n<p>将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：</p>\n<ol>\n<li><p>你可以将它赋值给一个变量</p>\n</li>\n<li><p>你可以拷贝它</p>\n</li>\n<li><p>你可以为它增加属性</p>\n</li>\n<li><p>你可以将它作为函数参数进行传递</p>\n</li>\n</ol>\n<p>下面是示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ObjectCreator     <span class=\"comment\"># 你可以打印一个类，因为它其实也是一个对象</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">echo</span>(<span class=\"params\">o</span>):</span><br><span class=\"line\">…       <span class=\"built_in\">print</span> o</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>echo(ObjectCreator)                 <span class=\"comment\"># 你可以将类做为参数传给函数</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(ObjectCreator, <span class=\"string\">&#x27;new_attribute&#x27;</span>)</span><br><span class=\"line\">Fasle</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class=\"string\">&#x27;foo&#x27;</span> <span class=\"comment\">#  你可以为类增加属性</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(ObjectCreator, <span class=\"string\">&#x27;new_attribute&#x27;</span>)</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ObjectCreator.new_attribute</span><br><span class=\"line\">foo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class=\"comment\"># 你可以将类赋值给一个变量</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ObjectCreatorMirror()</span><br><span class=\"line\">&lt;__main__.ObjectCreator <span class=\"built_in\">object</span> at <span class=\"number\">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ObjectCreator     <span class=\"comment\"># 你可以打印一个类，因为它其实也是一个对象</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">echo</span>(<span class=\"params\">o</span>):</span><br><span class=\"line\">…       <span class=\"built_in\">print</span> o</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>echo(ObjectCreator)                 <span class=\"comment\"># 你可以将类做为参数传给函数</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(ObjectCreator, <span class=\"string\">&#x27;new_attribute&#x27;</span>)</span><br><span class=\"line\">Fasle</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class=\"string\">&#x27;foo&#x27;</span> <span class=\"comment\">#  你可以为类增加属性</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(ObjectCreator, <span class=\"string\">&#x27;new_attribute&#x27;</span>)</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ObjectCreator.new_attribute</span><br><span class=\"line\">foo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class=\"comment\"># 你可以将类赋值给一个变量</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> ObjectCreatorMirror()</span><br><span class=\"line\">&lt;__main__.ObjectCreator <span class=\"built_in\">object</span> at <span class=\"number\">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>动态地创建类</p>\n<p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">choose_class</span>(<span class=\"params\">name</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;foo&#x27;</span>:</span><br><span class=\"line\">…           <span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…               <span class=\"keyword\">pass</span></span><br><span class=\"line\">…           <span class=\"keyword\">return</span> Foo     <span class=\"comment\"># 返回的是类，不是类的实例</span></span><br><span class=\"line\">…       <span class=\"keyword\">else</span>:</span><br><span class=\"line\">…           <span class=\"keyword\">class</span> <span class=\"title class_\">Bar</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…               <span class=\"keyword\">pass</span></span><br><span class=\"line\">…           <span class=\"keyword\">return</span> Bar</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyClass = choose_class(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyClass              <span class=\"comment\"># 函数返回的是类，不是类的实例</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__&#x27;</span>.Foo&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyClass()            <span class=\"comment\"># 你可以通过这个类创建类实例，也就是对象</span></span><br><span class=\"line\">&lt;__main__.Foo <span class=\"built_in\">object</span> at <span class=\"number\">0x89c6d4c</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">choose_class</span>(<span class=\"params\">name</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;foo&#x27;</span>:</span><br><span class=\"line\">…           <span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…               <span class=\"keyword\">pass</span></span><br><span class=\"line\">…           <span class=\"keyword\">return</span> Foo     <span class=\"comment\"># 返回的是类，不是类的实例</span></span><br><span class=\"line\">…       <span class=\"keyword\">else</span>:</span><br><span class=\"line\">…           <span class=\"keyword\">class</span> <span class=\"title class_\">Bar</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…               <span class=\"keyword\">pass</span></span><br><span class=\"line\">…           <span class=\"keyword\">return</span> Bar</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyClass = choose_class(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyClass              <span class=\"comment\"># 函数返回的是类，不是类的实例</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__&#x27;</span>.Foo&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyClass()            <span class=\"comment\"># 你可以通过这个类创建类实例，也就是对象</span></span><br><span class=\"line\">&lt;__main__.Foo <span class=\"built_in\">object</span> at <span class=\"number\">0x89c6d4c</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;int&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;str&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(ObjectCreator)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(ObjectCreator())</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;int&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;str&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(ObjectCreator)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> <span class=\"built_in\">type</span>(ObjectCreator())</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）</p>\n<p>type可以像这样工作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">type</span>(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</span><br><span class=\"line\">````</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">type</span>(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</span><br><span class=\"line\">比如下面的代码：</span><br><span class=\"line\"></span><br><span class=\"line\">```Python</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">MyShinyClass</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">MyShinyClass</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>可以手动像这样创建：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyShinyClass = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;MyShinyClass&#x27;</span>, (), &#123;&#125;)  <span class=\"comment\"># 返回一个类对象</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyShinyClass</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.MyShinyClass&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyShinyClass()  <span class=\"comment\">#  创建一个该类的实例</span></span><br><span class=\"line\">&lt;__main__.MyShinyClass <span class=\"built_in\">object</span> at <span class=\"number\">0x8997cec</span>&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyShinyClass = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;MyShinyClass&#x27;</span>, (), &#123;&#125;)  <span class=\"comment\"># 返回一个类对象</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyShinyClass</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.MyShinyClass&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> MyShinyClass()  <span class=\"comment\">#  创建一个该类的实例</span></span><br><span class=\"line\">&lt;__main__.MyShinyClass <span class=\"built_in\">object</span> at <span class=\"number\">0x8997cec</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。</p>\n<p>type 接受一个字典来为类定义属性，因此</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       bar = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">…       bar = <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>可以翻译为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Foo = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;Foo&#x27;</span>, (), &#123;<span class=\"string\">&#x27;bar&#x27;</span>:<span class=\"literal\">True</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Foo = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;Foo&#x27;</span>, (), &#123;<span class=\"string\">&#x27;bar&#x27;</span>:<span class=\"literal\">True</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>并且可以将Foo当成一个普通的类一样使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> Foo</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.Foo&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> Foo.bar</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = Foo()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> f</span><br><span class=\"line\">&lt;__main__.Foo <span class=\"built_in\">object</span> at <span class=\"number\">0x8a9b84c</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> f.bar</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> Foo</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.Foo&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> Foo.bar</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = Foo()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> f</span><br><span class=\"line\">&lt;__main__.Foo <span class=\"built_in\">object</span> at <span class=\"number\">0x8a9b84c</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> f.bar</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>当然，你可以向这个类继承，所以，如下的代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">FooChild</span>(<span class=\"title class_ inherited__\">Foo</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">FooChild</span>(<span class=\"title class_ inherited__\">Foo</span>):</span><br><span class=\"line\">…       <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>就可以写成：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;FooChild&#x27;</span>, (Foo,),&#123;&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> FooChild</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.FooChild&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> FooChild.bar   <span class=\"comment\"># bar属性是由Foo继承而来</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;FooChild&#x27;</span>, (Foo,),&#123;&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> FooChild</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.FooChild&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> FooChild.bar   <span class=\"comment\"># bar属性是由Foo继承而来</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">echo_bar</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">…       <span class=\"built_in\">print</span> self.bar</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;FooChild&#x27;</span>, (Foo,), &#123;<span class=\"string\">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">hasattr</span>(Foo, <span class=\"string\">&#x27;echo_bar&#x27;</span>)</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">hasattr</span>(FooChild, <span class=\"string\">&#x27;echo_bar&#x27;</span>)</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">echo_bar</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">…       <span class=\"built_in\">print</span> self.bar</span><br><span class=\"line\">…</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;FooChild&#x27;</span>, (Foo,), &#123;<span class=\"string\">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">hasattr</span>(Foo, <span class=\"string\">&#x27;echo_bar&#x27;</span>)</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">hasattr</span>(FooChild, <span class=\"string\">&#x27;echo_bar&#x27;</span>)</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<p>你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。</p>\n<p>到底什么是元类（终于到主题了）</p>\n<p>元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">MyClass = MetaClass()</span><br><span class=\"line\">MyObject = MyClass()</span><br><span class=\"line\">MyClass = MetaClass()</span><br><span class=\"line\">MyObject = MyClass()</span><br></pre></td></tr></table></figure>\n<p>你已经看到了type可以让你像这样做：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">MyClass = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;MyClass&#x27;</span>, (), &#123;&#125;)</span><br><span class=\"line\">MyClass = <span class=\"built_in\">type</span>(<span class=\"string\">&#x27;MyClass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age = <span class=\"number\">35</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;int&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name = <span class=\"string\">&#x27;bob&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;str&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">foo</span>(): <span class=\"keyword\">pass</span></span><br><span class=\"line\">&gt;&gt;&gt;foo.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;function&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">Bar</span>(<span class=\"title class_ inherited__\">object</span>): <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = Bar()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.Bar&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age = <span class=\"number\">35</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;int&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name = <span class=\"string\">&#x27;bob&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;str&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">foo</span>(): <span class=\"keyword\">pass</span></span><br><span class=\"line\">&gt;&gt;&gt;foo.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;function&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">class</span> <span class=\"title class_\">Bar</span>(<span class=\"title class_ inherited__\">object</span>): <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = Bar()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;__main__.Bar&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>现在，对于任何一个__class__的__class__属性又是什么呢？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。</p>\n<p>__metaclass__属性</p>\n<p>你可以在写一个类的时候为其添加__metaclass__属性。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">\t__metaclass__ = something…</span><br><span class=\"line\">[…]</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">\t__metaclass__ = something…</span><br><span class=\"line\">[…]</span><br></pre></td></tr></table></figure>\n<p>如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">Bar</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">Bar</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>Python做了如下的操作：</p>\n<p>Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。</p>\n<p>现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。</p>\n<p>自定义元类</p>\n<p>元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。</p>\n<p>幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 元类会自动将你通常传给‘type’的参数作为自己的参数传入</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upper_attr</span>(<span class=\"params\">future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;返回一个类对象，将属性都转为大写形式&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#  选择所有不以&#x27;__&#x27;开头的属性</span></span><br><span class=\"line\">    attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> future_class_attr.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 元类会自动将你通常传给‘type’的参数作为自己的参数传入</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upper_attr</span>(<span class=\"params\">future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;返回一个类对象，将属性都转为大写形式&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#  选择所有不以&#x27;__&#x27;开头的属性</span></span><br><span class=\"line\">    attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> future_class_attr.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 将它们转为大写形式</span></span><br><span class=\"line\">    uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 通过&#x27;type&#x27;来做类对象的创建</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br><span class=\"line\"></span><br><span class=\"line\">__metaclass__ = upper_attr  <span class=\"comment\">#  这会作用到这个模块中的所有类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中</span></span><br><span class=\"line\">    bar = <span class=\"string\">&#x27;bip&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\"># 将它们转为大写形式</span></span><br><span class=\"line\">    uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># 通过&#x27;type&#x27;来做类对象的创建</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br><span class=\"line\"> </span><br><span class=\"line\">__metaclass__ = upper_attr  <span class=\"comment\">#  这会作用到这个模块中的所有类</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中</span></span><br><span class=\"line\">    bar = <span class=\"string\">&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(Foo, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 输出: False</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(Foo, <span class=\"string\">&#x27;BAR&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 输出:True</span></span><br><span class=\"line\"></span><br><span class=\"line\">f = Foo()</span><br><span class=\"line\"><span class=\"built_in\">print</span> f.BAR</span><br><span class=\"line\"><span class=\"comment\"># 输出:&#x27;bip&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(Foo, <span class=\"string\">&#x27;bar&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 输出: False</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">hasattr</span>(Foo, <span class=\"string\">&#x27;BAR&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 输出:True</span></span><br><span class=\"line\"> </span><br><span class=\"line\">f = Foo()</span><br><span class=\"line\"><span class=\"built_in\">print</span> f.BAR</span><br><span class=\"line\"><span class=\"comment\"># 输出:&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>现在让我们再做一次，这一次用一个真正的class来当做元类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 请记住，&#x27;type&#x27;实际上是一个类，就像&#x27;str&#x27;和&#x27;int&#x27;一样</span></span><br><span class=\"line\"><span class=\"comment\"># 所以，你可以从type继承</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaClass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"comment\"># __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class=\"line\">    <span class=\"comment\"># __new__是用来创建对象并返回之的方法</span></span><br><span class=\"line\">    <span class=\"comment\"># 而__init__只是用来将传入的参数初始化给对象</span></span><br><span class=\"line\">    <span class=\"comment\"># 你很少用到__new__，除非你希望能够控制对象的创建</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class=\"line\">    <span class=\"comment\"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> future_class_attr.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br><span class=\"line\">        uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br><span class=\"line\"><span class=\"comment\"># 请记住，&#x27;type&#x27;实际上是一个类，就像&#x27;str&#x27;和&#x27;int&#x27;一样</span></span><br><span class=\"line\"><span class=\"comment\"># 所以，你可以从type继承</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaClass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"comment\"># __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class=\"line\">    <span class=\"comment\"># __new__是用来创建对象并返回之的方法</span></span><br><span class=\"line\">    <span class=\"comment\"># 而__init__只是用来将传入的参数初始化给对象</span></span><br><span class=\"line\">    <span class=\"comment\"># 你很少用到__new__，除非你希望能够控制对象的创建</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class=\"line\">    <span class=\"comment\"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> future_class_attr.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br><span class=\"line\">        uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaclass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> future_class_attr.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br><span class=\"line\">        uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 复用type.__new__方法</span></span><br><span class=\"line\">        <span class=\"comment\"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaclass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">upperattr_metaclass, future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> future_class_attr.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br><span class=\"line\">        uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># 复用type.__new__方法</span></span><br><span class=\"line\">        <span class=\"comment\"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaclass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, name, bases, dct</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> dct.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>)</span><br><span class=\"line\">        uppercase_attr  = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>.__new__(cls, name, bases, uppercase_attr)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaclass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, name, bases, dct</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> dct.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>)</span><br><span class=\"line\">        uppercase_attr  = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">type</span>.__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaclass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, name, bases, dct</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> dct.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br><span class=\"line\">        uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UpperAttrMetaclass</span>(<span class=\"title class_ inherited__\">type</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__new__</span>(<span class=\"params\">cls, name, bases, dct</span>):</span><br><span class=\"line\">        attrs = ((name, value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> dct.items() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">&#x27;__&#x27;</span>))</span><br><span class=\"line\">        uppercase_attr = <span class=\"built_in\">dict</span>((name.upper(), value) <span class=\"keyword\">for</span> name, value <span class=\"keyword\">in</span> attrs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：</p>\n<ol>\n<li><p>拦截类的创建</p>\n</li>\n<li><p>修改类</p>\n</li>\n<li><p>返回修改之后的类</p>\n</li>\n</ol>\n<p>为什么要用metaclass类而不是函数?</p>\n<p>由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因：</p>\n<p>1）  意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。</p>\n<p>2） 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。</p>\n<p>3）  你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。</p>\n<p>4） 你可以使用__new__, __init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。</p>\n<p>5） 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！</p>\n<p>究竟为什么要使用元类？</p>\n<p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：</p>\n<p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters</p>\n<p>元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>(models.Model):</span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">30</span>)</span><br><span class=\"line\">    age = models.IntegerField()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>(models.Model):</span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">30</span>)</span><br><span class=\"line\">    age = models.IntegerField()</span><br></pre></td></tr></table></figure>\n<p>但是如果你像这样做的话：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">guy  = Person(name=<span class=\"string\">&#x27;bob&#x27;</span>, age=<span class=\"string\">&#x27;35&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> guy.age</span><br><span class=\"line\">guy  = Person(name=<span class=\"string\">&#x27;bob&#x27;</span>, age=<span class=\"string\">&#x27;35&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> guy.age</span><br></pre></td></tr></table></figure>\n<p>这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。</p>\n<p>结语</p>\n<p>首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>): <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(Foo)</span><br><span class=\"line\"><span class=\"number\">142630324</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>(<span class=\"title class_ inherited__\">object</span>): <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(Foo)</span><br><span class=\"line\"><span class=\"number\">142630324</span></span><br></pre></td></tr></table></figure>\n<p>Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：</p>\n<p>1） Monkey patching</p>\n<ol start=\"2\">\n<li>class decorators</li>\n</ol>\n<p>当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D</p>\n","slug":"深入理解Python中的元类-metaclass","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB-metaclass/","excerpt":"转载自深入理解Python中的元类","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"metaclass","slug":"metaclass","permalink":"http://vwin.github.io/tags/metaclass/"}]},{"title":"重启php7-fpm和php5-fpm方法","date":"2018-12-02T20:53:44.000Z","path":"2018/12/02/重启php7-fpm和php5-fpm方法/","text":"各个平台上如何重启php7-fpm和php5-fpm PHP-FPM是一款简单好用的PHP FastCGI进程管理工具。它可以和Apache、Nginx或其他服务器一起构建完整的PHP环境。接下来我们看看在更改了php.ini 文件后，如何stop、restart或者reload PHP-FPM，以使修改生效。 修改php.ini或www.conf修改php.ini文件： 12$ php --ini # 确定php.ini文件的位置$ sudo vi /etc/php.ini # 修改php.ini文件 修改php-fpm.conf文件： 1$ sudo vi /etc/php-fpm/www.conf 编辑之后保存。 CentOS&#x2F;RHEL 71234$ sudo systemctl start php-fpm # 启动php-fpm$ sudo systemctl stop php-fpm # 停止php-fpm$ sudo systemctl reload php-fpm # 重载php-fpm$ sudo systemctl restart php-fpm # 重启php-fpm CentOS&#x2F;RHEL 6.x等旧版本1234$ sudo service php-fpm start # 启动php-fpm$ sudo service php-fpm stop # 停止php-fpm$ sudo service php-fpm restart # 重启php-fpm$ sudo service php-fpm reload # 重载php-fpm Ubuntu&#x2F;Debian1234$ sudo service php5-fpm start # 启动$ sudo service php5-fpm stop # 停止$ sudo service php5-fpm restart # 重启$ sudo service php5-fpm reload # 重载 如果系统使用systemd，比如Ubuntu Linux 16.04+ LTS或者Debian Linux 8.x+，可以这样： 1234$ sudo systemctl start php5-fpm.service # 启动$ sudo systemctl stop php5-fpm.service # 停止$ sudo systemctl restart php5-fpm.service # 重启$ sudo systemctl reload php5-fpm.service # 重载 Ubuntu&#x2F;Debian操作php7.0-fpm1234$ sudo service php7.0-fpm start$ sudo service php7.0-fpm stop$ sudo service php7.0-fpm restart$ sudo service php7.0-fpm reload 如果系统使用systemd，比如Ubuntu Linux 16.04+ LTS或者Debian Linux 8.x+，可以这样： 1234$ sudo systemctl start php7.0-fpm.service$ sudo systemctl stop php7.0-fpm.service$ sudo systemctl restart php7.0-fpm.service$ sudo systemctl reload php7.0-fpm.service Alpine Linux123# /etc/init.d/php-fpm start# /etc/init.d/php-fpm stop# /etc/init.d/php-fpm restart FreeBSD Unix1234# /usr/local/etc/rc.d/php-fpm start# /usr/local/etc/rc.d/php-fpm stop# /usr/local/etc/rc.d/php-fpm reload# /usr/local/etc/rc.d/php-fpm restart 或者用service命令： 1234# service php-fpm start# service php-fpm stop# service php-fpm restart# service php-fpm reload How to reload&#x2F;restart php7.0-fpm &#x2F; php5.0-fpm service","raw":"---\ntitle: 重启php7-fpm和php5-fpm方法\ntoc: true\ndate: 2018-12-03 04:53:44\ntags: [php7-fpm,php5-fpm,php]\ncategories: [技术]\ndescription:\n---\n\n各个平台上如何重启php7-fpm和php5-fpm\n<!--more-->\n\nPHP-FPM是一款简单好用的PHP FastCGI进程管理工具。\n它可以和Apache、Nginx或其他服务器一起构建完整的PHP环境。\n接下来我们看看在更改了php.ini 文件后，如何stop、restart或者reload PHP-FPM，以使修改生效。\n\n# 修改php.ini或www.conf\n修改php.ini文件：\n```shell\n$ php --ini                               # 确定php.ini文件的位置\n$ sudo vi /etc/php.ini                    # 修改php.ini文件\n```\n\n修改php-fpm.conf文件：\n```\n$ sudo vi /etc/php-fpm/www.conf\n```\n编辑之后保存。\n\n# CentOS/RHEL 7\n\n```shell\n$ sudo systemctl start php-fpm      # 启动php-fpm\n$ sudo systemctl stop php-fpm       # 停止php-fpm\n$ sudo systemctl reload php-fpm     # 重载php-fpm\n$ sudo systemctl restart php-fpm    # 重启php-fpm\n```\n\n# CentOS/RHEL 6.x等旧版本\n\n```shell\n$ sudo service php-fpm start        # 启动php-fpm\n$ sudo service php-fpm stop         # 停止php-fpm\n$ sudo service php-fpm restart      # 重启php-fpm\n$ sudo service php-fpm reload       # 重载php-fpm\n```\n\n# Ubuntu/Debian\n\n```shell\n$ sudo service php5-fpm start       # 启动\n$ sudo service php5-fpm stop        # 停止\n$ sudo service php5-fpm restart     # 重启\n$ sudo service php5-fpm reload      # 重载\n```\n\n如果系统使用systemd，比如Ubuntu Linux 16.04+ LTS或者Debian Linux 8.x+，可以这样：\n\n```shell\n$ sudo systemctl start php5-fpm.service        # 启动\n$ sudo systemctl stop php5-fpm.service         # 停止\n$ sudo systemctl restart php5-fpm.service      # 重启\n$ sudo systemctl reload php5-fpm.service       # 重载\n```\n\n# Ubuntu/Debian操作php7.0-fpm\n\n```shell\n$ sudo service php7.0-fpm start\n$ sudo service php7.0-fpm stop\n$ sudo service php7.0-fpm restart\n$ sudo service php7.0-fpm reload\n```\n\n如果系统使用systemd，比如Ubuntu Linux 16.04+ LTS或者Debian Linux 8.x+，可以这样：\n\n```shell\n$ sudo systemctl start php7.0-fpm.service\n$ sudo systemctl stop php7.0-fpm.service\n$ sudo systemctl restart php7.0-fpm.service\n$ sudo systemctl reload php7.0-fpm.service\n```\n\n# Alpine Linux\n\n```shell\n# /etc/init.d/php-fpm start\n# /etc/init.d/php-fpm stop\n# /etc/init.d/php-fpm restart\n```\n\n# FreeBSD Unix\n\n```shell\n# /usr/local/etc/rc.d/php-fpm start\n# /usr/local/etc/rc.d/php-fpm stop\n# /usr/local/etc/rc.d/php-fpm reload\n# /usr/local/etc/rc.d/php-fpm restart\n```\n\n或者用service命令：\n\n```shell\n# service php-fpm start\n# service php-fpm stop\n# service php-fpm restart\n# service php-fpm reload\n```\n\n[How to reload/restart php7.0-fpm / php5.0-fpm service](https://www.cyberciti.biz/faq/how-to-reload-restart-php7-0-fpm-service-linux-unix/)","content":"<p>各个平台上如何重启php7-fpm和php5-fpm</p>\n<span id=\"more\"></span>\n\n<p>PHP-FPM是一款简单好用的PHP FastCGI进程管理工具。<br>它可以和Apache、Nginx或其他服务器一起构建完整的PHP环境。<br>接下来我们看看在更改了php.ini 文件后，如何stop、restart或者reload PHP-FPM，以使修改生效。</p>\n<h1 id=\"修改php-ini或www-conf\"><a href=\"#修改php-ini或www-conf\" class=\"headerlink\" title=\"修改php.ini或www.conf\"></a>修改php.ini或<a href=\"http://www.conf/\">www.conf</a></h1><p>修改php.ini文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">php --ini                               <span class=\"comment\"># 确定php.ini文件的位置</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo vi /etc/php.ini                    <span class=\"comment\"># 修改php.ini文件</span></span></span><br></pre></td></tr></table></figure>\n\n<p>修改php-fpm.conf文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vi /etc/php-fpm/www.conf</span><br></pre></td></tr></table></figure>\n<p>编辑之后保存。</p>\n<h1 id=\"CentOS-x2F-RHEL-7\"><a href=\"#CentOS-x2F-RHEL-7\" class=\"headerlink\" title=\"CentOS&#x2F;RHEL 7\"></a>CentOS&#x2F;RHEL 7</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl start php-fpm      <span class=\"comment\"># 启动php-fpm</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl stop php-fpm       <span class=\"comment\"># 停止php-fpm</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl reload php-fpm     <span class=\"comment\"># 重载php-fpm</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl restart php-fpm    <span class=\"comment\"># 重启php-fpm</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CentOS-x2F-RHEL-6-x等旧版本\"><a href=\"#CentOS-x2F-RHEL-6-x等旧版本\" class=\"headerlink\" title=\"CentOS&#x2F;RHEL 6.x等旧版本\"></a>CentOS&#x2F;RHEL 6.x等旧版本</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php-fpm start        <span class=\"comment\"># 启动php-fpm</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php-fpm stop         <span class=\"comment\"># 停止php-fpm</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php-fpm restart      <span class=\"comment\"># 重启php-fpm</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php-fpm reload       <span class=\"comment\"># 重载php-fpm</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Ubuntu-x2F-Debian\"><a href=\"#Ubuntu-x2F-Debian\" class=\"headerlink\" title=\"Ubuntu&#x2F;Debian\"></a>Ubuntu&#x2F;Debian</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php5-fpm start       <span class=\"comment\"># 启动</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php5-fpm stop        <span class=\"comment\"># 停止</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php5-fpm restart     <span class=\"comment\"># 重启</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php5-fpm reload      <span class=\"comment\"># 重载</span></span></span><br></pre></td></tr></table></figure>\n\n<p>如果系统使用systemd，比如Ubuntu Linux 16.04+ LTS或者Debian Linux 8.x+，可以这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl start php5-fpm.service        <span class=\"comment\"># 启动</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl stop php5-fpm.service         <span class=\"comment\"># 停止</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl restart php5-fpm.service      <span class=\"comment\"># 重启</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl reload php5-fpm.service       <span class=\"comment\"># 重载</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Ubuntu-x2F-Debian操作php7-0-fpm\"><a href=\"#Ubuntu-x2F-Debian操作php7-0-fpm\" class=\"headerlink\" title=\"Ubuntu&#x2F;Debian操作php7.0-fpm\"></a>Ubuntu&#x2F;Debian操作php7.0-fpm</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php7.0-fpm start</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php7.0-fpm stop</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php7.0-fpm restart</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo service php7.0-fpm reload</span></span><br></pre></td></tr></table></figure>\n\n<p>如果系统使用systemd，比如Ubuntu Linux 16.04+ LTS或者Debian Linux 8.x+，可以这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl start php7.0-fpm.service</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl stop php7.0-fpm.service</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl restart php7.0-fpm.service</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo systemctl reload php7.0-fpm.service</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Alpine-Linux\"><a href=\"#Alpine-Linux\" class=\"headerlink\" title=\"Alpine Linux\"></a>Alpine Linux</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">/etc/init.d/php-fpm start</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">/etc/init.d/php-fpm stop</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">/etc/init.d/php-fpm restart</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"FreeBSD-Unix\"><a href=\"#FreeBSD-Unix\" class=\"headerlink\" title=\"FreeBSD Unix\"></a>FreeBSD Unix</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">/usr/local/etc/rc.d/php-fpm start</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">/usr/local/etc/rc.d/php-fpm stop</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">/usr/local/etc/rc.d/php-fpm reload</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">/usr/local/etc/rc.d/php-fpm restart</span></span><br></pre></td></tr></table></figure>\n\n<p>或者用service命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">service php-fpm start</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">service php-fpm stop</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">service php-fpm restart</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">service php-fpm reload</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.cyberciti.biz/faq/how-to-reload-restart-php7-0-fpm-service-linux-unix/\">How to reload&#x2F;restart php7.0-fpm &#x2F; php5.0-fpm service</a></p>\n","slug":"重启php7-fpm和php5-fpm方法","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/12/02/%E9%87%8D%E5%90%AFphp7-fpm%E5%92%8Cphp5-fpm%E6%96%B9%E6%B3%95/","excerpt":"各个平台上如何重启php7-fpm和php5-fpm","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php7-fpm","slug":"php7-fpm","permalink":"http://vwin.github.io/tags/php7-fpm/"},{"name":"php5-fpm","slug":"php5-fpm","permalink":"http://vwin.github.io/tags/php5-fpm/"},{"name":"php","slug":"php","permalink":"http://vwin.github.io/tags/php/"}]},{"title":"Python使用Jupyter notebook","date":"2018-11-23T15:20:15.000Z","path":"2018/11/23/Python使用Jupyter-notebook/","text":"Python 使用jupyter notebook 基础知识Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。在本文中，我们将介绍 Jupyter notebook 的主要特性，以及为什么对于希望编写漂亮的交互式文档的人来说是一个强大工具。 在开始使用 notebook 之前，我们先需要安装该库。你可以在 Jupyter 官网上找到完整的步骤。 其实只要” pip install jupyter “就可以了 运行jupyter notebook 运行上面的命令之后，你将看到类似下面这样的输出： 12345[I 20:06:36.367 NotebookApp] Writing notebook server cookie secret to /run/user/1000/jupyter/notebook_cookie_secret[I 20:06:36.813 NotebookApp] Serving notebooks from local directory: /home/your_username[I 20:06:36.813 NotebookApp] 0 active kernels[I 20:06:36.813 NotebookApp] The IPython Notebook is running at: http://localhost:8888/[I 20:06:36.813 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). 同时，会在你开启 notebook 的文件夹中启动 Jupyter 主界面，如下所示： 新建如果想新建一个 notebook，只需要点击New，选择你希望启动的 notebook 类型即可。 这里，因为我只有一个 Python 内核，所以我们运行一个 Python notebook。在新打开的标签页中，我们会看到 notebook 界面，目前里面什么也没有。 组成notebook 界面由以下部分组成： notebook 的名称 主工具栏，提供了保存、导出、重载 notebook，以及重启内核等选项 快捷键 notebook 主要区域，包含了 notebook 的内容编辑区 慢慢熟悉这些菜单和选项。如果想要详细了解有关 notebook 或一些库的具体话题，可以使用菜单栏右侧的帮助菜单。 下方的主要区域，由被称为单元格的部分组成。每个 notebook 由多个单元格构成，而每个单元格又可以有不同的用途。 执行代码下方截图中看到的是一个代码单元格（code cell），以[ ]开头。在这种类型的单元格中，可以输入任意代码并执行。例如，输入1 + 2并按下Shift + Enter。之后，单元格中的代码就会被计算，光标也会被移动动一个新的单元格中。你会得到如下结果： 根据绿色边框线，我们可以轻松地识别出当前工作的单元格。接下来，我们在第二个单元格中输入些其他代码，例如： 12for i in range(5): print(i) 对上面的代码求值时，你会得到： 和前一个示例一样，代码被计算之后，马上就会显示结果。你应该注意到了，这次没有出现类似Out[2]这样的文字。这是因为我们将结果打印出来了，没有返回任何的值。 notebook 有一个非常有趣的特性，就是可以修改之前的单元格，对其重新计算，这样就可以更新整个文档了。试着把光标移回第一个单元格，并将1 + 2修改成2 + 3，然后按下Shift + Enter重新计算该单元格。你会发现结果马上就更新成了 5。如果你不想重新运行整个脚本，只想用不同的参数测试某个程式的话，这个特性显得尤其强大。不过，你也可以重新计算整个 notebook，只要点击Cell -&gt; Run all即可。 渲染现在我们已经知道了如何输入代码，为什么不尝试着让这个 notebook 更加漂亮、内容更丰富？为此，我们需要使用其他类型的单元格，即 Header单元格和 Markdown单元格。 首先，我们在顶部添加一个 notebook 的标题。选中第一个单元格，然后点击Insert -&gt; Insert单元格above（在上方插入单元格）。你会发现，文档的顶部马上就出现了一个新的单元格。点击在快捷键栏中的单元格类型，将其变成一个标题单元格（heading cell）： 选中下拉选项中的 Heading。然后会出现一个弹出消息，告诉你如何创建不同层级的标题，这样你就有了一个不同类型的 cell： 这个单元格以#标记开头，意味着这是一个一级标题。如果需要子标题，可以使用以下标记表示（改变单元格类型时弹出消息中有解释）： 1234# : 一级标题## : 二级标题### : 三级标题... 在#之后写下文档的标题，然后计算该单元格。你会发现一个样式非常好看的标题。作为示例和练习，我还添加了其他几个标题单元格： 添加好标题之后，我们在编写一些解释，介绍每个代码单元格中的情况。为此，我们要在相应的地方插入单元格，然后将其类型变成 Markdown。然后，计算新的单元格。就这样，你的解释文本就漂亮地渲染出来了！ 保存最后，你可以重命名该 notebook，点击Fiel -&gt; Rename，然后输入新的名称。这样，新的名称将会出现在窗口的左上角，在 Jupyter 的标志旁边。 高级操作单元格操作高级单元格操作，将让编写 notebook 变得更加方便。举例如下： 如果想删除某个单元格，可以选择该单元格，然后依次点击Edit -&gt; Delete Cell； 如果想移动某个单元格，只需要依次点击Edit -&gt; Move cell [up | down]； 如果想剪贴某个单元测，可以先点击Edit -&gt; Cut Cell，然后在点击Edit -&gt; Paste Cell [Above | Below]； 如果你的 notebook 中有很多单元格只需要执行一次，或者想一次性执行大段代码，那么可以选择合并这些单元格。点击Edit -&gt; Merge Cell [Above | below]。 记住这些操作，它们可以帮助你节省许多时间。 Markdown 单元格高级用法我们再来看看 Markdown 单元格。虽然它的类型是 markdown，但是这类单元格也接受 HTML 代码。这样，你就可以在单元格类实现更加丰富的样式，添加图片，等等。例如，如果想在 notebook 中添加 Jupyter 的 logo，将其大小设置为 100px x 100px，并且放置在单元格左侧，可以这样编写： 12&lt;img src=&quot;https://cdn-images-1.medium.com/fit/c/36/36/1*VigrxIzP3-wH7oxoPULjrA.png&quot;style=&quot;width:100px;height:100px;float:left&quot;&gt; 计算该单元格之后，会出现这样的结果： 另外，markdown 单元格还支持 LaTex 语法。例如： 1$$\\int_0^&#123;+\\infty&#125; x^2 dx$$ 计算上述单元格，将获得下面的 LaTex 方程式： 导出notebook 还有一个强大的特性，就是其导出功能。可以将 notebook 导出为多种格式： HTML Markdown ReST PDF（通过 LaTeX） Raw Python 导出 PDF 功能，可以让你不用写 LaTex 即可创建漂亮的 PDF 文档。你还可以将 notebook 作为网页发布在你的网站上。甚至，你可以导出为 ReST 格式，作为软件库的文档。 Matplotlib 集成如果你用 Python 绘制过图形，那你肯定知道 matplotlib。Matplotlib 是一个用于创建漂亮图形的 Python 库，结合 Jupyter notebook 使用时体验更佳。 要想在 Jupyter notebook 中使用 matplotlib，需要告诉 Jupyter 获取 matplotlib 生成的所有图形，并将其嵌入 notebook 中。为此，需要计算： 1%matplotlib inline 要想执行成功，需要先pip install matplotlib。 运行这个指令可能要花个几秒钟，但是在 notebook 中需要执行一次即可。接下来，我们来绘制一个图形，看看具体的集成效果： 1234567import matplotlib.pyplot as pltimport numpy as npx = np.arange(20)y = x**2plt.plot(x, y) 上面的代码将绘制方程式 y&#x3D;x^2 。计算单元格后，会得到如下图形：我们看到，绘制出的图形直接添加在了 notebook 中，就在代码的下面。我们可以之后修改代码，重新计算，这时图形也会动态更新。这是每个数据科学家都想要的一个特性：将代码和图片放在同一个文件中，清楚地看出每段代码的效果。 非本地内核我们可以非常容易地在一台电脑上启动 Jupyter，而且支持多人通过网络连接同一个 Jupyter 实例。在上一篇文章中，你有没有注意启动 Jupyter 时出现过这样一段话： 1The IPython Notebook is running at: http://localhost:8888/ 这意味着，你的 notebook 是本地运行的，可以在浏览器上打开 http://localhost:8888/ ，从而访问 notebook。你也可以修改下配置，让该 notebook 可以被公开访问。这样，任何知道 notebook 地址的人都可以连接到 notebook 进行远程修改。 结束从这两篇快速入门介绍中，我们可以看到：Jupyter notebook 是一个非常强大的工具，可以创建漂亮的交互式文档，制作教学材料，等等。建议你马上开始使用 Jupyter notebook，探索更多 notebook 的强大功能。","raw":"---\ntitle: Python使用Jupyter notebook\ntoc: true\ndate: 2018-11-23 23:20:15\ntags: [python,jupyter notebook]\ncategories: [技术]\ndescription:\n---\nPython 使用jupyter notebook \n\n<!--more-->\n# 基础知识\nJupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。在本文中，我们将介绍 Jupyter notebook 的主要特性，以及为什么对于希望编写漂亮的交互式文档的人来说是一个强大工具。\n\n在开始使用 notebook 之前，我们先需要安装该库。你可以在 Jupyter 官网上找到完整的步骤。\n\n其实只要\" pip install jupyter \"就可以了\n\n# 运行\njupyter notebook\n\n运行上面的命令之后，你将看到类似下面这样的输出：\n\n```shell\n[I 20:06:36.367 NotebookApp] Writing notebook server cookie secret to /run/user/1000/jupyter/notebook_cookie_secret\n[I 20:06:36.813 NotebookApp] Serving notebooks from local directory: /home/your_username\n[I 20:06:36.813 NotebookApp] 0 active kernels\n[I 20:06:36.813 NotebookApp] The IPython Notebook is running at: http://localhost:8888/\n[I 20:06:36.813 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n```\n同时，会在你开启 notebook 的文件夹中启动 Jupyter 主界面，如下所示：\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fxj1bj8risj30id05gdg7.jpg)\n\n## 新建\n\n如果想新建一个 notebook，只需要点击New，选择你希望启动的 notebook 类型即可。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fxj1bv3s24j30id09tt94.jpg)\n\n这里，因为我只有一个 Python 内核，所以我们运行一个 Python notebook。在新打开的标签页中，我们会看到 notebook 界面，目前里面什么也没有。\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fxj1c3u9vyj30id04idgb.jpg)\n\n## 组成\nnotebook 界面由以下部分组成：\n\n1. notebook 的名称\n2. 主工具栏，提供了保存、导出、重载 notebook，以及重启内核等选项\n3. 快捷键\n4. notebook 主要区域，包含了 notebook 的内容编辑区\n\n慢慢熟悉这些菜单和选项。如果想要详细了解有关 notebook 或一些库的具体话题，可以使用菜单栏右侧的帮助菜单。\n\n下方的主要区域，由被称为单元格的部分组成。每个 notebook 由多个单元格构成，而每个单元格又可以有不同的用途。\n\n## 执行代码\n\n下方截图中看到的是一个代码单元格（code cell），以[ ]开头。在这种类型的单元格中，可以输入任意代码并执行。例如，输入1 + 2并按下Shift + Enter。之后，单元格中的代码就会被计算，光标也会被移动动一个新的单元格中。你会得到如下结果：\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fxj1cq3qxij30id05y0te.jpg)\n\n根据绿色边框线，我们可以轻松地识别出当前工作的单元格。接下来，我们在第二个单元格中输入些其他代码，例如：\n\n```python\nfor i in range(5):\n    print(i)\n```\n\n对上面的代码求值时，你会得到：\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fxj1dlfcdfj30id09kq3s.jpg)\n\n和前一个示例一样，代码被计算之后，马上就会显示结果。你应该注意到了，这次没有出现类似Out[2]这样的文字。这是因为我们将结果打印出来了，没有返回任何的值。\n\nnotebook 有一个非常有趣的特性，就是可以修改之前的单元格，对其重新计算，这样就可以更新整个文档了。试着把光标移回第一个单元格，并将1 + 2修改成2 + 3，然后按下Shift + Enter重新计算该单元格。你会发现结果马上就更新成了 5。如果你不想重新运行整个脚本，只想用不同的参数测试某个程式的话，这个特性显得尤其强大。不过，你也可以重新计算整个 notebook，只要点击Cell -> Run all即可。\n\n## 渲染\n\n现在我们已经知道了如何输入代码，为什么不尝试着让这个 notebook 更加漂亮、内容更丰富？为此，我们需要使用其他类型的单元格，即 Header单元格和 Markdown单元格。\n\n首先，我们在顶部添加一个 notebook 的标题。选中第一个单元格，然后点击Insert -> Insert单元格above（在上方插入单元格）。你会发现，文档的顶部马上就出现了一个新的单元格。点击在快捷键栏中的单元格类型，将其变成一个标题单元格（heading cell）：\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fxj1e17id6j30id00uweh.jpg)\n\n选中下拉选项中的 Heading。然后会出现一个弹出消息，告诉你如何创建不同层级的标题，这样你就有了一个不同类型的 cell：\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fxj1ebz43gj30id035dg0.jpg)\n\n这个单元格以#标记开头，意味着这是一个一级标题。如果需要子标题，可以使用以下标记表示（改变单元格类型时弹出消息中有解释）：\n\n```\n# : 一级标题\n## : 二级标题\n### : 三级标题\n...\n```\n\n在#之后写下文档的标题，然后计算该单元格。你会发现一个样式非常好看的标题。作为示例和练习，我还添加了其他几个标题单元格：\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fxj1evktloj30id0bn750.jpg)\n\n添加好标题之后，我们在编写一些解释，介绍每个代码单元格中的情况。为此，我们要在相应的地方插入单元格，然后将其类型变成 Markdown。然后，计算新的单元格。就这样，你的解释文本就漂亮地渲染出来了！\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fxj1f3w7llj30id0dt3zc.jpg)\n\n## 保存\n\n最后，你可以重命名该 notebook，点击Fiel -> Rename，然后输入新的名称。这样，新的名称将会出现在窗口的左上角，在 Jupyter 的标志旁边。\n\n# 高级操作\n\n## 单元格操作\n高级单元格操作，将让编写 notebook 变得更加方便。举例如下：\n\n- 如果想删除某个单元格，可以选择该单元格，然后依次点击Edit -> Delete Cell；\n- 如果想移动某个单元格，只需要依次点击Edit -> Move cell [up | down]；\n- 如果想剪贴某个单元测，可以先点击Edit -> Cut Cell，然后在点击Edit -> Paste Cell [Above | Below]；\n- 如果你的 notebook 中有很多单元格只需要执行一次，或者想一次性执行大段代码，那么可以选择合并这些单元格。点击Edit -> Merge Cell [Above | below]。\n\n记住这些操作，它们可以帮助你节省许多时间。\n\n## Markdown 单元格高级用法\n我们再来看看 Markdown 单元格。虽然它的类型是 markdown，但是这类单元格也接受 HTML 代码。这样，你就可以在单元格类实现更加丰富的样式，添加图片，等等。例如，如果想在 notebook 中添加 Jupyter 的 logo，将其大小设置为 100px x 100px，并且放置在单元格左侧，可以这样编写：\n\n```javascript\n<img src=\"https://cdn-images-1.medium.com/fit/c/36/36/1*VigrxIzP3-wH7oxoPULjrA.png\"\nstyle=\"width:100px;height:100px;float:left\">\n```\n\n计算该单元格之后，会出现这样的结果：\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fxj1jnr169j30id04kq34.jpg)\n\n另外，markdown 单元格还支持 LaTex 语法。例如：\n```python\n$$\\int_0^{+\\infty} x^2 dx$$\n```\n\n计算上述单元格，将获得下面的 LaTex 方程式：\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fxj1k0ig72j30id03cjrj.jpg)\n\n## 导出\n\nnotebook 还有一个强大的特性，就是其导出功能。可以将 notebook 导出为多种格式：\n\n- HTML\n- Markdown\n- ReST\n- PDF（通过 LaTeX）\n- Raw Python\n- 导出 PDF 功能，可以让你不用写 LaTex 即可创建漂亮的 PDF 文档。你还可以将 notebook 作为网页发布在你的网站上。甚至，你可以导出为 ReST 格式，作为软件库的文档。\n\n## Matplotlib 集成\n如果你用 Python 绘制过图形，那你肯定知道 matplotlib。Matplotlib 是一个用于创建漂亮图形的 Python 库，结合 Jupyter notebook 使用时体验更佳。\n\n要想在 Jupyter notebook 中使用 matplotlib，需要告诉 Jupyter 获取 matplotlib 生成的所有图形，并将其嵌入 notebook 中。为此，需要计算：\n```python\n%matplotlib inline\n```\n\n> 要想执行成功，需要先pip install matplotlib。\n\n运行这个指令可能要花个几秒钟，但是在 notebook 中需要执行一次即可。接下来，我们来绘制一个图形，看看具体的集成效果：\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(20)\ny = x**2\n\nplt.plot(x, y)\n```\n\n上面的代码将绘制方程式 y=x^2 。计算单元格后，会得到如下图形：\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fxj1lwfu3fj30id0e0759.jpg)\n我们看到，绘制出的图形直接添加在了 notebook 中，就在代码的下面。我们可以之后修改代码，重新计算，这时图形也会动态更新。这是每个数据科学家都想要的一个特性：将代码和图片放在同一个文件中，清楚地看出每段代码的效果。\n\n## 非本地内核\n我们可以非常容易地在一台电脑上启动 Jupyter，而且支持多人通过网络连接同一个 Jupyter 实例。在上一篇文章中，你有没有注意启动 Jupyter 时出现过这样一段话：\n\n```shell\nThe IPython Notebook is running at: http://localhost:8888/\n```\n\n这意味着，你的 notebook 是本地运行的，可以在浏览器上打开 http://localhost:8888/ ，从而访问 notebook。你也可以修改下配置，让该 notebook 可以被公开访问。这样，任何知道 notebook 地址的人都可以连接到 notebook 进行远程修改。\n\n# 结束\n\n从这两篇快速入门介绍中，我们可以看到：Jupyter notebook 是一个非常强大的工具，可以创建漂亮的交互式文档，制作教学材料，等等。建议你马上开始使用 Jupyter notebook，探索更多 notebook 的强大功能。\n\n","content":"<p>Python 使用jupyter notebook </p>\n<span id=\"more\"></span>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。在本文中，我们将介绍 Jupyter notebook 的主要特性，以及为什么对于希望编写漂亮的交互式文档的人来说是一个强大工具。</p>\n<p>在开始使用 notebook 之前，我们先需要安装该库。你可以在 Jupyter 官网上找到完整的步骤。</p>\n<p>其实只要” pip install jupyter “就可以了</p>\n<h1 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h1><p>jupyter notebook</p>\n<p>运行上面的命令之后，你将看到类似下面这样的输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[I 20:06:36.367 NotebookApp] Writing notebook server cookie secret to /run/user/1000/jupyter/notebook_cookie_secret</span><br><span class=\"line\">[I 20:06:36.813 NotebookApp] Serving notebooks from local directory: /home/your_username</span><br><span class=\"line\">[I 20:06:36.813 NotebookApp] 0 active kernels</span><br><span class=\"line\">[I 20:06:36.813 NotebookApp] The IPython Notebook is running at: http://localhost:8888/</span><br><span class=\"line\">[I 20:06:36.813 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span><br></pre></td></tr></table></figure>\n<p>同时，会在你开启 notebook 的文件夹中启动 Jupyter 主界面，如下所示：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fxj1bj8risj30id05gdg7.jpg\"></p>\n<h2 id=\"新建\"><a href=\"#新建\" class=\"headerlink\" title=\"新建\"></a>新建</h2><p>如果想新建一个 notebook，只需要点击New，选择你希望启动的 notebook 类型即可。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fxj1bv3s24j30id09tt94.jpg\"></p>\n<p>这里，因为我只有一个 Python 内核，所以我们运行一个 Python notebook。在新打开的标签页中，我们会看到 notebook 界面，目前里面什么也没有。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fxj1c3u9vyj30id04idgb.jpg\"></p>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>notebook 界面由以下部分组成：</p>\n<ol>\n<li>notebook 的名称</li>\n<li>主工具栏，提供了保存、导出、重载 notebook，以及重启内核等选项</li>\n<li>快捷键</li>\n<li>notebook 主要区域，包含了 notebook 的内容编辑区</li>\n</ol>\n<p>慢慢熟悉这些菜单和选项。如果想要详细了解有关 notebook 或一些库的具体话题，可以使用菜单栏右侧的帮助菜单。</p>\n<p>下方的主要区域，由被称为单元格的部分组成。每个 notebook 由多个单元格构成，而每个单元格又可以有不同的用途。</p>\n<h2 id=\"执行代码\"><a href=\"#执行代码\" class=\"headerlink\" title=\"执行代码\"></a>执行代码</h2><p>下方截图中看到的是一个代码单元格（code cell），以[ ]开头。在这种类型的单元格中，可以输入任意代码并执行。例如，输入1 + 2并按下Shift + Enter。之后，单元格中的代码就会被计算，光标也会被移动动一个新的单元格中。你会得到如下结果：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fxj1cq3qxij30id05y0te.jpg\"></p>\n<p>根据绿色边框线，我们可以轻松地识别出当前工作的单元格。接下来，我们在第二个单元格中输入些其他代码，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>对上面的代码求值时，你会得到：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fxj1dlfcdfj30id09kq3s.jpg\"></p>\n<p>和前一个示例一样，代码被计算之后，马上就会显示结果。你应该注意到了，这次没有出现类似Out[2]这样的文字。这是因为我们将结果打印出来了，没有返回任何的值。</p>\n<p>notebook 有一个非常有趣的特性，就是可以修改之前的单元格，对其重新计算，这样就可以更新整个文档了。试着把光标移回第一个单元格，并将1 + 2修改成2 + 3，然后按下Shift + Enter重新计算该单元格。你会发现结果马上就更新成了 5。如果你不想重新运行整个脚本，只想用不同的参数测试某个程式的话，这个特性显得尤其强大。不过，你也可以重新计算整个 notebook，只要点击Cell -&gt; Run all即可。</p>\n<h2 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h2><p>现在我们已经知道了如何输入代码，为什么不尝试着让这个 notebook 更加漂亮、内容更丰富？为此，我们需要使用其他类型的单元格，即 Header单元格和 Markdown单元格。</p>\n<p>首先，我们在顶部添加一个 notebook 的标题。选中第一个单元格，然后点击Insert -&gt; Insert单元格above（在上方插入单元格）。你会发现，文档的顶部马上就出现了一个新的单元格。点击在快捷键栏中的单元格类型，将其变成一个标题单元格（heading cell）：</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fxj1e17id6j30id00uweh.jpg\"></p>\n<p>选中下拉选项中的 Heading。然后会出现一个弹出消息，告诉你如何创建不同层级的标题，这样你就有了一个不同类型的 cell：</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fxj1ebz43gj30id035dg0.jpg\"></p>\n<p>这个单元格以#标记开头，意味着这是一个一级标题。如果需要子标题，可以使用以下标记表示（改变单元格类型时弹出消息中有解释）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># : 一级标题</span><br><span class=\"line\">## : 二级标题</span><br><span class=\"line\">### : 三级标题</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>在#之后写下文档的标题，然后计算该单元格。你会发现一个样式非常好看的标题。作为示例和练习，我还添加了其他几个标题单元格：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fxj1evktloj30id0bn750.jpg\"></p>\n<p>添加好标题之后，我们在编写一些解释，介绍每个代码单元格中的情况。为此，我们要在相应的地方插入单元格，然后将其类型变成 Markdown。然后，计算新的单元格。就这样，你的解释文本就漂亮地渲染出来了！</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fxj1f3w7llj30id0dt3zc.jpg\"></p>\n<h2 id=\"保存\"><a href=\"#保存\" class=\"headerlink\" title=\"保存\"></a>保存</h2><p>最后，你可以重命名该 notebook，点击Fiel -&gt; Rename，然后输入新的名称。这样，新的名称将会出现在窗口的左上角，在 Jupyter 的标志旁边。</p>\n<h1 id=\"高级操作\"><a href=\"#高级操作\" class=\"headerlink\" title=\"高级操作\"></a>高级操作</h1><h2 id=\"单元格操作\"><a href=\"#单元格操作\" class=\"headerlink\" title=\"单元格操作\"></a>单元格操作</h2><p>高级单元格操作，将让编写 notebook 变得更加方便。举例如下：</p>\n<ul>\n<li>如果想删除某个单元格，可以选择该单元格，然后依次点击Edit -&gt; Delete Cell；</li>\n<li>如果想移动某个单元格，只需要依次点击Edit -&gt; Move cell [up | down]；</li>\n<li>如果想剪贴某个单元测，可以先点击Edit -&gt; Cut Cell，然后在点击Edit -&gt; Paste Cell [Above | Below]；</li>\n<li>如果你的 notebook 中有很多单元格只需要执行一次，或者想一次性执行大段代码，那么可以选择合并这些单元格。点击Edit -&gt; Merge Cell [Above | below]。</li>\n</ul>\n<p>记住这些操作，它们可以帮助你节省许多时间。</p>\n<h2 id=\"Markdown-单元格高级用法\"><a href=\"#Markdown-单元格高级用法\" class=\"headerlink\" title=\"Markdown 单元格高级用法\"></a>Markdown 单元格高级用法</h2><p>我们再来看看 Markdown 单元格。虽然它的类型是 markdown，但是这类单元格也接受 HTML 代码。这样，你就可以在单元格类实现更加丰富的样式，添加图片，等等。例如，如果想在 notebook 中添加 Jupyter 的 logo，将其大小设置为 100px x 100px，并且放置在单元格左侧，可以这样编写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">&quot;https://cdn-images-1.medium.com/fit/c/36/36/1*VigrxIzP3-wH7oxoPULjrA.png&quot;</span></span><br><span class=\"line\">style=<span class=\"string\">&quot;width:100px;height:100px;float:left&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>计算该单元格之后，会出现这样的结果：<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fxj1jnr169j30id04kq34.jpg\"></p>\n<p>另外，markdown 单元格还支持 LaTex 语法。例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$\\int_0^&#123;+\\infty&#125; x^<span class=\"number\">2</span> dx$$</span><br></pre></td></tr></table></figure>\n\n<p>计算上述单元格，将获得下面的 LaTex 方程式：<br><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fxj1k0ig72j30id03cjrj.jpg\"></p>\n<h2 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h2><p>notebook 还有一个强大的特性，就是其导出功能。可以将 notebook 导出为多种格式：</p>\n<ul>\n<li>HTML</li>\n<li>Markdown</li>\n<li>ReST</li>\n<li>PDF（通过 LaTeX）</li>\n<li>Raw Python</li>\n<li>导出 PDF 功能，可以让你不用写 LaTex 即可创建漂亮的 PDF 文档。你还可以将 notebook 作为网页发布在你的网站上。甚至，你可以导出为 ReST 格式，作为软件库的文档。</li>\n</ul>\n<h2 id=\"Matplotlib-集成\"><a href=\"#Matplotlib-集成\" class=\"headerlink\" title=\"Matplotlib 集成\"></a>Matplotlib 集成</h2><p>如果你用 Python 绘制过图形，那你肯定知道 matplotlib。Matplotlib 是一个用于创建漂亮图形的 Python 库，结合 Jupyter notebook 使用时体验更佳。</p>\n<p>要想在 Jupyter notebook 中使用 matplotlib，需要告诉 Jupyter 获取 matplotlib 生成的所有图形，并将其嵌入 notebook 中。为此，需要计算：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%matplotlib inline</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>要想执行成功，需要先pip install matplotlib。</p>\n</blockquote>\n<p>运行这个指令可能要花个几秒钟，但是在 notebook 中需要执行一次即可。接下来，我们来绘制一个图形，看看具体的集成效果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">x = np.arange(<span class=\"number\">20</span>)</span><br><span class=\"line\">y = x**<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">plt.plot(x, y)</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码将绘制方程式 y&#x3D;x^2 。计算单元格后，会得到如下图形：<br><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fxj1lwfu3fj30id0e0759.jpg\"><br>我们看到，绘制出的图形直接添加在了 notebook 中，就在代码的下面。我们可以之后修改代码，重新计算，这时图形也会动态更新。这是每个数据科学家都想要的一个特性：将代码和图片放在同一个文件中，清楚地看出每段代码的效果。</p>\n<h2 id=\"非本地内核\"><a href=\"#非本地内核\" class=\"headerlink\" title=\"非本地内核\"></a>非本地内核</h2><p>我们可以非常容易地在一台电脑上启动 Jupyter，而且支持多人通过网络连接同一个 Jupyter 实例。在上一篇文章中，你有没有注意启动 Jupyter 时出现过这样一段话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The IPython Notebook is running at: http://localhost:8888/</span><br></pre></td></tr></table></figure>\n\n<p>这意味着，你的 notebook 是本地运行的，可以在浏览器上打开 <a href=\"http://localhost:8888/\">http://localhost:8888/</a> ，从而访问 notebook。你也可以修改下配置，让该 notebook 可以被公开访问。这样，任何知道 notebook 地址的人都可以连接到 notebook 进行远程修改。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>从这两篇快速入门介绍中，我们可以看到：Jupyter notebook 是一个非常强大的工具，可以创建漂亮的交互式文档，制作教学材料，等等。建议你马上开始使用 Jupyter notebook，探索更多 notebook 的强大功能。</p>\n","slug":"Python使用Jupyter-notebook","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/11/23/Python%E4%BD%BF%E7%94%A8Jupyter-notebook/","excerpt":"Python 使用jupyter notebook","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"jupyter notebook","slug":"jupyter-notebook","permalink":"http://vwin.github.io/tags/jupyter-notebook/"}]},{"title":"Python使用paramiko实现ssh和scp","date":"2018-11-22T20:12:01.000Z","path":"2018/11/22/Python-使用paramiko实现ssh和scp/","text":"Python使用paramiko模块实现ssh和scp 介绍这篇文章简单地介绍了python的paramiko模块的用法，paramiko实现了SSH协议，能够方便地与远程计算机交互。简单的说，就是你在terminal下执行的如下语句，现在可以通过python的paramiko实现了。 12345# 执行shell语句ssh -i ~/.ssh/id_rsa -p 1098 xxx@12.164.145.21 -e &#x27;ls -al&#x27;# 拷贝数据到远程计算机scp -i ~/.ssh/id_rsa -P 1098 -r data xxx@12.164.145.21:~/data 这里不讨论shell与python实现的优缺点，如果你没有需求，也不会看到这篇博客了。我个人使用paramiko是为了使用python的多线程，并发地对多台远程计算机执行相同的操作。 这篇博客虽然篇幅不大，但是，可能是目前网络上最好的中文入门教程了。那就开始吧！ 安装安装非常简单，直接使用pip安装即可: 1sudo pip install paramiko 建立SSH连接使用密码连接： 12import paramikossh = paramiko.SSHClient() 123#这行代码的作用是允许连接不在know_hosts文件中的主机。ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())ssh.connect(&quot;IP&quot;, port, &quot;username&quot;, &quot;password&quot;) 使用私钥连接： 123ssh = paramiko.SSHClient()ssh.connect(&#x27;10.120.48.109&#x27;, port, &#x27;用户名&#x27;,key_filename=&#x27;私钥&#x27;) 连接以后可以执行shell命令： 12345In [8]: ssh.exec_command(&#x27;ls&#x27;)Out[8]:(&lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;, &lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;, &lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;) 执行shell命令以后，并不会立即打印命令的执行结果，而是返回几个Channel, 只能像下面这样获取输出： 1234In [9]: stdin, stdout, stderr = ssh.exec_command(&#x27;ls&#x27;)In [10]: print stdout.readlines()[&#x27;AgentBackkup_2018-06-10\\n&#x27;, &#x27;AgentBackup\\n&#x27;, &#x27;log\\n&#x27;, &#x27;mysql.sh\\n&#x27;, &#x27;rdsAgent\\n&#x27;] 注意： 命令执行出错并不会抛出异常，所以，对于命令出错需要根据自己的需求进行相应的处理： 12345678910In [54]: stdin, stdout, stderr = ssh.exec_command(&#x27;cat file_not_found&#x27;)In [55]: print stdout.readlines()[]In [56]: print stderr.readlines()[u&#x27;cat: file_not_found: No such file or directory\\n&#x27;]In [57]: stdin, stdout, stderr = ssh.exec_command(&#x27;ls&#x27;)In [58]: print stderr.readlines()[] API文档: https://paramiko-docs.readthedocs.org/en/1.15/api/client.html SCP vs SFTP通过paramiko还可以传输文件，这是我写这篇博客的主要原因。搜了很多博客，都没有说明白如何通过paramiko在计算机之间传输文件，通过阅读官方文档，发现有如下两种方式： 12sftp = paramiko.SFTPClient.from_transport(ssh.get_transport())sftp = ssh.open_sftp() 即新建一个SFTPClient对象，该对象复用之前的SSH连接，因此，我们使用sftp传输文件时，不需要再次进行用户认证。 文件上传 12In [59]: sftp.put(&#x27;memory.py&#x27;, &#x27;memory.py&#x27;)Out[59]: &lt;SFTPAttributes: [ size=288 uid=1000 gid=1000 mode=0100644 atime=1435391914 mtime=1435391914 ]&gt; 文件下载 1In [60]: sftp.get(&#x27;memory.py&#x27;, &#x27;backup.py&#x27;) 执行命令 paramiko并没有提供一个叫做scp的子模块，如果我们希望在计算机之间传输数据，可以通过sftp(sftp实现了scp所有的功能，也就没有必再实现一个scp)传输文件，还可以通过sftp执行命令，如下所示： 12345678910111213141516171819In [44]: sftp.listdir()Out[44]:[&#x27;.viminfo&#x27;,&#x27;.bash_logout&#x27;,&#x27;.bash_history&#x27;,&#x27;AgentBackkup_2018-06-10&#x27;,&#x27;AgentBackup&#x27;,&#x27;rdsAgent&#x27;]In [45]: sftp.rename(&#x27;AgentBackkup_2018-06-10&#x27;, &#x27;AgentBackkup_2018-11-10&#x27;)In [46]: sftp.listdir()Out[46]:[&#x27;AgentBackkup_2018-11-10&#x27;,&#x27;.viminfo&#x27;,&#x27;.bash_logout&#x27;,&#x27;.bash_history&#x27;,&#x27;AgentBackup&#x27;,&#x27;rdsAgent&#x27;] sftp提供了很多命令，具体内容可以参考官方文档 。","raw":"---\ntitle: Python使用paramiko实现ssh和scp\ntoc: true\ndate: 2018-11-23 04:12:01\ntags: [python,paramiko,ssh,scp]\ncategories: [技术]\ndescription:\n---\n\nPython使用paramiko模块实现ssh和scp\n\n<!--more-->\n# 介绍\n\n这篇文章简单地介绍了python的paramiko模块的用法，paramiko实现了SSH协议，能够方便地与远程计算机交互。简单的说，就是你在terminal下执行的如下语句，现在可以通过python的paramiko实现了。\n```s\n# 执行shell语句\nssh -i ~/.ssh/id_rsa -p 1098  xxx@12.164.145.21 -e 'ls -al'\n\n# 拷贝数据到远程计算机\nscp -i ~/.ssh/id_rsa -P 1098 -r data xxx@12.164.145.21:~/data\n```\n这里不讨论shell与python实现的优缺点，如果你没有需求，也不会看到这篇博客了。我个人使用paramiko是为了使用python的多线程，并发地对多台远程计算机执行相同的操作。\n\n这篇博客虽然篇幅不大，但是，可能是目前网络上最好的中文入门教程了。那就开始吧！\n\n# 安装\n安装非常简单，直接使用pip安装即可:\n\n```shell\nsudo pip install paramiko\n```\n\n# 建立SSH连接\n使用密码连接：\n\n```shell\nimport paramiko\nssh = paramiko.SSHClient()\n```\n\n```shell\n#这行代码的作用是允许连接不在know_hosts文件中的主机。\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh.connect(\"IP\",  port, \"username\", \"password\")\n```\n\n使用私钥连接：\n\n```shell\nssh = paramiko.SSHClient()\nssh.connect('10.120.48.109', port, '用户名',\nkey_filename='私钥')\n```\n\n连接以后可以执行shell命令：\n\n```shell\nIn [8]: ssh.exec_command('ls')\nOut[8]:\n(<paramiko.ChannelFile from <paramiko.Channel 1 (open) window=2097152 -> <paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))>>>,\n <paramiko.ChannelFile from <paramiko.Channel 1 (open) window=2097152 -> <paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))>>>,\n <paramiko.ChannelFile from <paramiko.Channel 1 (open) window=2097152 -> <paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))>>>)\n ```\n\n执行shell命令以后，并不会立即打印命令的执行结果，而是返回几个Channel, 只能像下面这样获取输出：\n\n```shell\nIn [9]: stdin, stdout, stderr = ssh.exec_command('ls')\n\nIn [10]: print stdout.readlines()\n['AgentBackkup_2018-06-10\\n', 'AgentBackup\\n', 'log\\n', 'mysql.sh\\n', 'rdsAgent\\n']\n```\n\n注意： 命令执行出错并不会抛出异常，所以，对于命令出错需要根据自己的需求进行相应的处理：\n\n```shell\nIn [54]: stdin, stdout, stderr = ssh.exec_command('cat file_not_found')\nIn [55]: print stdout.readlines()\n[]\n\nIn [56]: print stderr.readlines()\n[u'cat: file_not_found: No such file or directory\\n']\n\nIn [57]: stdin, stdout, stderr = ssh.exec_command('ls')\nIn [58]: print stderr.readlines()\n[]\n```\n\nAPI文档: https://paramiko-docs.readthedocs.org/en/1.15/api/client.html\n\n# SCP vs SFTP\n通过paramiko还可以传输文件，这是我写这篇博客的主要原因。搜了很多博客，都没有说明白如何通过paramiko在计算机之间传输文件，通过阅读官方文档，发现有如下两种方式：\n\n```shell\nsftp = paramiko.SFTPClient.from_transport(ssh.get_transport())\nsftp = ssh.open_sftp()\n```\n\n即新建一个SFTPClient对象，该对象复用之前的SSH连接，因此，我们使用sftp传输文件时，不需要再次进行用户认证。\n\n文件上传\n\n```shell\n  In [59]: sftp.put('memory.py', 'memory.py')\n  Out[59]: <SFTPAttributes: [ size=288 uid=1000 gid=1000 mode=0100644 atime=1435391914 mtime=1435391914 ]>\n```\n文件下载\n\n```shell\n  In [60]: sftp.get('memory.py', 'backup.py')\n```\n\n执行命令\n\nparamiko并没有提供一个叫做scp的子模块，如果我们希望在计算机之间传输数据，可以通过sftp(sftp实现了scp所有的功能，也就没有必再实现一个scp)传输文件，还可以通过sftp执行命令，如下所示：\n```shell\n  In [44]: sftp.listdir()\n  Out[44]:\n  ['.viminfo',\n  '.bash_logout',\n  '.bash_history',\n  'AgentBackkup_2018-06-10',\n  'AgentBackup',\n  'rdsAgent']\n\n  In [45]: sftp.rename('AgentBackkup_2018-06-10', 'AgentBackkup_2018-11-10')\n\n  In [46]: sftp.listdir()\n  Out[46]:\n  ['AgentBackkup_2018-11-10',\n  '.viminfo',\n  '.bash_logout',\n  '.bash_history',\n  'AgentBackup',\n  'rdsAgent']\n```\nsftp提供了很多命令，具体内容可以参考官方文档 。\n","content":"<p>Python使用paramiko模块实现ssh和scp</p>\n<span id=\"more\"></span>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>这篇文章简单地介绍了python的paramiko模块的用法，paramiko实现了SSH协议，能够方便地与远程计算机交互。简单的说，就是你在terminal下执行的如下语句，现在可以通过python的paramiko实现了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 执行shell语句</span><br><span class=\"line\">ssh -i ~/.ssh/id_rsa -p 1098  xxx@12.164.145.21 -e &#x27;ls -al&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"># 拷贝数据到远程计算机</span><br><span class=\"line\">scp -i ~/.ssh/id_rsa -P 1098 -r data xxx@12.164.145.21:~/data</span><br></pre></td></tr></table></figure>\n<p>这里不讨论shell与python实现的优缺点，如果你没有需求，也不会看到这篇博客了。我个人使用paramiko是为了使用python的多线程，并发地对多台远程计算机执行相同的操作。</p>\n<p>这篇博客虽然篇幅不大，但是，可能是目前网络上最好的中文入门教程了。那就开始吧！</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>安装非常简单，直接使用pip安装即可:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install paramiko</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"建立SSH连接\"><a href=\"#建立SSH连接\" class=\"headerlink\" title=\"建立SSH连接\"></a>建立SSH连接</h1><p>使用密码连接：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import paramiko</span><br><span class=\"line\">ssh = paramiko.SSHClient()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">这行代码的作用是允许连接不在know_hosts文件中的主机。</span></span><br><span class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class=\"line\">ssh.connect(&quot;IP&quot;,  port, &quot;username&quot;, &quot;password&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>使用私钥连接：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh = paramiko.SSHClient()</span><br><span class=\"line\">ssh.connect(&#x27;10.120.48.109&#x27;, port, &#x27;用户名&#x27;,</span><br><span class=\"line\">key_filename=&#x27;私钥&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>连接以后可以执行shell命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [8]: ssh.exec_command(&#x27;ls&#x27;)</span><br><span class=\"line\">Out[8]:</span><br><span class=\"line\">(&lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;,</span><br><span class=\"line\"> &lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;,</span><br><span class=\"line\"> &lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>执行shell命令以后，并不会立即打印命令的执行结果，而是返回几个Channel, 只能像下面这样获取输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [9]: stdin, stdout, stderr = ssh.exec_command(&#x27;ls&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">In [10]: print stdout.readlines()</span><br><span class=\"line\">[&#x27;AgentBackkup_2018-06-10\\n&#x27;, &#x27;AgentBackup\\n&#x27;, &#x27;log\\n&#x27;, &#x27;mysql.sh\\n&#x27;, &#x27;rdsAgent\\n&#x27;]</span><br></pre></td></tr></table></figure>\n\n<p>注意： 命令执行出错并不会抛出异常，所以，对于命令出错需要根据自己的需求进行相应的处理：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [54]: stdin, stdout, stderr = ssh.exec_command(&#x27;cat file_not_found&#x27;)</span><br><span class=\"line\">In [55]: print stdout.readlines()</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\">In [56]: print stderr.readlines()</span><br><span class=\"line\">[u&#x27;cat: file_not_found: No such file or directory\\n&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">In [57]: stdin, stdout, stderr = ssh.exec_command(&#x27;ls&#x27;)</span><br><span class=\"line\">In [58]: print stderr.readlines()</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure>\n\n<p>API文档: <a href=\"https://paramiko-docs.readthedocs.org/en/1.15/api/client.html\">https://paramiko-docs.readthedocs.org/en/1.15/api/client.html</a></p>\n<h1 id=\"SCP-vs-SFTP\"><a href=\"#SCP-vs-SFTP\" class=\"headerlink\" title=\"SCP vs SFTP\"></a>SCP vs SFTP</h1><p>通过paramiko还可以传输文件，这是我写这篇博客的主要原因。搜了很多博客，都没有说明白如何通过paramiko在计算机之间传输文件，通过阅读官方文档，发现有如下两种方式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sftp = paramiko.SFTPClient.from_transport(ssh.get_transport())</span><br><span class=\"line\">sftp = ssh.open_sftp()</span><br></pre></td></tr></table></figure>\n\n<p>即新建一个SFTPClient对象，该对象复用之前的SSH连接，因此，我们使用sftp传输文件时，不需要再次进行用户认证。</p>\n<p>文件上传</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [59]: sftp.put(&#x27;memory.py&#x27;, &#x27;memory.py&#x27;)</span><br><span class=\"line\">Out[59]: &lt;SFTPAttributes: [ size=288 uid=1000 gid=1000 mode=0100644 atime=1435391914 mtime=1435391914 ]&gt;</span><br></pre></td></tr></table></figure>\n<p>文件下载</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [60]: sftp.get(&#x27;memory.py&#x27;, &#x27;backup.py&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>执行命令</p>\n<p>paramiko并没有提供一个叫做scp的子模块，如果我们希望在计算机之间传输数据，可以通过sftp(sftp实现了scp所有的功能，也就没有必再实现一个scp)传输文件，还可以通过sftp执行命令，如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [44]: sftp.listdir()</span><br><span class=\"line\">Out[44]:</span><br><span class=\"line\">[&#x27;.viminfo&#x27;,</span><br><span class=\"line\">&#x27;.bash_logout&#x27;,</span><br><span class=\"line\">&#x27;.bash_history&#x27;,</span><br><span class=\"line\">&#x27;AgentBackkup_2018-06-10&#x27;,</span><br><span class=\"line\">&#x27;AgentBackup&#x27;,</span><br><span class=\"line\">&#x27;rdsAgent&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">In [45]: sftp.rename(&#x27;AgentBackkup_2018-06-10&#x27;, &#x27;AgentBackkup_2018-11-10&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">In [46]: sftp.listdir()</span><br><span class=\"line\">Out[46]:</span><br><span class=\"line\">[&#x27;AgentBackkup_2018-11-10&#x27;,</span><br><span class=\"line\">&#x27;.viminfo&#x27;,</span><br><span class=\"line\">&#x27;.bash_logout&#x27;,</span><br><span class=\"line\">&#x27;.bash_history&#x27;,</span><br><span class=\"line\">&#x27;AgentBackup&#x27;,</span><br><span class=\"line\">&#x27;rdsAgent&#x27;]</span><br></pre></td></tr></table></figure>\n<p>sftp提供了很多命令，具体内容可以参考官方文档 。</p>\n","slug":"Python-使用paramiko实现ssh和scp","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/11/22/Python-%E4%BD%BF%E7%94%A8paramiko%E5%AE%9E%E7%8E%B0ssh%E5%92%8Cscp/","excerpt":"Python使用paramiko模块实现ssh和scp","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://vwin.github.io/tags/ssh/"},{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"paramiko","slug":"paramiko","permalink":"http://vwin.github.io/tags/paramiko/"},{"name":"scp","slug":"scp","permalink":"http://vwin.github.io/tags/scp/"}]},{"title":"Python 解析一行中的多个json对象","date":"2018-11-14T17:05:01.000Z","path":"2018/11/14/Python-解析一行中的多个JSon对象/","text":"最近遇到一个需要解析一行中有多个json对象的问题。比如：{“data1”: {“data1_inside”: “bla{bl&quot;a”}}{“data1”: {“data1_inside”: “blabla[“}}{“data1”: {“data1_inside”: “bla{bla”}}{“data1”: {“data1_inside”: “bla[“}} 方法一：re正则1234567import res = r&#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bl\\&quot;a&quot;&#125;&#125;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;blabla[&quot;&#125;&#125;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bla&quot;&#125;&#125;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla[&quot;&#125;&#125;&#x27;r = re.split(&#x27;(\\&#123;.*?\\&#125;)(?= *\\&#123;)&#x27;, s)[&#x27;&#x27;, &#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bl\\\\&quot;a&quot;&#125;&#125;&#x27;, &#x27;&#x27;, &#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;blabla[&quot;&#125;&#125;&#x27;, &#x27;&#x27;, &#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bla&quot;&#125;&#125;&#x27;, &#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla[&quot;&#125;&#125;&#x27;] 上述方法在遇到如果包含}{的时候会失败用下面的方法对每个子串进行校验r就是上面的结果 123456789accumulator = &#x27;&#x27;res = []for subs in r: accumulator += subs try: res.append(json.loads(accumulator)) accumulator = &#x27;&#x27; except: pass 方法二：json raw_decoder12345678dec = json.JSONDecoder()json_str = &#x27;&#123;&quot;data&quot;: &quot;Foo&quot;&#125;&#123;&quot;data&quot;: &quot;BarBaz&quot;&#125;&#123;&quot;data&quot;: &quot;Qux&quot;&#125;&#x27;dec.raw_decode(json_str)(&#123;u&#x27;data&#x27;: u&#x27;Foo&#x27;&#125;, 15)dec.raw_decode(json_str[15:])(&#123;u&#x27;data&#x27;: u&#x27;BarBaz&#x27;&#125;, 18)dec.raw_decode(json_str[33:])(&#123;u&#x27;data&#x27;: u&#x27;Qux&#x27;&#125;, 15) 可由上面输出得到，raw_decode会输出一个子串的position，所以使用循环搞定 123456dec = json.JSONDecoder()pos = 0while not pos == len(str(json_str)): j, json_len = dec.raw_decode(str(json_str)[pos:]) pos += json_len # Do something with the json j here","raw":"---\ntitle: Python 解析一行中的多个json对象\ntoc: true\ndate: 2018-11-15 01:05:01\ntags: [python,json]\ncategories: [技术]\ndescription:\n---\n\n最近遇到一个需要解析一行中有多个json对象的问题。\n比如：{\"data1\": {\"data1_inside\": \"bla{bl\\\"a\"}}{\"data1\": {\"data1_inside\": \"blabla[\"}}{\"data1\": {\"data1_inside\": \"bla{bla\"}}{\"data1\": {\"data1_inside\": \"bla[\"}}\n\n<!--more-->\n## 方法一：re正则\n```python\nimport re\n\ns = r'{\"data1\": {\"data1_inside\": \"bla{bl\\\"a\"}}{\"data1\": {\"data1_inside\": \"blabla[\"}}{\"data1\": {\"data1_inside\": \"bla{bla\"}}{\"data1\": {\"data1_inside\": \"bla[\"}}'\n\nr = re.split('(\\{.*?\\})(?= *\\{)', s)\n\n['', '{\"data1\": {\"data1_inside\": \"bla{bl\\\\\"a\"}}', '', '{\"data1\": {\"data1_inside\": \"blabla[\"}}', '', '{\"data1\": {\"data1_inside\": \"bla{bla\"}}', '{\"data1\": {\"data1_inside\": \"bla[\"}}']\n```\n\n上述方法在遇到如果包含}{的时候会失败\n用下面的方法对每个子串进行校验\nr就是上面的结果\n```python\naccumulator = ''\nres = []\nfor subs in r:\n    accumulator += subs\n    try:\n        res.append(json.loads(accumulator))\n        accumulator = ''\n    except:\n        pass\n```\n\n## 方法二：json raw_decoder\n```python\ndec = json.JSONDecoder()\njson_str = '{\"data\": \"Foo\"}{\"data\": \"BarBaz\"}{\"data\": \"Qux\"}'\ndec.raw_decode(json_str)\n({u'data': u'Foo'}, 15)\ndec.raw_decode(json_str[15:])\n({u'data': u'BarBaz'}, 18)\ndec.raw_decode(json_str[33:])\n({u'data': u'Qux'}, 15)\n```\n\n可由上面输出得到，raw_decode会输出一个子串的position，所以使用循环搞定\n```python\ndec = json.JSONDecoder()\npos = 0\nwhile not pos == len(str(json_str)):\n    j, json_len = dec.raw_decode(str(json_str)[pos:])\n    pos += json_len\n    # Do something with the json j here\n```\n","content":"<p>最近遇到一个需要解析一行中有多个json对象的问题。<br>比如：{“data1”: {“data1_inside”: “bla{bl&quot;a”}}{“data1”: {“data1_inside”: “blabla[“}}{“data1”: {“data1_inside”: “bla{bla”}}{“data1”: {“data1_inside”: “bla[“}}</p>\n<span id=\"more\"></span>\n<h2 id=\"方法一：re正则\"><a href=\"#方法一：re正则\" class=\"headerlink\" title=\"方法一：re正则\"></a>方法一：re正则</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">s = <span class=\"string\">r&#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bl\\&quot;a&quot;&#125;&#125;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;blabla[&quot;&#125;&#125;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bla&quot;&#125;&#125;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla[&quot;&#125;&#125;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">r = re.split(<span class=\"string\">&#x27;(\\&#123;.*?\\&#125;)(?= *\\&#123;)&#x27;</span>, s)</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bl\\\\&quot;a&quot;&#125;&#125;&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;blabla[&quot;&#125;&#125;&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla&#123;bla&quot;&#125;&#125;&#x27;</span>, <span class=\"string\">&#x27;&#123;&quot;data1&quot;: &#123;&quot;data1_inside&quot;: &quot;bla[&quot;&#125;&#125;&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>上述方法在遇到如果包含}{的时候会失败<br>用下面的方法对每个子串进行校验<br>r就是上面的结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">accumulator = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">res = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> subs <span class=\"keyword\">in</span> r:</span><br><span class=\"line\">    accumulator += subs</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        res.append(json.loads(accumulator))</span><br><span class=\"line\">        accumulator = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法二：json-raw-decoder\"><a href=\"#方法二：json-raw-decoder\" class=\"headerlink\" title=\"方法二：json raw_decoder\"></a>方法二：json raw_decoder</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dec = json.JSONDecoder()</span><br><span class=\"line\">json_str = <span class=\"string\">&#x27;&#123;&quot;data&quot;: &quot;Foo&quot;&#125;&#123;&quot;data&quot;: &quot;BarBaz&quot;&#125;&#123;&quot;data&quot;: &quot;Qux&quot;&#125;&#x27;</span></span><br><span class=\"line\">dec.raw_decode(json_str)</span><br><span class=\"line\">(&#123;<span class=\"string\">u&#x27;data&#x27;</span>: <span class=\"string\">u&#x27;Foo&#x27;</span>&#125;, <span class=\"number\">15</span>)</span><br><span class=\"line\">dec.raw_decode(json_str[<span class=\"number\">15</span>:])</span><br><span class=\"line\">(&#123;<span class=\"string\">u&#x27;data&#x27;</span>: <span class=\"string\">u&#x27;BarBaz&#x27;</span>&#125;, <span class=\"number\">18</span>)</span><br><span class=\"line\">dec.raw_decode(json_str[<span class=\"number\">33</span>:])</span><br><span class=\"line\">(&#123;<span class=\"string\">u&#x27;data&#x27;</span>: <span class=\"string\">u&#x27;Qux&#x27;</span>&#125;, <span class=\"number\">15</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可由上面输出得到，raw_decode会输出一个子串的position，所以使用循环搞定</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dec = json.JSONDecoder()</span><br><span class=\"line\">pos = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> pos == <span class=\"built_in\">len</span>(<span class=\"built_in\">str</span>(json_str)):</span><br><span class=\"line\">    j, json_len = dec.raw_decode(<span class=\"built_in\">str</span>(json_str)[pos:])</span><br><span class=\"line\">    pos += json_len</span><br><span class=\"line\">    <span class=\"comment\"># Do something with the json j here</span></span><br></pre></td></tr></table></figure>\n","slug":"Python-解析一行中的多个JSon对象","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/11/14/Python-%E8%A7%A3%E6%9E%90%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AAJSon%E5%AF%B9%E8%B1%A1/","excerpt":"最近遇到一个需要解析一行中有多个json对象的问题。比如：{“data1”: {“data1_inside”: “bla{bl&quot;a”}}{“data1”: {“data1_inside”: “blabla[“}}{“data1”: {“data1_inside”: “bla{bla”}}{“data1”: {“data1_inside”: “bla[“}}","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"json","slug":"json","permalink":"http://vwin.github.io/tags/json/"}]},{"title":"TP FP TN FN ROC理解","date":"2018-11-11T13:37:20.000Z","path":"2018/11/11/TP-FP-TN-FN-ROC理解/","text":"机器学习中算法评估的几个概念，tp,fp,tn,fn,roc,auc,F1值的理解 True Positive （真正, TP）被模型预测为正的正样本；可以称作判断为真的正确率 True Negative（真负 , TN）被模型预测为负的负样本 ；可以称作判断为假的正确率 False Positive （假正, FP）被模型预测为正的负样本；可以称作误报率 False Negative（假负 , FN）被模型预测为负的正样本；可以称作漏报率 True Positive Rate（真正率 , TPR）或灵敏度（sensitivity）TPR &#x3D; TP &#x2F;（TP + FN）正样本预测结果数 &#x2F; 正样本实际数 True Negative Rate（真负率 , TNR）或特指度（specificity）TNR &#x3D; TN &#x2F;（TN + FP）负样本预测结果数 &#x2F; 负样本实际数 False Positive Rate （假正率, FPR）FPR &#x3D; FP &#x2F;（FP + TN）被预测为正的负样本结果数 &#x2F;负样本实际数 False Negative Rate（假负率 , FNR）FNR &#x3D; FN &#x2F;（TP + FN）被预测为负的正样本结果数 &#x2F; 正样本实际数 精确度（Precision）：P &#x3D; TP&#x2F;(TP+FP) ; 反映了被分类器判定的正例中真正的正例样本的比重 准确率（Accuracy）A &#x3D; (TP + TN)&#x2F;(P+N) &#x3D; (TP + TN)&#x2F;(TP + FN + FP + TN);反映了分类器统对整个样本的判定能力——能将正的判定为正，负的判定为负 召回率(Recall)，也称为 True Positive Rate:R &#x3D; TP&#x2F;(TP+FN) &#x3D; 1 - FN&#x2F;T; 反映了被正确判定的正例占总的正例的比重 ROC曲线指受试者工作特征曲线 &#x2F; 接收器操作特性曲线(receiver operating characteristic curve), 是反映敏感性和特异性连续变量的综合指标,是用构图法揭示敏感性和特异性的相互关系，它通过将连续变量设定出多个不同的临界值，从而计算出一系列敏感性和特异性，再以敏感性为纵坐标、（1-特异性）为横坐标绘制成曲线，曲线下面积越大，诊断准确性越高。在ROC曲线上，最靠近坐标图左上方的点为敏感性和特异性均较高的临界值。 精确率(Precision）是指在所有系统判定的“真”的样本中，确实是真的的占比，就是TP&#x2F;(TP+FP)。 召回率（Recall）是指在所有确实为真的样本中，被判为的“真”的占比，就是TP&#x2F;(TP+FN)。 FPR（False Positive Rate），又被称为“Probability of False Alarm”，就是所有确实为“假”的样本中，被误判真的样本，或者FP&#x2F;(FP+TN) F1值是为了综合考量精确率和召回率而设计的一个指标，一般公式为取P和R的harmonic mean:2PrecisionRecall&#x2F;(Precision+Recall)。 ROC&#x3D;Receiver Operating Characteristic，是TPR vs FPR的曲线；与之对应的是Precision-Recall Curve，展示的是Precision vs Recall的曲线。 参考：知乎","raw":"---\ntitle: TP FP TN FN ROC理解\ntoc: true\ndate: 2018-11-11 21:37:20\ntags: [tp,fn,tn,fp,roc,AI评测]\ncategories: [技术]\ndescription:\n---\n机器学习中算法评估的几个概念，tp,fp,tn,fn,roc,auc,F1值的理解\n<!--more-->\n\n1. True Positive （真正, TP）被模型预测为正的正样本；可以称作判断为真的正确率\n2. True Negative（真负 , TN）被模型预测为负的负样本 ；可以称作判断为假的正确率\n3. False Positive （假正, FP）被模型预测为正的负样本；可以称作误报率\n4. False Negative（假负 , FN）被模型预测为负的正样本；可以称作漏报率\n5. True Positive Rate（真正率 , TPR）或灵敏度（sensitivity） \nTPR = TP /（TP + FN） \n正样本预测结果数 / 正样本实际数\n6. True Negative Rate（真负率 , TNR）或特指度（specificity） \nTNR = TN /（TN + FP） \n负样本预测结果数 / 负样本实际数\n7. False Positive Rate （假正率, FPR） \nFPR = FP /（FP + TN） \n被预测为正的负样本结果数 /负样本实际数\n8. False Negative Rate（假负率 , FNR） \nFNR = FN /（TP + FN） \n被预测为负的正样本结果数 / 正样本实际数\n9. 精确度（Precision）： \nP = TP/(TP+FP) ; 反映了被分类器判定的正例中真正的正例样本的比重\n10. 准确率（Accuracy） \nA = (TP + TN)/(P+N) = (TP + TN)/(TP + FN + FP + TN);\n反映了分类器统对整个样本的判定能力——能将正的判定为正，负的判定为负\n11. 召回率(Recall)，也称为 True Positive Rate: \nR = TP/(TP+FN) = 1 - FN/T; 反映了被正确判定的正例占总的正例的比重\n12. ROC曲线指受试者工作特征曲线 / 接收器操作特性曲线(receiver operating characteristic curve), 是反映敏感性和特异性连续变量的综合指标,是用构图法揭示敏感性和特异性的相互关系，它通过将连续变量设定出多个不同的临界值，从而计算出一系列敏感性和特异性，再以敏感性为纵坐标、（1-特异性）为横坐标绘制成曲线，曲线下面积越大，诊断准确性越高。在ROC曲线上，最靠近坐标图左上方的点为敏感性和特异性均较高的临界值。\n13. 精确率(Precision）是指在所有系统判定的“真”的样本中，确实是真的的占比，就是TP/(TP+FP)。\n14. 召回率（Recall）是指在所有确实为真的样本中，被判为的“真”的占比，就是TP/(TP+FN)。\n15. FPR（False Positive Rate），又被称为“Probability of False Alarm”，就是所有确实为“假”的样本中，被误判真的样本，或者FP/(FP+TN)\n16. F1值是为了综合考量精确率和召回率而设计的一个指标，一般公式为取P和R的harmonic mean:2*Precision*Recall/(Precision+Recall)。\n17. ROC=Receiver Operating Characteristic，是TPR vs FPR的曲线；与之对应的是Precision-Recall Curve，展示的是Precision vs Recall的曲线。\n\n参考：\n[知乎](https://www.zhihu.com/question/30643044/answer/161955532)\n","content":"<p>机器学习中算法评估的几个概念，tp,fp,tn,fn,roc,auc,F1值的理解</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>True Positive （真正, TP）被模型预测为正的正样本；可以称作判断为真的正确率</li>\n<li>True Negative（真负 , TN）被模型预测为负的负样本 ；可以称作判断为假的正确率</li>\n<li>False Positive （假正, FP）被模型预测为正的负样本；可以称作误报率</li>\n<li>False Negative（假负 , FN）被模型预测为负的正样本；可以称作漏报率</li>\n<li>True Positive Rate（真正率 , TPR）或灵敏度（sensitivity）<br>TPR &#x3D; TP &#x2F;（TP + FN）<br>正样本预测结果数 &#x2F; 正样本实际数</li>\n<li>True Negative Rate（真负率 , TNR）或特指度（specificity）<br>TNR &#x3D; TN &#x2F;（TN + FP）<br>负样本预测结果数 &#x2F; 负样本实际数</li>\n<li>False Positive Rate （假正率, FPR）<br>FPR &#x3D; FP &#x2F;（FP + TN）<br>被预测为正的负样本结果数 &#x2F;负样本实际数</li>\n<li>False Negative Rate（假负率 , FNR）<br>FNR &#x3D; FN &#x2F;（TP + FN）<br>被预测为负的正样本结果数 &#x2F; 正样本实际数</li>\n<li>精确度（Precision）：<br>P &#x3D; TP&#x2F;(TP+FP) ; 反映了被分类器判定的正例中真正的正例样本的比重</li>\n<li>准确率（Accuracy）<br>A &#x3D; (TP + TN)&#x2F;(P+N) &#x3D; (TP + TN)&#x2F;(TP + FN + FP + TN);<br>反映了分类器统对整个样本的判定能力——能将正的判定为正，负的判定为负</li>\n<li>召回率(Recall)，也称为 True Positive Rate:<br>R &#x3D; TP&#x2F;(TP+FN) &#x3D; 1 - FN&#x2F;T; 反映了被正确判定的正例占总的正例的比重</li>\n<li>ROC曲线指受试者工作特征曲线 &#x2F; 接收器操作特性曲线(receiver operating characteristic curve), 是反映敏感性和特异性连续变量的综合指标,是用构图法揭示敏感性和特异性的相互关系，它通过将连续变量设定出多个不同的临界值，从而计算出一系列敏感性和特异性，再以敏感性为纵坐标、（1-特异性）为横坐标绘制成曲线，曲线下面积越大，诊断准确性越高。在ROC曲线上，最靠近坐标图左上方的点为敏感性和特异性均较高的临界值。</li>\n<li>精确率(Precision）是指在所有系统判定的“真”的样本中，确实是真的的占比，就是TP&#x2F;(TP+FP)。</li>\n<li>召回率（Recall）是指在所有确实为真的样本中，被判为的“真”的占比，就是TP&#x2F;(TP+FN)。</li>\n<li>FPR（False Positive Rate），又被称为“Probability of False Alarm”，就是所有确实为“假”的样本中，被误判真的样本，或者FP&#x2F;(FP+TN)</li>\n<li>F1值是为了综合考量精确率和召回率而设计的一个指标，一般公式为取P和R的harmonic mean:2<em>Precision</em>Recall&#x2F;(Precision+Recall)。</li>\n<li>ROC&#x3D;Receiver Operating Characteristic，是TPR vs FPR的曲线；与之对应的是Precision-Recall Curve，展示的是Precision vs Recall的曲线。</li>\n</ol>\n<p>参考：<br><a href=\"https://www.zhihu.com/question/30643044/answer/161955532\">知乎</a></p>\n","slug":"TP-FP-TN-FN-ROC理解","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/11/11/TP-FP-TN-FN-ROC%E7%90%86%E8%A7%A3/","excerpt":"机器学习中算法评估的几个概念，tp,fp,tn,fn,roc,auc,F1值的理解","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"tp","slug":"tp","permalink":"http://vwin.github.io/tags/tp/"},{"name":"fn","slug":"fn","permalink":"http://vwin.github.io/tags/fn/"},{"name":"tn","slug":"tn","permalink":"http://vwin.github.io/tags/tn/"},{"name":"fp","slug":"fp","permalink":"http://vwin.github.io/tags/fp/"},{"name":"roc","slug":"roc","permalink":"http://vwin.github.io/tags/roc/"},{"name":"AI评测","slug":"AI评测","permalink":"http://vwin.github.io/tags/AI%E8%AF%84%E6%B5%8B/"}]},{"title":"Python 检测生僻字","date":"2018-11-01T16:43:44.000Z","path":"2018/11/01/Python-检测生僻字/","text":"Python 检测生僻字 最近碰到一个需求，要求检测字段是否包含生僻字以及一些非法字符如 ~!@#$%^&amp;*。 首先想到的就是利用 python 的正则表达式来匹配非法字符，然后找出非法记录。然而理想总是丰满的，现实却是残酷的。在实现的过程中，才发现自己对于字符编码、以及 python 内部字符串表示的相关知识的缺乏。在这期间，踩过了不少坑，到最后虽然还有些模糊的地方，但总算有一个总体清晰的了解。在此记录下心得，避免以后在同一个地方跌倒。 以下的测试环境是 python 2.7.8 环境，不保证其他 python 环境也适用。 python 正则表达式python 中的正则功能由内嵌的 re 函数库提供，主要用到 3 个函数。re.compile() 提供可重用的正则表达式，match() 和 search() 函数返回匹配结果，两者之间的区别在于： match() 从指定位置开始匹配，search() 会从指定位置向后搜索直到找到匹配字符串。例如下面的代码中，match_result 从第一个字符 f 开始匹配，匹配失败返回空值；search_result 从 f 开始向后搜索，直到找到第一个匹配的字符 a, 然后通过 group() 函数输出匹配结果为字符 a。 12345678910import repattern = re.compile(&#x27;[abc]&#x27;)match_result = pattern.match(&#x27;fabc&#x27;)if match_result: print match_result.group()search_result = pattern.search(&#x27;fabc&#x27;)if search_result: print search_result.group() 以上的实现方式需要先编译一个 pattern，然后再进行匹配。实际上，我们可以直接利用 re.match(pattern, string) 函数来实现相同的功能。但是直接匹配的方式没有先编译再匹配的方式灵活，首先是正则表达式没办法重用，如果大量数据进行同一模式匹配，意味着每次都需要内部编译，造成性能损失；另外，re.match() 函数没有 pattern.match() 功能强大，后者可以指定从哪个位置开始匹配。 编码问题了解 python 正则的基本功能后，剩下的事情就是找到一个合适的正则表达式来匹配生僻字和非法字符。非法字符很简单，采用以下 pattern 就可以实现匹配：pattern &#x3D; re.compile(r’[~!@#$%^&amp;* ]’)然而对于生僻字的匹配，着实难倒了我。首先是对于生僻字的定义，什么样的字算生僻字？经过咨询项目经理，规定非 GB2312 的字符属于生僻字。接下来的问题是，如何匹配 GB2312 字符？ 经过查询，GB2312 的范围是 [\\xA1-\\xF7][\\xA1-\\xFE]，其中汉字区的范围是 [\\xB0-\\xF7][\\xA1-\\xFE]。因此，添加生僻字匹配后的表达式为： pattern &#x3D; re.compile(r’[~!@#$%^&amp;* ]|[^\\xA1-\\xF7][^\\xA1-\\xFE]’)问题似乎是顺理得当地解决了，然而我还是 too simple too naive 。由于要判断的字符串都是从图层文件读取的，arcpy 贴心地将读取的字符编码为 unicode 格式。因此，我需要找出 GB2312 字符集在 unicode 中的编码范围。但现实是，GB2312 字符集在 unicode 中的分布并不是连续的，使用正则表示这个范围必定是非常复杂的。使用正则表达式匹配生僻字的构想，似乎陷入了死胡同。 解决方案既然提供的字符串是 unicode 格式，那么我可不可以将其转换为 GB2312 再进行匹配呢？实际上是不行，因为 unicode 字符集要远大于 GB2312 字符集，因此 GB2312 &#x3D;&gt; unicode 总是可以实现的，而反过来 unicode &#x3D;&gt; GB2312 不一定能成功。 这突然为我提供了另外一种思路，假设一个字符串的 unicode &#x3D;&gt; GB2312 转换会失败，那么是不是恰恰说明了它不属于 GB2312 字符集？所以，我使用 unicode_string.encode(‘GB2312’) 函数尝试转换字符串，捕获 UnicodeEncodeError 异常来识别生僻字。 最终的代码如下： 1234567891011121314import redef is_rare_name(string): pattern = re.compile(u&quot;[~!@#$%^&amp;* ]&quot;) match = pattern.search(string) if match: return True try: string.encode(&quot;gb2312&quot;) except UnicodeEncodeError: return True return False","raw":"---\ntitle: Python 检测生僻字\ntoc: true\ndate: 2018-11-02 00:43:44\ntags: [Python,re]\ncategories: [技术]\ndescription:\n---\nPython 检测生僻字\n<!--more-->\n\n最近碰到一个需求，要求检测字段是否包含生僻字以及一些非法字符如 ~!@#$%^&*。\n\n首先想到的就是利用 python 的正则表达式来匹配非法字符，然后找出非法记录。然而理想总是丰满的，现实却是残酷的。在实现的过程中，才发现自己对于字符编码、以及 python 内部字符串表示的相关知识的缺乏。在这期间，踩过了不少坑，到最后虽然还有些模糊的地方，但总算有一个总体清晰的了解。在此记录下心得，避免以后在同一个地方跌倒。\n\n以下的测试环境是 python 2.7.8 环境，不保证其他 python 环境也适用。\n\npython 正则表达式\npython 中的正则功能由内嵌的 re 函数库提供，主要用到 3 个函数。re.compile() 提供可重用的正则表达式，match() 和 search() 函数返回匹配结果，两者之间的区别在于： match() 从指定位置开始匹配，search() 会从指定位置向后搜索直到找到匹配字符串。例如下面的代码中，match_result 从第一个字符 f 开始匹配，匹配失败返回空值；search_result 从 f 开始向后搜索，直到找到第一个匹配的字符 a, 然后通过 group() 函数输出匹配结果为字符 a。\n\n```python\nimport re\n\npattern = re.compile('[abc]')\nmatch_result = pattern.match('fabc')\nif match_result:\n\tprint match_result.group()\n\nsearch_result = pattern.search('fabc')\nif search_result:\n\tprint search_result.group()\n```\n\n以上的实现方式需要先编译一个 pattern，然后再进行匹配。实际上，我们可以直接利用 re.match(pattern, string) 函数来实现相同的功能。但是直接匹配的方式没有先编译再匹配的方式灵活，首先是正则表达式没办法重用，如果大量数据进行同一模式匹配，意味着每次都需要内部编译，造成性能损失；另外，re.match() 函数没有 pattern.match() 功能强大，后者可以指定从哪个位置开始匹配。\n\n编码问题\n了解 python 正则的基本功能后，剩下的事情就是找到一个合适的正则表达式来匹配生僻字和非法字符。非法字符很简单，采用以下 pattern 就可以实现匹配：\npattern = re.compile(r'[~!@#$%^&* ]')\n然而对于生僻字的匹配，着实难倒了我。首先是对于生僻字的定义，什么样的字算生僻字？经过咨询项目经理，规定非 GB2312 的字符属于生僻字。接下来的问题是，如何匹配 GB2312 字符？\n\n经过查询，GB2312 的范围是 [\\xA1-\\xF7][\\xA1-\\xFE]，其中汉字区的范围是 [\\xB0-\\xF7][\\xA1-\\xFE]。因此，添加生僻字匹配后的表达式为：\n\npattern = re.compile(r'[~!@#$%^&* ]|[^\\xA1-\\xF7][^\\xA1-\\xFE]')\n问题似乎是顺理得当地解决了，然而我还是 too simple too naive 。由于要判断的字符串都是从图层文件读取的，arcpy 贴心地将读取的字符编码为 unicode 格式。因此，我需要找出 GB2312 字符集在 unicode 中的编码范围。但现实是，GB2312 字符集在 unicode 中的分布并不是连续的，使用正则表示这个范围必定是非常复杂的。使用正则表达式匹配生僻字的构想，似乎陷入了死胡同。\n\n解决方案\n既然提供的字符串是 unicode 格式，那么我可不可以将其转换为 GB2312 再进行匹配呢？实际上是不行，因为 unicode 字符集要远大于 GB2312 字符集，因此 GB2312 => unicode 总是可以实现的，而反过来 unicode => GB2312 不一定能成功。\n\n这突然为我提供了另外一种思路，假设一个字符串的 unicode => GB2312 转换会失败，那么是不是恰恰说明了它不属于 GB2312 字符集？所以，我使用 unicode_string.encode('GB2312') 函数尝试转换字符串，捕获 UnicodeEncodeError 异常来识别生僻字。\n\n最终的代码如下：\n\n```python\nimport re\n\ndef is_rare_name(string):\n\tpattern = re.compile(u\"[~!@#$%^&* ]\")\n\tmatch = pattern.search(string)\n\tif match:\n\t\treturn True\n\n\ttry:\n        string.encode(\"gb2312\")\n    except UnicodeEncodeError:\n    \treturn True\n\n    return False\n```","content":"<p>Python 检测生僻字</p>\n<span id=\"more\"></span>\n\n<p>最近碰到一个需求，要求检测字段是否包含生僻字以及一些非法字符如 ~!@#$%^&amp;*。</p>\n<p>首先想到的就是利用 python 的正则表达式来匹配非法字符，然后找出非法记录。然而理想总是丰满的，现实却是残酷的。在实现的过程中，才发现自己对于字符编码、以及 python 内部字符串表示的相关知识的缺乏。在这期间，踩过了不少坑，到最后虽然还有些模糊的地方，但总算有一个总体清晰的了解。在此记录下心得，避免以后在同一个地方跌倒。</p>\n<p>以下的测试环境是 python 2.7.8 环境，不保证其他 python 环境也适用。</p>\n<p>python 正则表达式<br>python 中的正则功能由内嵌的 re 函数库提供，主要用到 3 个函数。re.compile() 提供可重用的正则表达式，match() 和 search() 函数返回匹配结果，两者之间的区别在于： match() 从指定位置开始匹配，search() 会从指定位置向后搜索直到找到匹配字符串。例如下面的代码中，match_result 从第一个字符 f 开始匹配，匹配失败返回空值；search_result 从 f 开始向后搜索，直到找到第一个匹配的字符 a, 然后通过 group() 函数输出匹配结果为字符 a。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">&#x27;[abc]&#x27;</span>)</span><br><span class=\"line\">match_result = pattern.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;fabc&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> match_result:</span><br><span class=\"line\">\t<span class=\"built_in\">print</span> match_result.group()</span><br><span class=\"line\"></span><br><span class=\"line\">search_result = pattern.search(<span class=\"string\">&#x27;fabc&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> search_result:</span><br><span class=\"line\">\t<span class=\"built_in\">print</span> search_result.group()</span><br></pre></td></tr></table></figure>\n\n<p>以上的实现方式需要先编译一个 pattern，然后再进行匹配。实际上，我们可以直接利用 re.match(pattern, string) 函数来实现相同的功能。但是直接匹配的方式没有先编译再匹配的方式灵活，首先是正则表达式没办法重用，如果大量数据进行同一模式匹配，意味着每次都需要内部编译，造成性能损失；另外，re.match() 函数没有 pattern.match() 功能强大，后者可以指定从哪个位置开始匹配。</p>\n<p>编码问题<br>了解 python 正则的基本功能后，剩下的事情就是找到一个合适的正则表达式来匹配生僻字和非法字符。非法字符很简单，采用以下 pattern 就可以实现匹配：<br>pattern &#x3D; re.compile(r’[~!@#$%^&amp;* ]’)<br>然而对于生僻字的匹配，着实难倒了我。首先是对于生僻字的定义，什么样的字算生僻字？经过咨询项目经理，规定非 GB2312 的字符属于生僻字。接下来的问题是，如何匹配 GB2312 字符？</p>\n<p>经过查询，GB2312 的范围是 [\\xA1-\\xF7][\\xA1-\\xFE]，其中汉字区的范围是 [\\xB0-\\xF7][\\xA1-\\xFE]。因此，添加生僻字匹配后的表达式为：</p>\n<p>pattern &#x3D; re.compile(r’[~!@#$%^&amp;* ]|[^\\xA1-\\xF7][^\\xA1-\\xFE]’)<br>问题似乎是顺理得当地解决了，然而我还是 too simple too naive 。由于要判断的字符串都是从图层文件读取的，arcpy 贴心地将读取的字符编码为 unicode 格式。因此，我需要找出 GB2312 字符集在 unicode 中的编码范围。但现实是，GB2312 字符集在 unicode 中的分布并不是连续的，使用正则表示这个范围必定是非常复杂的。使用正则表达式匹配生僻字的构想，似乎陷入了死胡同。</p>\n<p>解决方案<br>既然提供的字符串是 unicode 格式，那么我可不可以将其转换为 GB2312 再进行匹配呢？实际上是不行，因为 unicode 字符集要远大于 GB2312 字符集，因此 GB2312 &#x3D;&gt; unicode 总是可以实现的，而反过来 unicode &#x3D;&gt; GB2312 不一定能成功。</p>\n<p>这突然为我提供了另外一种思路，假设一个字符串的 unicode &#x3D;&gt; GB2312 转换会失败，那么是不是恰恰说明了它不属于 GB2312 字符集？所以，我使用 unicode_string.encode(‘GB2312’) 函数尝试转换字符串，捕获 UnicodeEncodeError 异常来识别生僻字。</p>\n<p>最终的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">is_rare_name</span>(<span class=\"params\">string</span>):</span><br><span class=\"line\">\tpattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">u&quot;[~!@#$%^&amp;* ]&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">match</span> = pattern.search(string)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"keyword\">match</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span>:</span><br><span class=\"line\">        string.encode(<span class=\"string\">&quot;gb2312&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> UnicodeEncodeError:</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>","slug":"Python-检测生僻字","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/11/01/Python-%E6%A3%80%E6%B5%8B%E7%94%9F%E5%83%BB%E5%AD%97/","excerpt":"Python 检测生僻字","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://vwin.github.io/tags/Python/"},{"name":"re","slug":"re","permalink":"http://vwin.github.io/tags/re/"}]},{"title":"Linux命令总结","date":"2018-10-25T15:42:19.000Z","path":"2018/10/25/Linux命令总结/","text":"常用Linux命令总结 timeout 命令 timeout默认单位是秒，后缀”s”代表秒(默认值)，”m”代表分，”h”代表小时，”d”代表天。 1timeout 10 top //代表top命令运行10s后自动结束 sudosudo -E : 代表使用当前的环境变量","raw":"---\ntitle: Linux命令总结\ntoc: true\ndate: 2018-10-25 23:42:19\ntags: [linux,timeout,sudo]\ncategories: [技术]\ndescription:\n---\n\n常用Linux命令总结\n\n<!--more-->\n1. timeout 命令\n\ntimeout默认单位是秒，后缀”s”代表秒(默认值)，”m”代表分，”h”代表小时，”d”代表天。\n```shell\ntimeout 10 top //代表top命令运行10s后自动结束\n```\n\n2. sudo\nsudo -E : 代表使用当前的环境变量\n","content":"<p>常用Linux命令总结</p>\n<span id=\"more\"></span>\n<ol>\n<li>timeout 命令</li>\n</ol>\n<p>timeout默认单位是秒，后缀”s”代表秒(默认值)，”m”代表分，”h”代表小时，”d”代表天。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout 10 top //代表top命令运行10s后自动结束</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>sudo<br>sudo -E : 代表使用当前的环境变量</li>\n</ol>\n","slug":"Linux命令总结","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/25/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","excerpt":"常用Linux命令总结","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"timeout","slug":"timeout","permalink":"http://vwin.github.io/tags/timeout/"},{"name":"sudo","slug":"sudo","permalink":"http://vwin.github.io/tags/sudo/"}]},{"title":"BIO,NIO,AIO理解","date":"2018-10-24T11:35:45.000Z","path":"2018/10/24/BIO-NIO-AIO理解/","text":"同步，异步阻塞，非阻塞 IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。 BIO在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。 NIONIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I&#x2F;O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。 NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。 也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。 BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。 NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。 在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。 HTTP&#x2F;1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。 AIO与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read&#x2F;write方法都是异步的，完成后会主动调用回调函数。 在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道： AsynchronousSocketChannel AsynchronousServerSocketChannel AsynchronousFileChannel AsynchronousDatagramChannel其中的read&#x2F;write方法，会返回一个带回调函数的对象，当执行完读取&#x2F;写入操作后，直接调用回调函数。 BIO是一个连接一个线程。NIO是一个请求一个线程。AIO是一个有效请求一个线程。 先来个例子理解一下概念，以银行取款为例： 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）； 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）； 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）； 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成） Java对BIO、NIO、AIO的支持： Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。 Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， BIO、NIO、AIO适用场景分析: BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 另外，I&#x2F;O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。 在高性能的I&#x2F;O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I&#x2F;O，而Proactor运用于异步I&#x2F;O操作。 在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。 一般来说I&#x2F;O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO 同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！ 同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。 异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！ 异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。","raw":"---\ntitle: 'BIO,NIO,AIO理解'\ntoc: true\ndate: 2018-10-24 19:35:45\ntags: [bio,nio,aio]\ncategories: [技术]\ndescription:\n---\n同步，异步\n阻塞，非阻塞\n<!--more-->\n\nIO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。\n\n## BIO\n在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。\n\n## NIO\nNIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。\n\nNIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。\n\nBIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fwjjocz4hgj30bk0e275d.jpg)\n\nNIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。\n\n在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。\n\nHTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。\n\n## AIO\n\n与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。  在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：\n\n- AsynchronousSocketChannel\n- AsynchronousServerSocketChannel\n- AsynchronousFileChannel\n- AsynchronousDatagramChannel\n其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。\n\nBIO是一个连接一个线程。\nNIO是一个请求一个线程。\nAIO是一个有效请求一个线程。\n\n先来个例子理解一下概念，以银行取款为例： \n\n1. 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；\n2. 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；\n3. 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；\n4. 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）\n\nJava对BIO、NIO、AIO的支持：\n1. Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。\n2. Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。\n3. Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，\n\nBIO、NIO、AIO适用场景分析:\n\n1. BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。\n2. NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。\n3. AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。\n\n另外，I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。\n\n在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。\n\n在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。\n\n一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO\n\n1. 同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！\n2. 同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。\n3. 异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！\n4. 异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。  ","content":"<p>同步，异步<br>阻塞，非阻塞</p>\n<span id=\"more\"></span>\n\n<p>IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。</p>\n<h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。</p>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I&#x2F;O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。</p>\n<p>NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>\n<p>BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。<br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fwjjocz4hgj30bk0e275d.jpg\"></p>\n<p>NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p>\n<p>在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。</p>\n<p>HTTP&#x2F;1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。</p>\n<h2 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h2><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read&#x2F;write方法都是异步的，完成后会主动调用回调函数。  在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：</p>\n<ul>\n<li>AsynchronousSocketChannel</li>\n<li>AsynchronousServerSocketChannel</li>\n<li>AsynchronousFileChannel</li>\n<li>AsynchronousDatagramChannel<br>其中的read&#x2F;write方法，会返回一个带回调函数的对象，当执行完读取&#x2F;写入操作后，直接调用回调函数。</li>\n</ul>\n<p>BIO是一个连接一个线程。<br>NIO是一个请求一个线程。<br>AIO是一个有效请求一个线程。</p>\n<p>先来个例子理解一下概念，以银行取款为例： </p>\n<ol>\n<li>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；</li>\n<li>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；</li>\n<li>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；</li>\n<li>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）</li>\n</ol>\n<p>Java对BIO、NIO、AIO的支持：</p>\n<ol>\n<li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>\n<li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>\n<li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li>\n</ol>\n<p>BIO、NIO、AIO适用场景分析:</p>\n<ol>\n<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>\n<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>\n<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>\n</ol>\n<p>另外，I&#x2F;O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。</p>\n<p>在高性能的I&#x2F;O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I&#x2F;O，而Proactor运用于异步I&#x2F;O操作。</p>\n<p>在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。</p>\n<p>一般来说I&#x2F;O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO</p>\n<ol>\n<li>同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！</li>\n<li>同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。</li>\n<li>异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！</li>\n<li>异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。</li>\n</ol>\n","slug":"BIO-NIO-AIO理解","updated":"2022-11-27T10:39:22.787Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/24/BIO-NIO-AIO%E7%90%86%E8%A7%A3/","excerpt":"同步，异步阻塞，非阻塞","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"bio","slug":"bio","permalink":"http://vwin.github.io/tags/bio/"},{"name":"nio","slug":"nio","permalink":"http://vwin.github.io/tags/nio/"},{"name":"aio","slug":"aio","permalink":"http://vwin.github.io/tags/aio/"}]},{"title":"kafka-topics.sh --describe显示结果解释","date":"2018-10-22T20:23:29.000Z","path":"2018/10/22/kafka-topics-sh-describe显示结果解释/","text":"Kafka-topics.sh –describe 显示结果解释 123&gt; bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topicTopic:my-replicated-topic PartitionCount:1 ReplicationFactor:3 Configs: Topic: my-replicated-topic Partition: 0 Leader: 1 Replicas: 1,2,0 Isr: 1,2,0 第一个行显示所有partitions的一个总结，以下每一行给出一个partition中的信息，如果我们只有一个partition，则只显示一行。 leader：是在给出的所有partitons中负责读写的节点，每个节点都有可能成为leaderreplicas：显示给定partiton所有副本所存储节点的节点列表，不管该节点是否是leader或者是否存活。isr：副本都已同步的的节点集合，这个集合中的所有节点都是存活状态，并且跟leader同步 12345[root@dx3 bin]# ./kafka-topics.sh --describe --zookeeper localhost:2183 --topic testTopic:test PartitionCount:3 ReplicationFactor:3 Configs: Topic: test Partition: 0 Leader: 0 Replicas: 0,1,2 Isr: 0,2,1 Topic: test Partition: 1 Leader: 1 Replicas: 1,2,0 Isr: 1,2,0 Topic: test Partition: 2 Leader: 2 Replicas: 2,0,1 Isr: 2,0,1 解释：测试Kafka集群一共三个节点，test这个Topic, 编号为0的Partition,Leader在broker.id&#x3D;0这个节点上，副本在broker.id为0 1 2这个三个几点，并且所有副本都存活，并跟broker.id&#x3D;0这个节点同步","raw":"---\ntitle: kafka-topics.sh --describe显示结果解释\ntoc: true\ndate: 2018-10-23 04:23:29\ntags: [kafka-topic.sh,describe]\ncategories: [技术]\ndescription:\n---\nKafka-topics.sh --describe 显示结果解释\n\n<!--more-->\n```shell\n> bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic\nTopic:my-replicated-topic\tPartitionCount:1\tReplicationFactor:3\tConfigs:\n\tTopic: my-replicated-topic\tPartition: 0\tLeader: 1\tReplicas: 1,2,0\tIsr: 1,2,0\n```\n\n第一个行显示所有partitions的一个总结，以下每一行给出一个partition中的信息，如果我们只有一个partition，则只显示一行。\n\nleader：是在给出的所有partitons中负责读写的节点，每个节点都有可能成为leader\nreplicas：显示给定partiton所有副本所存储节点的节点列表，不管该节点是否是leader或者是否存活。\nisr：副本都已同步的的节点集合，这个集合中的所有节点都是存活状态，并且跟leader同步\n\n```shell\n[root@dx3 bin]# ./kafka-topics.sh --describe --zookeeper localhost:2183 --topic test\nTopic:test    PartitionCount:3    ReplicationFactor:3    Configs:\n    Topic: test    Partition: 0    Leader: 0    Replicas: 0,1,2    Isr: 0,2,1\n    Topic: test    Partition: 1    Leader: 1    Replicas: 1,2,0    Isr: 1,2,0\n    Topic: test    Partition: 2    Leader: 2    Replicas: 2,0,1    Isr: 2,0,1\n```\n\n解释：\n测试Kafka集群一共三个节点，test这个Topic, 编号为0的Partition,Leader在broker.id=0这个节点上，副本在broker.id为0 1 2这个三个几点，并且所有副本都存活，并跟broker.id=0这个节点同步\n","content":"<p>Kafka-topics.sh –describe 显示结果解释</p>\n<span id=\"more\"></span>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</span></span><br><span class=\"line\">Topic:my-replicated-topic\tPartitionCount:1\tReplicationFactor:3\tConfigs:</span><br><span class=\"line\">\tTopic: my-replicated-topic\tPartition: 0\tLeader: 1\tReplicas: 1,2,0\tIsr: 1,2,0</span><br></pre></td></tr></table></figure>\n\n<p>第一个行显示所有partitions的一个总结，以下每一行给出一个partition中的信息，如果我们只有一个partition，则只显示一行。</p>\n<p>leader：是在给出的所有partitons中负责读写的节点，每个节点都有可能成为leader<br>replicas：显示给定partiton所有副本所存储节点的节点列表，不管该节点是否是leader或者是否存活。<br>isr：副本都已同步的的节点集合，这个集合中的所有节点都是存活状态，并且跟leader同步</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@dx3 bin]# ./kafka-topics.sh --describe --zookeeper localhost:2183 --topic test</span><br><span class=\"line\">Topic:test    PartitionCount:3    ReplicationFactor:3    Configs:</span><br><span class=\"line\">    Topic: test    Partition: 0    Leader: 0    Replicas: 0,1,2    Isr: 0,2,1</span><br><span class=\"line\">    Topic: test    Partition: 1    Leader: 1    Replicas: 1,2,0    Isr: 1,2,0</span><br><span class=\"line\">    Topic: test    Partition: 2    Leader: 2    Replicas: 2,0,1    Isr: 2,0,1</span><br></pre></td></tr></table></figure>\n\n<p>解释：<br>测试Kafka集群一共三个节点，test这个Topic, 编号为0的Partition,Leader在broker.id&#x3D;0这个节点上，副本在broker.id为0 1 2这个三个几点，并且所有副本都存活，并跟broker.id&#x3D;0这个节点同步</p>\n","slug":"kafka-topics-sh-describe显示结果解释","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/22/kafka-topics-sh-describe%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%9C%E8%A7%A3%E9%87%8A/","excerpt":"Kafka-topics.sh –describe 显示结果解释","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"kafka-topic.sh","slug":"kafka-topic-sh","permalink":"http://vwin.github.io/tags/kafka-topic-sh/"},{"name":"describe","slug":"describe","permalink":"http://vwin.github.io/tags/describe/"}]},{"title":"Kafka简介入门","date":"2018-10-16T11:45:46.000Z","path":"2018/10/16/Kafka-简介入门/","text":"Kafka工作原理 http://www.aboutyun.com/thread-11895-1-1.htmlkafka入门：简介、使用场景、设计原理、主要配置及集群搭建（转）:http://www.cnblogs.com/likehua/p/3999538.htmlapache kafka系列之在zookeeper中存储结构：http://blog.csdn.net/strawbingo/article/details/45484139Kafka文件存储机制那些事:http://www.open-open.com/lib/view/open1421150566328.htmlapache kafka系列之server.properties配置文件参数说明:http://blog.csdn.net/lizhitao/article/details/25667831kafka入门:http://bit1129.iteye.com/blog/2174791Kafka 设计与原理详解:http://blog.csdn.net/suifeng3051/article/details/48053965 Kafka系统的角色 Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic topic： 可以理解为一个MQ消息队列的名字 Partition： 为了实现扩展性，一个非常大的topic可以分布到多个 broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。 partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体 （多个partition间）的顺序。 也就是说，一个topic在集群中可以有多个partition，那么分区的策略是什么？(消息发送到哪个分区上，有两种基本的策略，一是采用Key Hash算法，一是采用Round Robin算法) Offset：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka Producer ：消息生产者，就是向kafka broker发消息的客户端。 Consumer ：消息消费者，向kafka broker取消息的客户端 Consumer Group （CG）： 消息系统有两类，一是广播，二是订阅发布。广播是把消息发送给所有的消费者；发布订阅是把消息只发送给订阅者。Kafka通过Consumer Group组合实现了这两种机制： 实现一个topic消息广播（发给所有的consumer）和单播（发给任意一个consumer）。一个topic可以有多个CG。 topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个 consumer（这是实现一个Topic多Consumer的关键点：为一个Topic定义一个CG，CG下定义多个Consumer）。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。 典型的应用场景是，多个Consumer来读取一个Topic(理想情况下是一个Consumer读取Topic的一个Partition）,那么可以让这些Consumer属于同一个Consumer Group即可实现消息的多Consumer并行处理，原理是Kafka将一个消息发布出去后，ConsumerGroup中的Consumers可以通过Round Robin的方式进行消费(Consumers之间的负载均衡使用Zookeeper来实现) Topic、Partition和Replica的关系如上图，一个Topic有四个Partition，每个Partition两个replication。 Zookeeper在Kakfa中扮演的角色Kafka将元数据信息保存在Zookeeper中，但是发送给Topic本身的数据是不会发到Zk上的，否则Zk就疯了。 kafka使用zookeeper来实现动态的集群扩展，不需要更改客户端（producer和consumer）的配置。broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新。 而客户端会在zookeeper上注册相关的watcher。一旦zookeeper发生变化，客户端能及时感知并作出相应调整。这样就保证了添加或去除broker时，各broker间仍能自动实现负载均衡。这里的客户端指的是Kafka的消息生产端(Producer)和消息消费端(Consumer) Broker端使用zookeeper来注册broker信息，以及监测partition leader存活性。 Consumer端使用zookeeper用来注册consumer信息，其中包括consumer消费的partition列表等，同时也用来发现broker列表，并和partition leader建立socket连接，并获取消息。 Zookeeper和Producer没有建立关系，只和Brokers、Consumers建立关系以实现负载均衡，即同一个Consumer Group中的Consumers可以实现负载均衡。 问题 Topic有多个Partition，那么消息分配到某个Partition的依据是什么？ Key Hash或者Round Robin 如何查看一个Topic有多少个Partition？ 使用kakfa-topic.sh –list topic topicName –zookeeper zookeeper.servers.list zookeeper存储结果原文：http://blog.csdn.net/strawbingo/article/details/45484139 Kafka分区机制介绍与示例原文：http://lxw1234.com/archives/2015/10/538.htm","raw":"---\ntitle: Kafka简介入门\ntoc: true\ndate: 2018-10-16 19:45:46\ntags: [kafka,replica,broker,partition,consumer]\ncategories: [技术]\ndescription:\n---\nKafka工作原理\n\nhttp://www.aboutyun.com/thread-11895-1-1.html\nkafka入门：简介、使用场景、设计原理、主要配置及集群搭建（转）:http://www.cnblogs.com/likehua/p/3999538.html\napache kafka系列之在zookeeper中存储结构：http://blog.csdn.net/strawbingo/article/details/45484139\nKafka文件存储机制那些事:http://www.open-open.com/lib/view/open1421150566328.html\napache kafka系列之server.properties配置文件参数说明:http://blog.csdn.net/lizhitao/article/details/25667831\nkafka入门:http://bit1129.iteye.com/blog/2174791\nKafka 设计与原理详解:http://blog.csdn.net/suifeng3051/article/details/48053965\n\n<!--more-->\n\n## Kafka系统的角色\n- Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic\n- topic： 可以理解为一个MQ消息队列的名字\n- Partition：\n    - 为了实现扩展性，一个非常大的topic可以分布到多个 broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。\n    - partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体 （多个partition间）的顺序。\n    - 也就是说，一个topic在集群中可以有多个partition，那么分区的策略是什么？(消息发送到哪个分区上，有两种基本的策略，一是采用Key Hash算法，一是采用Round Robin算法)\n    - ![](https://ws3.sinaimg.cn/large/006tNbRwly1fwab0cjcpjj30bk07faao.jpg)\n\n- Offset：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka\n- Producer ：消息生产者，就是向kafka broker发消息的客户端。\n- Consumer ：消息消费者，向kafka broker取消息的客户端\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fwab0ve2q6j3076050dg3.jpg)\n\n- Consumer Group （CG）：\n    - 消息系统有两类，一是广播，二是订阅发布。广播是把消息发送给所有的消费者；发布订阅是把消息只发送给订阅者。Kafka通过Consumer Group组合实现了这两种机制： 实现一个topic消息广播（发给所有的consumer）和单播（发给任意一个consumer）。一个topic可以有多个CG。\n    - topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个 consumer（这是实现一个Topic多Consumer的关键点：为一个Topic定义一个CG，CG下定义多个Consumer）。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。\n    - 典型的应用场景是，多个Consumer来读取一个Topic(理想情况下是一个Consumer读取Topic的一个Partition）,那么可以让这些Consumer属于同一个Consumer Group即可实现消息的多Consumer并行处理，原理是Kafka将一个消息发布出去后，ConsumerGroup中的Consumers可以通过Round Robin的方式进行消费(Consumers之间的负载均衡使用Zookeeper来实现)\n    - ![](https://ws4.sinaimg.cn/large/006tNbRwly1fwab1fu2htj30d6070752.jpg)\n\n## Topic、Partition和Replica的关系\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fwab1up9m4j30m60d975t.jpg)\n如上图，一个Topic有四个Partition，每个Partition两个replication。\n\n- Zookeeper在Kakfa中扮演的角色Kafka将元数据信息保存在Zookeeper中，但是发送给Topic本身的数据是不会发到Zk上的，否则Zk就疯了。\n\n- kafka使用zookeeper来实现动态的集群扩展，不需要更改客户端（producer和consumer）的配置。broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新。\n- 而客户端会在zookeeper上注册相关的watcher。一旦zookeeper发生变化，客户端能及时感知并作出相应调整。这样就保证了添加或去除broker时，各broker间仍能自动实现负载均衡。这里的客户端指的是Kafka的消息生产端(Producer)和消息消费端(Consumer)\n- Broker端使用zookeeper来注册broker信息，以及监测partition leader存活性。\n- Consumer端使用zookeeper用来注册consumer信息，其中包括consumer消费的partition列表等，同时也用来发现broker列表，并和partition leader建立socket连接，并获取消息。\n- Zookeeper和Producer没有建立关系，只和Brokers、Consumers建立关系以实现负载均衡，即同一个Consumer Group中的Consumers可以实现负载均衡。\n## 问题\n1. Topic有多个Partition，那么消息分配到某个Partition的依据是什么？\n    Key Hash或者Round Robin\n2. 如何查看一个Topic有多少个Partition？\n    使用kakfa-topic.sh --list topic topicName --zookeeper zookeeper.servers.list\n\n## zookeeper存储结果\n原文：http://blog.csdn.net/strawbingo/article/details/45484139\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fwab31496gj317g0t6qbg.jpg)\n\n## Kafka分区机制介绍与示例\n原文：http://lxw1234.com/archives/2015/10/538.htm\n","content":"<p>Kafka工作原理</p>\n<p><a href=\"http://www.aboutyun.com/thread-11895-1-1.html\">http://www.aboutyun.com/thread-11895-1-1.html</a><br>kafka入门：简介、使用场景、设计原理、主要配置及集群搭建（转）:<a href=\"http://www.cnblogs.com/likehua/p/3999538.html\">http://www.cnblogs.com/likehua/p/3999538.html</a><br>apache kafka系列之在zookeeper中存储结构：<a href=\"http://blog.csdn.net/strawbingo/article/details/45484139\">http://blog.csdn.net/strawbingo/article/details/45484139</a><br>Kafka文件存储机制那些事:<a href=\"http://www.open-open.com/lib/view/open1421150566328.html\">http://www.open-open.com/lib/view/open1421150566328.html</a><br>apache kafka系列之server.properties配置文件参数说明:<a href=\"http://blog.csdn.net/lizhitao/article/details/25667831\">http://blog.csdn.net/lizhitao/article/details/25667831</a><br>kafka入门:<a href=\"http://bit1129.iteye.com/blog/2174791\">http://bit1129.iteye.com/blog/2174791</a><br>Kafka 设计与原理详解:<a href=\"http://blog.csdn.net/suifeng3051/article/details/48053965\">http://blog.csdn.net/suifeng3051/article/details/48053965</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Kafka系统的角色\"><a href=\"#Kafka系统的角色\" class=\"headerlink\" title=\"Kafka系统的角色\"></a>Kafka系统的角色</h2><ul>\n<li><p>Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic</p>\n</li>\n<li><p>topic： 可以理解为一个MQ消息队列的名字</p>\n</li>\n<li><p>Partition：</p>\n<ul>\n<li>为了实现扩展性，一个非常大的topic可以分布到多个 broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。</li>\n<li>partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体 （多个partition间）的顺序。</li>\n<li>也就是说，一个topic在集群中可以有多个partition，那么分区的策略是什么？(消息发送到哪个分区上，有两种基本的策略，一是采用Key Hash算法，一是采用Round Robin算法)</li>\n<li><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fwab0cjcpjj30bk07faao.jpg\"></li>\n</ul>\n</li>\n<li><p>Offset：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka</p>\n</li>\n<li><p>Producer ：消息生产者，就是向kafka broker发消息的客户端。</p>\n</li>\n<li><p>Consumer ：消息消费者，向kafka broker取消息的客户端<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fwab0ve2q6j3076050dg3.jpg\"></p>\n</li>\n<li><p>Consumer Group （CG）：</p>\n<ul>\n<li>消息系统有两类，一是广播，二是订阅发布。广播是把消息发送给所有的消费者；发布订阅是把消息只发送给订阅者。Kafka通过Consumer Group组合实现了这两种机制： 实现一个topic消息广播（发给所有的consumer）和单播（发给任意一个consumer）。一个topic可以有多个CG。</li>\n<li>topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个 consumer（这是实现一个Topic多Consumer的关键点：为一个Topic定义一个CG，CG下定义多个Consumer）。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</li>\n<li>典型的应用场景是，多个Consumer来读取一个Topic(理想情况下是一个Consumer读取Topic的一个Partition）,那么可以让这些Consumer属于同一个Consumer Group即可实现消息的多Consumer并行处理，原理是Kafka将一个消息发布出去后，ConsumerGroup中的Consumers可以通过Round Robin的方式进行消费(Consumers之间的负载均衡使用Zookeeper来实现)</li>\n<li><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fwab1fu2htj30d6070752.jpg\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Topic、Partition和Replica的关系\"><a href=\"#Topic、Partition和Replica的关系\" class=\"headerlink\" title=\"Topic、Partition和Replica的关系\"></a>Topic、Partition和Replica的关系</h2><p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fwab1up9m4j30m60d975t.jpg\"><br>如上图，一个Topic有四个Partition，每个Partition两个replication。</p>\n<ul>\n<li><p>Zookeeper在Kakfa中扮演的角色Kafka将元数据信息保存在Zookeeper中，但是发送给Topic本身的数据是不会发到Zk上的，否则Zk就疯了。</p>\n</li>\n<li><p>kafka使用zookeeper来实现动态的集群扩展，不需要更改客户端（producer和consumer）的配置。broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新。</p>\n</li>\n<li><p>而客户端会在zookeeper上注册相关的watcher。一旦zookeeper发生变化，客户端能及时感知并作出相应调整。这样就保证了添加或去除broker时，各broker间仍能自动实现负载均衡。这里的客户端指的是Kafka的消息生产端(Producer)和消息消费端(Consumer)</p>\n</li>\n<li><p>Broker端使用zookeeper来注册broker信息，以及监测partition leader存活性。</p>\n</li>\n<li><p>Consumer端使用zookeeper用来注册consumer信息，其中包括consumer消费的partition列表等，同时也用来发现broker列表，并和partition leader建立socket连接，并获取消息。</p>\n</li>\n<li><p>Zookeeper和Producer没有建立关系，只和Brokers、Consumers建立关系以实现负载均衡，即同一个Consumer Group中的Consumers可以实现负载均衡。</p>\n</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>Topic有多个Partition，那么消息分配到某个Partition的依据是什么？<br> Key Hash或者Round Robin</li>\n<li>如何查看一个Topic有多少个Partition？<br> 使用kakfa-topic.sh –list topic topicName –zookeeper zookeeper.servers.list</li>\n</ol>\n<h2 id=\"zookeeper存储结果\"><a href=\"#zookeeper存储结果\" class=\"headerlink\" title=\"zookeeper存储结果\"></a>zookeeper存储结果</h2><p>原文：<a href=\"http://blog.csdn.net/strawbingo/article/details/45484139\">http://blog.csdn.net/strawbingo/article/details/45484139</a><br><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fwab31496gj317g0t6qbg.jpg\"></p>\n<h2 id=\"Kafka分区机制介绍与示例\"><a href=\"#Kafka分区机制介绍与示例\" class=\"headerlink\" title=\"Kafka分区机制介绍与示例\"></a>Kafka分区机制介绍与示例</h2><p>原文：<a href=\"http://lxw1234.com/archives/2015/10/538.htm\">http://lxw1234.com/archives/2015/10/538.htm</a></p>\n","slug":"Kafka-简介入门","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/16/Kafka-%E7%AE%80%E4%BB%8B%E5%85%A5%E9%97%A8/","excerpt":"Kafka工作原理 http://www.aboutyun.com/thread-11895-1-1.htmlkafka入门：简介、使用场景、设计原理、主要配置及集群搭建（转）:http://www.cnblogs.com/likehua/p/3999538.htmlapache kafka系列之在zookeeper中存储结构：http://blog.csdn.net/strawbingo/article/details/45484139Kafka文件存储机制那些事:http://www.open-open.com/lib/view/open1421150566328.htmlapache kafka系列之server.properties配置文件参数说明:http://blog.csdn.net/lizhitao/article/details/25667831kafka入门:http://bit1129.iteye.com/blog/2174791Kafka 设计与原理详解:http://blog.csdn.net/suifeng3051/article/details/48053965","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://vwin.github.io/tags/kafka/"},{"name":"replica","slug":"replica","permalink":"http://vwin.github.io/tags/replica/"},{"name":"broker","slug":"broker","permalink":"http://vwin.github.io/tags/broker/"},{"name":"partition","slug":"partition","permalink":"http://vwin.github.io/tags/partition/"},{"name":"consumer","slug":"consumer","permalink":"http://vwin.github.io/tags/consumer/"}]},{"title":"Kafka集群partitions/replicas默认分配解析","date":"2018-10-16T11:41:37.000Z","path":"2018/10/16/Kafka-集群partitions-replicas默认分配解析/","text":"Kafka集群partition replication默认自动分配分析 下面以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示： 当集群中新增2节点，Partition增加到6个时分布情况如下： 副本分配逻辑规则如下： 在Kafka集群中，每个Broker都有均等分配Partition的Leader机会。 上述图Broker Partition中，箭头指向为副本，以Partition-0为例:broker1中parition-0为Leader，Broker2中Partition-0为副本。 上述图种每个Broker(按照BrokerId有序)依次分配主Partition,下一个Broker为副本，如此循环迭代分配，多副本都遵循此规则。 副本分配算法如下： 将所有N Broker和待分配的i个Partition排序. 将第i个Partition分配到第(i mod n)个Broker上. 将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上.","raw":"---\ntitle: Kafka集群partitions/replicas默认分配解析\ntoc: true\ndate: 2018-10-16 19:41:37\ntags: [kafka,partition,replica]\ncategories: [技术]\ndescription:\n---\n\nKafka集群partition replication默认自动分配分析\n\n<!--more-->\n\n1. 下面以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示：\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fwaav5qdhsj30n808gq42.jpg)\n\n2. 当集群中新增2节点，Partition增加到6个时分布情况如下：\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fwaavp7adsj30np07xq4c.jpg)\n\n3. 副本分配逻辑规则如下：\n- 在Kafka集群中，每个Broker都有均等分配Partition的Leader机会。\n- 上述图Broker Partition中，箭头指向为副本，以Partition-0为例:broker1中parition-0为Leader，Broker2中Partition-0为副本。\n- 上述图种每个Broker(按照BrokerId有序)依次分配主Partition,下一个Broker为副本，如此循环迭代分配，多副本都遵循此规则。\n\n4. 副本分配算法如下：\n- 将所有N Broker和待分配的i个Partition排序.\n- 将第i个Partition分配到第(i mod n)个Broker上.\n- 将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上.\n\n\n\n\n","content":"<p>Kafka集群partition replication默认自动分配分析</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><p>下面以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示：<br><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fwaav5qdhsj30n808gq42.jpg\"></p>\n</li>\n<li><p>当集群中新增2节点，Partition增加到6个时分布情况如下：<br><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fwaavp7adsj30np07xq4c.jpg\"></p>\n</li>\n<li><p>副本分配逻辑规则如下：</p>\n</li>\n</ol>\n<ul>\n<li>在Kafka集群中，每个Broker都有均等分配Partition的Leader机会。</li>\n<li>上述图Broker Partition中，箭头指向为副本，以Partition-0为例:broker1中parition-0为Leader，Broker2中Partition-0为副本。</li>\n<li>上述图种每个Broker(按照BrokerId有序)依次分配主Partition,下一个Broker为副本，如此循环迭代分配，多副本都遵循此规则。</li>\n</ul>\n<ol start=\"4\">\n<li>副本分配算法如下：</li>\n</ol>\n<ul>\n<li>将所有N Broker和待分配的i个Partition排序.</li>\n<li>将第i个Partition分配到第(i mod n)个Broker上.</li>\n<li>将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上.</li>\n</ul>\n","slug":"Kafka-集群partitions-replicas默认分配解析","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/16/Kafka-%E9%9B%86%E7%BE%A4partitions-replicas%E9%BB%98%E8%AE%A4%E5%88%86%E9%85%8D%E8%A7%A3%E6%9E%90/","excerpt":"Kafka集群partition replication默认自动分配分析","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://vwin.github.io/tags/kafka/"},{"name":"replica","slug":"replica","permalink":"http://vwin.github.io/tags/replica/"},{"name":"partition","slug":"partition","permalink":"http://vwin.github.io/tags/partition/"}]},{"title":"Ubuntu 16.04安装Docker","date":"2018-10-12T07:59:23.000Z","path":"2018/10/12/Ubuntu-16-04安装Docker/","text":"Ubuntu 16.04安装Docker 查看Ubuntu版本1sudo lsb_release -a 或者 1cat /etc/issue 查看Linux 内核版本1uname -a 安装Docker官方Ubuntu存储库中提供的Docker安装包可能不是最新版本。为了确保我们获得最新版本，我们将从官方Docker存储库安装Docker。为此，我们将添加一个新的包源，从Docker添加GPG密钥以确保下载有效，然后安装该包。 首先，更新现有的包列表： 1sudo apt update 接下来，安装一些允许apt通过HTTPS使用包的必备软件包： 1sudo apt install apt-transport-https ca-certificates curl software-properties-common 然后将官方Docker存储库的GPG密钥添加到您的系统： 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 将Docker存储库添加到APT源： 1sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot; 接下来，使用新添加的repo中的Docker包更新包数据库： 1sudo apt update 确保您要从Docker repo而不是默认的Ubuntu repo安装： 1apt-cache policy docker-ce 虽然Docker的版本号可能不同，但您会看到这样的输出：apt-cache策略docker-ce的输出 123456docker-ce: Installed: (none) Candidate: 18.03.1~ce~3-0~ubuntu Version table: 18.03.1~ce~3-0~ubuntu 500 500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages 请注意，docker-ce未安装，但安装的候选者来自Ubuntu 18.04（bionic）的Docker存储库。 最后，安装Docker： 1sudo apt install docker-ce 现在应该安装Docker，守护进程启动，并启用进程启动进程。检查它是否正在运行： 1sudo systemctl status docker 输出应类似于以下内容，表明该服务处于活动状态并正在运行： 12345678910Output● docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2018-07-05 15:08:39 UTC; 2min 55s ago Docs: https://docs.docker.com Main PID: 10096 (dockerd) Tasks: 16 CGroup: /system.slice/docker.service ├─10096 /usr/bin/dockerd -H fd:// └─10113 docker-containerd --config /var/run/docker/containerd/containerd.toml 现在安装Docker不仅可以为您提供Docker服务（守护程序），还可以为您提供docker命令行实用程序或Docker客户端。我们将docker在本教程后面探讨如何使用该命令。 在没有Sudo的情况下执行Docker命令默认情况下，该docker命令只能由root用户或docker组中的用户运行，该用户在Docker的安装过程中自动创建。如果您尝试运行该docker命令而不使用sudo或不在docker组中作为前缀，您将获得如下输出： 123Outputdocker: Cannot connect to the Docker daemon. Is the docker daemon running on this host?.See &#x27;docker run --help&#x27;. 如果要sudo在运行docker命令时避免键入，请将用户名添加到docker组中： 1sudo usermod -aG docker $&#123;USER&#125; 要应用新的组成员身份，请注销服务器并重新登录，或键入以下内容： 1su - $&#123;USER&#125; 系统将提示您输入用户密码以继续。 通过键入以下内容确认您的用户现已添加到docker组： 1id -nG 输出： 1username sudo docker 如果您需要将用户添加到docker您未登录的组中，请使用以下方式明确声明该用户名： 1sudo usermod -aG docker username 本文的其余部分假定您docker以docker组中的用户身份运行该命令。如果您选择不这样做，请在前面添加命令sudo。 使用Docker命令使用docker包括传递一系列选项和命令，后跟参数。语法采用以下形式： 1docker [option] [command] [arguments] 要查看所有可用的子命令，请键入： 1docker 从Docker 18开始，可用子命令的完整列表包括： 123456789101112131415161718192021222324252627282930313233343536373839404142Output attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container&#x27;s changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container&#x27;s filesystem events Get real time events from the server exec Run a command in a running container export Export a container&#x27;s filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes 要查看特定命令可用的选项，请键入： 1docker docker-subcommand --help 要查看有关Docker的系统范围信息，请使用： 1docker info 使用Docker镜像Docker容器是从Docker镜像构建的。默认情况下，Docker从[Docker Hub]（https://hub.docker.com）中提取这些图像，这是一个由Docker管理的Docker注册表，这是Docker项目背后的公司。任何人都可以在Docker Hub上托管他们的Docker镜像，所以大多数您需要的应​​用程序和Linux发行版将在那里托管图像。 要检查您是否可以从Docker Hub访问和下载图像，请键入： 1docker run hello-world 输出将指示Docker正常工作： 12345678910OutputUnable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-world9bb5a5d4561a: Pull completeDigest: sha256:3e1764d0f546ceac4565547df2ac4907fe46f007ea229fd7ef2718514bcec35dStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.... Docker最初无法在hello-world本地找到图像，因此它从Docker Hub下载了图像，Docker Hub是默认存储库。下载映像后，Docker从映像创建了一个容器，并在容器中执行了应用程序，显示了该消息。 您可以使用带子docker命令的search命令搜索Docker Hub上可用的图像。例如，要搜索Ubuntu映像，请键入： 1docker search ubuntu 该脚本将对Docker Hub进行爬网，并返回名称与搜索字符串匹配的所有图像的列表。在这种情况下，输出将类似于： 12345678910111213141516171819202122232425262728OutputNAME DESCRIPTION STARS OFFICIAL AUTOMATEDubuntu Ubuntu is a Debian-based Linux operating sys… 7917 [OK]dorowu/ubuntu-desktop-lxde-vnc Ubuntu with openssh-server and NoVNC 193 [OK]rastasheep/ubuntu-sshd Dockerized SSH service, built on top of offi… 156 [OK]ansible/ubuntu14.04-ansible Ubuntu 14.04 LTS with ansible 93 [OK]ubuntu-upstart Upstart is an event-based replacement for th… 87 [OK]neurodebian NeuroDebian provides neuroscience research s… 50 [OK]ubuntu-debootstrap debootstrap --variant=minbase --components=m… 38 [OK]1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 36 [OK]nuagebec/ubuntu Simple always updated Ubuntu docker images w… 23 [OK]tutum/ubuntu Simple Ubuntu docker images with SSH access 18i386/ubuntu Ubuntu is a Debian-based Linux operating sys… 13ppc64le/ubuntu Ubuntu is a Debian-based Linux operating sys… 121and1internet/ubuntu-16-apache-php-7.0 ubuntu-16-apache-php-7.0 10 [OK]1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10 ubuntu-16-nginx-php-phpmyadmin-mariadb-10 6 [OK]eclipse/ubuntu_jdk8 Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, … 6 [OK]codenvy/ubuntu_jdk8 Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, … 4 [OK]darksheer/ubuntu Base Ubuntu Image -- Updated hourly 4 [OK]1and1internet/ubuntu-16-apache ubuntu-16-apache 3 [OK]1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4 ubuntu-16-nginx-php-5.6-wordpress-4 3 [OK]1and1internet/ubuntu-16-sshd ubuntu-16-sshd 1 [OK]pivotaldata/ubuntu A quick freshening-up of the base Ubuntu doc… 11and1internet/ubuntu-16-healthcheck ubuntu-16-healthcheck 0 [OK]pivotaldata/ubuntu-gpdb-dev Ubuntu images for GPDB development 0smartentry/ubuntu ubuntu with smartentry 0 [OK]ossobv/ubuntu... 在OFFICIAL列中，OK表示由项目后面的公司构建和支持的图像。确定要使用的映像后，可以使用pull子命令将其下载到计算机。 执行以下命令将官方ubuntu映像下载到您的计算机： 1docker pull ubuntu 您将看到以下输出： 12345678910OutputUsing default tag: latestlatest: Pulling from library/ubuntu6b98dfc16071: Pull complete4001a1209541: Pull complete6319fc68c576: Pull completeb24603670dc3: Pull complete97f170c87c6f: Pull completeDigest: sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6dStatus: Downloaded newer image for ubuntu:latest 下载映像后，可以使用带有run子命令的下载映像运行容器。正如您在hello-world示例中看到的，如果在docker使用run子命令执行时未下载图像，则Docker客户端将首先下载图像，然后使用它运行容器。 要查看已下载到计算机的图像，请键入： 1docker images 输出应类似于以下内容： 1234OutputREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 113a43faa138 4 weeks ago 81.2MBhello-world latest e38bc07ac18e 2 months ago 1.85kB 正如您将在本教程后面看到的那样，用于运行容器的图像可以被修改并用于生成新图像，然后可以将其上载（推送是技术术语）到Docker Hub或其他Docker注册表。 我们来看看如何更详细地运行容器。 运行Docker容器在hello-world您在上一步中跑容器是运行并发出一个测试消息之后退出容器的一个例子。容器可以比这更有用，它们可以是交互式的。毕竟，它们类似于虚拟机，只是更加资源友好。 举个例子，让我们使用Ubuntu的最新图像运行一个容器。-i和-t开关的组合为您提供了对容器的交互式shell访问： 1docker run -it ubuntu 您的命令提示符应该更改以反映您现在正在容器内工作的事实，并应采用以下形式： 12Outputroot@d9b100f2f636:/# 请注意命令提示符中的容器ID。在这个例子中，它是d9b100f2f636。稍后您需要该容器ID以在要删除容器时标识容器。 现在您可以在容器内运行任何命令。例如，让我们更新容器内的包数据库。您不需要为任何命令添加前缀sudo，因为您以root用户身份在容器内操作： 1apt update 然后在其中安装任何应用程序。我们安装Node.js： 1apt install nodejs 这将从官方Ubuntu存储库中安装容器中的Node.js. 安装完成后，验证是否已安装Node.js： 1node -v 您将看到终端中显示的版本号： 12Outputv8.10.0 您在容器内进行的任何更改仅适用于该容器。 要退出容器，请exit在提示符处键入。 让我们看看下一步管理我们系统上的容器 管理Docker容器使用Docker一段时间后，您的计算机上将有许多活动（运行）和非活动容器。要查看活动的，请使用： 1docker ps 您将看到类似于以下内容的输出： 12OutputCONTAINER ID IMAGE COMMAND CREATED 在本教程中，您启动了两个容器; 一个来自hello-world图像，另一个来自ubuntu图像。两个容器都不再运行，但它们仍然存在于您的系统上。 要查看所有容器 - 活动和非活动，请docker ps 使用-a开关运行： 1docker ps -a 您将看到类似于此的输出： 12d9b100f2f636 ubuntu &quot;/bin/bash&quot; About an hour ago Exited (0) 8 minutes ago sharp_volhard01c950718166 hello-world &quot;/hello&quot; About an hour ago Exited (0) About an hour ago festive_williams 要查看您创建的最新容器，请将其传递给-l交换机： 123docker ps -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd9b100f2f636 ubuntu &quot;/bin/bash&quot; About an hour ago Exited (0) 10 minutes ago sharp_volhard 要启动已停止的容器，请使用docker start，后跟容器ID或容器名称。让我们启动基于Ubuntu的容器，其ID为 d9b100f2f636： 1docker start d9b100f2f636 容器将启动，您可以使用它docker ps来查看其状态： 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd9b100f2f636 ubuntu &quot;/bin/bash&quot; About an hour ago Up 8 seconds sharp_volhard 要停止正在运行的容器，请使用docker stop，后跟容器ID或名称。这次，我们将使用Docker分配容器的名称，即sharp_volhard： 1docker stop sharp_volhard 一旦您决定不再需要容器，请使用该docker rm命令将其删除，再次使用容器ID或名称。使用该docker ps -a命令查找与hello-world映像关联的容器的容器ID或名称，然后将其删除。 1docker rm festive_williams 您可以使用–name开关启动一个新容器并为其命名。您还可以使用该–rm开关创建一个在停止时自行删除的容器。有关docker run help这些选项和其他选项的更多信息，请参阅该命令。 容器可以转换为可用于构建新容器的映像。让我们来看看它是如何工作的 将容器中的更改提交到Docker镜像当您启动Docker镜像时，您可以像使用虚拟机一样创建，修改和删除文件。您所做的更改仅适用于该容器。您可以启动和停止它，但是一旦使用该docker rm命令销毁它，更改将永久丢失。 本节介绍如何将容器的状态保存为新的Docker镜像。 在Ubuntu容器中安装Node.js后，您现在有一个运行图像的容器，但容器与您用来创建它的图像不同。但是您可能希望稍后重新使用此Node.js容器作为新映像的基础。 然后使用以下命令将更改提交到新的Docker镜像实例。 1docker commit -m &quot;What you did to the image&quot; -a &quot;Author Name&quot; container_id repository/new_image_name 该-m开关是提交信息，可以帮助你和其他人知道你所做的修改，而-a用于指定作者。container_id当您启动交互式Docker会话时，这是您在本教程前面提到的那个。除非您在Docker Hub上创建了其他存储库，否则repository通常是您的Docker Hub用户名。 例如，对于用户sammy，使用容器ID d9b100f2f636，命令将是： 1docker commit -m &quot;added Node.js&quot; -a &quot;sammy&quot; d9b100f2f636 sammy/ubuntu-nodejs 当你提交的图像，新的图像在您的计算机上本地保存。在本教程的后面，您将学习如何将映像推送到Docker Hub之类的Docker注册表，以便其他人可以访问它。 再次列出Docker图像将显示新图像以及从中派生的旧图像： 1docker images 你会看到这样的输出： 12345OutputREPOSITORY TAG IMAGE ID CREATED SIZEsammy/ubuntu-nodejs latest 7c1f35226ca6 7 seconds ago 179MBubuntu latest 113a43faa138 4 weeks ago 81.2MBhello-world latest e38bc07ac18e 2 months ago 1.85kB 在此示例中，ubuntu-nodejs是新图像，它是ubuntu从Docker Hub 的现有图像派生的。尺寸差异反映了所做的变化。在此示例中，更改是NodeJS已安装。因此，下次需要使用预先安装了NodeJS的Ubuntu运行容器时，您可以使用新映像。 您还可以从a构建映像Dockerfile，这样可以在新映像中自动安装软件。但是，这超出了本教程的范围。 现在让我们与他人分享新图像，以便他们可以从中创建容器。 将Docker镜像推送到Docker存储库从现有映像创建新映像之后的下一个逻辑步骤是与您选择的几个朋友，Docker Hub上的整个世界或您可以访问的其他Docker注册表共享它。要将映像推送到Docker Hub或任何其他Docker注册表，您必须在那里拥有一个帐户。 本节介绍如何将Docker镜像推送到Docker Hub。要了解如何创建自己的私有Docker注册表，请查看如何在Ubuntu 14.04上设置私有Docker注册表。 要推送图像，请先登录Docker Hub。 1docker login -u docker-registry-username 系统将提示您使用Docker Hub密码进行身份验证。如果您指定了正确的密码，则身份验证应该成功。然后你可以使用以下方法推送自己的图像 1docker push docker-registry-username/docker-image-name 要将ubuntu-nodejs图像推送到sammy存储库，命令将是： 1docker push sammy/ubuntu-nodejs 上传图像时，该过程可能需要一些时间才能完成，但完成后，输出将如下所示： 12345678910OutputThe push refers to a repository [docker.io/sammy/ubuntu-nodejs]e3fbbfb44187: Pushed5f70bf18a086: Pusheda3b5c80a4eba: Pushed7f18b442972b: Pushed3ce512daaf78: Pushed7aae4540b42d: Pushed... 将图像推送到注册表后，它应该列在您帐户的仪表板上，如下图所示。 如果推送尝试导致此类错误，那么您可能没有登录： 123456789OutputThe push refers to a repository [docker.io/sammy/ubuntu-nodejs]e3fbbfb44187: Preparing5f70bf18a086: Preparinga3b5c80a4eba: Preparing7f18b442972b: Preparing3ce512daaf78: Preparing7aae4540b42d: Waitingunauthorized: authentication required 登录docker login并重复推送尝试。然后验证它是否存在于Docker Hub存储库页面上。 您现在可以使用将图像拉到新计算机并使用它来运行新容器。 1docker pull sammy/ubuntu-node&lt;^&gt; 结论在本教程中，您安装了Docker，使用了镜像和容器，并将修改后的镜像推送到Docker Hub。现在您已了解基础知识，请浏览DigitalOcean社区中的其他Docker教程。","raw":"---\ntitle: Ubuntu 16.04安装Docker\ntoc: true\ndate: 2018-10-12 15:59:23\ntags: [ubuntu,docker,linux]\ncategories: [技术]\ndescription:\n---\n\nUbuntu 16.04安装Docker\n\n<!--more-->\n\n## 查看Ubuntu版本\n\n```shell\nsudo lsb_release -a\n```\n或者\n\n```shell\ncat /etc/issue\n```\n\n## 查看Linux 内核版本\n\n```shell\nuname -a\n```\n\n## 安装Docker\n官方Ubuntu存储库中提供的Docker安装包可能不是最新版本。为了确保我们获得最新版本，我们将从官方Docker存储库安装Docker。为此，我们将添加一个新的包源，从Docker添加GPG密钥以确保下载有效，然后安装该包。\n\n首先，更新现有的包列表：\n```shell\nsudo apt update\n```\n\n接下来，安装一些允许apt通过HTTPS使用包的必备软件包：\n```shell\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\n```\n然后将官方Docker存储库的GPG密钥添加到您的系统：\n```shell\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n将Docker存储库添加到APT源：\n```shell\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\"\n```\n接下来，使用新添加的repo中的Docker包更新包数据库：\n```shell\nsudo apt update\n```\n确保您要从Docker repo而不是默认的Ubuntu repo安装：\n```shell\napt-cache policy docker-ce\n```\n虽然Docker的版本号可能不同，但您会看到这样的输出：\napt-cache策略docker-ce的输出\n```shell\ndocker-ce:\n  Installed: (none)\n  Candidate: 18.03.1~ce~3-0~ubuntu\n  Version table:\n     18.03.1~ce~3-0~ubuntu 500\n        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages\n```\n请注意，docker-ce未安装，但安装的候选者来自Ubuntu 18.04（bionic）的Docker存储库。\n\n最后，安装Docker：\n```shell\nsudo apt install docker-ce\n```\n现在应该安装Docker，守护进程启动，并启用进程启动进程。检查它是否正在运行：\n```shell\nsudo systemctl status docker\n```\n输出应类似于以下内容，表明该服务处于活动状态并正在运行：\n```shell\nOutput\n● docker.service - Docker Application Container Engine\n   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)\n   Active: active (running) since Thu 2018-07-05 15:08:39 UTC; 2min 55s ago\n     Docs: https://docs.docker.com\n Main PID: 10096 (dockerd)\n    Tasks: 16\n   CGroup: /system.slice/docker.service\n           ├─10096 /usr/bin/dockerd -H fd://\n           └─10113 docker-containerd --config /var/run/docker/containerd/containerd.toml\n```\n现在安装Docker不仅可以为您提供Docker服务（守护程序），还可以为您提供docker命令行实用程序或Docker客户端。我们将docker在本教程后面探讨如何使用该命令。\n\n## 在没有Sudo的情况下执行Docker命令\n默认情况下，该docker命令只能由root用户或docker组中的用户运行，该用户在Docker的安装过程中自动创建。如果您尝试运行该docker命令而不使用sudo或不在docker组中作为前缀，您将获得如下输出：\n```shell\nOutput\ndocker: Cannot connect to the Docker daemon. Is the docker daemon running on this host?.\nSee 'docker run --help'.\n```\n如果要sudo在运行docker命令时避免键入，请将用户名添加到docker组中：\n```shell\nsudo usermod -aG docker ${USER}\n```\n要应用新的组成员身份，请注销服务器并重新登录，或键入以下内容：\n```shell\nsu - ${USER}\n```\n系统将提示您输入用户密码以继续。\n\n通过键入以下内容确认您的用户现已添加到docker组：\n```shell\nid -nG\n```\n\n输出：\n```shell\nusername sudo docker\n```\n\n如果您需要将用户添加到docker您未登录的组中，请使用以下方式明确声明该用户名：\n```shell\nsudo usermod -aG docker username\n```\n本文的其余部分假定您docker以docker组中的用户身份运行该命令。如果您选择不这样做，请在前面添加命令sudo。\n\n## 使用Docker命令\n使用docker包括传递一系列选项和命令，后跟参数。语法采用以下形式：\n```shell\ndocker [option] [command] [arguments]\n```\n要查看所有可用的子命令，请键入：\n```shell\ndocker\n```\n\n从Docker 18开始，可用子命令的完整列表包括：\n```shell\nOutput\n\n  attach      Attach local standard input, output, and error streams to a running container\n  build       Build an image from a Dockerfile\n  commit      Create a new image from a container's changes\n  cp          Copy files/folders between a container and the local filesystem\n  create      Create a new container\n  diff        Inspect changes to files or directories on a container's filesystem\n  events      Get real time events from the server\n  exec        Run a command in a running container\n  export      Export a container's filesystem as a tar archive\n  history     Show the history of an image\n  images      List images\n  import      Import the contents from a tarball to create a filesystem image\n  info        Display system-wide information\n  inspect     Return low-level information on Docker objects\n  kill        Kill one or more running containers\n  load        Load an image from a tar archive or STDIN\n  login       Log in to a Docker registry\n  logout      Log out from a Docker registry\n  logs        Fetch the logs of a container\n  pause       Pause all processes within one or more containers\n  port        List port mappings or a specific mapping for the container\n  ps          List containers\n  pull        Pull an image or a repository from a registry\n  push        Push an image or a repository to a registry\n  rename      Rename a container\n  restart     Restart one or more containers\n  rm          Remove one or more containers\n  rmi         Remove one or more images\n  run         Run a command in a new container\n  save        Save one or more images to a tar archive (streamed to STDOUT by default)\n  search      Search the Docker Hub for images\n  start       Start one or more stopped containers\n  stats       Display a live stream of container(s) resource usage statistics\n  stop        Stop one or more running containers\n  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n  top         Display the running processes of a container\n  unpause     Unpause all processes within one or more containers\n  update      Update configuration of one or more containers\n  version     Show the Docker version information\n  wait        Block until one or more containers stop, then print their exit codes\n```\n要查看特定命令可用的选项，请键入：\n```shell\ndocker docker-subcommand --help\n```\n要查看有关Docker的系统范围信息，请使用：\n```shell\ndocker info\n```\n\n## 使用Docker镜像\nDocker容器是从Docker镜像构建的。默认情况下，Docker从[Docker Hub]（https://hub.docker.com）中提取这些图像，这是一个由Docker管理的Docker注册表，这是Docker项目背后的公司。任何人都可以在Docker Hub上托管他们的Docker镜像，所以大多数您需要的应​​用程序和Linux发行版将在那里托管图像。\n\n要检查您是否可以从Docker Hub访问和下载图像，请键入：\n```shell\ndocker run hello-world\n```\n输出将指示Docker正常工作：\n```shell\nOutput\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n9bb5a5d4561a: Pull complete\nDigest: sha256:3e1764d0f546ceac4565547df2ac4907fe46f007ea229fd7ef2718514bcec35d\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n...\n```\nDocker最初无法在hello-world本地找到图像，因此它从Docker Hub下载了图像，Docker Hub是默认存储库。下载映像后，Docker从映像创建了一个容器，并在容器中执行了应用程序，显示了该消息。\n\n您可以使用带子docker命令的search命令搜索Docker Hub上可用的图像。例如，要搜索Ubuntu映像，请键入：\n```shell\ndocker search ubuntu\n```\n该脚本将对Docker Hub进行爬网，并返回名称与搜索字符串匹配的所有图像的列表。在这种情况下，输出将类似于：\n```shell\nOutput\nNAME                                                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   7917                [OK]\ndorowu/ubuntu-desktop-lxde-vnc                            Ubuntu with openssh-server and NoVNC            193                                     [OK]\nrastasheep/ubuntu-sshd                                    Dockerized SSH service, built on top of offi…   156                                     [OK]\nansible/ubuntu14.04-ansible                               Ubuntu 14.04 LTS with ansible                   93                                      [OK]\nubuntu-upstart                                            Upstart is an event-based replacement for th…   87                  [OK]\nneurodebian                                               NeuroDebian provides neuroscience research s…   50                  [OK]\nubuntu-debootstrap                                        debootstrap --variant=minbase --components=m…   38                  [OK]\n1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5      ubuntu-16-nginx-php-phpmyadmin-mysql-5          36                                      [OK]\nnuagebec/ubuntu                                           Simple always updated Ubuntu docker images w…   23                                      [OK]\ntutum/ubuntu                                              Simple Ubuntu docker images with SSH access     18\ni386/ubuntu                                               Ubuntu is a Debian-based Linux operating sys…   13\nppc64le/ubuntu                                            Ubuntu is a Debian-based Linux operating sys…   12\n1and1internet/ubuntu-16-apache-php-7.0                    ubuntu-16-apache-php-7.0                        10                                      [OK]\n1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10   ubuntu-16-nginx-php-phpmyadmin-mariadb-10       6                                       [OK]\neclipse/ubuntu_jdk8                                       Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   6                                       [OK]\ncodenvy/ubuntu_jdk8                                       Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   4                                       [OK]\ndarksheer/ubuntu                                          Base Ubuntu Image -- Updated hourly             4                                       [OK]\n1and1internet/ubuntu-16-apache                            ubuntu-16-apache                                3                                       [OK]\n1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4         ubuntu-16-nginx-php-5.6-wordpress-4             3                                       [OK]\n1and1internet/ubuntu-16-sshd                              ubuntu-16-sshd                                  1                                       [OK]\npivotaldata/ubuntu                                        A quick freshening-up of the base Ubuntu doc…   1\n1and1internet/ubuntu-16-healthcheck                       ubuntu-16-healthcheck                           0                                       [OK]\npivotaldata/ubuntu-gpdb-dev                               Ubuntu images for GPDB development              0\nsmartentry/ubuntu                                         ubuntu with smartentry                          0                                       [OK]\nossobv/ubuntu\n...\n```\n在OFFICIAL列中，OK表示由项目后面的公司构建和支持的图像。确定要使用的映像后，可以使用pull子命令将其下载到计算机。\n\n执行以下命令将官方ubuntu映像下载到您的计算机：\n```shell\ndocker pull ubuntu\n```\n您将看到以下输出：\n```shell\nOutput\nUsing default tag: latest\nlatest: Pulling from library/ubuntu\n6b98dfc16071: Pull complete\n4001a1209541: Pull complete\n6319fc68c576: Pull complete\nb24603670dc3: Pull complete\n97f170c87c6f: Pull complete\nDigest: sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d\nStatus: Downloaded newer image for ubuntu:latest\n```\n下载映像后，可以使用带有run子命令的下载映像运行容器。正如您在hello-world示例中看到的，如果在docker使用run子命令执行时未下载图像，则Docker客户端将首先下载图像，然后使用它运行容器。\n\n要查看已下载到计算机的图像，请键入：\n```shell\ndocker images\n```\n输出应类似于以下内容：\n```shell\nOutput\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nubuntu              latest              113a43faa138        4 weeks ago         81.2MB\nhello-world         latest              e38bc07ac18e        2 months ago        1.85kB\n```\n正如您将在本教程后面看到的那样，用于运行容器的图像可以被修改并用于生成新图像，然后可以将其上载（推送是技术术语）到Docker Hub或其他Docker注册表。\n\n我们来看看如何更详细地运行容器。\n\n## 运行Docker容器\n在hello-world您在上一步中跑容器是运行并发出一个测试消息之后退出容器的一个例子。容器可以比这更有用，它们可以是交互式的。毕竟，它们类似于虚拟机，只是更加资源友好。\n\n举个例子，让我们使用Ubuntu的最新图像运行一个容器。-i和-t开关的组合为您提供了对容器的交互式shell访问：\n```shell\ndocker run -it ubuntu\n```\n您的命令提示符应该更改以反映您现在正在容器内工作的事实，并应采用以下形式：\n```shell\nOutput\nroot@d9b100f2f636:/#\n```\n请注意命令提示符中的容器ID。在这个例子中，它是d9b100f2f636。稍后您需要该容器ID以在要删除容器时标识容器。\n\n现在您可以在容器内运行任何命令。例如，让我们更新容器内的包数据库。您不需要为任何命令添加前缀sudo，因为您以root用户身份在容器内操作：\n```shell\napt update\n```\n然后在其中安装任何应用程序。我们安装Node.js：\n```shell\napt install nodejs\n```\n这将从官方Ubuntu存储库中安装容器中的Node.js. 安装完成后，验证是否已安装Node.js：\n```shell\nnode -v\n```\n您将看到终端中显示的版本号：\n```shell\nOutput\nv8.10.0\n```\n您在容器内进行的任何更改仅适用于该容器。\n\n要退出容器，请exit在提示符处键入。\n\n让我们看看下一步管理我们系统上的容器\n\n## 管理Docker容器\n使用Docker一段时间后，您的计算机上将有许多活动（运行）和非活动容器。要查看活动的，请使用：\n```shell\ndocker ps\n```\n您将看到类似于以下内容的输出：\n```shell\nOutput\nCONTAINER ID        IMAGE               COMMAND             CREATED             \n```\n在本教程中，您启动了两个容器; 一个来自hello-world图像，另一个来自ubuntu图像。两个容器都不再运行，但它们仍然存在于您的系统上。\n\n要查看所有容器 - 活动和非活动，请docker ps 使用-a开关运行：\n```shell\ndocker ps -a\n```\n您将看到类似于此的输出：\n```shell\nd9b100f2f636        ubuntu              \"/bin/bash\"         About an hour ago   Exited (0) 8 minutes ago                           sharp_volhard\n01c950718166        hello-world         \"/hello\"            About an hour ago   Exited (0) About an hour ago                       festive_williams\n```\n要查看您创建的最新容器，请将其传递给-l交换机：\n```shell\ndocker ps -l\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES\nd9b100f2f636        ubuntu              \"/bin/bash\"         About an hour ago   Exited (0) 10 minutes ago                       sharp_volhard\n```\n要启动已停止的容器，请使用docker start，后跟容器ID或容器名称。让我们启动基于Ubuntu的容器，其ID为 d9b100f2f636：\n```shell\ndocker start d9b100f2f636\n```\n容器将启动，您可以使用它docker ps来查看其状态：\n```shell\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nd9b100f2f636        ubuntu              \"/bin/bash\"         About an hour ago   Up 8 seconds                            sharp_volhard\n```\n要停止正在运行的容器，请使用docker stop，后跟容器ID或名称。这次，我们将使用Docker分配容器的名称，即sharp_volhard：\n```shell\ndocker stop sharp_volhard\n```\n一旦您决定不再需要容器，请使用该docker rm命令将其删除，再次使用容器ID或名称。使用该docker ps -a命令查找与hello-world映像关联的容器的容器ID或名称，然后将其删除。\n\n```shell\ndocker rm festive_williams\n```\n\n您可以使用--name开关启动一个新容器并为其命名。您还可以使用该--rm开关创建一个在停止时自行删除的容器。有关docker run help这些选项和其他选项的更多信息，请参阅该命令。\n\n容器可以转换为可用于构建新容器的映像。让我们来看看它是如何工作的\n\n## 将容器中的更改提交到Docker镜像\n当您启动Docker镜像时，您可以像使用虚拟机一样创建，修改和删除文件。您所做的更改仅适用于该容器。您可以启动和停止它，但是一旦使用该docker rm命令销毁它，更改将永久丢失。\n\n本节介绍如何将容器的状态保存为新的Docker镜像。\n\n在Ubuntu容器中安装Node.js后，您现在有一个运行图像的容器，但容器与您用来创建它的图像不同。但是您可能希望稍后重新使用此Node.js容器作为新映像的基础。\n\n然后使用以下命令将更改提交到新的Docker镜像实例。\n\n```shell\ndocker commit -m \"What you did to the image\" -a \"Author Name\" container_id repository/new_image_name\n```\n该-m开关是提交信息，可以帮助你和其他人知道你所做的修改，而-a用于指定作者。container_id当您启动交互式Docker会话时，这是您在本教程前面提到的那个。除非您在Docker Hub上创建了其他存储库，否则repository通常是您的Docker Hub用户名。\n\n例如，对于用户sammy，使用容器ID d9b100f2f636，命令将是：\n```shell\ndocker commit -m \"added Node.js\" -a \"sammy\" d9b100f2f636 sammy/ubuntu-nodejs\n```\n当你提交的图像，新的图像在您的计算机上本地保存。在本教程的后面，您将学习如何将映像推送到Docker Hub之类的Docker注册表，以便其他人可以访问它。\n\n再次列出Docker图像将显示新图像以及从中派生的旧图像：\n```shell\ndocker images\n```\n你会看到这样的输出：\n```shell\nOutput\nREPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\nsammy/ubuntu-nodejs   latest              7c1f35226ca6        7 seconds ago       179MB\nubuntu                   latest              113a43faa138        4 weeks ago         81.2MB\nhello-world              latest              e38bc07ac18e        2 months ago        1.85kB\n```\n在此示例中，ubuntu-nodejs是新图像，它是ubuntu从Docker Hub 的现有图像派生的。尺寸差异反映了所做的变化。在此示例中，更改是NodeJS已安装。因此，下次需要使用预先安装了NodeJS的Ubuntu运行容器时，您可以使用新映像。\n\n您还可以从a构建映像Dockerfile，这样可以在新映像中自动安装软件。但是，这超出了本教程的范围。\n\n现在让我们与他人分享新图像，以便他们可以从中创建容器。\n\n## 将Docker镜像推送到Docker存储库\n\n从现有映像创建新映像之后的下一个逻辑步骤是与您选择的几个朋友，Docker Hub上的整个世界或您可以访问的其他Docker注册表共享它。要将映像推送到Docker Hub或任何其他Docker注册表，您必须在那里拥有一个帐户。\n\n本节介绍如何将Docker镜像推送到Docker Hub。要了解如何创建自己的私有Docker注册表，请查看如何在Ubuntu 14.04上设置私有Docker注册表。\n\n要推送图像，请先登录Docker Hub。\n```shell\ndocker login -u docker-registry-username\n```\n系统将提示您使用Docker Hub密码进行身份验证。如果您指定了正确的密码，则身份验证应该成功。然后你可以使用以下方法推送自己的图像\n```shell\ndocker push docker-registry-username/docker-image-name\n```\n要将ubuntu-nodejs图像推送到sammy存储库，命令将是：\n```shell\ndocker push sammy/ubuntu-nodejs\n```\n上传图像时，该过程可能需要一些时间才能完成，但完成后，输出将如下所示：\n```shell\nOutput\nThe push refers to a repository [docker.io/sammy/ubuntu-nodejs]\ne3fbbfb44187: Pushed\n5f70bf18a086: Pushed\na3b5c80a4eba: Pushed\n7f18b442972b: Pushed\n3ce512daaf78: Pushed\n7aae4540b42d: Pushed\n\n...\n```\n\n将图像推送到注册表后，它应该列在您帐户的仪表板上，如下图所示。\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fw5iuokdkaj30ud0au3zr.jpg)\n\n如果推送尝试导致此类错误，那么您可能没有登录：\n```shell\nOutput\nThe push refers to a repository [docker.io/sammy/ubuntu-nodejs]\ne3fbbfb44187: Preparing\n5f70bf18a086: Preparing\na3b5c80a4eba: Preparing\n7f18b442972b: Preparing\n3ce512daaf78: Preparing\n7aae4540b42d: Waiting\nunauthorized: authentication required\n```\n登录docker login并重复推送尝试。然后验证它是否存在于Docker Hub存储库页面上。\n\n您现在可以使用将图像拉到新计算机并使用它来运行新容器。\n```shell\ndocker pull sammy/ubuntu-node<^>\n```\n\n## 结论\n在本教程中，您安装了Docker，使用了镜像和容器，并将修改后的镜像推送到Docker Hub。现在您已了解基础知识，请浏览DigitalOcean社区中的其他Docker教程。","content":"<p>Ubuntu 16.04安装Docker</p>\n<span id=\"more\"></span>\n\n<h2 id=\"查看Ubuntu版本\"><a href=\"#查看Ubuntu版本\" class=\"headerlink\" title=\"查看Ubuntu版本\"></a>查看Ubuntu版本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo lsb_release -a</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/issue</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看Linux-内核版本\"><a href=\"#查看Linux-内核版本\" class=\"headerlink\" title=\"查看Linux 内核版本\"></a>查看Linux 内核版本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装Docker</h2><p>官方Ubuntu存储库中提供的Docker安装包可能不是最新版本。为了确保我们获得最新版本，我们将从官方Docker存储库安装Docker。为此，我们将添加一个新的包源，从Docker添加GPG密钥以确保下载有效，然后安装该包。</p>\n<p>首先，更新现有的包列表：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n\n<p>接下来，安装一些允许apt通过HTTPS使用包的必备软件包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure>\n<p>然后将官方Docker存储库的GPG密钥添加到您的系统：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n<p>将Docker存储库添加到APT源：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;</span><br></pre></td></tr></table></figure>\n<p>接下来，使用新添加的repo中的Docker包更新包数据库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n<p>确保您要从Docker repo而不是默认的Ubuntu repo安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-cache policy docker-ce</span><br></pre></td></tr></table></figure>\n<p>虽然Docker的版本号可能不同，但您会看到这样的输出：<br>apt-cache策略docker-ce的输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-ce:</span><br><span class=\"line\">  Installed: (none)</span><br><span class=\"line\">  Candidate: 18.03.1~ce~3-0~ubuntu</span><br><span class=\"line\">  Version table:</span><br><span class=\"line\">     18.03.1~ce~3-0~ubuntu 500</span><br><span class=\"line\">        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br></pre></td></tr></table></figure>\n<p>请注意，docker-ce未安装，但安装的候选者来自Ubuntu 18.04（bionic）的Docker存储库。</p>\n<p>最后，安装Docker：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install docker-ce</span><br></pre></td></tr></table></figure>\n<p>现在应该安装Docker，守护进程启动，并启用进程启动进程。检查它是否正在运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status docker</span><br></pre></td></tr></table></figure>\n<p>输出应类似于以下内容，表明该服务处于活动状态并正在运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">● docker.service - Docker Application Container Engine</span><br><span class=\"line\">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Thu 2018-07-05 15:08:39 UTC; 2min 55s ago</span><br><span class=\"line\">     Docs: https://docs.docker.com</span><br><span class=\"line\"> Main PID: 10096 (dockerd)</span><br><span class=\"line\">    Tasks: 16</span><br><span class=\"line\">   CGroup: /system.slice/docker.service</span><br><span class=\"line\">           ├─10096 /usr/bin/dockerd -H fd://</span><br><span class=\"line\">           └─10113 docker-containerd --config /var/run/docker/containerd/containerd.toml</span><br></pre></td></tr></table></figure>\n<p>现在安装Docker不仅可以为您提供Docker服务（守护程序），还可以为您提供docker命令行实用程序或Docker客户端。我们将docker在本教程后面探讨如何使用该命令。</p>\n<h2 id=\"在没有Sudo的情况下执行Docker命令\"><a href=\"#在没有Sudo的情况下执行Docker命令\" class=\"headerlink\" title=\"在没有Sudo的情况下执行Docker命令\"></a>在没有Sudo的情况下执行Docker命令</h2><p>默认情况下，该docker命令只能由root用户或docker组中的用户运行，该用户在Docker的安装过程中自动创建。如果您尝试运行该docker命令而不使用sudo或不在docker组中作为前缀，您将获得如下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">docker: Cannot connect to the Docker daemon. Is the docker daemon running on this host?.</span><br><span class=\"line\">See &#x27;docker run --help&#x27;.</span><br></pre></td></tr></table></figure>\n<p>如果要sudo在运行docker命令时避免键入，请将用户名添加到docker组中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker $&#123;USER&#125;</span><br></pre></td></tr></table></figure>\n<p>要应用新的组成员身份，请注销服务器并重新登录，或键入以下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su - $&#123;USER&#125;</span><br></pre></td></tr></table></figure>\n<p>系统将提示您输入用户密码以继续。</p>\n<p>通过键入以下内容确认您的用户现已添加到docker组：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id -nG</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username sudo docker</span><br></pre></td></tr></table></figure>\n\n<p>如果您需要将用户添加到docker您未登录的组中，请使用以下方式明确声明该用户名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker username</span><br></pre></td></tr></table></figure>\n<p>本文的其余部分假定您docker以docker组中的用户身份运行该命令。如果您选择不这样做，请在前面添加命令sudo。</p>\n<h2 id=\"使用Docker命令\"><a href=\"#使用Docker命令\" class=\"headerlink\" title=\"使用Docker命令\"></a>使用Docker命令</h2><p>使用docker包括传递一系列选项和命令，后跟参数。语法采用以下形式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker [option] [command] [arguments]</span><br></pre></td></tr></table></figure>\n<p>要查看所有可用的子命令，请键入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker</span><br></pre></td></tr></table></figure>\n\n<p>从Docker 18开始，可用子命令的完整列表包括：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\"></span><br><span class=\"line\">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class=\"line\">  build       Build an image from a Dockerfile</span><br><span class=\"line\">  commit      Create a new image from a container&#x27;s changes</span><br><span class=\"line\">  cp          Copy files/folders between a container and the local filesystem</span><br><span class=\"line\">  create      Create a new container</span><br><span class=\"line\">  diff        Inspect changes to files or directories on a container&#x27;s filesystem</span><br><span class=\"line\">  events      Get real time events from the server</span><br><span class=\"line\">  exec        Run a command in a running container</span><br><span class=\"line\">  export      Export a container&#x27;s filesystem as a tar archive</span><br><span class=\"line\">  history     Show the history of an image</span><br><span class=\"line\">  images      List images</span><br><span class=\"line\">  import      Import the contents from a tarball to create a filesystem image</span><br><span class=\"line\">  info        Display system-wide information</span><br><span class=\"line\">  inspect     Return low-level information on Docker objects</span><br><span class=\"line\">  kill        Kill one or more running containers</span><br><span class=\"line\">  load        Load an image from a tar archive or STDIN</span><br><span class=\"line\">  login       Log in to a Docker registry</span><br><span class=\"line\">  logout      Log out from a Docker registry</span><br><span class=\"line\">  logs        Fetch the logs of a container</span><br><span class=\"line\">  pause       Pause all processes within one or more containers</span><br><span class=\"line\">  port        List port mappings or a specific mapping for the container</span><br><span class=\"line\">  ps          List containers</span><br><span class=\"line\">  pull        Pull an image or a repository from a registry</span><br><span class=\"line\">  push        Push an image or a repository to a registry</span><br><span class=\"line\">  rename      Rename a container</span><br><span class=\"line\">  restart     Restart one or more containers</span><br><span class=\"line\">  rm          Remove one or more containers</span><br><span class=\"line\">  rmi         Remove one or more images</span><br><span class=\"line\">  run         Run a command in a new container</span><br><span class=\"line\">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class=\"line\">  search      Search the Docker Hub for images</span><br><span class=\"line\">  start       Start one or more stopped containers</span><br><span class=\"line\">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class=\"line\">  stop        Stop one or more running containers</span><br><span class=\"line\">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class=\"line\">  top         Display the running processes of a container</span><br><span class=\"line\">  unpause     Unpause all processes within one or more containers</span><br><span class=\"line\">  update      Update configuration of one or more containers</span><br><span class=\"line\">  version     Show the Docker version information</span><br><span class=\"line\">  wait        Block until one or more containers stop, then print their exit codes</span><br></pre></td></tr></table></figure>\n<p>要查看特定命令可用的选项，请键入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker docker-subcommand --help</span><br></pre></td></tr></table></figure>\n<p>要查看有关Docker的系统范围信息，请使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用Docker镜像\"><a href=\"#使用Docker镜像\" class=\"headerlink\" title=\"使用Docker镜像\"></a>使用Docker镜像</h2><p>Docker容器是从Docker镜像构建的。默认情况下，Docker从[Docker Hub]（<a href=\"https://hub.docker.com)中提取这些图像,这是一个由docker管理的docker注册表,这是docker项目背后的公司.任何人都可以在docker/\">https://hub.docker.com）中提取这些图像，这是一个由Docker管理的Docker注册表，这是Docker项目背后的公司。任何人都可以在Docker</a> Hub上托管他们的Docker镜像，所以大多数您需要的应​​用程序和Linux发行版将在那里托管图像。</p>\n<p>要检查您是否可以从Docker Hub访问和下载图像，请键入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run hello-world</span><br></pre></td></tr></table></figure>\n<p>输出将指示Docker正常工作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class=\"line\">latest: Pulling from library/hello-world</span><br><span class=\"line\">9bb5a5d4561a: Pull complete</span><br><span class=\"line\">Digest: sha256:3e1764d0f546ceac4565547df2ac4907fe46f007ea229fd7ef2718514bcec35d</span><br><span class=\"line\">Status: Downloaded newer image for hello-world:latest</span><br><span class=\"line\"></span><br><span class=\"line\">Hello from Docker!</span><br><span class=\"line\">This message shows that your installation appears to be working correctly.</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>Docker最初无法在hello-world本地找到图像，因此它从Docker Hub下载了图像，Docker Hub是默认存储库。下载映像后，Docker从映像创建了一个容器，并在容器中执行了应用程序，显示了该消息。</p>\n<p>您可以使用带子docker命令的search命令搜索Docker Hub上可用的图像。例如，要搜索Ubuntu映像，请键入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search ubuntu</span><br></pre></td></tr></table></figure>\n<p>该脚本将对Docker Hub进行爬网，并返回名称与搜索字符串匹配的所有图像的列表。在这种情况下，输出将类似于：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">NAME                                                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class=\"line\">ubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   7917                [OK]</span><br><span class=\"line\">dorowu/ubuntu-desktop-lxde-vnc                            Ubuntu with openssh-server and NoVNC            193                                     [OK]</span><br><span class=\"line\">rastasheep/ubuntu-sshd                                    Dockerized SSH service, built on top of offi…   156                                     [OK]</span><br><span class=\"line\">ansible/ubuntu14.04-ansible                               Ubuntu 14.04 LTS with ansible                   93                                      [OK]</span><br><span class=\"line\">ubuntu-upstart                                            Upstart is an event-based replacement for th…   87                  [OK]</span><br><span class=\"line\">neurodebian                                               NeuroDebian provides neuroscience research s…   50                  [OK]</span><br><span class=\"line\">ubuntu-debootstrap                                        debootstrap --variant=minbase --components=m…   38                  [OK]</span><br><span class=\"line\">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5      ubuntu-16-nginx-php-phpmyadmin-mysql-5          36                                      [OK]</span><br><span class=\"line\">nuagebec/ubuntu                                           Simple always updated Ubuntu docker images w…   23                                      [OK]</span><br><span class=\"line\">tutum/ubuntu                                              Simple Ubuntu docker images with SSH access     18</span><br><span class=\"line\">i386/ubuntu                                               Ubuntu is a Debian-based Linux operating sys…   13</span><br><span class=\"line\">ppc64le/ubuntu                                            Ubuntu is a Debian-based Linux operating sys…   12</span><br><span class=\"line\">1and1internet/ubuntu-16-apache-php-7.0                    ubuntu-16-apache-php-7.0                        10                                      [OK]</span><br><span class=\"line\">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10   ubuntu-16-nginx-php-phpmyadmin-mariadb-10       6                                       [OK]</span><br><span class=\"line\">eclipse/ubuntu_jdk8                                       Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   6                                       [OK]</span><br><span class=\"line\">codenvy/ubuntu_jdk8                                       Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   4                                       [OK]</span><br><span class=\"line\">darksheer/ubuntu                                          Base Ubuntu Image -- Updated hourly             4                                       [OK]</span><br><span class=\"line\">1and1internet/ubuntu-16-apache                            ubuntu-16-apache                                3                                       [OK]</span><br><span class=\"line\">1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4         ubuntu-16-nginx-php-5.6-wordpress-4             3                                       [OK]</span><br><span class=\"line\">1and1internet/ubuntu-16-sshd                              ubuntu-16-sshd                                  1                                       [OK]</span><br><span class=\"line\">pivotaldata/ubuntu                                        A quick freshening-up of the base Ubuntu doc…   1</span><br><span class=\"line\">1and1internet/ubuntu-16-healthcheck                       ubuntu-16-healthcheck                           0                                       [OK]</span><br><span class=\"line\">pivotaldata/ubuntu-gpdb-dev                               Ubuntu images for GPDB development              0</span><br><span class=\"line\">smartentry/ubuntu                                         ubuntu with smartentry                          0                                       [OK]</span><br><span class=\"line\">ossobv/ubuntu</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>在OFFICIAL列中，OK表示由项目后面的公司构建和支持的图像。确定要使用的映像后，可以使用pull子命令将其下载到计算机。</p>\n<p>执行以下命令将官方ubuntu映像下载到您的计算机：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull ubuntu</span><br></pre></td></tr></table></figure>\n<p>您将看到以下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/ubuntu</span><br><span class=\"line\">6b98dfc16071: Pull complete</span><br><span class=\"line\">4001a1209541: Pull complete</span><br><span class=\"line\">6319fc68c576: Pull complete</span><br><span class=\"line\">b24603670dc3: Pull complete</span><br><span class=\"line\">97f170c87c6f: Pull complete</span><br><span class=\"line\">Digest: sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d</span><br><span class=\"line\">Status: Downloaded newer image for ubuntu:latest</span><br></pre></td></tr></table></figure>\n<p>下载映像后，可以使用带有run子命令的下载映像运行容器。正如您在hello-world示例中看到的，如果在docker使用run子命令执行时未下载图像，则Docker客户端将首先下载图像，然后使用它运行容器。</p>\n<p>要查看已下载到计算机的图像，请键入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>输出应类似于以下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">ubuntu              latest              113a43faa138        4 weeks ago         81.2MB</span><br><span class=\"line\">hello-world         latest              e38bc07ac18e        2 months ago        1.85kB</span><br></pre></td></tr></table></figure>\n<p>正如您将在本教程后面看到的那样，用于运行容器的图像可以被修改并用于生成新图像，然后可以将其上载（推送是技术术语）到Docker Hub或其他Docker注册表。</p>\n<p>我们来看看如何更详细地运行容器。</p>\n<h2 id=\"运行Docker容器\"><a href=\"#运行Docker容器\" class=\"headerlink\" title=\"运行Docker容器\"></a>运行Docker容器</h2><p>在hello-world您在上一步中跑容器是运行并发出一个测试消息之后退出容器的一个例子。容器可以比这更有用，它们可以是交互式的。毕竟，它们类似于虚拟机，只是更加资源友好。</p>\n<p>举个例子，让我们使用Ubuntu的最新图像运行一个容器。-i和-t开关的组合为您提供了对容器的交互式shell访问：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it ubuntu</span><br></pre></td></tr></table></figure>\n<p>您的命令提示符应该更改以反映您现在正在容器内工作的事实，并应采用以下形式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">root@d9b100f2f636:/#</span><br></pre></td></tr></table></figure>\n<p>请注意命令提示符中的容器ID。在这个例子中，它是d9b100f2f636。稍后您需要该容器ID以在要删除容器时标识容器。</p>\n<p>现在您可以在容器内运行任何命令。例如，让我们更新容器内的包数据库。您不需要为任何命令添加前缀sudo，因为您以root用户身份在容器内操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt update</span><br></pre></td></tr></table></figure>\n<p>然后在其中安装任何应用程序。我们安装Node.js：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install nodejs</span><br></pre></td></tr></table></figure>\n<p>这将从官方Ubuntu存储库中安装容器中的Node.js. 安装完成后，验证是否已安装Node.js：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n<p>您将看到终端中显示的版本号：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">v8.10.0</span><br></pre></td></tr></table></figure>\n<p>您在容器内进行的任何更改仅适用于该容器。</p>\n<p>要退出容器，请exit在提示符处键入。</p>\n<p>让我们看看下一步管理我们系统上的容器</p>\n<h2 id=\"管理Docker容器\"><a href=\"#管理Docker容器\" class=\"headerlink\" title=\"管理Docker容器\"></a>管理Docker容器</h2><p>使用Docker一段时间后，您的计算机上将有许多活动（运行）和非活动容器。要查看活动的，请使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>您将看到类似于以下内容的输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             </span><br></pre></td></tr></table></figure>\n<p>在本教程中，您启动了两个容器; 一个来自hello-world图像，另一个来自ubuntu图像。两个容器都不再运行，但它们仍然存在于您的系统上。</p>\n<p>要查看所有容器 - 活动和非活动，请docker ps 使用-a开关运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure>\n<p>您将看到类似于此的输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d9b100f2f636        ubuntu              &quot;/bin/bash&quot;         About an hour ago   Exited (0) 8 minutes ago                           sharp_volhard</span><br><span class=\"line\">01c950718166        hello-world         &quot;/hello&quot;            About an hour ago   Exited (0) About an hour ago                       festive_williams</span><br></pre></td></tr></table></figure>\n<p>要查看您创建的最新容器，请将其传递给-l交换机：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -l</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class=\"line\">d9b100f2f636        ubuntu              &quot;/bin/bash&quot;         About an hour ago   Exited (0) 10 minutes ago                       sharp_volhard</span><br></pre></td></tr></table></figure>\n<p>要启动已停止的容器，请使用docker start，后跟容器ID或容器名称。让我们启动基于Ubuntu的容器，其ID为 d9b100f2f636：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start d9b100f2f636</span><br></pre></td></tr></table></figure>\n<p>容器将启动，您可以使用它docker ps来查看其状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class=\"line\">d9b100f2f636        ubuntu              &quot;/bin/bash&quot;         About an hour ago   Up 8 seconds                            sharp_volhard</span><br></pre></td></tr></table></figure>\n<p>要停止正在运行的容器，请使用docker stop，后跟容器ID或名称。这次，我们将使用Docker分配容器的名称，即sharp_volhard：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop sharp_volhard</span><br></pre></td></tr></table></figure>\n<p>一旦您决定不再需要容器，请使用该docker rm命令将其删除，再次使用容器ID或名称。使用该docker ps -a命令查找与hello-world映像关联的容器的容器ID或名称，然后将其删除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm festive_williams</span><br></pre></td></tr></table></figure>\n\n<p>您可以使用–name开关启动一个新容器并为其命名。您还可以使用该–rm开关创建一个在停止时自行删除的容器。有关docker run help这些选项和其他选项的更多信息，请参阅该命令。</p>\n<p>容器可以转换为可用于构建新容器的映像。让我们来看看它是如何工作的</p>\n<h2 id=\"将容器中的更改提交到Docker镜像\"><a href=\"#将容器中的更改提交到Docker镜像\" class=\"headerlink\" title=\"将容器中的更改提交到Docker镜像\"></a>将容器中的更改提交到Docker镜像</h2><p>当您启动Docker镜像时，您可以像使用虚拟机一样创建，修改和删除文件。您所做的更改仅适用于该容器。您可以启动和停止它，但是一旦使用该docker rm命令销毁它，更改将永久丢失。</p>\n<p>本节介绍如何将容器的状态保存为新的Docker镜像。</p>\n<p>在Ubuntu容器中安装Node.js后，您现在有一个运行图像的容器，但容器与您用来创建它的图像不同。但是您可能希望稍后重新使用此Node.js容器作为新映像的基础。</p>\n<p>然后使用以下命令将更改提交到新的Docker镜像实例。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m &quot;What you did to the image&quot; -a &quot;Author Name&quot; container_id repository/new_image_name</span><br></pre></td></tr></table></figure>\n<p>该-m开关是提交信息，可以帮助你和其他人知道你所做的修改，而-a用于指定作者。container_id当您启动交互式Docker会话时，这是您在本教程前面提到的那个。除非您在Docker Hub上创建了其他存储库，否则repository通常是您的Docker Hub用户名。</p>\n<p>例如，对于用户sammy，使用容器ID d9b100f2f636，命令将是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m &quot;added Node.js&quot; -a &quot;sammy&quot; d9b100f2f636 sammy/ubuntu-nodejs</span><br></pre></td></tr></table></figure>\n<p>当你提交的图像，新的图像在您的计算机上本地保存。在本教程的后面，您将学习如何将映像推送到Docker Hub之类的Docker注册表，以便其他人可以访问它。</p>\n<p>再次列出Docker图像将显示新图像以及从中派生的旧图像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>你会看到这样的输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">sammy/ubuntu-nodejs   latest              7c1f35226ca6        7 seconds ago       179MB</span><br><span class=\"line\">ubuntu                   latest              113a43faa138        4 weeks ago         81.2MB</span><br><span class=\"line\">hello-world              latest              e38bc07ac18e        2 months ago        1.85kB</span><br></pre></td></tr></table></figure>\n<p>在此示例中，ubuntu-nodejs是新图像，它是ubuntu从Docker Hub 的现有图像派生的。尺寸差异反映了所做的变化。在此示例中，更改是NodeJS已安装。因此，下次需要使用预先安装了NodeJS的Ubuntu运行容器时，您可以使用新映像。</p>\n<p>您还可以从a构建映像Dockerfile，这样可以在新映像中自动安装软件。但是，这超出了本教程的范围。</p>\n<p>现在让我们与他人分享新图像，以便他们可以从中创建容器。</p>\n<h2 id=\"将Docker镜像推送到Docker存储库\"><a href=\"#将Docker镜像推送到Docker存储库\" class=\"headerlink\" title=\"将Docker镜像推送到Docker存储库\"></a>将Docker镜像推送到Docker存储库</h2><p>从现有映像创建新映像之后的下一个逻辑步骤是与您选择的几个朋友，Docker Hub上的整个世界或您可以访问的其他Docker注册表共享它。要将映像推送到Docker Hub或任何其他Docker注册表，您必须在那里拥有一个帐户。</p>\n<p>本节介绍如何将Docker镜像推送到Docker Hub。要了解如何创建自己的私有Docker注册表，请查看如何在Ubuntu 14.04上设置私有Docker注册表。</p>\n<p>要推送图像，请先登录Docker Hub。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login -u docker-registry-username</span><br></pre></td></tr></table></figure>\n<p>系统将提示您使用Docker Hub密码进行身份验证。如果您指定了正确的密码，则身份验证应该成功。然后你可以使用以下方法推送自己的图像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push docker-registry-username/docker-image-name</span><br></pre></td></tr></table></figure>\n<p>要将ubuntu-nodejs图像推送到sammy存储库，命令将是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push sammy/ubuntu-nodejs</span><br></pre></td></tr></table></figure>\n<p>上传图像时，该过程可能需要一些时间才能完成，但完成后，输出将如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">The push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span><br><span class=\"line\">e3fbbfb44187: Pushed</span><br><span class=\"line\">5f70bf18a086: Pushed</span><br><span class=\"line\">a3b5c80a4eba: Pushed</span><br><span class=\"line\">7f18b442972b: Pushed</span><br><span class=\"line\">3ce512daaf78: Pushed</span><br><span class=\"line\">7aae4540b42d: Pushed</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>将图像推送到注册表后，它应该列在您帐户的仪表板上，如下图所示。<br><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fw5iuokdkaj30ud0au3zr.jpg\"></p>\n<p>如果推送尝试导致此类错误，那么您可能没有登录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">The push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span><br><span class=\"line\">e3fbbfb44187: Preparing</span><br><span class=\"line\">5f70bf18a086: Preparing</span><br><span class=\"line\">a3b5c80a4eba: Preparing</span><br><span class=\"line\">7f18b442972b: Preparing</span><br><span class=\"line\">3ce512daaf78: Preparing</span><br><span class=\"line\">7aae4540b42d: Waiting</span><br><span class=\"line\">unauthorized: authentication required</span><br></pre></td></tr></table></figure>\n<p>登录docker login并重复推送尝试。然后验证它是否存在于Docker Hub存储库页面上。</p>\n<p>您现在可以使用将图像拉到新计算机并使用它来运行新容器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull sammy/ubuntu-node&lt;^&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>在本教程中，您安装了Docker，使用了镜像和容器，并将修改后的镜像推送到Docker Hub。现在您已了解基础知识，请浏览DigitalOcean社区中的其他Docker教程。</p>\n","slug":"Ubuntu-16-04安装Docker","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/12/Ubuntu-16-04%E5%AE%89%E8%A3%85Docker/","excerpt":"Ubuntu 16.04安装Docker","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://vwin.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"http://vwin.github.io/tags/docker/"}]},{"title":"Jenkins HTML报告样式无法显示问题解决","date":"2018-10-11T04:52:45.000Z","path":"2018/10/11/Jenkins-HTML报告样式无法显示问题解决/","text":"在部署jenkins持续集成的过程中经常会用到HTML Publisher Plugin插件来显示测试报告。为了测试报告样式的美观以及易读，测试报告中经常会搭配CSS和JS实现自定义的样式或动画效果。Jenkins中在访问有自定义样式或动画效果的测试报告时，展示的样式往往会出乎你的想象，面目全非，样式错乱，动画无法展示等等问题。打开浏览器开发工具控制台，可以看到CSS、JS加载失败。 问题 原因Jenkins为了避免受到恶意HTML&#x2F;JS文件的攻击，会默认将安全策略CSP设置为：sandbox; default-src ‘none’; img-src ‘self’; style-src ‘self’; 在此配置下，只允许加载： Jenkins服务器上托管的CSS文件 Jenkins服务器上托管的图片文件 以下形式的内容都会被禁止： JavaScript plugins (object&#x2F;embed) HTML中的内联样式表（Inline style sheets），以及引用的外站CSS文件 HTML中的内联图片（Inline image definitions），以及外站引用的图片文件 frames web fonts XHR&#x2F;AJAX 解决\b方法一修改CSP(Content Security Policy)的默认配置，到Jenkins系统管理-&gt;脚本命令行，执行以下Groovy命令，然后点击运行。配置完成后，重新构建原有项目，HTML页面即可正常显示。 1System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;) 然而当你重新启动jenkins时，你会发现，HTML页面再次面目全非，CSP恢复为默认配置，因此这个办法只是临时方案 方法二利用jenkins的以下两个插件可以巧妙解决这个问题 Startup Trigger: 可实现在Jenkins节点(master&#x2F;slave)启动时触发构建； Groovy plugin: 可实现直接执行Groovy代码。 解决步骤如下： Jenkins中新建一个Job，该Job专用Jenkins启动时执行的配置命令。 在“构建触发器”模块，选择“Build when job nodes start”选项。 在“构建”模块，选择“Execute system Groovy script”，执行如下Groovy命令：1System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;) 立即构建此Job，返回原项目重新构建，再次访问HTML页面即可发现问题已解决。","raw":"---\ntitle: Jenkins HTML报告样式无法显示问题解决\ntoc: true\ndate: 2018-10-11 12:52:45\ntags: [持续集成,Jenkins,HTML]\ncategories: [测试]\ndescription:\n---\n\n在部署jenkins持续集成的过程中经常会用到HTML Publisher Plugin插件来显示测试报告。\n为了测试报告样式的美观以及易读，测试报告中经常会搭配CSS和JS实现自定义的样式或动画效果。\nJenkins中在访问有自定义样式或动画效果的测试报告时，展示的样式往往会出乎你的想象，面目全非，样式错乱，动画无法展示等等问题。打开浏览器开发工具控制台，可以看到CSS、JS加载失败。\n<!--more-->\n\n## 问题\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fw46y2sfysj30iv0cyjum.jpg)\n\n## 原因\nJenkins为了避免受到恶意HTML/JS文件的攻击，会默认将安全策略CSP设置为：\nsandbox; default-src 'none'; img-src 'self'; style-src 'self';\n\n在此配置下，只允许加载：\n\n1. Jenkins服务器上托管的CSS文件\n2. Jenkins服务器上托管的图片文件\n\n以下形式的内容都会被禁止：\n\n- JavaScript\n- plugins (object/embed)\n- HTML中的内联样式表（Inline style sheets），以及引用的外站CSS文件\n- HTML中的内联图片（Inline image definitions），以及外站引用的图片文件\n- frames\n- web fonts\n- XHR/AJAX\n\n## 解决\b\n### 方法一\n修改CSP(Content Security Policy)的默认配置，到Jenkins系统管理->脚本命令行，执行以下Groovy命令，然后点击运行。配置完成后，重新构建原有项目，HTML页面即可正常显示。\n```shell\nSystem.setProperty(\"hudson.model.DirectoryBrowserSupport.CSP\", \"\")\n```\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fw471l5bsvj30u0097ab2.jpg)\n然而当你重新启动jenkins时，你会发现，HTML页面再次面目全非，CSP恢复为默认配置，因此这个办法只是临时方案\n\n### 方法二\n利用jenkins的以下两个插件可以巧妙解决这个问题\n1. Startup Trigger: 可实现在Jenkins节点(master/slave)启动时触发构建；\n2. Groovy plugin: 可实现直接执行Groovy代码。\n\n解决步骤如下：\n1. Jenkins中新建一个Job，该Job专用Jenkins启动时执行的配置命令。\n2. 在“构建触发器”模块，选择“Build when job nodes start”选项。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fw472m709uj30le07qaar.jpg)\n\n3. 在“构建”模块，选择“Execute system Groovy script”，执行如下Groovy命令：\n```shell\nSystem.setProperty(\"hudson.model.DirectoryBrowserSupport.CSP\", \"\")\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fw4737k557j30so0b1jsg.jpg)\n\n立即构建此Job，返回原项目重新构建，再次访问HTML页面即可发现问题已解决。\n","content":"<p>在部署jenkins持续集成的过程中经常会用到HTML Publisher Plugin插件来显示测试报告。<br>为了测试报告样式的美观以及易读，测试报告中经常会搭配CSS和JS实现自定义的样式或动画效果。<br>Jenkins中在访问有自定义样式或动画效果的测试报告时，展示的样式往往会出乎你的想象，面目全非，样式错乱，动画无法展示等等问题。打开浏览器开发工具控制台，可以看到CSS、JS加载失败。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fw46y2sfysj30iv0cyjum.jpg\"></p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>Jenkins为了避免受到恶意HTML&#x2F;JS文件的攻击，会默认将安全策略CSP设置为：<br>sandbox; default-src ‘none’; img-src ‘self’; style-src ‘self’;</p>\n<p>在此配置下，只允许加载：</p>\n<ol>\n<li>Jenkins服务器上托管的CSS文件</li>\n<li>Jenkins服务器上托管的图片文件</li>\n</ol>\n<p>以下形式的内容都会被禁止：</p>\n<ul>\n<li>JavaScript</li>\n<li>plugins (object&#x2F;embed)</li>\n<li>HTML中的内联样式表（Inline style sheets），以及引用的外站CSS文件</li>\n<li>HTML中的内联图片（Inline image definitions），以及外站引用的图片文件</li>\n<li>frames</li>\n<li>web fonts</li>\n<li>XHR&#x2F;AJAX</li>\n</ul>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\b\"></a>解决\b</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>修改CSP(Content Security Policy)的默认配置，到Jenkins系统管理-&gt;脚本命令行，执行以下Groovy命令，然后点击运行。配置完成后，重新构建原有项目，HTML页面即可正常显示。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fw471l5bsvj30u0097ab2.jpg\"><br>然而当你重新启动jenkins时，你会发现，HTML页面再次面目全非，CSP恢复为默认配置，因此这个办法只是临时方案</p>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>利用jenkins的以下两个插件可以巧妙解决这个问题</p>\n<ol>\n<li>Startup Trigger: 可实现在Jenkins节点(master&#x2F;slave)启动时触发构建；</li>\n<li>Groovy plugin: 可实现直接执行Groovy代码。</li>\n</ol>\n<p>解决步骤如下：</p>\n<ol>\n<li>Jenkins中新建一个Job，该Job专用Jenkins启动时执行的配置命令。</li>\n<li>在“构建触发器”模块，选择“Build when job nodes start”选项。</li>\n</ol>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fw472m709uj30le07qaar.jpg\"></p>\n<ol start=\"3\">\n<li>在“构建”模块，选择“Execute system Groovy script”，执行如下Groovy命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fw4737k557j30so0b1jsg.jpg\"></p>\n<p>立即构建此Job，返回原项目重新构建，再次访问HTML页面即可发现问题已解决。</p>\n","slug":"Jenkins-HTML报告样式无法显示问题解决","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/11/Jenkins-HTML%E6%8A%A5%E5%91%8A%E6%A0%B7%E5%BC%8F%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"在部署jenkins持续集成的过程中经常会用到HTML Publisher Plugin插件来显示测试报告。为了测试报告样式的美观以及易读，测试报告中经常会搭配CSS和JS实现自定义的样式或动画效果。Jenkins中在访问有自定义样式或动画效果的测试报告时，展示的样式往往会出乎你的想象，面目全非，样式错乱，动画无法展示等等问题。打开浏览器开发工具控制台，可以看到CSS、JS加载失败。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"http://vwin.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://vwin.github.io/tags/Jenkins/"},{"name":"HTML","slug":"HTML","permalink":"http://vwin.github.io/tags/HTML/"}]},{"title":"Python 升级所有包","date":"2018-10-09T02:45:08.000Z","path":"2018/10/09/Python-升级所有包/","text":"Python升级所有已安装的包 pip 当前内建命令并不支持升级所有已安装的Python模块。 列出当前安装的包： 1pip list 列出可升级的包： 1pip list --outdate 升级一个包： 1pip install --upgrade requests // mac,linux,unix 在命令前加 sudo -H 升级所有可升级的包： 1pip freeze --local | grep -v &#x27;^-e&#x27; | cut -d = -f 1 | xargs -n1 pip install -U 1for i in `pip list -o --format legacy|awk &#x27;&#123;print $1&#125;&#x27;` ; do pip install --upgrade $i; done pip默认源由于墙，所以速度很慢，可使用第三源提高速度： 1vim ~/.pip/pip.conf 123[global]trusted-host = mirrors.aliyun.comindex-url = http://mirrors.aliyun.com/pypi/simple","raw":"---\ntitle: Python 升级所有包\ntoc: true\ndate: 2018-10-09 10:45:08\ntags: [python,pip]\ncategories: [技术]\ndescription: Python 升级所有包\n---\n\nPython升级所有已安装的包\n<!--more-->\n\npip 当前内建命令并不支持升级所有已安装的Python模块。\n\n列出当前安装的包：\n\n```shell\npip list\n```\n\n列出可升级的包：\n\n```shell\npip list --outdate\n```\n\n升级一个包：\n```shell\npip install --upgrade requests  // mac,linux,unix 在命令前加 sudo -H\n```\n\n升级所有可升级的包：\n\n```shell\npip freeze --local | grep -v '^-e' | cut -d = -f 1  | xargs -n1 pip install -U\n```\n\n```shell\nfor i in `pip list -o --format legacy|awk '{print $1}'` ; do pip install --upgrade $i; done\n```\n\npip默认源由于墙，所以速度很慢，可使用第三源提高速度：\n\n```shell\nvim ~/.pip/pip.conf\n```\n\n```shell\n[global]\ntrusted-host = mirrors.aliyun.com\nindex-url = http://mirrors.aliyun.com/pypi/simple\n```\n","content":"<p>Python升级所有已安装的包</p>\n<span id=\"more\"></span>\n\n<p>pip 当前内建命令并不支持升级所有已安装的Python模块。</p>\n<p>列出当前安装的包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip list</span><br></pre></td></tr></table></figure>\n\n<p>列出可升级的包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip list --outdate</span><br></pre></td></tr></table></figure>\n\n<p>升级一个包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install --upgrade requests  // mac,linux,unix 在命令前加 sudo -H</span><br></pre></td></tr></table></figure>\n\n<p>升级所有可升级的包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip freeze --local | grep -v &#x27;^-e&#x27; | cut -d = -f 1  | xargs -n1 pip install -U</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in `pip list -o --format legacy|awk &#x27;&#123;print $1&#125;&#x27;` ; do pip install --upgrade $i; done</span><br></pre></td></tr></table></figure>\n\n<p>pip默认源由于墙，所以速度很慢，可使用第三源提高速度：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">trusted-host = mirrors.aliyun.com</span><br><span class=\"line\">index-url = http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure>\n","slug":"Python-升级所有包","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/10/09/Python-%E5%8D%87%E7%BA%A7%E6%89%80%E6%9C%89%E5%8C%85/","excerpt":"Python升级所有已安装的包","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"pip","slug":"pip","permalink":"http://vwin.github.io/tags/pip/"}]},{"title":"Supervisor管理进程","date":"2018-09-19T07:09:43.000Z","path":"2018/09/19/Supervisor管理进程/","text":"使用 supervisor 管理进程Supervisor (http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。 转载自：http://liyangliang.me/posts/2015/06/using-supervisor/ 安装Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : 1sudo pip install supervisor 如果是 Ubuntu 系统，还可以使用 apt-get 安装。 supervisord 配置Supervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分：supervisord（supervisor 是一个 C&#x2F;S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）。 首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行echo_supervisord_conf 命令输出默认的配置项，也可以重定向到一个配置文件里： echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf去除里面大部分注释和“不相关”的部分，我们可以先看这些配置： 123456789101112131415161718192021222324252627282930313233[unix_http_server]file=/tmp/supervisor.sock ; UNIX socket 文件，supervisorctl 会使用;chmod=0700 ; socket 文件的 mode，默认是 0700;chown=nobody:nogroup ; socket 文件的 owner，格式： uid:gid;[inet_http_server] ; HTTP 服务器，提供 web 管理界面;port=127.0.0.1:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性;username=user ; 登录管理后台的用户名;password=123 ; 登录管理后台的密码[supervisord]logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB ; 日志文件大小，超出会 rotate，默认 50MBlogfile_backups=10 ; 日志文件保留备份数量默认 10loglevel=info ; 日志级别，默认 info，其它: debug,warn,tracepidfile=/tmp/supervisord.pid ; pid 文件nodaemon=false ; 是否在前台启动，默认是 false，即以 daemon 的方式启动minfds=1024 ; 可以打开的文件描述符的最小值，默认 1024minprocs=200 ; 可以打开的进程数的最小值，默认 200; the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord; 包含其他的配置文件[include]files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini 我们把上面这部分配置保存到 &#x2F;etc&#x2F;supervisord.conf（或其他任意有权限访问的文件），然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD&#x2F;supervisord.conf, $CWD&#x2F;etc&#x2F;supervisord.conf, &#x2F;etc&#x2F;supervisord.conf）： 1234supervisord -c /etc/supervisord.conf查看 supervisord 是否在运行：ps aux | grep supervisord program 配置上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。这些配置可以都写到 supervisord.conf 文件里，如果应用程序很多，最好通过 include 的方式把不同的程序（组）写到不同的配置文件里。 为了举例，我们新建一个目录 &#x2F;etc&#x2F;supervisor&#x2F; 用于存放这些配置文件，相应的，把 &#x2F;etc&#x2F;supervisord.conf 里 include 部分的的配置修改一下： 12[include]files = /etc/supervisor/*.conf 假设有个用 Flask 开发的用户系统 usercenter, 生产环境使用 gunicorn 运行。项目代码位于 &#x2F;home&#x2F;leon&#x2F;projects&#x2F;usercenter，WSGI 对象位于 wsgi.py。在命令行启动的方式是这样的： 12cd /home/leon/projects/usercentergunicorn -w 8 -b 0.0.0.0:17510 wsgi:app 对应的配置文件可能是： 12345678910111213[program:usercenter]directory = /home/leon/projects/usercenter ; 程序的启动目录command = gunicorn -w 8 -b 0.0.0.0:17510 wsgi:app ; 启动命令autostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = leon ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/usercenter_stdout.log 其中 [program:usercenter] 中的 usercenter 是应用程序的唯一标识，不能重复。对该程序的所有操作（start, restart 等）都通过名字来实现。 Tips 1: Python 环境有两种方式指定程序使用的 Python 环境： command 使用绝对路径。假设使用 pyenv 来管理 Python 环境，上面例子中的 gunicorn 路径可以替换为 &#x2F;home&#x2F;leon&#x2F;.pyenv&#x2F;versions&#x2F;usercenter&#x2F;bin&#x2F;gunicorn. 这种方式一目了然，推荐。通过 environment 配置 PYTHONPATH. environment&#x3D;PYTHONPATH&#x3D;$PYTHONPATH:&#x2F;home&#x2F;leon&#x2F;.pyenv&#x2F;versions&#x2F;usercenter&#x2F;bin&#x2F;. environment 这个配置项非常有用，可以用来给程序传入环境变量。 Tips 2: 后台进程Supervisor 只能管理在前台运行的程序，所以如果应用程序有后台运行的选项，需要关闭。 Tips 3: 子进程有时候用 Supervisor 托管的程序还会有子进程（如 Tornado），如果只杀死主进程，子进程就可能变成孤儿进程。通过这两项配置来确保所有子进程都能正确停止： 12stopasgroup=truekillasgroup=true 使用 supervisorctlSupervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。 supervisorctl -c &#x2F;etc&#x2F;supervisord.conf上面这个命令会进入 supervisorctl 的 shell 界面，然后可以执行不同的命令了： 123456&gt; status # 查看程序状态&gt; stop usercenter # 关闭 usercenter 程序&gt; start usercenter # 启动 usercenter 程序&gt; restart usercenter # 重启 usercenter 程序&gt; reread ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序&gt; update ＃ 重启配置文件修改过的程序 上面这些命令都有相应的输出，除了进入 supervisorctl 的 shell 界面，也可以直接在 bash 终端运行： 123456$ supervisorctl status$ supervisorctl stop usercenter$ supervisorctl start usercenter$ supervisorctl restart usercenter$ supervisorctl reread$ supervisorctl update 其它除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。 除了单个进程的控制，还可以配置 group，进行分组管理。 经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。 Supervisor 有很丰富的功能，还有其他很多项配置，可以在官方文档获取更多信息：http://supervisord.org/index.html 注意 权限问题，在program的配置中需要配置启动用户，需要确保该用户有写日志，启动程序的权限","raw":"---\ntitle: Supervisor管理进程\ntoc: true\ndate: 2018-09-19 15:09:43\ntags: [supervisor,gunicorn,linux]\ncategories: [技术]\ndescription:\n---\n使用 supervisor 管理进程\nSupervisor (http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。\n\n转载自：http://liyangliang.me/posts/2015/06/using-supervisor/\n<!--more-->\n\n## 安装\nSupervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip :\n```shell\nsudo pip install supervisor\n```\n\n如果是 Ubuntu 系统，还可以使用 apt-get 安装。\n\n## supervisord 配置\nSupervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分：supervisord（supervisor 是一个 C/S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）。\n\n首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行echo_supervisord_conf 命令输出默认的配置项，也可以重定向到一个配置文件里：\n\necho_supervisord_conf > /etc/supervisord.conf\n去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：\n\n```shell\n[unix_http_server]\nfile=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用\n;chmod=0700                 ; socket 文件的 mode，默认是 0700\n;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid\n\n;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面\n;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性\n;username=user              ; 登录管理后台的用户名\n;password=123               ; 登录管理后台的密码\n\n[supervisord]\nlogfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log\nlogfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB\nlogfile_backups=10           ; 日志文件保留备份数量默认 10\nloglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace\npidfile=/tmp/supervisord.pid ; pid 文件\nnodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动\nminfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024\nminprocs=200                 ; 可以打开的进程数的最小值，默认 200\n\n; the below section must remain in the config file for RPC\n; (supervisorctl/web interface) to work, additional interfaces may be\n; added by defining them in separate rpcinterface: sections\n[rpcinterface:supervisor]\nsupervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface\n\n[supervisorctl]\nserverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致\n;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord\n\n; 包含其他的配置文件\n[include]\nfiles = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini\n```\n\n我们把上面这部分配置保存到 /etc/supervisord.conf（或其他任意有权限访问的文件），然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD/supervisord.conf, $CWD/etc/supervisord.conf, /etc/supervisord.conf）：\n\n```shell\nsupervisord -c /etc/supervisord.conf\n查看 supervisord 是否在运行：\n\nps aux | grep supervisord\n```\n## program 配置\n上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。这些配置可以都写到 supervisord.conf 文件里，如果应用程序很多，最好通过 include 的方式把不同的程序（组）写到不同的配置文件里。\n\n为了举例，我们新建一个目录 /etc/supervisor/ 用于存放这些配置文件，相应的，把 /etc/supervisord.conf 里 include 部分的的配置修改一下：\n\n```shell\n[include]\nfiles = /etc/supervisor/*.conf\n```\n\n假设有个用 Flask 开发的用户系统 usercenter, 生产环境使用 gunicorn 运行。项目代码位于 /home/leon/projects/usercenter，WSGI 对象位于 wsgi.py。在命令行启动的方式是这样的：\n\n```shell\ncd /home/leon/projects/usercenter\ngunicorn -w 8 -b 0.0.0.0:17510 wsgi:app\n```\n\n对应的配置文件可能是：\n```shell\n[program:usercenter]\ndirectory = /home/leon/projects/usercenter ; 程序的启动目录\ncommand = gunicorn -w 8 -b 0.0.0.0:17510 wsgi:app  ; 启动命令\nautostart = true     ; 在 supervisord 启动的时候也自动启动\nstartsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了\nautorestart = true   ; 程序异常退出后自动重启\nstartretries = 3     ; 启动失败自动重试次数，默认是 3\nuser = leon          ; 用哪个用户启动\nredirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false\nstdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB\nstdout_logfile_backups = 20     ; stdout 日志文件备份数\n; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）\nstdout_logfile = /data/logs/usercenter_stdout.log\n```\n其中 [program:usercenter] 中的 usercenter 是应用程序的唯一标识，不能重复。\n对该程序的所有操作（start, restart 等）都通过名字来实现。\n\nTips 1: Python 环境\n有两种方式指定程序使用的 Python 环境：\n\ncommand 使用绝对路径。假设使用 pyenv 来管理 Python 环境，上面例子中的 gunicorn 路径可以替换为 /home/leon/.pyenv/versions/usercenter/bin/gunicorn. 这种方式一目了然，推荐。\n通过 environment 配置 PYTHONPATH. environment=PYTHONPATH=$PYTHONPATH:/home/leon/.pyenv/versions/usercenter/bin/. environment 这个配置项非常有用，可以用来给程序传入环境变量。\n\nTips 2: 后台进程\nSupervisor 只能管理在前台运行的程序，所以如果应用程序有后台运行的选项，需要关闭。\n\nTips 3: 子进程\n有时候用 Supervisor 托管的程序还会有子进程（如 Tornado），如果只杀死主进程，子进程就可能变成孤儿进程。通过这两项配置来确保所有子进程都能正确停止：\n\n```shell\nstopasgroup=true\nkillasgroup=true\n```\n\n使用 supervisorctl\nSupervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。\n\nsupervisorctl -c /etc/supervisord.conf\n上面这个命令会进入 supervisorctl 的 shell 界面，然后可以执行不同的命令了：\n```shell\n> status    # 查看程序状态\n> stop usercenter   # 关闭 usercenter 程序\n> start usercenter  # 启动 usercenter 程序\n> restart usercenter    # 重启 usercenter 程序\n> reread    ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序\n> update    ＃ 重启配置文件修改过的程序\n```\n上面这些命令都有相应的输出，除了进入 supervisorctl 的 shell 界面，也可以直接在 bash 终端运行：\n\n```shell\n$ supervisorctl status\n$ supervisorctl stop usercenter\n$ supervisorctl start usercenter\n$ supervisorctl restart usercenter\n$ supervisorctl reread\n$ supervisorctl update\n```\n\n## 其它\n\n除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。\n\n除了单个进程的控制，还可以配置 group，进行分组管理。\n\n经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。\n\nSupervisor 有很丰富的功能，还有其他很多项配置，可以在官方文档获取更多信息：http://supervisord.org/index.html\n\n## 注意\n> 权限问题，在program的配置中需要配置启动用户，需要确保该用户有写日志，启动程序的权限","content":"<p>使用 supervisor 管理进程<br>Supervisor (<a href=\"http://supervisord.org/\">http://supervisord.org</a>) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p>\n<p>转载自：<a href=\"http://liyangliang.me/posts/2015/06/using-supervisor/\">http://liyangliang.me/posts/2015/06/using-supervisor/</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install supervisor</span><br></pre></td></tr></table></figure>\n\n<p>如果是 Ubuntu 系统，还可以使用 apt-get 安装。</p>\n<h2 id=\"supervisord-配置\"><a href=\"#supervisord-配置\" class=\"headerlink\" title=\"supervisord 配置\"></a>supervisord 配置</h2><p>Supervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分：supervisord（supervisor 是一个 C&#x2F;S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）。</p>\n<p>首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行echo_supervisord_conf 命令输出默认的配置项，也可以重定向到一个配置文件里：</p>\n<p>echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf<br>去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[unix_http_server]</span><br><span class=\"line\">file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用</span><br><span class=\"line\">;chmod=0700                 ; socket 文件的 mode，默认是 0700</span><br><span class=\"line\">;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid</span><br><span class=\"line\"></span><br><span class=\"line\">;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面</span><br><span class=\"line\">;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span><br><span class=\"line\">;username=user              ; 登录管理后台的用户名</span><br><span class=\"line\">;password=123               ; 登录管理后台的密码</span><br><span class=\"line\"></span><br><span class=\"line\">[supervisord]</span><br><span class=\"line\">logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log</span><br><span class=\"line\">logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB</span><br><span class=\"line\">logfile_backups=10           ; 日志文件保留备份数量默认 10</span><br><span class=\"line\">loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace</span><br><span class=\"line\">pidfile=/tmp/supervisord.pid ; pid 文件</span><br><span class=\"line\">nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动</span><br><span class=\"line\">minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024</span><br><span class=\"line\">minprocs=200                 ; 可以打开的进程数的最小值，默认 200</span><br><span class=\"line\"></span><br><span class=\"line\">; the below section must remain in the config file for RPC</span><br><span class=\"line\">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class=\"line\">; added by defining them in separate rpcinterface: sections</span><br><span class=\"line\">[rpcinterface:supervisor]</span><br><span class=\"line\">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class=\"line\"></span><br><span class=\"line\">[supervisorctl]</span><br><span class=\"line\">serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span><br><span class=\"line\">;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord</span><br><span class=\"line\"></span><br><span class=\"line\">; 包含其他的配置文件</span><br><span class=\"line\">[include]</span><br><span class=\"line\">files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini</span><br></pre></td></tr></table></figure>\n\n<p>我们把上面这部分配置保存到 &#x2F;etc&#x2F;supervisord.conf（或其他任意有权限访问的文件），然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD&#x2F;supervisord.conf, $CWD&#x2F;etc&#x2F;supervisord.conf, &#x2F;etc&#x2F;supervisord.conf）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisord -c /etc/supervisord.conf</span><br><span class=\"line\">查看 supervisord 是否在运行：</span><br><span class=\"line\"></span><br><span class=\"line\">ps aux | grep supervisord</span><br></pre></td></tr></table></figure>\n<h2 id=\"program-配置\"><a href=\"#program-配置\" class=\"headerlink\" title=\"program 配置\"></a>program 配置</h2><p>上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。这些配置可以都写到 supervisord.conf 文件里，如果应用程序很多，最好通过 include 的方式把不同的程序（组）写到不同的配置文件里。</p>\n<p>为了举例，我们新建一个目录 &#x2F;etc&#x2F;supervisor&#x2F; 用于存放这些配置文件，相应的，把 &#x2F;etc&#x2F;supervisord.conf 里 include 部分的的配置修改一下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[include]</span><br><span class=\"line\">files = /etc/supervisor/*.conf</span><br></pre></td></tr></table></figure>\n\n<p>假设有个用 Flask 开发的用户系统 usercenter, 生产环境使用 gunicorn 运行。项目代码位于 &#x2F;home&#x2F;leon&#x2F;projects&#x2F;usercenter，WSGI 对象位于 wsgi.py。在命令行启动的方式是这样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/leon/projects/usercenter</span><br><span class=\"line\">gunicorn -w 8 -b 0.0.0.0:17510 wsgi:app</span><br></pre></td></tr></table></figure>\n\n<p>对应的配置文件可能是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:usercenter]</span><br><span class=\"line\">directory = /home/leon/projects/usercenter ; 程序的启动目录</span><br><span class=\"line\">command = gunicorn -w 8 -b 0.0.0.0:17510 wsgi:app  ; 启动命令</span><br><span class=\"line\">autostart = true     ; 在 supervisord 启动的时候也自动启动</span><br><span class=\"line\">startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了</span><br><span class=\"line\">autorestart = true   ; 程序异常退出后自动重启</span><br><span class=\"line\">startretries = 3     ; 启动失败自动重试次数，默认是 3</span><br><span class=\"line\">user = leon          ; 用哪个用户启动</span><br><span class=\"line\">redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false</span><br><span class=\"line\">stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB</span><br><span class=\"line\">stdout_logfile_backups = 20     ; stdout 日志文件备份数</span><br><span class=\"line\">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class=\"line\">stdout_logfile = /data/logs/usercenter_stdout.log</span><br></pre></td></tr></table></figure>\n<p>其中 [program:usercenter] 中的 usercenter 是应用程序的唯一标识，不能重复。<br>对该程序的所有操作（start, restart 等）都通过名字来实现。</p>\n<p>Tips 1: Python 环境<br>有两种方式指定程序使用的 Python 环境：</p>\n<p>command 使用绝对路径。假设使用 pyenv 来管理 Python 环境，上面例子中的 gunicorn 路径可以替换为 &#x2F;home&#x2F;leon&#x2F;.pyenv&#x2F;versions&#x2F;usercenter&#x2F;bin&#x2F;gunicorn. 这种方式一目了然，推荐。<br>通过 environment 配置 PYTHONPATH. environment&#x3D;PYTHONPATH&#x3D;$PYTHONPATH:&#x2F;home&#x2F;leon&#x2F;.pyenv&#x2F;versions&#x2F;usercenter&#x2F;bin&#x2F;. environment 这个配置项非常有用，可以用来给程序传入环境变量。</p>\n<p>Tips 2: 后台进程<br>Supervisor 只能管理在前台运行的程序，所以如果应用程序有后台运行的选项，需要关闭。</p>\n<p>Tips 3: 子进程<br>有时候用 Supervisor 托管的程序还会有子进程（如 Tornado），如果只杀死主进程，子进程就可能变成孤儿进程。通过这两项配置来确保所有子进程都能正确停止：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stopasgroup=true</span><br><span class=\"line\">killasgroup=true</span><br></pre></td></tr></table></figure>\n\n<p>使用 supervisorctl<br>Supervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。</p>\n<p>supervisorctl -c &#x2F;etc&#x2F;supervisord.conf<br>上面这个命令会进入 supervisorctl 的 shell 界面，然后可以执行不同的命令了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">status    <span class=\"comment\"># 查看程序状态</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">stop usercenter   <span class=\"comment\"># 关闭 usercenter 程序</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">start usercenter  <span class=\"comment\"># 启动 usercenter 程序</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">restart usercenter    <span class=\"comment\"># 重启 usercenter 程序</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">reread    ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">update    ＃ 重启配置文件修改过的程序</span></span><br></pre></td></tr></table></figure>\n<p>上面这些命令都有相应的输出，除了进入 supervisorctl 的 shell 界面，也可以直接在 bash 终端运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl status</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl stop usercenter</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl start usercenter</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl restart usercenter</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl reread</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl update</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。</p>\n<p>除了单个进程的控制，还可以配置 group，进行分组管理。</p>\n<p>经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。</p>\n<p>Supervisor 有很丰富的功能，还有其他很多项配置，可以在官方文档获取更多信息：<a href=\"http://supervisord.org/index.html\">http://supervisord.org/index.html</a></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><blockquote>\n<p>权限问题，在program的配置中需要配置启动用户，需要确保该用户有写日志，启动程序的权限</p>\n</blockquote>\n","slug":"Supervisor管理进程","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/09/19/Supervisor%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B/","excerpt":"使用 supervisor 管理进程Supervisor (http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。 转载自：http://liyangliang.me/posts/2015/06/using-supervisor/","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"supervisor","slug":"supervisor","permalink":"http://vwin.github.io/tags/supervisor/"},{"name":"gunicorn","slug":"gunicorn","permalink":"http://vwin.github.io/tags/gunicorn/"}]},{"title":"Bootstrap后台管理系统框架收集","date":"2018-09-18T12:36:21.000Z","path":"2018/09/18/Bootstrap后台管理系统收集/","text":"后台管理系统框架收集 框架整理 灰黑色后台框架 论如何把后台管理系统写出花(关于后台开发的相关技术） 最新的技术-Vue后台管理 AdminLTE 可以使用YII建立RABC权限管理yii2+AdminLTE搭建完美后台并实现rbac权限控制实例教程 Laravel建立RABC权限管理 在Laravel5.* 中使用AdminLTE flatlab laravel-vue-cms 支付宝蚂蚁前段框架 饿了么开源的后台管理框架 Larval 5.3 Rbac 后台实例 2016 Top20后端管理模板 模板之家国内后台管理框架收集 选择框架后台管理系统框架非常多，经过考虑，选择饿了么的开源框架，原因是：该框架大气简洁，最重要的一点是使用最新的前端技术Vue.js，Vue简单易上手，有许多现成的脚手架可以直接拿来用，在使用该框架时，也可以顺手学学目前最流行的前端技术。 打包工具Webpack了解Webpack是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 包管里工具npm在正式开始饿了么管理框架学习之前，我们先认识一下npm。 npm是什么东东？npm其实是Node.js的包管理工具（package manager）。 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 简而言之，NPM是随同NodeJS一起安装的包管理工具(安装NodeJS)，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 讲了这么多，npm究竟在哪？ 其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出： 1、查看npm的版本 1$ npm -v 2、使用 npm 命令安装模块npm 安装 Node.js 模块语法格式如下： 1$ npm install &lt;Module Name&gt; 以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express: 1$ npm install express 安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 1var express = require(&#x27;express&#x27;); 示例使用element开发的后台框架示例演示地址：https://taylorchen709.github….源码地址：https://github.com/taylorchen… 使用： 12345678# install dependenciesnpm install# serve with hot reload at localhost:8081npm run dev# build for production with minificationnpm run build Laravel-Administrator【扩展推荐】管理员后台快速生成工具 Administrator “增强版” 分享该后台非常好用，十分钟就可以搭建起一个简单的管理后台 laravel-admin该管理后台非常强大，使用Laravel AdminLTE开发，可以快速实现增删改查功能及角色管理。 项目：GitHub地址: z-song&#x2F;laravel-admin","raw":"---\ntitle: Bootstrap后台管理系统框架收集\ntoc: true\ndate: 2018-09-18 20:36:21\ntags: [后台关系,bootstrap,vue,laravel,element ui]\ncategories: [技术]\ndescription:\n---\n后台管理系统框架收集\n<!--more-->\n\n## 框架整理\n1. [灰黑色后台框架](http://pan.baidu.com/s/1kVGodJD)\n2. [论如何把后台管理系统写出花(关于后台开发的相关技术）](https://segmentfault.com/a/1190000005822465)\n3. [最新的技术-Vue后台管理](https://www.awesomes.cn/)\n4. [AdminLTE](https://almsaeedstudio.com/)\n5. 可以使用YII建立RABC权限管理[yii2+AdminLTE搭建完美后台并实现rbac权限控制实例教程](https://segmentfault.com/a/1190000004963496)\n6. Laravel建立RABC权限管理 [在Laravel5.* 中使用AdminLTE](https://segmentfault.com/a/1190000003917210)\n7. [flatlab](http://download.csdn.net/tag/flatlab)\n8. [laravel-vue-cms](https://github.com/liukaijv/laravel-vue-cms)\n9. [支付宝蚂蚁前段框架](https://ant.design)\n10. [饿了么开源的后台管理框架](http://element.eleme.io/#/zh-CN)\n11. [Larval 5.3 Rbac 后台实例](https://laravel-china.org/topics/3609)\n12. [2016 Top20后端管理模板](https://colorlib.com/wp/free-html5-admin-dashboard-templates/)\n13. [模板之家国内后台管理框架收集](http://www.cssmoban.com/cssthemes/houtaimoban/)\n\n## 选择框架\n后台管理系统框架非常多，经过考虑，选择[饿了么的开源框架](http://element.eleme.io/#/zh-CN)，原因是：该框架大气简洁，最重要的一点是使用最新的前端技术[Vue.js](http://cn.vuejs.org/)，Vue简单易上手，有许多现成的脚手架可以直接拿来用，在使用该框架时，也可以顺手学学目前最流行的前端技术。\n\n## 打包工具Webpack了解\n[Webpack](http://webpackdoc.com/)是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。\n\n## 包管里工具npm\n在正式开始饿了么管理框架学习之前，我们先认识一下npm。\n\n[npm](http://www.runoob.com/nodejs/nodejs-npm.html)是什么东东？npm其实是Node.js的包管理工具（package manager）。\n\n为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。\n\n更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。\n\n简而言之，NPM是随同NodeJS一起安装的包管理工具([安装NodeJS](http://www.runoob.com/nodejs/nodejs-install-setup.html))，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：\n\n允许用户从NPM服务器下载别人编写的第三方包到本地使用。\n\n允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。\n\n允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\n\n讲了这么多，npm究竟在哪？\n\n其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出：\n\n1、查看npm的版本\n```shell\n$ npm -v\n```\n\n2、使用 npm 命令安装模块\nnpm 安装 Node.js 模块语法格式如下：\n\n```shell\n$ npm install <Module Name>\n```\n\n以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:\n\n```shell\n$ npm install express\n```\n安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require('express') 的方式就好，无需指定第三方包路径。\n\n```shell\nvar express = require('express');\n```\n\n## 示例\n[使用element开发的后台框架示例](http://www.cnblogs.com/taylorchen/p/6083099.html)\n演示地址：https://taylorchen709.github....\n源码地址：https://github.com/taylorchen...\n\n使用：\n```shell\n# install dependencies\nnpm install\n\n# serve with hot reload at localhost:8081\nnpm run dev\n\n# build for production with minification\nnpm run build\n```\n\n## Laravel-Administrator\n[【扩展推荐】管理员后台快速生成工具 Administrator \"增强版\" 分享](https://laravel-china.org/topics/2301/extension-administrator-background-fast-generation-tool-administrator-enhanced-version-sharing)\n该后台非常好用，十分钟就可以搭建起一个简单的管理后台\n## laravel-admin\n该管理后台非常强大，使用Laravel AdminLTE开发，可以快速实现增删改查功能及角色管理。\n\n项目：[GitHub地址: z-song/laravel-admin](https://almsaeedstudio.com/)\n","content":"<p>后台管理系统框架收集</p>\n<span id=\"more\"></span>\n\n<h2 id=\"框架整理\"><a href=\"#框架整理\" class=\"headerlink\" title=\"框架整理\"></a>框架整理</h2><ol>\n<li><a href=\"http://pan.baidu.com/s/1kVGodJD\">灰黑色后台框架</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000005822465\">论如何把后台管理系统写出花(关于后台开发的相关技术）</a></li>\n<li><a href=\"https://www.awesomes.cn/\">最新的技术-Vue后台管理</a></li>\n<li><a href=\"https://almsaeedstudio.com/\">AdminLTE</a></li>\n<li>可以使用YII建立RABC权限管理<a href=\"https://segmentfault.com/a/1190000004963496\">yii2+AdminLTE搭建完美后台并实现rbac权限控制实例教程</a></li>\n<li>Laravel建立RABC权限管理 <a href=\"https://segmentfault.com/a/1190000003917210\">在Laravel5.* 中使用AdminLTE</a></li>\n<li><a href=\"http://download.csdn.net/tag/flatlab\">flatlab</a></li>\n<li><a href=\"https://github.com/liukaijv/laravel-vue-cms\">laravel-vue-cms</a></li>\n<li><a href=\"https://ant.design/\">支付宝蚂蚁前段框架</a></li>\n<li><a href=\"http://element.eleme.io/#/zh-CN\">饿了么开源的后台管理框架</a></li>\n<li><a href=\"https://laravel-china.org/topics/3609\">Larval 5.3 Rbac 后台实例</a></li>\n<li><a href=\"https://colorlib.com/wp/free-html5-admin-dashboard-templates/\">2016 Top20后端管理模板</a></li>\n<li><a href=\"http://www.cssmoban.com/cssthemes/houtaimoban/\">模板之家国内后台管理框架收集</a></li>\n</ol>\n<h2 id=\"选择框架\"><a href=\"#选择框架\" class=\"headerlink\" title=\"选择框架\"></a>选择框架</h2><p>后台管理系统框架非常多，经过考虑，选择<a href=\"http://element.eleme.io/#/zh-CN\">饿了么的开源框架</a>，原因是：该框架大气简洁，最重要的一点是使用最新的前端技术<a href=\"http://cn.vuejs.org/\">Vue.js</a>，Vue简单易上手，有许多现成的脚手架可以直接拿来用，在使用该框架时，也可以顺手学学目前最流行的前端技术。</p>\n<h2 id=\"打包工具Webpack了解\"><a href=\"#打包工具Webpack了解\" class=\"headerlink\" title=\"打包工具Webpack了解\"></a>打包工具Webpack了解</h2><p><a href=\"http://webpackdoc.com/\">Webpack</a>是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。</p>\n<h2 id=\"包管里工具npm\"><a href=\"#包管里工具npm\" class=\"headerlink\" title=\"包管里工具npm\"></a>包管里工具npm</h2><p>在正式开始饿了么管理框架学习之前，我们先认识一下npm。</p>\n<p><a href=\"http://www.runoob.com/nodejs/nodejs-npm.html\">npm</a>是什么东东？npm其实是Node.js的包管理工具（package manager）。</p>\n<p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>\n<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>\n<p>简而言之，NPM是随同NodeJS一起安装的包管理工具(<a href=\"http://www.runoob.com/nodejs/nodejs-install-setup.html\">安装NodeJS</a>)，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>\n<p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>\n<p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>\n<p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>\n<p>讲了这么多，npm究竟在哪？</p>\n<p>其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出：</p>\n<p>1、查看npm的版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm -v</span></span><br></pre></td></tr></table></figure>\n\n<p>2、使用 npm 命令安装模块<br>npm 安装 Node.js 模块语法格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install &lt;Module Name&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install express</span></span><br></pre></td></tr></table></figure>\n<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&#x27;express&#x27;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p><a href=\"http://www.cnblogs.com/taylorchen/p/6083099.html\">使用element开发的后台框架示例</a><br>演示地址：<a href=\"https://taylorchen709.github/\">https://taylorchen709.github</a>….<br>源码地址：<a href=\"https://github.com/taylorchen\">https://github.com/taylorchen</a>…</p>\n<p>使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">install dependencies</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">serve with hot reload at localhost:8081</span></span><br><span class=\"line\">npm run dev</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">build <span class=\"keyword\">for</span> production with minification</span></span><br><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Laravel-Administrator\"><a href=\"#Laravel-Administrator\" class=\"headerlink\" title=\"Laravel-Administrator\"></a>Laravel-Administrator</h2><p><a href=\"https://laravel-china.org/topics/2301/extension-administrator-background-fast-generation-tool-administrator-enhanced-version-sharing\">【扩展推荐】管理员后台快速生成工具 Administrator “增强版” 分享</a><br>该后台非常好用，十分钟就可以搭建起一个简单的管理后台</p>\n<h2 id=\"laravel-admin\"><a href=\"#laravel-admin\" class=\"headerlink\" title=\"laravel-admin\"></a>laravel-admin</h2><p>该管理后台非常强大，使用Laravel AdminLTE开发，可以快速实现增删改查功能及角色管理。</p>\n<p>项目：<a href=\"https://almsaeedstudio.com/\">GitHub地址: z-song&#x2F;laravel-admin</a></p>\n","slug":"Bootstrap后台管理系统收集","updated":"2022-11-27T10:39:22.787Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/09/18/Bootstrap%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%94%B6%E9%9B%86/","excerpt":"后台管理系统框架收集","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"后台关系","slug":"后台关系","permalink":"http://vwin.github.io/tags/%E5%90%8E%E5%8F%B0%E5%85%B3%E7%B3%BB/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://vwin.github.io/tags/bootstrap/"},{"name":"vue","slug":"vue","permalink":"http://vwin.github.io/tags/vue/"},{"name":"laravel","slug":"laravel","permalink":"http://vwin.github.io/tags/laravel/"},{"name":"element ui","slug":"element-ui","permalink":"http://vwin.github.io/tags/element-ui/"}]},{"title":"Ubuntu 修改默认Python版本","date":"2018-09-12T10:42:28.000Z","path":"2018/09/12/Ubuntu-修改默认Python版本/","text":"修改Ubuntu中默认的Python版本 查看系统中有哪些Python123456$ ls /usr/bin/python*/usr/bin/python /usr/bin/python2-config /usr/bin/python3m/usr/bin/python2 /usr/bin/python3 /usr/bin/python-config/usr/bin/python2.7 /usr/bin/python3.5/usr/bin/python2.7-config /usr/bin/python3.5m 查系统默认Python版本123$ python --versionPython 2.7.12 用户级修改为某个特定用户修改Python版本，只需要在其home目录下创建一个alias 12345678910111213打开该用户的~/.bashrc文件vim ~/.bashrc添加新的别名来修改默认Python版本alias python=&#x27;/usr/bin/python3.5&#x27;重新登录或者重新加载.bashrc文件，使操作生效$ . ~/.bashrc 检查当前的Python版本$ python --versionPython 3.5.2 系统级修改基于软链接12345先删除默认的Python软链接sudo rm /usr/bin/python然后创建一个新的软链接指向需要的Python版本sudo ln -s /usr/bin/python3.5 /usr/bin/python update-alternatives可以使用update-alternatives来为整个系统更改Python版本 列出替代版本首先列出所有可用的python替代版本信息 123$ update-alternatives --list pythonupdate-alternatives: 错误: 无 python 的候选项 如果出现以上所示的错误信息，表示update-alternatives没有添加Python的替代版本 添加替代版本将Python的替代版本添加进去 12345678$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1update-alternatives: 使用 /usr/bin/python2.7 来在自动模式中提供 /usr/bin/python (python) $ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 2update-alternatives: 使用 /usr/bin/python3.5 来在自动模式中提供 /usr/bin/python (python) –install选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中 这个例子中，我们为&#x2F;usr&#x2F;bin&#x2F;python3.5设置的优先级为2，所以update-alternatives命令会自动将它设置为默认Python版本 123$ python --versionPython 3.5.2 再列出可用的Python替代版本 1234$ update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.5 现在就可以在列出的Python替代版本中任意切换 123456789101112$ update-alternatives --config python有 2 个候选项可用于替换 python (提供 /usr/bin/python)。 选择 路径 优先级 状态------------------------------------------------------------* 0 /usr/bin/python3.5 2 自动模式 1 /usr/bin/python2.7 1 手动模式 2 /usr/bin/python3.5 2 手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：1 然后查看版本号 123$ python --versionPython 2.7.12 删除替代版本当系统不再存在某个Python替代版本时，我们可以将其从update-alternatives列表中删除掉 例如，可以将列表中的python2.7版本移除 12345$ sudo update-alternatives --remove python /usr/bin/python2.7 $ update-alternatives --list python/usr/bin/python3.5 升级后的错误pip错误更改Python默认版本之后可能会出现如下错误 123456$ pip --versionTraceback (most recent call last): File &quot;/usr/local/bin/pip&quot;, line 7, in &lt;module&gt; from pip import mainImportError: No module named &#x27;pip&#x27; 解决方法是将pip版本更改为符合当前的Python版本 12345678对于Python3sudo apt-get install python3-pip对于Python2sudo apt-get install python-pip安装pip之后，可能版本不是最新的，需要更新pip install --upgrade pip","raw":"---\ntitle: Ubuntu 修改默认Python版本\ntoc: true\ndate: 2018-09-12 18:42:28\ntags: [Ubuntu,python,linux]\ncategories: [技术]\ndescription:\n---\n\n修改Ubuntu中默认的Python版本\n<!--more-->\n\n## 查看系统中有哪些Python\n```shell\n$ ls /usr/bin/python*\n\n/usr/bin/python            /usr/bin/python2-config  /usr/bin/python3m\n/usr/bin/python2           /usr/bin/python3         /usr/bin/python-config\n/usr/bin/python2.7         /usr/bin/python3.5\n/usr/bin/python2.7-config  /usr/bin/python3.5m\n```\n\n## 查系统默认Python版本\n```shell\n$ python --version\n\nPython 2.7.12\n```\n\n## 用户级修改\n为某个特定用户修改Python版本，只需要在其home目录下创建一个alias\n```shell\n打开该用户的~/.bashrc文件\nvim ~/.bashrc\n\n添加新的别名来修改默认Python版本\nalias python='/usr/bin/python3.5'\n\n重新登录或者重新加载.bashrc文件，使操作生效\n$ . ~/.bashrc \n\n检查当前的Python版本\n$ python --version\n\nPython 3.5.2\n```\n\n## 系统级修改\n\n### 基于软链接\n```shell\n先删除默认的Python软链接\nsudo rm /usr/bin/python\n\n然后创建一个新的软链接指向需要的Python版本\nsudo ln -s /usr/bin/python3.5 /usr/bin/python\n```\n\n### update-alternatives\n可以使用update-alternatives来为整个系统更改Python版本\n\n#### 列出替代版本\n首先列出所有可用的python替代版本信息\n```shell\n$ update-alternatives --list python\n\nupdate-alternatives: 错误: 无 python 的候选项\n```\n如果出现以上所示的错误信息，表示update-alternatives没有添加Python的替代版本\n\n#### 添加替代版本\n将Python的替代版本添加进去\n```shell\n$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1\n\nupdate-alternatives: 使用 /usr/bin/python2.7 来在自动模式中提供 /usr/bin/python (python) \n\n$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 2\n\nupdate-alternatives: 使用 /usr/bin/python3.5 来在自动模式中提供 /usr/bin/python (python)\n\n```\n--install选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中\n\n这个例子中，我们为/usr/bin/python3.5设置的优先级为2，所以update-alternatives命令会自动将它设置为默认Python版本\n\n```shell\n$ python --version\n\nPython 3.5.2\n```\n\n再列出可用的Python替代版本\n```shell\n$ update-alternatives --list python\n\n/usr/bin/python2.7\n/usr/bin/python3.5\n```\n现在就可以在列出的Python替代版本中任意切换\n\n\n```shell\n$ update-alternatives --config python\n\n有 2 个候选项可用于替换 python (提供 /usr/bin/python)。\n\n  选择       路径              优先级  状态\n------------------------------------------------------------\n* 0            /usr/bin/python3.5   2         自动模式\n  1            /usr/bin/python2.7   1         手动模式\n  2            /usr/bin/python3.5   2         手动模式\n\n要维持当前值[*]请按<回车键>，或者键入选择的编号：1\n\n```\n然后查看版本号\n\n```shell\n$ python --version\n\nPython 2.7.12\n```\n\n### 删除替代版本\n当系统不再存在某个Python替代版本时，我们可以将其从update-alternatives列表中删除掉\n\n例如，可以将列表中的python2.7版本移除\n```shell\n$ sudo update-alternatives --remove python /usr/bin/python2.7 \n\n$ update-alternatives --list python\n\n/usr/bin/python3.5\n```\n\n## 升级后的错误\npip错误\n更改Python默认版本之后可能会出现如下错误\n```shell\n$ pip --version\n\nTraceback (most recent call last):\n  File \"/usr/local/bin/pip\", line 7, in <module>\n    from pip import main\nImportError: No module named 'pip'\n```\n解决方法是将pip版本更改为符合当前的Python版本\n```shell\n对于Python3\nsudo apt-get install python3-pip\n\n对于Python2\nsudo apt-get install python-pip\n\n安装pip之后，可能版本不是最新的，需要更新\npip install --upgrade pip\n```\n","content":"<p>修改Ubuntu中默认的Python版本</p>\n<span id=\"more\"></span>\n\n<h2 id=\"查看系统中有哪些Python\"><a href=\"#查看系统中有哪些Python\" class=\"headerlink\" title=\"查看系统中有哪些Python\"></a>查看系统中有哪些Python</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> /usr/bin/python*</span></span><br><span class=\"line\"></span><br><span class=\"line\">/usr/bin/python            /usr/bin/python2-config  /usr/bin/python3m</span><br><span class=\"line\">/usr/bin/python2           /usr/bin/python3         /usr/bin/python-config</span><br><span class=\"line\">/usr/bin/python2.7         /usr/bin/python3.5</span><br><span class=\"line\">/usr/bin/python2.7-config  /usr/bin/python3.5m</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查系统默认Python版本\"><a href=\"#查系统默认Python版本\" class=\"headerlink\" title=\"查系统默认Python版本\"></a>查系统默认Python版本</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">python --version</span></span><br><span class=\"line\"></span><br><span class=\"line\">Python 2.7.12</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用户级修改\"><a href=\"#用户级修改\" class=\"headerlink\" title=\"用户级修改\"></a>用户级修改</h2><p>为某个特定用户修改Python版本，只需要在其home目录下创建一个alias</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">打开该用户的~/.bashrc文件</span><br><span class=\"line\">vim ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\">添加新的别名来修改默认Python版本</span><br><span class=\"line\">alias python=&#x27;/usr/bin/python3.5&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">重新登录或者重新加载.bashrc文件，使操作生效</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">. ~/.bashrc</span> </span><br><span class=\"line\"></span><br><span class=\"line\">检查当前的Python版本</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">python --version</span></span><br><span class=\"line\"></span><br><span class=\"line\">Python 3.5.2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系统级修改\"><a href=\"#系统级修改\" class=\"headerlink\" title=\"系统级修改\"></a>系统级修改</h2><h3 id=\"基于软链接\"><a href=\"#基于软链接\" class=\"headerlink\" title=\"基于软链接\"></a>基于软链接</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先删除默认的Python软链接</span><br><span class=\"line\">sudo rm /usr/bin/python</span><br><span class=\"line\"></span><br><span class=\"line\">然后创建一个新的软链接指向需要的Python版本</span><br><span class=\"line\">sudo ln -s /usr/bin/python3.5 /usr/bin/python</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"update-alternatives\"><a href=\"#update-alternatives\" class=\"headerlink\" title=\"update-alternatives\"></a>update-alternatives</h3><p>可以使用update-alternatives来为整个系统更改Python版本</p>\n<h4 id=\"列出替代版本\"><a href=\"#列出替代版本\" class=\"headerlink\" title=\"列出替代版本\"></a>列出替代版本</h4><p>首先列出所有可用的python替代版本信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">update-alternatives --list python</span></span><br><span class=\"line\"></span><br><span class=\"line\">update-alternatives: 错误: 无 python 的候选项</span><br></pre></td></tr></table></figure>\n<p>如果出现以上所示的错误信息，表示update-alternatives没有添加Python的替代版本</p>\n<h4 id=\"添加替代版本\"><a href=\"#添加替代版本\" class=\"headerlink\" title=\"添加替代版本\"></a>添加替代版本</h4><p>将Python的替代版本添加进去</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">update-alternatives: 使用 /usr/bin/python2.7 来在自动模式中提供 /usr/bin/python (python) </span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">update-alternatives: 使用 /usr/bin/python3.5 来在自动模式中提供 /usr/bin/python (python)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>–install选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中</p>\n<p>这个例子中，我们为&#x2F;usr&#x2F;bin&#x2F;python3.5设置的优先级为2，所以update-alternatives命令会自动将它设置为默认Python版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">python --version</span></span><br><span class=\"line\"></span><br><span class=\"line\">Python 3.5.2</span><br></pre></td></tr></table></figure>\n\n<p>再列出可用的Python替代版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">update-alternatives --list python</span></span><br><span class=\"line\"></span><br><span class=\"line\">/usr/bin/python2.7</span><br><span class=\"line\">/usr/bin/python3.5</span><br></pre></td></tr></table></figure>\n<p>现在就可以在列出的Python替代版本中任意切换</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">update-alternatives --config python</span></span><br><span class=\"line\"></span><br><span class=\"line\">有 2 个候选项可用于替换 python (提供 /usr/bin/python)。</span><br><span class=\"line\"></span><br><span class=\"line\">  选择       路径              优先级  状态</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">* 0            /usr/bin/python3.5   2         自动模式</span><br><span class=\"line\">  1            /usr/bin/python2.7   1         手动模式</span><br><span class=\"line\">  2            /usr/bin/python3.5   2         手动模式</span><br><span class=\"line\"></span><br><span class=\"line\">要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后查看版本号</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">python --version</span></span><br><span class=\"line\"></span><br><span class=\"line\">Python 2.7.12</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除替代版本\"><a href=\"#删除替代版本\" class=\"headerlink\" title=\"删除替代版本\"></a>删除替代版本</h3><p>当系统不再存在某个Python替代版本时，我们可以将其从update-alternatives列表中删除掉</p>\n<p>例如，可以将列表中的python2.7版本移除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo update-alternatives --remove python /usr/bin/python2.7</span> </span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">update-alternatives --list python</span></span><br><span class=\"line\"></span><br><span class=\"line\">/usr/bin/python3.5</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"升级后的错误\"><a href=\"#升级后的错误\" class=\"headerlink\" title=\"升级后的错误\"></a>升级后的错误</h2><p>pip错误<br>更改Python默认版本之后可能会出现如下错误</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">pip --version</span></span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;/usr/local/bin/pip&quot;, line 7, in &lt;module&gt;</span><br><span class=\"line\">    from pip import main</span><br><span class=\"line\">ImportError: No module named &#x27;pip&#x27;</span><br></pre></td></tr></table></figure>\n<p>解决方法是将pip版本更改为符合当前的Python版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于Python3</span><br><span class=\"line\">sudo apt-get install python3-pip</span><br><span class=\"line\"></span><br><span class=\"line\">对于Python2</span><br><span class=\"line\">sudo apt-get install python-pip</span><br><span class=\"line\"></span><br><span class=\"line\">安装pip之后，可能版本不是最新的，需要更新</span><br><span class=\"line\">pip install --upgrade pip</span><br></pre></td></tr></table></figure>\n","slug":"Ubuntu-修改默认Python版本","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/09/12/Ubuntu-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/","excerpt":"修改Ubuntu中默认的Python版本","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://vwin.github.io/tags/Ubuntu/"}]},{"title":"Python 时间日期处理总结","date":"2018-09-12T10:22:57.000Z","path":"2018/09/12/Python-时间日期处理总结/","text":"python中有date,time,datetime等关于时间，日期的模块，经常需要在各种形式中进行转换，进行以下总结 常用模块datetime123456&gt;&gt;&gt; import datetime&gt;&gt;&gt; now = datetime.datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2018, 9, 12, 18, 25, 53, 374738)&gt;&gt;&gt; type(now)&lt;class &#x27;datetime.datetime&#x27;&gt; timestamp12345&gt;&gt;&gt; import time&gt;&gt;&gt; time.time()1536747994.9385228&gt;&gt;&gt; int(time.time())1536748012 time tuple123&gt;&gt;&gt; import time&gt;&gt;&gt; time.localtime()time.struct_time(tm_year=2018, tm_mon=9, tm_mday=12, tm_hour=18, tm_min=27, tm_sec=22, tm_wday=2, tm_yday=255, tm_isdst=0) string获取格式化的日期和时间 12345&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#x27;2018-09-12 18:27:53&#x27;&gt;&gt;&gt; datetime.datetime.now().strftime(&quot;%Y-%m-%d&quot;)&#x27;2018-09-12&#x27; date123&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.now().date()datetime.date(2018, 9, 12) datetime基本操作获取当前datetime123&gt;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.now()datetime.datetime(2018, 9, 12, 18, 29, 42, 735565) 获取当天date12&gt;&gt;&gt; datetime.date.today()datetime.date(2018, 9, 12) 获取明天&#x2F;前N天1234567明天：&gt;&gt;&gt; datetime.date.today() + datetime.timedelta(days=1)datetime.date(2018, 9, 13)三天前：&gt;&gt;&gt; datetime.datetime.now() - datetime.timedelta(days=3)datetime.datetime(2018, 9, 9, 18, 32, 7, 652425) 获取当天开始和结束时间(00:00:00 23:59:59)1234&gt;&gt;&gt; datetime.datetime.combine(datetime.date.today(), datetime.time.min)datetime.datetime(2018, 9, 12, 0, 0)&gt;&gt;&gt; datetime.datetime.combine(datetime.date.today(), datetime.time.max)datetime.datetime(2018, 9, 12, 23, 59, 59, 999999) 获取本周&#x2F;本月&#x2F;上月最后一天12345678910111213141516171819202122本周：&gt;&gt;&gt; today = datetime.date.today()&gt;&gt;&gt; todaydatetime.date(2018, 9, 12)&gt;&gt;&gt; sunday = today + datetime.timedelta(6 - today.weekday())&gt;&gt;&gt; sundaydatetime.date(2018, 9, 16)本月：&gt;&gt;&gt; import calendar&gt;&gt;&gt; today = datetime.date.today()&gt;&gt;&gt; _, last_day_num = calendar.monthrange(today.year, today.month)&gt;&gt;&gt; last_day = datetime.date(today.year, today.month, last_day_num)&gt;&gt;&gt; last_daydatetime.date(2018, 9, 30)上个月最后一天：&gt;&gt;&gt; today = datetime.date.today()&gt;&gt;&gt; first = datetime.date(day=1, month=today.month, year=today.year)&gt;&gt;&gt; lastMonth = first - datetime.timedelta(days=1)&gt;&gt;&gt; lastMonthdatetime.date(2018, 8, 31) 关系转换Datetime Object &#x2F; String &#x2F; timestamp &#x2F; time tuple datetime &amp; string1234567datetime -&gt; string&gt;&gt;&gt; datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#x27;2018-09-12 18:36:37&#x27;string -&gt; datetime&gt;&gt; datetime.datetime.strptime(&quot;2019-12-31 18:20:10&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)datetime.datetime(2019, 12, 31, 18, 20, 10) datetime &amp; timetuple123456datetime -&gt; timetuple&gt;&gt;&gt; datetime.datetime.now().timetuple()time.struct_time(tm_year=2018, tm_mon=9, tm_mday=12, tm_hour=18, tm_min=37, tm_sec=35, tm_wday=2, tm_yday=255, tm_isdst=-1)timetuple -&gt; datetimetimetuple =&gt; timestamp =&gt; datetime [看后面datetime&lt;=&gt;timestamp] datetime &amp; date1234567891011121314datetime -&gt; date&gt;&gt;&gt; datetime.datetime.now().date()datetime.date(2018, 9, 12)date -&gt; datetime&gt;&gt;&gt; today = datetime.date.today()&gt;&gt;&gt; todaydatetime.date(2018, 9, 12)&gt;&gt;&gt; datetime.datetime.combine(today, datetime.time())datetime.datetime(2018, 9, 12, 0, 0)&gt;&gt;&gt; datetime.datetime.combine(today, datetime.time.min)datetime.datetime(2018, 9, 12, 0, 0)&gt;&gt;&gt; datetime.datetime.combine(today, datetime.time.max)datetime.datetime(2018, 9, 12, 23, 59, 59, 999999) datetime &amp; timestamp123456789datetime -&gt; timestamp&gt;&gt;&gt; now = datetime.datetime.now()&gt;&gt;&gt; timestamp = time.mktime(now.timetuple())&gt;&gt;&gt; timestamp1536748809.0timestamp -&gt; datetime&gt;&gt;&gt; datetime.datetime.fromtimestamp(1536748809.0)datetime.datetime(2018, 9, 12, 18, 40, 9)","raw":"---\ntitle: Python 时间日期处理总结\ntoc: true\ndate: 2018-09-12 18:22:57\ntags: [Python,datetime,time,date,时间,日期]\ncategories: [技术]\ndescription:\n---\npython中有date,time,datetime等关于时间，日期的模块，经常需要在各种形式中进行转换，进行以下总结\n\n<!--more-->\n\n## 常用模块\n### datetime\n```python\n>>> import datetime\n>>> now = datetime.datetime.now()\n>>> now\ndatetime.datetime(2018, 9, 12, 18, 25, 53, 374738)\n>>> type(now)\n<class 'datetime.datetime'>\n```\n### timestamp\n```python\n>>> import time\n>>> time.time()\n1536747994.9385228\n>>> int(time.time())\n1536748012\n```\n### time tuple\n```python\n>>> import time\n>>> time.localtime()\ntime.struct_time(tm_year=2018, tm_mon=9, tm_mday=12, tm_hour=18, tm_min=27, tm_sec=22, tm_wday=2, tm_yday=255, tm_isdst=0)\n```\n### string\n获取格式化的日期和时间\n```python\n>>> import datetime\n>>> datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n'2018-09-12 18:27:53'\n>>> datetime.datetime.now().strftime(\"%Y-%m-%d\")\n'2018-09-12'\n```\n### date\n```python\n>>> import datetime\n>>> datetime.datetime.now().date()\ndatetime.date(2018, 9, 12)\n```\n\n## datetime基本操作\n### 获取当前datetime\n```python\n>>> import datetime\n>>> datetime.datetime.now()\ndatetime.datetime(2018, 9, 12, 18, 29, 42, 735565)\n```\n\n### 获取当天date\n```python\n>>> datetime.date.today()\ndatetime.date(2018, 9, 12)\n```\n\n### 获取明天/前N天\n```python\n明天：\n>>> datetime.date.today() + datetime.timedelta(days=1)\ndatetime.date(2018, 9, 13)\n\n三天前：\n>>> datetime.datetime.now() - datetime.timedelta(days=3)\ndatetime.datetime(2018, 9, 9, 18, 32, 7, 652425)\n```\n\n### 获取当天开始和结束时间(00:00:00 23:59:59)\n```python\n>>> datetime.datetime.combine(datetime.date.today(), datetime.time.min)\ndatetime.datetime(2018, 9, 12, 0, 0)\n>>> datetime.datetime.combine(datetime.date.today(), datetime.time.max)\ndatetime.datetime(2018, 9, 12, 23, 59, 59, 999999)\n```\n\n### 获取本周/本月/上月最后一天\n```python\n本周：\n>>> today = datetime.date.today()\n>>> today\ndatetime.date(2018, 9, 12)\n>>> sunday = today + datetime.timedelta(6 - today.weekday())\n>>> sunday\ndatetime.date(2018, 9, 16)\n\n本月：\n>>> import calendar\n>>> today = datetime.date.today()\n>>> _, last_day_num = calendar.monthrange(today.year, today.month)\n>>> last_day = datetime.date(today.year, today.month, last_day_num)\n>>> last_day\ndatetime.date(2018, 9, 30)\n\n上个月最后一天：\n>>> today = datetime.date.today()\n>>> first = datetime.date(day=1, month=today.month, year=today.year)\n>>> lastMonth = first - datetime.timedelta(days=1)\n>>> lastMonth\ndatetime.date(2018, 8, 31)\n```\n\n\n## 关系转换\nDatetime Object / String / timestamp / time tuple\n\n### datetime & string\n\n```python\ndatetime -> string\n>>> datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n'2018-09-12 18:36:37'\n\nstring -> datetime\n>> datetime.datetime.strptime(\"2019-12-31 18:20:10\", \"%Y-%m-%d %H:%M:%S\")\ndatetime.datetime(2019, 12, 31, 18, 20, 10)\n```\n\n### datetime & timetuple\n\n```python\ndatetime -> timetuple\n>>> datetime.datetime.now().timetuple()\ntime.struct_time(tm_year=2018, tm_mon=9, tm_mday=12, tm_hour=18, tm_min=37, tm_sec=35, tm_wday=2, tm_yday=255, tm_isdst=-1)\n\ntimetuple -> datetime\ntimetuple => timestamp => datetime [看后面datetime<=>timestamp]\n```\n\n### datetime & date\n```python\ndatetime -> date\n>>> datetime.datetime.now().date()\ndatetime.date(2018, 9, 12)\n\ndate -> datetime\n>>> today = datetime.date.today()\n>>> today\ndatetime.date(2018, 9, 12)\n>>> datetime.datetime.combine(today, datetime.time())\ndatetime.datetime(2018, 9, 12, 0, 0)\n>>> datetime.datetime.combine(today, datetime.time.min)\ndatetime.datetime(2018, 9, 12, 0, 0)\n>>> datetime.datetime.combine(today, datetime.time.max)\ndatetime.datetime(2018, 9, 12, 23, 59, 59, 999999)\n```\n\n### datetime & timestamp\n```python\ndatetime -> timestamp\n>>> now = datetime.datetime.now()\n>>> timestamp = time.mktime(now.timetuple())\n>>> timestamp\n1536748809.0\n\ntimestamp -> datetime\n>>> datetime.datetime.fromtimestamp(1536748809.0)\ndatetime.datetime(2018, 9, 12, 18, 40, 9)\n```\n","content":"<p>python中有date,time,datetime等关于时间，日期的模块，经常需要在各种形式中进行转换，进行以下总结</p>\n<span id=\"more\"></span>\n\n<h2 id=\"常用模块\"><a href=\"#常用模块\" class=\"headerlink\" title=\"常用模块\"></a>常用模块</h2><h3 id=\"datetime\"><a href=\"#datetime\" class=\"headerlink\" title=\"datetime\"></a>datetime</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.datetime.now()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">18</span>, <span class=\"number\">25</span>, <span class=\"number\">53</span>, <span class=\"number\">374738</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(now)</span><br><span class=\"line\">&lt;<span class=\"keyword\">class</span> <span class=\"string\">&#x27;datetime.datetime&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"timestamp\"><a href=\"#timestamp\" class=\"headerlink\" title=\"timestamp\"></a>timestamp</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>time.time()</span><br><span class=\"line\"><span class=\"number\">1536747994.9385228</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">int</span>(time.time())</span><br><span class=\"line\"><span class=\"number\">1536748012</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"time-tuple\"><a href=\"#time-tuple\" class=\"headerlink\" title=\"time tuple\"></a>time tuple</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>time.localtime()</span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">2018</span>, tm_mon=<span class=\"number\">9</span>, tm_mday=<span class=\"number\">12</span>, tm_hour=<span class=\"number\">18</span>, tm_min=<span class=\"number\">27</span>, tm_sec=<span class=\"number\">22</span>, tm_wday=<span class=\"number\">2</span>, tm_yday=<span class=\"number\">255</span>, tm_isdst=<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>获取格式化的日期和时间</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;2018-09-12 18:27:53&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y-%m-%d&quot;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;2018-09-12&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"date\"><a href=\"#date\" class=\"headerlink\" title=\"date\"></a>date</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now().date()</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"datetime基本操作\"><a href=\"#datetime基本操作\" class=\"headerlink\" title=\"datetime基本操作\"></a>datetime基本操作</h2><h3 id=\"获取当前datetime\"><a href=\"#获取当前datetime\" class=\"headerlink\" title=\"获取当前datetime\"></a>获取当前datetime</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now()</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">18</span>, <span class=\"number\">29</span>, <span class=\"number\">42</span>, <span class=\"number\">735565</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取当天date\"><a href=\"#获取当天date\" class=\"headerlink\" title=\"获取当天date\"></a>获取当天date</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.date.today()</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取明天-x2F-前N天\"><a href=\"#获取明天-x2F-前N天\" class=\"headerlink\" title=\"获取明天&#x2F;前N天\"></a>获取明天&#x2F;前N天</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">明天：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.date.today() + datetime.timedelta(days=<span class=\"number\">1</span>)</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">三天前：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now() - datetime.timedelta(days=<span class=\"number\">3</span>)</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">32</span>, <span class=\"number\">7</span>, <span class=\"number\">652425</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取当天开始和结束时间-00-00-00-23-59-59\"><a href=\"#获取当天开始和结束时间-00-00-00-23-59-59\" class=\"headerlink\" title=\"获取当天开始和结束时间(00:00:00 23:59:59)\"></a>获取当天开始和结束时间(00:00:00 23:59:59)</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.combine(datetime.date.today(), datetime.time.<span class=\"built_in\">min</span>)</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.combine(datetime.date.today(), datetime.time.<span class=\"built_in\">max</span>)</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">59</span>, <span class=\"number\">59</span>, <span class=\"number\">999999</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取本周-x2F-本月-x2F-上月最后一天\"><a href=\"#获取本周-x2F-本月-x2F-上月最后一天\" class=\"headerlink\" title=\"获取本周&#x2F;本月&#x2F;上月最后一天\"></a>获取本周&#x2F;本月&#x2F;上月最后一天</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本周：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>today = datetime.date.today()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>today</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sunday = today + datetime.timedelta(<span class=\"number\">6</span> - today.weekday())</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sunday</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">本月：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> calendar</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>today = datetime.date.today()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>_, last_day_num = calendar.monthrange(today.year, today.month)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>last_day = datetime.date(today.year, today.month, last_day_num)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>last_day</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">上个月最后一天：</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>today = datetime.date.today()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>first = datetime.date(day=<span class=\"number\">1</span>, month=today.month, year=today.year)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lastMonth = first - datetime.timedelta(days=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lastMonth</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">8</span>, <span class=\"number\">31</span>)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"关系转换\"><a href=\"#关系转换\" class=\"headerlink\" title=\"关系转换\"></a>关系转换</h2><p>Datetime Object &#x2F; String &#x2F; timestamp &#x2F; time tuple</p>\n<h3 id=\"datetime-amp-string\"><a href=\"#datetime-amp-string\" class=\"headerlink\" title=\"datetime &amp; string\"></a>datetime &amp; string</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">datetime -&gt; string</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now().strftime(<span class=\"string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;2018-09-12 18:36:37&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">string -&gt; datetime</span><br><span class=\"line\">&gt;&gt; datetime.datetime.strptime(<span class=\"string\">&quot;2019-12-31 18:20:10&quot;</span>, <span class=\"string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2019</span>, <span class=\"number\">12</span>, <span class=\"number\">31</span>, <span class=\"number\">18</span>, <span class=\"number\">20</span>, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"datetime-amp-timetuple\"><a href=\"#datetime-amp-timetuple\" class=\"headerlink\" title=\"datetime &amp; timetuple\"></a>datetime &amp; timetuple</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">datetime -&gt; timetuple</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now().timetuple()</span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">2018</span>, tm_mon=<span class=\"number\">9</span>, tm_mday=<span class=\"number\">12</span>, tm_hour=<span class=\"number\">18</span>, tm_min=<span class=\"number\">37</span>, tm_sec=<span class=\"number\">35</span>, tm_wday=<span class=\"number\">2</span>, tm_yday=<span class=\"number\">255</span>, tm_isdst=-<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">timetuple -&gt; datetime</span><br><span class=\"line\">timetuple =&gt; timestamp =&gt; datetime [看后面datetime&lt;=&gt;timestamp]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"datetime-amp-date\"><a href=\"#datetime-amp-date\" class=\"headerlink\" title=\"datetime &amp; date\"></a>datetime &amp; date</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">datetime -&gt; date</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.now().date()</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">date -&gt; datetime</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>today = datetime.date.today()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>today</span><br><span class=\"line\">datetime.date(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.combine(today, datetime.time())</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.combine(today, datetime.time.<span class=\"built_in\">min</span>)</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.combine(today, datetime.time.<span class=\"built_in\">max</span>)</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">59</span>, <span class=\"number\">59</span>, <span class=\"number\">999999</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"datetime-amp-timestamp\"><a href=\"#datetime-amp-timestamp\" class=\"headerlink\" title=\"datetime &amp; timestamp\"></a>datetime &amp; timestamp</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">datetime -&gt; timestamp</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.datetime.now()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>timestamp = time.mktime(now.timetuple())</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>timestamp</span><br><span class=\"line\"><span class=\"number\">1536748809.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">timestamp -&gt; datetime</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>datetime.datetime.fromtimestamp(<span class=\"number\">1536748809.0</span>)</span><br><span class=\"line\">datetime.datetime(<span class=\"number\">2018</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">18</span>, <span class=\"number\">40</span>, <span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure>\n","slug":"Python-时间日期处理总结","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/09/12/Python-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/","excerpt":"python中有date,time,datetime等关于时间，日期的模块，经常需要在各种形式中进行转换，进行以下总结","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://vwin.github.io/tags/Python/"},{"name":"datetime","slug":"datetime","permalink":"http://vwin.github.io/tags/datetime/"},{"name":"time","slug":"time","permalink":"http://vwin.github.io/tags/time/"},{"name":"date","slug":"date","permalink":"http://vwin.github.io/tags/date/"},{"name":"时间","slug":"时间","permalink":"http://vwin.github.io/tags/%E6%97%B6%E9%97%B4/"},{"name":"日期","slug":"日期","permalink":"http://vwin.github.io/tags/%E6%97%A5%E6%9C%9F/"}]},{"title":"Python 使用lambda应对各种排序","date":"2018-08-30T06:04:15.000Z","path":"2018/08/30/Python-使用lambda应对各种排序/","text":"使用Python实现各种排序，比如dict的按key和value排序，list嵌套dict排序考虑到tuple在排序时和list的区别并不大，所以不考虑tuple；而dict的key采用hash实现，仅仅对dict进行排序并无实际意义，所以仅考虑需要输出等情况下的dict排序实现。 函数sortedsorted函数原型 1sorted(iterable[,key][,reverse]) sorted()可以接受3个参数，需要排序的变量必不可少，然后是key指定排序的元素，reverse指定是否逆序 lambdalambda是匿名函数 一般形式 1lambda arguments:expression 函数形式 12def &lt;lambda&gt;(arguments): return expression 排序简单list排序12345lis = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]print(sorted(lis))# [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]print(sorted(lis, reverse=True))# [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;] dict按照key排序12345dic = &#123;&#x27;c&#x27;: 1, &#x27;b&#x27;: 2, &#x27;a&#x27;: 3&#125;print(sorted(dic))# [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]print(sorted(dic, reverse=True))# [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;] dict按照value排序12345dic = &#123;&#x27;c&#x27;: 1, &#x27;b&#x27;: 2, &#x27;a&#x27;: 3&#125;print(sorted(dic, key=lambda k: dic[k]))# [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]print(sorted(dic, key=lambda k: dic[k], reverse=True))# [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] list嵌套list排序123456789101112lis = [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[0]))# [[1, 5, 6], [4, 2, 9], [7, 8, 3]]print(sorted(lis, key=lambda k: k[1]))# [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[2]))# [[7, 8, 3], [1, 5, 6], [4, 2, 9]]print(sorted(lis, key=lambda k: k[0], reverse=True))# [[7, 8, 3], [4, 2, 9], [1, 5, 6]] dict嵌套dict排序1234567891011121314151617lis = [ &#123;&#x27;x&#x27;: 3, &#x27;y&#x27;: 2, &#x27;z&#x27;: 1&#125;, &#123;&#x27;x&#x27;: 2, &#x27;y&#x27;: 1, &#x27;z&#x27;: 3&#125;, &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 3, &#x27;z&#x27;: 2&#125;,]print(sorted(lis, key=lambda k: k[&#x27;x&#x27;]))# [&#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;, &#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;, &#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;]print(sorted(lis, key=lambda k: k[&#x27;y&#x27;]))# [&#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;, &#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;, &#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;]print(sorted(lis, key=lambda k: k[&#x27;z&#x27;]))# [&#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;, &#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;, &#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;]print(sorted(lis, key=lambda k: k[&#x27;x&#x27;], reverse=True))# [&#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;, &#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;, &#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;] dict嵌套list排序12345678910111213141516dic = &#123; &#x27;a&#x27;: [1, 2, 3], &#x27;b&#x27;: [2, 1, 3], &#x27;c&#x27;: [3, 1, 2],&#125;print(sorted(dic, key=lambda k: dic[k][0]))# [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]print(sorted(dic, key=lambda k: dic[k][1]))# [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]print(sorted(dic, key=lambda k: dic[k][2]))# [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]print(sorted(dic, key=lambda k: dic[k][0], reverse=True))# [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;] 其他嵌套排序更深层嵌套排序方法和上面介绍的大同小异，实际就是lambda的操作；需要注意的就是dict的排序只会取其key，所以需要lambda首先将其转换为value才能操作value排序。","raw":"---\ntitle: Python 使用lambda应对各种排序\ntoc: true\ndate: 2018-08-30 14:04:15\ntags: [python,lambda,排序,list,dict]\ncategories: [技术]\ndescription:\n---\n\n使用Python实现各种排序，比如dict的按key和value排序，list嵌套dict排序\n考虑到tuple在排序时和list的区别并不大，所以不考虑tuple；\n而dict的key采用hash实现，仅仅对dict进行排序并无实际意义，所以仅考虑需要输出等情况下的dict排序实现。\n<!--more-->\n\n## 函数\n### sorted\nsorted函数原型\n```python\nsorted(iterable[,key][,reverse])\n```\n\nsorted()可以接受3个参数，需要排序的变量必不可少，然后是key指定排序的元素，reverse指定是否逆序\n\n### lambda\n\nlambda是匿名函数\n\n一般形式\n```python \nlambda arguments:expression\n```\n\n函数形式\n```python\ndef <lambda>(arguments):\n    return expression\n```\n\n## 排序\n\n### 简单list排序\n```python\nlis = ['a', 'b', 'c']\nprint(sorted(lis))\n# ['a', 'b', 'c']\nprint(sorted(lis, reverse=True))\n# ['c', 'b', 'a']\n```\n\n### dict按照key排序\n```python\ndic = {'c': 1, 'b': 2, 'a': 3}\nprint(sorted(dic))\n# ['a', 'b', 'c']\nprint(sorted(dic, reverse=True))\n# ['c', 'b', 'a']\n```\n\n### dict按照value排序\n```python\ndic = {'c': 1, 'b': 2, 'a': 3}\nprint(sorted(dic, key=lambda k: dic[k]))\n# ['c', 'b', 'a']\nprint(sorted(dic, key=lambda k: dic[k], reverse=True))\n# ['a', 'b', 'c']\n```\n\n### list嵌套list排序\n\n```python\nlis = [[4, 2, 9], [1, 5, 6], [7, 8, 3]]\nprint(sorted(lis, key=lambda k: k[0]))\n# [[1, 5, 6], [4, 2, 9], [7, 8, 3]]\n\nprint(sorted(lis, key=lambda k: k[1]))\n# [[4, 2, 9], [1, 5, 6], [7, 8, 3]]\n\nprint(sorted(lis, key=lambda k: k[2]))\n# [[7, 8, 3], [1, 5, 6], [4, 2, 9]]\n\nprint(sorted(lis, key=lambda k: k[0], reverse=True))\n# [[7, 8, 3], [4, 2, 9], [1, 5, 6]]\n```\n\n### dict嵌套dict排序\n```python\nlis = [\n    {'x': 3, 'y': 2, 'z': 1},\n    {'x': 2, 'y': 1, 'z': 3},\n    {'x': 1, 'y': 3, 'z': 2},\n]\nprint(sorted(lis, key=lambda k: k['x']))\n# [{'z': 2, 'x': 1, 'y': 3}, {'z': 3, 'x': 2, 'y': 1}, {'z': 1, 'x': 3, 'y': 2}]\n\nprint(sorted(lis, key=lambda k: k['y']))\n# [{'z': 3, 'x': 2, 'y': 1}, {'z': 1, 'x': 3, 'y': 2}, {'z': 2, 'x': 1, 'y': 3}]\n\nprint(sorted(lis, key=lambda k: k['z']))\n# [{'z': 1, 'x': 3, 'y': 2}, {'z': 2, 'x': 1, 'y': 3}, {'z': 3, 'x': 2, 'y': 1}]\n\nprint(sorted(lis, key=lambda k: k['x'], reverse=True))\n# [{'z': 1, 'x': 3, 'y': 2}, {'z': 3, 'x': 2, 'y': 1}, {'z': 2, 'x': 1, 'y': 3}]\n\n```\n\n### dict嵌套list排序\n```python\ndic = {\n    'a': [1, 2, 3],\n    'b': [2, 1, 3],\n    'c': [3, 1, 2],\n}\nprint(sorted(dic, key=lambda k: dic[k][0]))\n# ['a', 'b', 'c']\n\nprint(sorted(dic, key=lambda k: dic[k][1]))\n# ['b', 'c', 'a']\n\nprint(sorted(dic, key=lambda k: dic[k][2]))\n# ['c', 'b', 'a']\n\nprint(sorted(dic, key=lambda k: dic[k][0], reverse=True))\n# ['c', 'b', 'a']\n```\n\n## 其他嵌套排序\n更深层嵌套排序方法和上面介绍的大同小异，实际就是lambda的操作；\n需要注意的就是dict的排序只会取其key，所以需要lambda首先将其转换为value才能操作value排序。\n\n","content":"<p>使用Python实现各种排序，比如dict的按key和value排序，list嵌套dict排序<br>考虑到tuple在排序时和list的区别并不大，所以不考虑tuple；<br>而dict的key采用hash实现，仅仅对dict进行排序并无实际意义，所以仅考虑需要输出等情况下的dict排序实现。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h3><p>sorted函数原型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sorted</span>(iterable[,key][,reverse])</span><br></pre></td></tr></table></figure>\n\n<p>sorted()可以接受3个参数，需要排序的变量必不可少，然后是key指定排序的元素，reverse指定是否逆序</p>\n<h3 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h3><p>lambda是匿名函数</p>\n<p>一般形式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lambda</span> arguments:expression</span><br></pre></td></tr></table></figure>\n\n<p>函数形式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> &lt;<span class=\"keyword\">lambda</span>&gt;(arguments):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expression</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"简单list排序\"><a href=\"#简单list排序\" class=\"headerlink\" title=\"简单list排序\"></a>简单list排序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dict按照key排序\"><a href=\"#dict按照key排序\" class=\"headerlink\" title=\"dict按照key排序\"></a>dict按照key排序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic, reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dict按照value排序\"><a href=\"#dict按照value排序\" class=\"headerlink\" title=\"dict按照value排序\"></a>dict按照value排序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;<span class=\"string\">&#x27;c&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic, key=<span class=\"keyword\">lambda</span> k: dic[k]))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic, key=<span class=\"keyword\">lambda</span> k: dic[k], reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"list嵌套list排序\"><a href=\"#list嵌套list排序\" class=\"headerlink\" title=\"list嵌套list排序\"></a>list嵌套list排序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = [[<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>], [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"number\">0</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [[1, 5, 6], [4, 2, 9], [7, 8, 3]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [[4, 2, 9], [1, 5, 6], [7, 8, 3]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"number\">2</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [[7, 8, 3], [1, 5, 6], [4, 2, 9]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"number\">0</span>], reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\"><span class=\"comment\"># [[7, 8, 3], [4, 2, 9], [1, 5, 6]]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dict嵌套dict排序\"><a href=\"#dict嵌套dict排序\" class=\"headerlink\" title=\"dict嵌套dict排序\"></a>dict嵌套dict排序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lis = [</span><br><span class=\"line\">    &#123;<span class=\"string\">&#x27;x&#x27;</span>: <span class=\"number\">3</span>, <span class=\"string\">&#x27;y&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;z&#x27;</span>: <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&#x27;x&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;y&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;z&#x27;</span>: <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&#x27;x&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;y&#x27;</span>: <span class=\"number\">3</span>, <span class=\"string\">&#x27;z&#x27;</span>: <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"string\">&#x27;x&#x27;</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [&#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;, &#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;, &#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"string\">&#x27;y&#x27;</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [&#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;, &#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;, &#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"string\">&#x27;z&#x27;</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [&#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;, &#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;, &#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(lis, key=<span class=\"keyword\">lambda</span> k: k[<span class=\"string\">&#x27;x&#x27;</span>], reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\"><span class=\"comment\"># [&#123;&#x27;z&#x27;: 1, &#x27;x&#x27;: 3, &#x27;y&#x27;: 2&#125;, &#123;&#x27;z&#x27;: 3, &#x27;x&#x27;: 2, &#x27;y&#x27;: 1&#125;, &#123;&#x27;z&#x27;: 2, &#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;]</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dict嵌套list排序\"><a href=\"#dict嵌套list排序\" class=\"headerlink\" title=\"dict嵌套list排序\"></a>dict嵌套list排序</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dic = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;a&#x27;</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">    <span class=\"string\">&#x27;b&#x27;</span>: [<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">    <span class=\"string\">&#x27;c&#x27;</span>: [<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic, key=<span class=\"keyword\">lambda</span> k: dic[k][<span class=\"number\">0</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic, key=<span class=\"keyword\">lambda</span> k: dic[k][<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic, key=<span class=\"keyword\">lambda</span> k: dic[k][<span class=\"number\">2</span>]))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sorted</span>(dic, key=<span class=\"keyword\">lambda</span> k: dic[k][<span class=\"number\">0</span>], reverse=<span class=\"literal\">True</span>))</span><br><span class=\"line\"><span class=\"comment\"># [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他嵌套排序\"><a href=\"#其他嵌套排序\" class=\"headerlink\" title=\"其他嵌套排序\"></a>其他嵌套排序</h2><p>更深层嵌套排序方法和上面介绍的大同小异，实际就是lambda的操作；<br>需要注意的就是dict的排序只会取其key，所以需要lambda首先将其转换为value才能操作value排序。</p>\n","slug":"Python-使用lambda应对各种排序","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/30/Python-%E4%BD%BF%E7%94%A8lambda%E5%BA%94%E5%AF%B9%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/","excerpt":"使用Python实现各种排序，比如dict的按key和value排序，list嵌套dict排序考虑到tuple在排序时和list的区别并不大，所以不考虑tuple；而dict的key采用hash实现，仅仅对dict进行排序并无实际意义，所以仅考虑需要输出等情况下的dict排序实现。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"lambda","slug":"lambda","permalink":"http://vwin.github.io/tags/lambda/"},{"name":"排序","slug":"排序","permalink":"http://vwin.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"list","slug":"list","permalink":"http://vwin.github.io/tags/list/"},{"name":"dict","slug":"dict","permalink":"http://vwin.github.io/tags/dict/"}]},{"title":"Python 更简单的写法","date":"2018-08-23T08:35:12.000Z","path":"2018/08/23/Python-更简单的写法/","text":"Pythonic如果翻译成中文的话就是很python。很+名词结构的用法，比如：很国足，很CCTV等。所以很python可以理解为：只有python能做到的，区别于其他语言的写法，其实就是python的惯用和特有写法。 以下为了简略，我们用P表示pythonic的写法，NP表示non-pythonic的写法。为什么要追求pythonic? 相比于NP，P的写法简练，明确，优雅，绝大部分时候执行效率高。认识到pythonic的写法，会更便利和高效.以下将给出P和NP的n种示例。 链式比较123456P:a = 3b = 1 1 &lt;= b &lt;= a &lt; 10 #TrueNP:b &gt;= 1 and b &lt;= a and a &lt; 10 #True 真值测试12345678910P:name = &#x27;Tim&#x27;langs = [&#x27;AS3&#x27;, &#x27;Lua&#x27;, &#x27;C&#x27;]info = &#123;&#x27;name&#x27;: &#x27;Tim&#x27;, &#x27;sex&#x27;: &#x27;Male&#x27;, &#x27;age&#x27;:23 &#125; if name and langs and info: print(&#x27;All True!&#x27;) #All True!NP:if name != &#x27;&#x27; and len(langs) &gt; 0 and info != &#123;&#125;: print(&#x27;All True!&#x27;) #All True! 简而言之，P的写法就是对于任意对象，直接判断其真假，无需写判断条件，这样既能保证正确性，又能减少代码量。 真假值表： 真 假 True False 任意非空字符串 空的字符串 ‘’ 任意非0数字 数字0 任意非空容器 空的容器 [] () {} set() 其他任意非False None 字符串反转123456789P:def reverse_str( s ): return s[::-1] NP:def reverse_str( s ): t = &#x27;&#x27; for x in xrange(len(s)-1,-1,-1): t += s[x] return t P的写法简单，经测试，效率也更好。如果用于检测回文，就是一句话input &#x3D;&#x3D; input[::-1] 字符串列表连接12345678910P:strList = [&quot;Python&quot;, &quot;is&quot;, &quot;good&quot;] res = &#x27; &#x27;.join(strList) #Python is goodNP:res = &#x27;&#x27;for s in strList: res += s + &#x27; &#x27;#Python is good #最后还有个多余空格 string.join()常用于连接列表里的字符串，相对于NP，P的方式十分高效，且不会犯错。 列表求和，最大值，最小值，乘积 123456789101112131415161718192021P:numList = [1,2,3,4,5] sum = sum(numList) #sum = 15maxNum = max(numList) #maxNum = 5minNum = min(numList) #minNum = 1from operator import mulprod = reduce(mul, numList, 1) #prod = 120 默认值传1以防空列表报错NP:sum = 0maxNum = -float(&#x27;inf&#x27;)minNum = float(&#x27;inf&#x27;)prod = 1for num in numList: if num &gt; maxNum: maxNum = num if num &lt; minNum: minNum = num sum += num prod *= num# sum = 15 maxNum = 5 minNum = 1 prod = 120 列表推导式123456789P:l = [x*x for x in range(10) if x % 3 == 0]#l = [0, 9, 36, 81]NP:l = []for x in range(10): if x % 3 == 0: l.append(x*x)#l = [0, 9, 36, 81] 字典的默认值1234567891011P:dic = &#123;&#x27;name&#x27;:&#x27;Tim&#x27;, &#x27;age&#x27;:23&#125; dic[&#x27;workage&#x27;] = dic.get(&#x27;workage&#x27;,0) + 1#dic = &#123;&#x27;age&#x27;: 23, &#x27;workage&#x27;: 1, &#x27;name&#x27;: &#x27;Tim&#x27;&#125;NP:if &#x27;workage&#x27; in dic: dic[&#x27;workage&#x27;] += 1else: dic[&#x27;workage&#x27;] = 1#dic = &#123;&#x27;age&#x27;: 23, &#x27;workage&#x27;: 1, &#x27;name&#x27;: &#x27;Tim&#x27;&#125; dict的get(key,default)方法用于获取字典中key的值，若不存在该key，则将key赋默认值default。P相比NP的写法少了if…else… for…else…语句123456789101112131415161718P:for x in xrange(1,5): if x == 5: print &#x27;find 5&#x27; breakelse: print &#x27;can not find 5!&#x27;#can not find 5! NP:find = Falsefor x in xrange(1,5): if x == 5: find = True print &#x27;find 5&#x27; breakif not find: print &#x27;can not find 5!&#x27;#can not find 5! for…else…的else部分用来处理没有从for循环中断的情况。不用设置状态变量来检查是否for循环有break出来，简单方便。 三元符的替代1234567891011P:a = 3 b = 2 if a &gt; 2 else 1#b = 2NP:if a &gt; 2: b = 2else: b = 1#b = 2 如果你具备C的编程经验，你就会寻找A ? B : C的替代品。你可能发现A and B or C看起来还不错，但是b &#x3D; a &gt; 1 and False or True会返回True，而实际意图应该返回False。使用b &#x3D; False if a &gt; 1 else True则会正确返回False。 Enumerate123456789101112131415161718P:array = [1, 2, 3, 4, 5] for i, e in enumerate(array,0): print i, e#0 1#1 2#2 3#3 4#4 5 NP:for i in xrange(len(array)): print i, array[i]#0 1#1 2#2 3#3 4#4 5 使用enumerate可以一次性将索引和值取出，避免使用索引来取值，而且enumerate的第二个参数可以调整索引下标的起始位置，默认为0。 使用zip创建字典1234567891011P:keys = [&#x27;Name&#x27;, &#x27;Sex&#x27;, &#x27;Age&#x27;]values = [&#x27;Tim&#x27;, &#x27;Male&#x27;, 23] dic = dict(zip(keys, values))#&#123;&#x27;Age&#x27;: 23, &#x27;Name&#x27;: &#x27;Tim&#x27;, &#x27;Sex&#x27;: &#x27;Male&#x27;&#125;NP:dic = &#123;&#125;for i,e in enumerate(keys): dic[e] = values[i]#&#123;&#x27;Age&#x27;: 23, &#x27;Name&#x27;: &#x27;Tim&#x27;, &#x27;Sex&#x27;: &#x27;Male&#x27;&#125; zip方法返回的是一个元组，用它来创建键值对，简单明了。 参考链接 Python官网","raw":"---\ntitle: Python 更简单的写法\ntoc: true\ndate: 2018-08-23 16:35:12\ntags: [python,pythonic,语法糖]\ncategories: [技术]\ndescription:\n---\nPythonic如果翻译成中文的话就是很python。很+名词结构的用法，比如：很国足，很CCTV等。\n所以很python可以理解为：只有python能做到的，区别于其他语言的写法，其实就是python的惯用和特有写法。\n\n以下为了简略，我们用P表示pythonic的写法，NP表示non-pythonic的写法。\n为什么要追求pythonic?\n\n相比于NP，P的写法简练，明确，优雅，绝大部分时候执行效率高。认识到pythonic的写法，会更便利和高效.\n以下将给出P和NP的n种示例。\n\n<!--more-->\n\n## 链式比较\n```python\nP:\na = 3\nb = 1 \n1 <= b <= a < 10  #True\nNP:\nb >= 1 and b <= a and a < 10 #True\n```\n\n## 真值测试\n\n```python\nP:\nname = 'Tim'\nlangs = ['AS3', 'Lua', 'C']\ninfo = {'name': 'Tim', 'sex': 'Male', 'age':23 }    \n \nif name and langs and info:\n    print('All True!')  #All True!\nNP:\nif name != '' and len(langs) > 0 and info != {}:\n    print('All True!') #All True!\n```\n简而言之，P的写法就是对于任意对象，直接判断其真假，无需写判断条件，这样既能保证正确性，又能减少代码量。\n\n真假值表：\n\n| 真          | 假 |\n| ----------  | --- |\n| True        |  False |\n| 任意非空字符串|  空的字符串 '' |\n| 任意非0数字   |  数字0  |\n| 任意非空容器  |   空的容器 [] () {} set() |\n| 其他任意非False    |  None |\n\n\n## 字符串反转\n```python\nP:\ndef reverse_str( s ):\n    return s[::-1]  \nNP:\ndef reverse_str( s ):\n    t = ''\n    for x in xrange(len(s)-1,-1,-1):\n        t += s[x]\n    return t\n```\n\nP的写法简单，经测试，效率也更好。 \n如果用于检测回文，就是一句话input == input[::-1]\n\n## 字符串列表连接\n```python\nP:\nstrList = [\"Python\", \"is\", \"good\"]  \n \nres =  ' '.join(strList) #Python is good\nNP:\nres = ''\nfor s in strList:\n    res += s + ' '\n#Python is good \n#最后还有个多余空格\n```\nstring.join()常用于连接列表里的字符串，相对于NP，P的方式十分高效，且不会犯错。\n\n列表求和，最大值，最小值，乘积\n```python\nP:\nnumList = [1,2,3,4,5]   \n \nsum = sum(numList)  #sum = 15\nmaxNum = max(numList) #maxNum = 5\nminNum = min(numList) #minNum = 1\nfrom operator import mul\nprod = reduce(mul, numList, 1) #prod = 120 默认值传1以防空列表报错\nNP:\nsum = 0\nmaxNum = -float('inf')\nminNum = float('inf')\nprod = 1\nfor num in numList:\n    if num > maxNum:\n        maxNum = num\n    if num < minNum:\n        minNum = num\n    sum += num\n    prod *= num\n# sum = 15 maxNum = 5 minNum = 1 prod = 120\n```\n\n## 列表推导式\n```python\nP:\nl = [x*x for x in range(10) if x % 3 == 0]\n#l = [0, 9, 36, 81]\nNP:\nl = []\nfor x in range(10):\n    if x % 3 == 0:\n        l.append(x*x)\n#l = [0, 9, 36, 81]\n```\n\n## 字典的默认值\n```python\nP:\ndic = {'name':'Tim', 'age':23}  \n \ndic['workage'] = dic.get('workage',0) + 1\n#dic = {'age': 23, 'workage': 1, 'name': 'Tim'}\nNP:\nif 'workage' in dic:\n    dic['workage'] += 1\nelse:\n    dic['workage'] = 1\n#dic = {'age': 23, 'workage': 1, 'name': 'Tim'}\n```\ndict的get(key,default)方法用于获取字典中key的值，若不存在该key，则将key赋默认值default。\nP相比NP的写法少了if...else...\n\n## for…else…语句\n```python\nP:\nfor x in xrange(1,5):\n    if x == 5:\n        print 'find 5'\n        break\nelse:\n    print 'can not find 5!'\n#can not find 5!    \nNP:\nfind = False\nfor x in xrange(1,5):\n    if x == 5:\n        find = True\n        print 'find 5'\n        break\nif not find:\n    print 'can not find 5!'\n#can not find 5!\n```\nfor...else...的else部分用来处理没有从for循环中断的情况。不用设置状态变量来检查是否for循环有break出来，简单方便。\n\n## 三元符的替代\n```python\nP:\na = 3   \n \nb = 2 if a > 2 else 1\n#b = 2\nNP:\nif a > 2:\n    b = 2\nelse:\n    b = 1\n#b = 2\n```\n如果你具备C的编程经验，你就会寻找A ? B : C的替代品。你可能发现A and B or C看起来还不错，但是b = a > 1 and False or True会返回True，而实际意图应该返回False。 \n使用b = False if a > 1 else True则会正确返回False。\n\n## Enumerate\n```python\nP:\narray = [1, 2, 3, 4, 5]\n \nfor i, e in enumerate(array,0):\n    print i, e\n#0 1\n#1 2\n#2 3\n#3 4\n#4 5 \nNP:\nfor i in xrange(len(array)):\n    print i, array[i]\n#0 1\n#1 2\n#2 3\n#3 4\n#4 5 \n```\n使用enumerate可以一次性将索引和值取出，避免使用索引来取值，而且enumerate的第二个参数可以调整索引下标的起始位置，默认为0。\n\n## 使用zip创建字典\n```python\nP:\nkeys = ['Name', 'Sex', 'Age']\nvalues = ['Tim', 'Male', 23]\n \ndic = dict(zip(keys, values))\n#{'Age': 23, 'Name': 'Tim', 'Sex': 'Male'}\nNP:\ndic = {}\nfor i,e in enumerate(keys):\n    dic[e] = values[i]\n#{'Age': 23, 'Name': 'Tim', 'Sex': 'Male'}\n```\nzip方法返回的是一个元组，用它来创建键值对，简单明了。\n\n## 参考链接\n1. [Python官网](https://docs.python.org/release/3.7.0/library/stdtypes.html#truth-value-testing)\n\n","content":"<p>Pythonic如果翻译成中文的话就是很python。很+名词结构的用法，比如：很国足，很CCTV等。<br>所以很python可以理解为：只有python能做到的，区别于其他语言的写法，其实就是python的惯用和特有写法。</p>\n<p>以下为了简略，我们用P表示pythonic的写法，NP表示non-pythonic的写法。<br>为什么要追求pythonic?</p>\n<p>相比于NP，P的写法简练，明确，优雅，绝大部分时候执行效率高。认识到pythonic的写法，会更便利和高效.<br>以下将给出P和NP的n种示例。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"链式比较\"><a href=\"#链式比较\" class=\"headerlink\" title=\"链式比较\"></a>链式比较</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">a = <span class=\"number\">3</span></span><br><span class=\"line\">b = <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"number\">1</span> &lt;= b &lt;= a &lt; <span class=\"number\">10</span>  <span class=\"comment\">#True</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\">b &gt;= <span class=\"number\">1</span> <span class=\"keyword\">and</span> b &lt;= a <span class=\"keyword\">and</span> a &lt; <span class=\"number\">10</span> <span class=\"comment\">#True</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"真值测试\"><a href=\"#真值测试\" class=\"headerlink\" title=\"真值测试\"></a>真值测试</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">name = <span class=\"string\">&#x27;Tim&#x27;</span></span><br><span class=\"line\">langs = [<span class=\"string\">&#x27;AS3&#x27;</span>, <span class=\"string\">&#x27;Lua&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>]</span><br><span class=\"line\">info = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;Tim&#x27;</span>, <span class=\"string\">&#x27;sex&#x27;</span>: <span class=\"string\">&#x27;Male&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"number\">23</span> &#125;    </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> name <span class=\"keyword\">and</span> langs <span class=\"keyword\">and</span> info:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;All True!&#x27;</span>)  <span class=\"comment\">#All True!</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\"><span class=\"keyword\">if</span> name != <span class=\"string\">&#x27;&#x27;</span> <span class=\"keyword\">and</span> <span class=\"built_in\">len</span>(langs) &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> info != &#123;&#125;:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;All True!&#x27;</span>) <span class=\"comment\">#All True!</span></span><br></pre></td></tr></table></figure>\n<p>简而言之，P的写法就是对于任意对象，直接判断其真假，无需写判断条件，这样既能保证正确性，又能减少代码量。</p>\n<p>真假值表：</p>\n<table>\n<thead>\n<tr>\n<th>真</th>\n<th>假</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>True</td>\n<td>False</td>\n</tr>\n<tr>\n<td>任意非空字符串</td>\n<td>空的字符串 ‘’</td>\n</tr>\n<tr>\n<td>任意非0数字</td>\n<td>数字0</td>\n</tr>\n<tr>\n<td>任意非空容器</td>\n<td>空的容器 [] () {} set()</td>\n</tr>\n<tr>\n<td>其他任意非False</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<h2 id=\"字符串反转\"><a href=\"#字符串反转\" class=\"headerlink\" title=\"字符串反转\"></a>字符串反转</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">reverse_str</span>(<span class=\"params\"> s </span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[::-<span class=\"number\">1</span>]  </span><br><span class=\"line\">NP:</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">reverse_str</span>(<span class=\"params\"> s </span>):</span><br><span class=\"line\">    t = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> xrange(<span class=\"built_in\">len</span>(s)-<span class=\"number\">1</span>,-<span class=\"number\">1</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\">        t += s[x]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t</span><br></pre></td></tr></table></figure>\n\n<p>P的写法简单，经测试，效率也更好。<br>如果用于检测回文，就是一句话input &#x3D;&#x3D; input[::-1]</p>\n<h2 id=\"字符串列表连接\"><a href=\"#字符串列表连接\" class=\"headerlink\" title=\"字符串列表连接\"></a>字符串列表连接</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">strList = [<span class=\"string\">&quot;Python&quot;</span>, <span class=\"string\">&quot;is&quot;</span>, <span class=\"string\">&quot;good&quot;</span>]  </span><br><span class=\"line\"> </span><br><span class=\"line\">res =  <span class=\"string\">&#x27; &#x27;</span>.join(strList) <span class=\"comment\">#Python is good</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\">res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> strList:</span><br><span class=\"line\">    res += s + <span class=\"string\">&#x27; &#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#Python is good </span></span><br><span class=\"line\"><span class=\"comment\">#最后还有个多余空格</span></span><br></pre></td></tr></table></figure>\n<p>string.join()常用于连接列表里的字符串，相对于NP，P的方式十分高效，且不会犯错。</p>\n<p>列表求和，最大值，最小值，乘积</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">numList = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]   </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>(numList)  <span class=\"comment\">#sum = 15</span></span><br><span class=\"line\">maxNum = <span class=\"built_in\">max</span>(numList) <span class=\"comment\">#maxNum = 5</span></span><br><span class=\"line\">minNum = <span class=\"built_in\">min</span>(numList) <span class=\"comment\">#minNum = 1</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> mul</span><br><span class=\"line\">prod = reduce(mul, numList, <span class=\"number\">1</span>) <span class=\"comment\">#prod = 120 默认值传1以防空列表报错</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">maxNum = -<span class=\"built_in\">float</span>(<span class=\"string\">&#x27;inf&#x27;</span>)</span><br><span class=\"line\">minNum = <span class=\"built_in\">float</span>(<span class=\"string\">&#x27;inf&#x27;</span>)</span><br><span class=\"line\">prod = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> numList:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> num &gt; maxNum:</span><br><span class=\"line\">        maxNum = num</span><br><span class=\"line\">    <span class=\"keyword\">if</span> num &lt; minNum:</span><br><span class=\"line\">        minNum = num</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> += num</span><br><span class=\"line\">    prod *= num</span><br><span class=\"line\"><span class=\"comment\"># sum = 15 maxNum = 5 minNum = 1 prod = 120</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"列表推导式\"><a href=\"#列表推导式\" class=\"headerlink\" title=\"列表推导式\"></a>列表推导式</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">l = [x*x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>) <span class=\"keyword\">if</span> x % <span class=\"number\">3</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\">#l = [0, 9, 36, 81]</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\">l = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x % <span class=\"number\">3</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        l.append(x*x)</span><br><span class=\"line\"><span class=\"comment\">#l = [0, 9, 36, 81]</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字典的默认值\"><a href=\"#字典的默认值\" class=\"headerlink\" title=\"字典的默认值\"></a>字典的默认值</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">dic = &#123;<span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;Tim&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>:<span class=\"number\">23</span>&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">dic[<span class=\"string\">&#x27;workage&#x27;</span>] = dic.get(<span class=\"string\">&#x27;workage&#x27;</span>,<span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">#dic = &#123;&#x27;age&#x27;: 23, &#x27;workage&#x27;: 1, &#x27;name&#x27;: &#x27;Tim&#x27;&#125;</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">&#x27;workage&#x27;</span> <span class=\"keyword\">in</span> dic:</span><br><span class=\"line\">    dic[<span class=\"string\">&#x27;workage&#x27;</span>] += <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    dic[<span class=\"string\">&#x27;workage&#x27;</span>] = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">#dic = &#123;&#x27;age&#x27;: 23, &#x27;workage&#x27;: 1, &#x27;name&#x27;: &#x27;Tim&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>dict的get(key,default)方法用于获取字典中key的值，若不存在该key，则将key赋默认值default。<br>P相比NP的写法少了if…else…</p>\n<h2 id=\"for…else…语句\"><a href=\"#for…else…语句\" class=\"headerlink\" title=\"for…else…语句\"></a>for…else…语句</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> xrange(<span class=\"number\">1</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;find 5&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">&#x27;can not find 5!&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#can not find 5!    </span></span><br><span class=\"line\">NP:</span><br><span class=\"line\">find = <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> xrange(<span class=\"number\">1</span>,<span class=\"number\">5</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">5</span>:</span><br><span class=\"line\">        find = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;find 5&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> find:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">&#x27;can not find 5!&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#can not find 5!</span></span><br></pre></td></tr></table></figure>\n<p>for…else…的else部分用来处理没有从for循环中断的情况。不用设置状态变量来检查是否for循环有break出来，简单方便。</p>\n<h2 id=\"三元符的替代\"><a href=\"#三元符的替代\" class=\"headerlink\" title=\"三元符的替代\"></a>三元符的替代</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">a = <span class=\"number\">3</span>   </span><br><span class=\"line\"> </span><br><span class=\"line\">b = <span class=\"number\">2</span> <span class=\"keyword\">if</span> a &gt; <span class=\"number\">2</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">#b = 2</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\"><span class=\"keyword\">if</span> a &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">    b = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    b = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">#b = 2</span></span><br></pre></td></tr></table></figure>\n<p>如果你具备C的编程经验，你就会寻找A ? B : C的替代品。你可能发现A and B or C看起来还不错，但是b &#x3D; a &gt; 1 and False or True会返回True，而实际意图应该返回False。<br>使用b &#x3D; False if a &gt; 1 else True则会正确返回False。</p>\n<h2 id=\"Enumerate\"><a href=\"#Enumerate\" class=\"headerlink\" title=\"Enumerate\"></a>Enumerate</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">for</span> i, e <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(array,<span class=\"number\">0</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> i, e</span><br><span class=\"line\"><span class=\"comment\">#0 1</span></span><br><span class=\"line\"><span class=\"comment\">#1 2</span></span><br><span class=\"line\"><span class=\"comment\">#2 3</span></span><br><span class=\"line\"><span class=\"comment\">#3 4</span></span><br><span class=\"line\"><span class=\"comment\">#4 5 </span></span><br><span class=\"line\">NP:</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> xrange(<span class=\"built_in\">len</span>(array)):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> i, array[i]</span><br><span class=\"line\"><span class=\"comment\">#0 1</span></span><br><span class=\"line\"><span class=\"comment\">#1 2</span></span><br><span class=\"line\"><span class=\"comment\">#2 3</span></span><br><span class=\"line\"><span class=\"comment\">#3 4</span></span><br><span class=\"line\"><span class=\"comment\">#4 5 </span></span><br></pre></td></tr></table></figure>\n<p>使用enumerate可以一次性将索引和值取出，避免使用索引来取值，而且enumerate的第二个参数可以调整索引下标的起始位置，默认为0。</p>\n<h2 id=\"使用zip创建字典\"><a href=\"#使用zip创建字典\" class=\"headerlink\" title=\"使用zip创建字典\"></a>使用zip创建字典</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P:</span><br><span class=\"line\">keys = [<span class=\"string\">&#x27;Name&#x27;</span>, <span class=\"string\">&#x27;Sex&#x27;</span>, <span class=\"string\">&#x27;Age&#x27;</span>]</span><br><span class=\"line\">values = [<span class=\"string\">&#x27;Tim&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>, <span class=\"number\">23</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">dic = <span class=\"built_in\">dict</span>(<span class=\"built_in\">zip</span>(keys, values))</span><br><span class=\"line\"><span class=\"comment\">#&#123;&#x27;Age&#x27;: 23, &#x27;Name&#x27;: &#x27;Tim&#x27;, &#x27;Sex&#x27;: &#x27;Male&#x27;&#125;</span></span><br><span class=\"line\">NP:</span><br><span class=\"line\">dic = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i,e <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(keys):</span><br><span class=\"line\">    dic[e] = values[i]</span><br><span class=\"line\"><span class=\"comment\">#&#123;&#x27;Age&#x27;: 23, &#x27;Name&#x27;: &#x27;Tim&#x27;, &#x27;Sex&#x27;: &#x27;Male&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>zip方法返回的是一个元组，用它来创建键值对，简单明了。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://docs.python.org/release/3.7.0/library/stdtypes.html#truth-value-testing\">Python官网</a></li>\n</ol>\n","slug":"Python-更简单的写法","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/23/Python-%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%99%E6%B3%95/","excerpt":"Pythonic如果翻译成中文的话就是很python。很+名词结构的用法，比如：很国足，很CCTV等。所以很python可以理解为：只有python能做到的，区别于其他语言的写法，其实就是python的惯用和特有写法。 以下为了简略，我们用P表示pythonic的写法，NP表示non-pythonic的写法。为什么要追求pythonic? 相比于NP，P的写法简练，明确，优雅，绝大部分时候执行效率高。认识到pythonic的写法，会更便利和高效.以下将给出P和NP的n种示例。","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"pythonic","slug":"pythonic","permalink":"http://vwin.github.io/tags/pythonic/"},{"name":"语法糖","slug":"语法糖","permalink":"http://vwin.github.io/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"}]},{"title":"free命令中cached和buffers的区别","date":"2018-08-23T06:44:15.000Z","path":"2018/08/23/Linux-free命令中cached和buffers的区别/","text":"linux的free命令中cached和buffers的区别 命令12345[root@localhost ~]# free -m total used free shared buffers cachedMem: 7869 7651 218 1 191 5081-/+ buffers/cache: 2378 5490Swap: 478 139 339 65485 2065 63420 计算这里使用1、2 分别代表第一行和第二行的数据 12345678total1：表示物理 内存总量used1：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用free1：未被分配的内存shared1：共享内存，一般系统不会用到，这里也不讨论buffers1： 系统分配但未被使用的buffers 数量cached1：系统分配但未被使用的cache 数量used2：实际使用的buffers 与cache 总量，也是实际使用的内存总量free2：未被 使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存 可以整理出如下等式 12341. total1 = used1 + free12. total1 = used2 + free23. used1 = buffers1 + cached1 + used24. free2 = buffers1 + cached1 + free1 具体计算 12341. 7869 = 7651 + 2182. 7869 = 2378 + 5490 #7868基本相等，因为有shared3. 7651 = 191 + 5081 + 2378 #7650 基本相等，因为有shared4. 5490 = 191 + 5081 + 218 为什么这样计算呢，因为buffers和cache其实也是内存的一部分，这部分特殊的内存是可以回收的，甚至如果需要我们还可以将这部分buffers和cache给释放出来 区别page cahe和buffer cachePage cache实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到page cache。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当page cache的数据需要刷新时，page cache中的数据交给buffer cache，但是这种处理在2.6版本的内核之后就变的很简单了，没有真正意义上的cache操作。 Buffer cache是针对磁盘块的缓存，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据会缓存到buffer cache中，例如，文件系统的元数据都会缓存到buffer cache中。简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。 补充一点，在文件系统层每个设备都会分配一个def_blk_ops的文件操作方法，这是设备的操作方法，在每个设备的inode下面会存在一个radix tree，这个radix tree下面将会放置缓存数据的page页。这个page的数量将会在top程序的buffer一栏中显示。如果设备做了文件系统，那么会生成一个inode，这个inode会分配ext3_ops之类的操作方法，这些方法是文件系统的方法，在这个inode下面同样存在一个radix tree，这里会缓存文件的page页，缓存页的数量在top程序的cache一栏进行统计。从上面的分析可以看出，2.6内核中的buffer cache和page cache在处理上是保持一致的，但是存在概念上的差别，page cache针对文件的cache，buffer是针对磁盘块数据的cache，仅此而已。 cache 和 buffer的区别A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use ; 对于共享内存（Shared memory），主要用于在UNIX 环境下不同进程之间共享数据，是进程间通信的一种方法，一般的应用程序不会申请使用共享内存 Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，这样就减少了CPU的等待时间，提高了系统的效率。Cache又分为一级Cache（L1 Cache）和二级Cache（L2 Cache），L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上，现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache 它是根据程序的局部性原理而设计的，就是cpu执行的指令和访问的数据往往在集中的某一块，所以把这块内容放入cache后，cpu就不用在访问内存了，这就提高了访问速度。当然若cache中没有cpu所需要的内容，还是要访问内存的 查看CPU的 L1、L2、L3 123456[root@root ~]# ll /sys/devices/system/cpu/cpu0/cache/total 0drwxr-xr-x 2 root root 0 Jan 26 22:49 index0 #一级cache中的data和instruction cachedrwxr-xr-x 2 root root 0 Jan 26 22:49 index1 #一级cache中的data和instruction cachedrwxr-xr-x 2 root root 0 Jan 26 22:49 index2 #二级cache，共享的drwxr-xr-x 2 root root 0 Jan 26 22:49 index3 #三级cache，共享的 Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。 Free中的buffer和cache （它们都是占用内存）基于内存的buffer ：作为buffer cache的内存，是块设备的读写缓冲区 cache：作为page cache的内存， 文件系统的cache 如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小 如何释放Cache Memory 123456To free pagecache:echo 1 &gt; /proc/sys/vm/drop_cachesTo free dentries and inodes:echo 2 &gt; /proc/sys/vm/drop_cachesTo free pagecache, dentries and inodes:echo 3 &gt; /proc/sys/vm/drop_caches 注意，释放前最好sync一下，防止丢失数据，但是一般情况下没有必要手动释放内存 总结cached是cpu与内存间的，buffer是内存与磁盘间的，都是为了解决速度不对等的问题 缓存（cached）是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除 缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期 清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。举个例子吧：我这里有一个ext2的U盘，我往里面cp一个3M的MP3，但U盘的灯 没有跳动，过了一会儿（或者手动输入sync）U盘的灯就跳动起来了。卸载设备时会清空缓冲，所以有些时候卸载一个设备时要等上几秒钟 修改&#x2F;etc&#x2F;sysctl.conf中的vm.swappiness右边的数字可以在下次开机时调节swap使用策略。该数字范围是0～100，数字越大越倾向于使用swap。默认为60，可以改一下试试。–两者都是RAM中的数据 buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的 buffer是由各种进程分配的，被用在如输入队列等方面。一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存 cache经常被用在磁盘的I&#x2F;O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提高系统性能 Buffer Cachebuffer cache，又称bcache，其中文名称为缓冲器高速缓冲存储器，简称缓冲器高缓。另外，buffer cache按照其工作原理，又被称为块高缓","raw":"---\ntitle: free命令中cached和buffers的区别\ntoc: true\ndate: 2018-08-23 14:44:15\ntags: [linux,free,cached,buffer]\ncategories: [技术]\ndescription: linux的free命令中cached和buffers的区别\n---\nlinux的free命令中cached和buffers的区别\n<!--more-->\n## 命令\n```s\n[root@localhost ~]# free -m\n             total       used       free     shared    buffers     cached\nMem:          7869       7651        218          1        191       5081\n-/+ buffers/cache:       2378       5490\nSwap:          478        139        339        65485        2065       63420\n```\n\n## 计算\n这里使用1、2 分别代表第一行和第二行的数据\n```s\ntotal1：表示物理 内存总量\nused1：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用\nfree1：未被分配的内存\nshared1：共享内存，一般系统不会用到，这里也不讨论\nbuffers1： 系统分配但未被使用的buffers 数量\ncached1：系统分配但未被使用的cache 数量\nused2：实际使用的buffers 与cache 总量，也是实际使用的内存总量\nfree2：未被 使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存\n```\n\n可以整理出如下等式\n\n```s\n1. total1 = used1 + free1\n2. total1 = used2 + free2\n3. used1 = buffers1 + cached1 + used2\n4. free2 = buffers1 + cached1 + free1\n```\n\n具体计算\n\n```s\n1. 7869 = 7651 + 218\n2. 7869 = 2378 + 5490  #7868基本相等，因为有shared\n3. 7651 = 191 + 5081 + 2378 #7650 基本相等，因为有shared\n4. 5490 = 191 + 5081 + 218\n```\n\n为什么这样计算呢，因为buffers和cache其实也是内存的一部分，这部分特殊的内存是可以回收的，甚至如果需要我们还可以将这部分buffers和cache给释放出来\n\n## 区别\n\n### page cahe和buffer cache\nPage cache实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到page cache。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当page cache的数据需要刷新时，page cache中的数据交给buffer cache，但是这种处理在2.6版本的内核之后就变的很简单了，没有真正意义上的cache操作。 \n\nBuffer cache是针对磁盘块的缓存，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据会缓存到buffer cache中，例如，文件系统的元数据都会缓存到buffer cache中。 \n简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。 \n\n补充一点，在文件系统层每个设备都会分配一个def_blk_ops的文件操作方法，这是设备的操作方法，在每个设备的inode下面会存在一个radix tree，这个radix tree下面将会放置缓存数据的page页。这个page的数量将会在top程序的buffer一栏中显示。如果设备做了文件系统，那么会生成一个inode，这个inode会分配ext3_ops之类的操作方法，这些方法是文件系统的方法，在这个inode下面同样存在一个radix tree，这里会缓存文件的page页，缓存页的数量在top程序的cache一栏进行统计。从上面的分析可以看出，2.6内核中的buffer cache和page cache在处理上是保持一致的，但是存在概念上的差别，page cache针对文件的cache，buffer是针对磁盘块数据的cache，仅此而已。 \n\n### cache 和 buffer的区别\nA buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use ; 对于共享内存（Shared memory），主要用于在UNIX 环境下不同进程之间共享数据，是进程间通信的一种方法，一般的应用程序不会申请使用共享内存\n\nCache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，这样就减少了CPU的等待时间，提高了系统的效率。Cache又分为一级Cache（L1 Cache）和二级Cache（L2 Cache），L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上，现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache\n\n它是根据程序的局部性原理而设计的，就是cpu执行的指令和访问的数据往往在集中的某一块，所以把这块内容放入cache后，cpu就不用在访问内存了，这就提高了访问速度。当然若cache中没有cpu所需要的内容，还是要访问内存的\n\n查看CPU的 L1、L2、L3\n```s\n[root@root ~]# ll /sys/devices/system/cpu/cpu0/cache/\ntotal 0\ndrwxr-xr-x 2 root root 0 Jan 26 22:49 index0 #一级cache中的data和instruction cache\ndrwxr-xr-x 2 root root 0 Jan 26 22:49 index1 #一级cache中的data和instruction cache\ndrwxr-xr-x 2 root root 0 Jan 26 22:49 index2 #二级cache，共享的\ndrwxr-xr-x 2 root root 0 Jan 26 22:49 index3 #三级cache，共享的 \n```\nBuffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。 \n\n### Free中的buffer和cache （它们都是占用内存）<font color=red>基于内存的</font>\nbuffer ：作为buffer cache的内存，是块设备的读写缓冲区 \n\ncache：作为page cache的内存， 文件系统的cache \n\n如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小\n\n如何释放Cache Memory\n```s\nTo free pagecache:\necho 1 > /proc/sys/vm/drop_caches\nTo free dentries and inodes:\necho 2 > /proc/sys/vm/drop_caches\nTo free pagecache, dentries and inodes:\necho 3 > /proc/sys/vm/drop_caches\n```\n \n>注意，释放前最好sync一下，防止丢失数据，但是一般情况下没有必要手动释放内存\n\n## 总结\n### cached是cpu与内存间的，buffer是内存与磁盘间的，都是为了解决速度不对等的问题\n- 缓存（cached）是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除\n\n- 缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期 清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。举个例子吧：我这里有一个ext2的U盘，我往里面cp一个3M的MP3，但U盘的灯 没有跳动，过了一会儿（或者手动输入sync）U盘的灯就跳动起来了。卸载设备时会清空缓冲，所以有些时候卸载一个设备时要等上几秒钟\n\n- 修改/etc/sysctl.conf中的vm.swappiness右边的数字可以在下次开机时调节swap使用策略。该数字范围是0～100，数字越大越倾向于使用swap。默认为60，可以改一下试试。–两者都是RAM中的数据\n\n### buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的\n \n- buffer是由各种进程分配的，被用在如输入队列等方面。一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存\n\n- cache经常被用在磁盘的I/O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提高系统性能\n\n- Buffer Cachebuffer cache，又称bcache，其中文名称为缓冲器高速缓冲存储器，简称缓冲器高缓。另外，buffer cache按照其工作原理，又被称为块高缓\n\n","content":"<p>linux的free命令中cached和buffers的区别</p>\n<span id=\"more\"></span>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# free -m</span><br><span class=\"line\">             total       used       free     shared    buffers     cached</span><br><span class=\"line\">Mem:          7869       7651        218          1        191       5081</span><br><span class=\"line\">-/+ buffers/cache:       2378       5490</span><br><span class=\"line\">Swap:          478        139        339        65485        2065       63420</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"计算\"><a href=\"#计算\" class=\"headerlink\" title=\"计算\"></a>计算</h2><p>这里使用1、2 分别代表第一行和第二行的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total1：表示物理 内存总量</span><br><span class=\"line\">used1：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用</span><br><span class=\"line\">free1：未被分配的内存</span><br><span class=\"line\">shared1：共享内存，一般系统不会用到，这里也不讨论</span><br><span class=\"line\">buffers1： 系统分配但未被使用的buffers 数量</span><br><span class=\"line\">cached1：系统分配但未被使用的cache 数量</span><br><span class=\"line\">used2：实际使用的buffers 与cache 总量，也是实际使用的内存总量</span><br><span class=\"line\">free2：未被 使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存</span><br></pre></td></tr></table></figure>\n\n<p>可以整理出如下等式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. total1 = used1 + free1</span><br><span class=\"line\">2. total1 = used2 + free2</span><br><span class=\"line\">3. used1 = buffers1 + cached1 + used2</span><br><span class=\"line\">4. free2 = buffers1 + cached1 + free1</span><br></pre></td></tr></table></figure>\n\n<p>具体计算</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 7869 = 7651 + 218</span><br><span class=\"line\">2. 7869 = 2378 + 5490  #7868基本相等，因为有shared</span><br><span class=\"line\">3. 7651 = 191 + 5081 + 2378 #7650 基本相等，因为有shared</span><br><span class=\"line\">4. 5490 = 191 + 5081 + 218</span><br></pre></td></tr></table></figure>\n\n<p>为什么这样计算呢，因为buffers和cache其实也是内存的一部分，这部分特殊的内存是可以回收的，甚至如果需要我们还可以将这部分buffers和cache给释放出来</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><h3 id=\"page-cahe和buffer-cache\"><a href=\"#page-cahe和buffer-cache\" class=\"headerlink\" title=\"page cahe和buffer cache\"></a>page cahe和buffer cache</h3><p>Page cache实际上是针对文件系统的，是文件的缓存，在文件层面上的数据会缓存到page cache。文件的逻辑层需要映射到实际的物理磁盘，这种映射关系由文件系统来完成。当page cache的数据需要刷新时，page cache中的数据交给buffer cache，但是这种处理在2.6版本的内核之后就变的很简单了，没有真正意义上的cache操作。 </p>\n<p>Buffer cache是针对磁盘块的缓存，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据会缓存到buffer cache中，例如，文件系统的元数据都会缓存到buffer cache中。<br>简单说来，page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。 </p>\n<p>补充一点，在文件系统层每个设备都会分配一个def_blk_ops的文件操作方法，这是设备的操作方法，在每个设备的inode下面会存在一个radix tree，这个radix tree下面将会放置缓存数据的page页。这个page的数量将会在top程序的buffer一栏中显示。如果设备做了文件系统，那么会生成一个inode，这个inode会分配ext3_ops之类的操作方法，这些方法是文件系统的方法，在这个inode下面同样存在一个radix tree，这里会缓存文件的page页，缓存页的数量在top程序的cache一栏进行统计。从上面的分析可以看出，2.6内核中的buffer cache和page cache在处理上是保持一致的，但是存在概念上的差别，page cache针对文件的cache，buffer是针对磁盘块数据的cache，仅此而已。 </p>\n<h3 id=\"cache-和-buffer的区别\"><a href=\"#cache-和-buffer的区别\" class=\"headerlink\" title=\"cache 和 buffer的区别\"></a>cache 和 buffer的区别</h3><p>A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use ; 对于共享内存（Shared memory），主要用于在UNIX 环境下不同进程之间共享数据，是进程间通信的一种方法，一般的应用程序不会申请使用共享内存</p>\n<p>Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，这样就减少了CPU的等待时间，提高了系统的效率。Cache又分为一级Cache（L1 Cache）和二级Cache（L2 Cache），L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上，现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache</p>\n<p>它是根据程序的局部性原理而设计的，就是cpu执行的指令和访问的数据往往在集中的某一块，所以把这块内容放入cache后，cpu就不用在访问内存了，这就提高了访问速度。当然若cache中没有cpu所需要的内容，还是要访问内存的</p>\n<p>查看CPU的 L1、L2、L3</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@root ~]# ll /sys/devices/system/cpu/cpu0/cache/</span><br><span class=\"line\">total 0</span><br><span class=\"line\">drwxr-xr-x 2 root root 0 Jan 26 22:49 index0 #一级cache中的data和instruction cache</span><br><span class=\"line\">drwxr-xr-x 2 root root 0 Jan 26 22:49 index1 #一级cache中的data和instruction cache</span><br><span class=\"line\">drwxr-xr-x 2 root root 0 Jan 26 22:49 index2 #二级cache，共享的</span><br><span class=\"line\">drwxr-xr-x 2 root root 0 Jan 26 22:49 index3 #三级cache，共享的 </span><br></pre></td></tr></table></figure>\n<p>Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。 </p>\n<h3 id=\"Free中的buffer和cache-（它们都是占用内存）基于内存的\"><a href=\"#Free中的buffer和cache-（它们都是占用内存）基于内存的\" class=\"headerlink\" title=\"Free中的buffer和cache （它们都是占用内存）基于内存的\"></a>Free中的buffer和cache （它们都是占用内存）<font color=\"red\">基于内存的</font></h3><p>buffer ：作为buffer cache的内存，是块设备的读写缓冲区 </p>\n<p>cache：作为page cache的内存， 文件系统的cache </p>\n<p>如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小</p>\n<p>如何释放Cache Memory</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To free pagecache:</span><br><span class=\"line\">echo 1 &gt; /proc/sys/vm/drop_caches</span><br><span class=\"line\">To free dentries and inodes:</span><br><span class=\"line\">echo 2 &gt; /proc/sys/vm/drop_caches</span><br><span class=\"line\">To free pagecache, dentries and inodes:</span><br><span class=\"line\">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，释放前最好sync一下，防止丢失数据，但是一般情况下没有必要手动释放内存</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"cached是cpu与内存间的，buffer是内存与磁盘间的，都是为了解决速度不对等的问题\"><a href=\"#cached是cpu与内存间的，buffer是内存与磁盘间的，都是为了解决速度不对等的问题\" class=\"headerlink\" title=\"cached是cpu与内存间的，buffer是内存与磁盘间的，都是为了解决速度不对等的问题\"></a>cached是cpu与内存间的，buffer是内存与磁盘间的，都是为了解决速度不对等的问题</h3><ul>\n<li><p>缓存（cached）是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除</p>\n</li>\n<li><p>缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期 清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。举个例子吧：我这里有一个ext2的U盘，我往里面cp一个3M的MP3，但U盘的灯 没有跳动，过了一会儿（或者手动输入sync）U盘的灯就跳动起来了。卸载设备时会清空缓冲，所以有些时候卸载一个设备时要等上几秒钟</p>\n</li>\n<li><p>修改&#x2F;etc&#x2F;sysctl.conf中的vm.swappiness右边的数字可以在下次开机时调节swap使用策略。该数字范围是0～100，数字越大越倾向于使用swap。默认为60，可以改一下试试。–两者都是RAM中的数据</p>\n</li>\n</ul>\n<h3 id=\"buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的\"><a href=\"#buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的\" class=\"headerlink\" title=\"buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的\"></a>buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的</h3><ul>\n<li><p>buffer是由各种进程分配的，被用在如输入队列等方面。一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存</p>\n</li>\n<li><p>cache经常被用在磁盘的I&#x2F;O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提高系统性能</p>\n</li>\n<li><p>Buffer Cachebuffer cache，又称bcache，其中文名称为缓冲器高速缓冲存储器，简称缓冲器高缓。另外，buffer cache按照其工作原理，又被称为块高缓</p>\n</li>\n</ul>\n","slug":"Linux-free命令中cached和buffers的区别","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/23/Linux-free%E5%91%BD%E4%BB%A4%E4%B8%ADcached%E5%92%8Cbuffers%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"linux的free命令中cached和buffers的区别","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"free","slug":"free","permalink":"http://vwin.github.io/tags/free/"},{"name":"cached","slug":"cached","permalink":"http://vwin.github.io/tags/cached/"},{"name":"buffer","slug":"buffer","permalink":"http://vwin.github.io/tags/buffer/"}]},{"title":"Git-核心概念","date":"2018-08-20T07:01:59.000Z","path":"2018/08/20/Git-核心概念/","text":"原文地址：https://lufficc.com/blog/the-core-conception-of-git Git的核心概念，原理理解 本文不是Git使用教学篇，而是偏向理论方面，旨在更加深刻的理解Git，这样才能更好的使用它，让工具成为我们得力的助手。 版本控制系统Git 是目前世界上最优秀的分布式版本控制系统。版本控制系统是能够随着时间的推进记录一系列文件的变化以便于你以后想要的退回到某个版本的系统。版本控制系统分为三大类：本地版本控制系统，集中式版本控制系统和分布式版本控制系统 本地版本控制（Local Version Control Systems）是将文件的各个版本以一定的数据格式存储在本地的磁盘（有的VCS 是保存文件的变化补丁，即在文件内容变化时计算出差量保存起来），这种方式在一定程度上解决了手动复制粘贴的问题，但无法解决多人协作的问题。 集中式版本控制（Centralized Version Control Systems）相比本地版本控制没有什么本质的变化，只是多了个一个中央服务器，各个版本的数据库存储在中央服务器，管理员可以控制开发人员的权限，而开发人员也可以从中央服务器拉取数据。集中式版本控制虽然解决了团队协作问题，但缺点也很明显：所有数据存储在中央服务器，服务器一旦宕机或者磁盘损坏，会造成不可估量的损失。 分布式版本控制（ Distributed Version Control System）与前两者均不同。首先，在分布式版本控制系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，系统保存的的不是文件变化的差量，而是文件的快照，即把文件的整体复制下来保存，而不关心具体的变化内容。其次，最重要的是分布式版本控制系统是分布式的，当你从中央服务器拷贝下来代码时，你拷贝的是一个完整的版本库，包括历史纪录，提交记录等，这样即使某一台机器宕机也能找到文件的完整备份。 Git基础Git是一个分布式版本控制系统，保存的是文件的完整快照，而不是差异变化或者文件补丁。 Git每一次提交都是对项目文件的一个完整拷贝，因此你可以完全恢复到以前的任一个提交而不会发生任何区别。这里有一个问题：如果我的项目大小是10M，那Git占用的空间是不是随着提交次数的增加线性增加呢？我提交（commit）了10次，占用空间是不是100M呢？很显然不是，Git是很智能的，如果文件没有变化，它只会保存一个指向上一个版本的文件的指针，即，对于一个特定版本的文件，Git只会保存一个副本，但可以有多个指向该文件的指针。 另外注意，Git最适合保存文本文件，事实上Git就是被设计出来就是为了保存文本文件的，像各种语言的源代码，因为Git可以对文本文件进行很好的压缩和差异分析（大家都见识过了，Git的差异分析可以精确到你添加或者删除了某个字母）。而二进制文件像视频，图片等，Git也能管理，但不能取得较好的效果（压缩比率低，不能差异分析）。实验证明，一个 500k 的文本文件经Git压缩后仅 50k 左右，稍微改变内容后两次提交，会有两个 50k 左右的文件，没错的，保存的是完整快照。而对于二进制文件，像视频，图片，压缩率非常小， Git 占用空间几乎随着提交次数线性增长。 Git工程有三个工作区域：工作目录，暂存区域，以及本地仓库。工作目录是你当前进行工作的区域；暂存区域是你运行git add命令后文件保存的区域，也是下次提交将要保存的文件（注意：Git 提交实际读取的是暂存区域的内容，而与工作区域的文件无关，这也是当你修改了文件之后，如果没有添加git add到暂存区域，并不会保存到版本库的原因）；本地仓库就是版本库，记录了你工程某次提交的完整状态和内容，这意味着你的数据永远不会丢失。 相应的，文件也有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地版本库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中，即暂存区域。所以使用Git的基本工作流程就是： 在工作区域增加，删除或者修改文件。 运行git add，将文件快照保存到暂存区域。 提交更新，将文件永久版保存到版本库中。 Git对象现在已经明白Git的基本流程，但Git是怎么完成的呢？Git怎么区分文件是否发生变化？下面简单介绍一下Git的基本原理。 SHA-1 校验和Git 是一套内容寻址文件系统。意思就是Git 从核心上来看不过是简单地存储键值对（key-value），value是文件的内容，而key是文件内容与文件头信息的 40个字符长度的 SHA-1 校验和，例如：5453545dccd33565a585ffe5f53fda3e067b84d8。Git使用该校验和不是为了加密，而是为了数据的完整性，它可以保证，在很多年后，你重新checkout某个commit时，一定是它多年前的当时的状态，完全一摸一样。当你对文件进行了哪怕一丁点儿的修改，也会计算出完全不同的 SHA-1 校验和，这种现象叫做“雪崩效应”（Avalanche effect）。 SHA-1 校验和因此就是上文提到的文件的指针，这和C语言中的指针很有些不同：C语言将数据在内存中的地址作为指针，Git将文件的 SHA-1 校验和作为指针，目的都是为了唯一区分不同的对象。但是当C语言指针指向的内存中的内容发生变化时，指针并不发生变化，但Git指针指向的文件内容发生变化时，指针也会发生变化。所以，Git中每一个版本的文件，都有一个唯一的指针指向它。 文件(blob)对象，树(tree)对象，提交(commit)对象blob 对象保存的仅仅是文件的内容，tree 对象更像是操作系统中的目录，它可以保存blob对象和tree 对象。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 对象或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息等： 当你对文件进行修改并提交时，变化的文件会生成一个新的blob对象，记录文件的完整内容（是全部内容，不是变化内容），然后针对该文件有一个唯一的 SHA-1 校验和，修改此次提交该文件的指针为该 SHA-1 校验和，而对于没有变化的文件，简单拷贝上一次版本的指针即 SHA-1 校验和，而不会生成一个全新的blob对象，这也解释了10M大小的项目进行10次提交总大小远远小于100M的原因。 另外，每次提交可能不仅仅只有一个 tree 对象，它们指明了项目的不同快照，但你必须记住所有对象的 SHA-1 校验和才能获得完整的快照，而且没有作者，何时，为什么保存这些快照的原因。commit对象就是问了解决这些问题诞生的，commit 对象的格式很简单：指明了该时间点项目快照的顶层tree对象、作者&#x2F;提交者信息（从 Git 设置的 user.name 和 user.email中获得)以及当前时间戳、一个空行，上一次的提交对象的ID以及提交注释信息。你可以简单的运行git log来获取这新信息： 1234567891011121314$ git logcommit 2cb0bb475c34a48957d18f67d0623e3304a26489Author: lufficc &lt;luffy.lcc@gmail.com&gt;Date: Sun Oct 2 17:29:30 2016 +0800 fix some font sizecommit f0c8b4b31735b5e5e96e456f9b0c8d5fc7a3e68aAuthor: lufficc &lt;luffy.lcc@gmail.com&gt;Date: Sat Oct 1 02:55:48 2016 +0800 fix post show css***********省略*********** 上图的Test.txt是第一次提交之前生成的，第一次它的初始 SHA-1 校验和以3c4e9c开头。随后对它进行了修改，所以第二次提交时生成了一个全新blob对象，校验和以1f7a7a开头。而第三次提交时Test.txt并没有变化，所以只是保存最近版本的 SHA-1 校验和而不生成全新的blob对象。在项目开发过程中新增加的文件在提交后都会生成一个全新的blob对象来保存它。注意除了第一次每个提交对象都有一个指向上一次提交对象的指针。 因此简单来说，blob对象保存文件的内容；tree对象类似文件夹，保存blob对象和其它tree对象；commit对象保存tree对象，提交信息，作者，邮箱以及上一次的提交对象的ID（第一次提交没有）。而Git就是通过组织和管理这些对象的状态以及复杂的关系实现的版本控制以及以及其他功能如分支。 Git引用现在再来看引用，就会很简单了。如果我们想要看某个提交记录之前的完整历史，就必须记住这个提交ID，但提交ID是一个40位的 SHA-1 校验和，难记。所以引用就是SHA-1 校验和的别名，存储在.git&#x2F;refs文件夹中。 最常见的引用也许就是master了，因为这是Git默认创建的（可以修改，但一般不修改），它始终指向你项目主分支的最后一次提交记录。如果在项目根目录运行cat .git&#x2F;refs&#x2F;heads，会输出一个SHA-1 校验和，例如： 12$ cat .git/refs/heads/master4f3e6a6f8c62bde818b4b3d12c8cf3af45d6dc00 因此master只是一个40位SHA-1 校验和的别名罢了。 还有一个问题，Git如何知道你当前分支的最后一次的提交ID?在.git文件夹下有一个HEAD文件，像这样： 12$ cat .git/HEADref: refs/heads/master HEAD文件其实并不包含 SHA-1 值，而是一个指向当前分支的引用，内容会随着切换分支而变化，内容格式像这样：ref: refs&#x2F;heads&#x2F;。当你执行git commit命令时，它就创建了一个commit对象，把这个commit对象的父级设置为 HEAD 指向的引用的 SHA-1 值。 再来说说 Git 的 tag，标签。标签从某种意义上像是一个引用， 它指向一个 commit 对象而不是一个 tree，包含一个标签，一组数据，一个消息和一个commit 对象的指针。但是区别就是引用随着项目进行它的值在不断向前推进变化，但是标签不会变化——永远指向同一个 commit，仅仅是提供一个更加友好的名字。 Git分支分支分支是Git的杀手级特征，而且Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。因为Git分支非常轻量级，不像其他的版本控制，创建分支意味着要把项目完整的拷贝一份，而Git创建分支是在瞬间完成的，而与你工程的复杂程度无关。 因为在上文中已经说到，Git保存文件的最基本的对象是blob对象，Git本质上只是一棵巨大的文件树，树的每一个节点就是blob对象，而分支只是树的一个分叉。说白了，分支就是一个有名字的引用，它包含一个提交对象的的40位校验和，所以创建分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以自然就快了，而且与项目的复杂程度无关。 Git的默认分支是master，存储在.git\\refs\\heads\\master文件中，假设你在master分支运行git branch dev创建了一个名字为dev的分支，那么git所做的实际操作是： 在.git\\refs\\heads文件夹下新建一个文件名为dev（没有扩展名）的文本文件。 将HEAD指向的当前分支（当前为master）的40位SHA-1 校验和外加一个换行符写入dev文件。 结束。 创建分支就是这么简单，那么切换分支呢？更简单： 修改.git文件下的HEAD文件为ref: refs&#x2F;heads&#x2F;&lt;分支名称&gt;。 按照分支指向的提交记录将工作区的文件恢复至一模一样。 结束。 记住，HEAD文件指向当前分支的最后一次提交，同时，它也是以当前分支再次创建一个分支时，将要写入的内容。 分支合并再来说一说合并，首先是Fast-forward，换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。比如： 注意箭头方向，因为每一次提交都有一个指向上一次提交的指针，所以箭头方向向左，更为合理 当在master分支合并dev分支时，因为他们在一条线上，这种单线的历史分支不存在任何需要解决的分歧，所以只需要master分支指向dev分支即可，所以非常快。 当分支出现分叉时，就有可能出现冲突，而这时Git就会要求你去解决冲突，比如像下面的历史： 因为master分支和dev分支不在一条线上，即v7不是v5的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（v7 和 v5）以及它们的共同祖先（v3）进行一次简单的三方合并计算。合并之后会生成一个和并提交v8： 注意：合并提交有两个祖先（v7和v5）。 分支的变基rebase把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase。首先merge 和 rebase最终的结果是一样的，但 rebase能产生一个更为整洁的提交历史。仍然以上图为例，如果简单的merge，会生成一个提交对象v8，现在我们尝试使用变基合并分支，切换到dev： 1234$ git checkout dev$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command 这段代码的意思是：回到两个分支最近的共同祖先v3，根据当前分支（也就是要进行变基的分支 dev）后续的历次提交对象（包括v4，v5），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（v7）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成两个新的合并提交对象（v4’，v5’）,从而改写 dev 的提交历史，使它成为 master 分支的直接下游，如下图： 现在，就可以回到master分支进行快速合并Fast-forward了，因为master分支和dev分支在一条线上： 12$ git checkout master$ git merge dev 现在的v5’对应的快照，其实和普通的三方合并，即上个例子中的 v8 对应的快照内容一模一样。虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。 总结 Git保存文件的完整内容，不保存差量变化。 Git以储键值对（key-value）的方式保存文件。 每一个文件，相同文件的不同版本，都有一个唯一的40位的 SHA-1 校验和与之对应。 SHA-1 校验和是文件的指针，Git依靠它来区分文件。 每一个文件都会在Git的版本库里生成blob对象来保存。 对于没有变化的文件，Git只会保留上一个版本的指针。 Git实际上是通过维持复杂的文件树来实现版本控制的。 使用Git的工作流程基本就是就是文件在三个工作区域之间的流动。 应该大量使用分支进行团队协作。 分支只是对提交对象的一个引用。","raw":"---\ntitle: Git-核心概念\ntoc: true\ndate: 2018-08-20 15:01:59\ntags: [git]\ncategories: [技术]\ndescription: Git的核心概念\n---\n原文地址：https://lufficc.com/blog/the-core-conception-of-git \n\nGit的核心概念，原理理解\n<!--more-->\n本文不是Git使用教学篇，而是偏向理论方面，旨在更加深刻的理解Git，这样才能更好的使用它，让工具成为我们得力的助手。\n\n## 版本控制系统\nGit 是目前世界上最优秀的分布式版本控制系统。版本控制系统是能够随着时间的推进记录一系列文件的变化以便于你以后想要的退回到某个版本的系统。版本控制系统分为三大类：本地版本控制系统，集中式版本控制系统和分布式版本控制系统\n\n### 本地版本控制（Local Version Control Systems）\n是将文件的各个版本以一定的数据格式存储在本地的磁盘（有的VCS 是保存文件的变化补丁，即在文件内容变化时计算出差量保存起来），这种方式在一定程度上解决了手动复制粘贴的问题，但无法解决多人协作的问题。\n![本地版本控制](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img.png)\n\n### 集中式版本控制（Centralized Version Control Systems）\n相比本地版本控制没有什么本质的变化，只是多了个一个中央服务器，各个版本的数据库存储在中央服务器，管理员可以控制开发人员的权限，而开发人员也可以从中央服务器拉取数据。集中式版本控制虽然解决了团队协作问题，但缺点也很明显：所有数据存储在中央服务器，服务器一旦宕机或者磁盘损坏，会造成不可估量的损失。\n![集中式版本控制](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-1.png)\n\n### 分布式版本控制（ Distributed Version Control System）\n与前两者均不同。首先，在分布式版本控制系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，系统保存的的不是文件变化的差量，而是文件的快照，即把文件的整体复制下来保存，而不关心具体的变化内容。其次，最重要的是分布式版本控制系统是分布式的，当你从中央服务器拷贝下来代码时，你拷贝的是一个完整的版本库，包括历史纪录，提交记录等，这样即使某一台机器宕机也能找到文件的完整备份。\n![分布式版本控制](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-2.png)\n\n## Git基础\nGit是一个分布式版本控制系统，保存的是文件的完整快照，而不是差异变化或者文件补丁。\n![保存每一次变化文件的完整内容](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-3.png)\n\nGit每一次提交都是对项目文件的一个完整拷贝，因此你可以完全恢复到以前的任一个提交而不会发生任何区别。这里有一个问题：如果我的项目大小是10M，那Git占用的空间是不是随着提交次数的增加线性增加呢？我提交（commit）了10次，占用空间是不是100M呢？很显然不是，Git是很智能的，如果文件没有变化，它只会保存一个指向上一个版本的文件的指针，即，对于一个特定版本的文件，Git只会保存一个副本，但可以有多个指向该文件的指针。\n\n>另外注意，Git最适合保存文本文件，事实上Git就是被设计出来就是为了保存文本文件的，像各种语言的源代码，因为Git可以对文本文件进行很好的压缩和差异分析（大家都见识过了，Git的差异分析可以精确到你添加或者删除了某个字母）。而二进制文件像视频，图片等，Git也能管理，但不能取得较好的效果（压缩比率低，不能差异分析）。实验证明，一个 500k 的文本文件经Git压缩后仅 50k 左右，稍微改变内容后两次提交，会有两个 50k 左右的文件，没错的，保存的是完整快照。而对于二进制文件，像视频，图片，压缩率非常小， Git 占用空间几乎随着提交次数线性增长。\n\n![未变化的文件只保存上一个版本的指针](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-4.png)\n\nGit工程有三个工作区域：工作目录，暂存区域，以及本地仓库。工作目录是你当前进行工作的区域；暂存区域是你运行git add命令后文件保存的区域，也是下次提交将要保存的文件（注意：Git 提交实际读取的是暂存区域的内容，而与工作区域的文件无关，这也是当你修改了文件之后，如果没有添加git add到暂存区域，并不会保存到版本库的原因）；本地仓库就是版本库，记录了你工程某次提交的完整状态和内容，这意味着你的数据永远不会丢失。\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-5.png)\n\n相应的，文件也有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地版本库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中，即暂存区域。所以使用Git的基本工作流程就是：\n\n1. 在工作区域增加，删除或者修改文件。\n2. 运行git add，将文件快照保存到暂存区域。\n3. 提交更新，将文件永久版保存到版本库中。\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-6.png)\n\n## Git对象\n\n现在已经明白Git的基本流程，但Git是怎么完成的呢？Git怎么区分文件是否发生变化？下面简单介绍一下Git的基本原理。\n\n### SHA-1 校验和\nGit 是一套内容寻址文件系统。意思就是Git 从核心上来看不过是简单地存储键值对（key-value），value是文件的内容，而key是文件内容与文件头信息的 40个字符长度的 SHA-1 校验和，例如：5453545dccd33565a585ffe5f53fda3e067b84d8。Git使用该校验和不是为了加密，而是为了数据的完整性，它可以保证，在很多年后，你重新checkout某个commit时，一定是它多年前的当时的状态，完全一摸一样。当你对文件进行了哪怕一丁点儿的修改，也会计算出完全不同的 SHA-1 校验和，这种现象叫做“雪崩效应”（Avalanche effect）。\n\nSHA-1 校验和因此就是上文提到的文件的指针，这和C语言中的指针很有些不同：C语言将数据在内存中的地址作为指针，Git将文件的 SHA-1 校验和作为指针，目的都是为了唯一区分不同的对象。但是当C语言指针指向的内存中的内容发生变化时，指针并不发生变化，但Git指针指向的文件内容发生变化时，指针也会发生变化。所以，Git中每一个版本的文件，都有一个唯一的指针指向它。\n\n### 文件(blob)对象，树(tree)对象，提交(commit)对象\nblob 对象保存的仅仅是文件的内容，tree 对象更像是操作系统中的目录，它可以保存blob对象和tree 对象。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 对象或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息等：\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-7.png)\n\n当你对文件进行修改并提交时，变化的文件会生成一个新的blob对象，记录文件的完整内容（是全部内容，不是变化内容），然后针对该文件有一个唯一的 SHA-1 校验和，修改此次提交该文件的指针为该 SHA-1 校验和，而对于没有变化的文件，简单拷贝上一次版本的指针即 SHA-1 校验和，而不会生成一个全新的blob对象，这也解释了10M大小的项目进行10次提交总大小远远小于100M的原因。\n\n另外，每次提交可能不仅仅只有一个 tree 对象，它们指明了项目的不同快照，但你必须记住所有对象的 SHA-1 校验和才能获得完整的快照，而且没有作者，何时，为什么保存这些快照的原因。commit对象就是问了解决这些问题诞生的，commit 对象的格式很简单：指明了该时间点项目快照的顶层tree对象、作者/提交者信息（从 Git 设置的 user.name 和 user.email中获得)以及当前时间戳、一个空行，上一次的提交对象的ID以及提交注释信息。你可以简单的运行git log来获取这新信息：\n\n```shell\n$ git log\ncommit 2cb0bb475c34a48957d18f67d0623e3304a26489\nAuthor: lufficc <luffy.lcc@gmail.com>\nDate:   Sun Oct 2 17:29:30 2016 +0800\n\n    fix some font size\n\ncommit f0c8b4b31735b5e5e96e456f9b0c8d5fc7a3e68a\nAuthor: lufficc <luffy.lcc@gmail.com>\nDate:   Sat Oct 1 02:55:48 2016 +0800\n\n    fix post show css\n\n***********省略***********\n```\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-8.png)\n\n上图的Test.txt是第一次提交之前生成的，第一次它的初始 SHA-1 校验和以3c4e9c开头。随后对它进行了修改，所以第二次提交时生成了一个全新blob对象，校验和以1f7a7a开头。而第三次提交时Test.txt并没有变化，所以只是保存最近版本的 SHA-1 校验和而不生成全新的blob对象。在项目开发过程中新增加的文件在提交后都会生成一个全新的blob对象来保存它。注意除了第一次每个提交对象都有一个指向上一次提交对象的指针。\n\n因此简单来说，blob对象保存文件的内容；tree对象类似文件夹，保存blob对象和其它tree对象；commit对象保存tree对象，提交信息，作者，邮箱以及上一次的提交对象的ID（第一次提交没有）。而Git就是通过组织和管理这些对象的状态以及复杂的关系实现的版本控制以及以及其他功能如分支。\n\n## Git引用\n现在再来看引用，就会很简单了。如果我们想要看某个提交记录之前的完整历史，就必须记住这个提交ID，但提交ID是一个40位的 SHA-1 校验和，难记。所以引用就是SHA-1 校验和的别名，存储在.git/refs文件夹中。\n\n最常见的引用也许就是master了，因为这是Git默认创建的（可以修改，但一般不修改），它始终指向你项目主分支的最后一次提交记录。如果在项目根目录运行cat .git/refs/heads，会输出一个SHA-1 校验和，例如：\n\n```shell\n$ cat .git/refs/heads/master\n4f3e6a6f8c62bde818b4b3d12c8cf3af45d6dc00\n```\n\n因此master只是一个40位SHA-1 校验和的别名罢了。\n\n还有一个问题，Git如何知道你当前分支的最后一次的提交ID?在.git文件夹下有一个HEAD文件，像这样：\n\n```shell\n$ cat .git/HEAD\nref: refs/heads/master\n```\n\nHEAD文件其实并不包含 SHA-1 值，而是一个指向当前分支的引用，内容会随着切换分支而变化，内容格式像这样：ref: refs/heads/<branch-name>。当你执行git commit命令时，它就创建了一个commit对象，把这个commit对象的父级设置为 HEAD 指向的引用的 SHA-1 值。\n\n再来说说 Git 的 tag，标签。标签从某种意义上像是一个引用， 它指向一个 commit 对象而不是一个 tree，包含一个标签，一组数据，一个消息和一个commit 对象的指针。但是区别就是引用随着项目进行它的值在不断向前推进变化，但是标签不会变化——永远指向同一个 commit，仅仅是提供一个更加友好的名字。\n\n## Git分支\n### 分支\n\n分支是Git的杀手级特征，而且Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。因为Git分支非常轻量级，不像其他的版本控制，创建分支意味着要把项目完整的拷贝一份，而Git创建分支是在瞬间完成的，而与你工程的复杂程度无关。\n\n因为在上文中已经说到，Git保存文件的最基本的对象是blob对象，Git本质上只是一棵巨大的文件树，树的每一个节点就是blob对象，而分支只是树的一个分叉。说白了，分支就是一个有名字的引用，它包含一个提交对象的的40位校验和，所以创建分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以自然就快了，而且与项目的复杂程度无关。\n\nGit的默认分支是master，存储在.git\\refs\\heads\\master文件中，假设你在master分支运行git branch dev创建了一个名字为dev的分支，那么git所做的实际操作是：\n\n1. 在.git\\refs\\heads文件夹下新建一个文件名为dev（没有扩展名）的文本文件。\n2. 将HEAD指向的当前分支（当前为master）的40位SHA-1 校验和外加一个换行符写入dev文件。\n3. 结束。\n\n创建分支就是这么简单，那么切换分支呢？更简单：\n\n1. 修改.git文件下的HEAD文件为ref: refs/heads/<分支名称>。\n2. 按照分支指向的提交记录将工作区的文件恢复至一模一样。\n3. 结束。\n\n>记住，HEAD文件指向当前分支的最后一次提交，同时，它也是以当前分支再次创建一个分支时，将要写入的内容。\n\n### 分支合并\n再来说一说合并，首先是Fast-forward，换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。比如：\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-9.png)\n\n注意箭头方向，因为每一次提交都有一个指向上一次提交的指针，所以箭头方向向左，更为合理\n\n当在master分支合并dev分支时，因为他们在一条线上，这种单线的历史分支不存在任何需要解决的分歧，所以只需要master分支指向dev分支即可，所以非常快。\n\n当分支出现分叉时，就有可能出现冲突，而这时Git就会要求你去解决冲突，比如像下面的历史：\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-10.png)\n\n因为master分支和dev分支不在一条线上，即v7不是v5的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（v7 和 v5）以及它们的共同祖先（v3）进行一次简单的三方合并计算。合并之后会生成一个和并提交v8：\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-11.png)\n\n>注意：合并提交有两个祖先（v7和v5）。\n\n分支的变基rebase\n把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase。首先merge 和 rebase最终的结果是一样的，但 rebase能产生一个更为整洁的提交历史。仍然以上图为例，如果简单的merge，会生成一个提交对象v8，现在我们尝试使用变基合并分支，切换到dev：\n\n```shell\n$ git checkout dev\n$ git rebase master\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n```\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-12.png)\n\n这段代码的意思是：回到两个分支最近的共同祖先v3，根据当前分支（也就是要进行变基的分支 dev）后续的历次提交对象（包括v4，v5），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（v7）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成两个新的合并提交对象（v4'，v5'）,从而改写 dev 的提交历史，使它成为 master 分支的直接下游，如下图：\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-13.png)\n\n现在，就可以回到master分支进行快速合并Fast-forward了，因为master分支和dev分支在一条线上：\n\n```shell\n$ git checkout master\n$ git merge dev\n```\n\n![](http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-14.png)\n\n现在的v5'对应的快照，其实和普通的三方合并，即上个例子中的 v8 对应的快照内容一模一样。虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。\n\n## 总结\n1. Git保存文件的完整内容，不保存差量变化。\n2. Git以储键值对（key-value）的方式保存文件。\n3. 每一个文件，相同文件的不同版本，都有一个唯一的40位的 SHA-1 校验和与之对应。\n4. SHA-1 校验和是文件的指针，Git依靠它来区分文件。\n5. 每一个文件都会在Git的版本库里生成blob对象来保存。\n6. 对于没有变化的文件，Git只会保留上一个版本的指针。\n7. Git实际上是通过维持复杂的文件树来实现版本控制的。\n8. 使用Git的工作流程基本就是就是文件在三个工作区域之间的流动。\n9. 应该大量使用分支进行团队协作。\n10. 分支只是对提交对象的一个引用。","content":"<p>原文地址：<a href=\"https://lufficc.com/blog/the-core-conception-of-git\">https://lufficc.com/blog/the-core-conception-of-git</a> </p>\n<p>Git的核心概念，原理理解</p>\n<span id=\"more\"></span>\n<p>本文不是Git使用教学篇，而是偏向理论方面，旨在更加深刻的理解Git，这样才能更好的使用它，让工具成为我们得力的助手。</p>\n<h2 id=\"版本控制系统\"><a href=\"#版本控制系统\" class=\"headerlink\" title=\"版本控制系统\"></a>版本控制系统</h2><p>Git 是目前世界上最优秀的分布式版本控制系统。版本控制系统是能够随着时间的推进记录一系列文件的变化以便于你以后想要的退回到某个版本的系统。版本控制系统分为三大类：本地版本控制系统，集中式版本控制系统和分布式版本控制系统</p>\n<h3 id=\"本地版本控制（Local-Version-Control-Systems）\"><a href=\"#本地版本控制（Local-Version-Control-Systems）\" class=\"headerlink\" title=\"本地版本控制（Local Version Control Systems）\"></a>本地版本控制（Local Version Control Systems）</h3><p>是将文件的各个版本以一定的数据格式存储在本地的磁盘（有的VCS 是保存文件的变化补丁，即在文件内容变化时计算出差量保存起来），这种方式在一定程度上解决了手动复制粘贴的问题，但无法解决多人协作的问题。<br><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img.png\" alt=\"本地版本控制\"></p>\n<h3 id=\"集中式版本控制（Centralized-Version-Control-Systems）\"><a href=\"#集中式版本控制（Centralized-Version-Control-Systems）\" class=\"headerlink\" title=\"集中式版本控制（Centralized Version Control Systems）\"></a>集中式版本控制（Centralized Version Control Systems）</h3><p>相比本地版本控制没有什么本质的变化，只是多了个一个中央服务器，各个版本的数据库存储在中央服务器，管理员可以控制开发人员的权限，而开发人员也可以从中央服务器拉取数据。集中式版本控制虽然解决了团队协作问题，但缺点也很明显：所有数据存储在中央服务器，服务器一旦宕机或者磁盘损坏，会造成不可估量的损失。<br><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-1.png\" alt=\"集中式版本控制\"></p>\n<h3 id=\"分布式版本控制（-Distributed-Version-Control-System）\"><a href=\"#分布式版本控制（-Distributed-Version-Control-System）\" class=\"headerlink\" title=\"分布式版本控制（ Distributed Version Control System）\"></a>分布式版本控制（ Distributed Version Control System）</h3><p>与前两者均不同。首先，在分布式版本控制系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，系统保存的的不是文件变化的差量，而是文件的快照，即把文件的整体复制下来保存，而不关心具体的变化内容。其次，最重要的是分布式版本控制系统是分布式的，当你从中央服务器拷贝下来代码时，你拷贝的是一个完整的版本库，包括历史纪录，提交记录等，这样即使某一台机器宕机也能找到文件的完整备份。<br><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-2.png\" alt=\"分布式版本控制\"></p>\n<h2 id=\"Git基础\"><a href=\"#Git基础\" class=\"headerlink\" title=\"Git基础\"></a>Git基础</h2><p>Git是一个分布式版本控制系统，保存的是文件的完整快照，而不是差异变化或者文件补丁。<br><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-3.png\" alt=\"保存每一次变化文件的完整内容\"></p>\n<p>Git每一次提交都是对项目文件的一个完整拷贝，因此你可以完全恢复到以前的任一个提交而不会发生任何区别。这里有一个问题：如果我的项目大小是10M，那Git占用的空间是不是随着提交次数的增加线性增加呢？我提交（commit）了10次，占用空间是不是100M呢？很显然不是，Git是很智能的，如果文件没有变化，它只会保存一个指向上一个版本的文件的指针，即，对于一个特定版本的文件，Git只会保存一个副本，但可以有多个指向该文件的指针。</p>\n<blockquote>\n<p>另外注意，Git最适合保存文本文件，事实上Git就是被设计出来就是为了保存文本文件的，像各种语言的源代码，因为Git可以对文本文件进行很好的压缩和差异分析（大家都见识过了，Git的差异分析可以精确到你添加或者删除了某个字母）。而二进制文件像视频，图片等，Git也能管理，但不能取得较好的效果（压缩比率低，不能差异分析）。实验证明，一个 500k 的文本文件经Git压缩后仅 50k 左右，稍微改变内容后两次提交，会有两个 50k 左右的文件，没错的，保存的是完整快照。而对于二进制文件，像视频，图片，压缩率非常小， Git 占用空间几乎随着提交次数线性增长。</p>\n</blockquote>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-4.png\" alt=\"未变化的文件只保存上一个版本的指针\"></p>\n<p>Git工程有三个工作区域：工作目录，暂存区域，以及本地仓库。工作目录是你当前进行工作的区域；暂存区域是你运行git add命令后文件保存的区域，也是下次提交将要保存的文件（注意：Git 提交实际读取的是暂存区域的内容，而与工作区域的文件无关，这也是当你修改了文件之后，如果没有添加git add到暂存区域，并不会保存到版本库的原因）；本地仓库就是版本库，记录了你工程某次提交的完整状态和内容，这意味着你的数据永远不会丢失。</p>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-5.png\"></p>\n<p>相应的，文件也有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地版本库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中，即暂存区域。所以使用Git的基本工作流程就是：</p>\n<ol>\n<li>在工作区域增加，删除或者修改文件。</li>\n<li>运行git add，将文件快照保存到暂存区域。</li>\n<li>提交更新，将文件永久版保存到版本库中。</li>\n</ol>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-6.png\"></p>\n<h2 id=\"Git对象\"><a href=\"#Git对象\" class=\"headerlink\" title=\"Git对象\"></a>Git对象</h2><p>现在已经明白Git的基本流程，但Git是怎么完成的呢？Git怎么区分文件是否发生变化？下面简单介绍一下Git的基本原理。</p>\n<h3 id=\"SHA-1-校验和\"><a href=\"#SHA-1-校验和\" class=\"headerlink\" title=\"SHA-1 校验和\"></a>SHA-1 校验和</h3><p>Git 是一套内容寻址文件系统。意思就是Git 从核心上来看不过是简单地存储键值对（key-value），value是文件的内容，而key是文件内容与文件头信息的 40个字符长度的 SHA-1 校验和，例如：5453545dccd33565a585ffe5f53fda3e067b84d8。Git使用该校验和不是为了加密，而是为了数据的完整性，它可以保证，在很多年后，你重新checkout某个commit时，一定是它多年前的当时的状态，完全一摸一样。当你对文件进行了哪怕一丁点儿的修改，也会计算出完全不同的 SHA-1 校验和，这种现象叫做“雪崩效应”（Avalanche effect）。</p>\n<p>SHA-1 校验和因此就是上文提到的文件的指针，这和C语言中的指针很有些不同：C语言将数据在内存中的地址作为指针，Git将文件的 SHA-1 校验和作为指针，目的都是为了唯一区分不同的对象。但是当C语言指针指向的内存中的内容发生变化时，指针并不发生变化，但Git指针指向的文件内容发生变化时，指针也会发生变化。所以，Git中每一个版本的文件，都有一个唯一的指针指向它。</p>\n<h3 id=\"文件-blob-对象，树-tree-对象，提交-commit-对象\"><a href=\"#文件-blob-对象，树-tree-对象，提交-commit-对象\" class=\"headerlink\" title=\"文件(blob)对象，树(tree)对象，提交(commit)对象\"></a>文件(blob)对象，树(tree)对象，提交(commit)对象</h3><p>blob 对象保存的仅仅是文件的内容，tree 对象更像是操作系统中的目录，它可以保存blob对象和tree 对象。一个单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 对象或子 tree 对象的 SHA-1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息等：</p>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-7.png\"></p>\n<p>当你对文件进行修改并提交时，变化的文件会生成一个新的blob对象，记录文件的完整内容（是全部内容，不是变化内容），然后针对该文件有一个唯一的 SHA-1 校验和，修改此次提交该文件的指针为该 SHA-1 校验和，而对于没有变化的文件，简单拷贝上一次版本的指针即 SHA-1 校验和，而不会生成一个全新的blob对象，这也解释了10M大小的项目进行10次提交总大小远远小于100M的原因。</p>\n<p>另外，每次提交可能不仅仅只有一个 tree 对象，它们指明了项目的不同快照，但你必须记住所有对象的 SHA-1 校验和才能获得完整的快照，而且没有作者，何时，为什么保存这些快照的原因。commit对象就是问了解决这些问题诞生的，commit 对象的格式很简单：指明了该时间点项目快照的顶层tree对象、作者&#x2F;提交者信息（从 Git 设置的 user.name 和 user.email中获得)以及当前时间戳、一个空行，上一次的提交对象的ID以及提交注释信息。你可以简单的运行git log来获取这新信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">log</span></span></span><br><span class=\"line\">commit 2cb0bb475c34a48957d18f67d0623e3304a26489</span><br><span class=\"line\">Author: lufficc &lt;luffy.lcc@gmail.com&gt;</span><br><span class=\"line\">Date:   Sun Oct 2 17:29:30 2016 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    fix some font size</span><br><span class=\"line\"></span><br><span class=\"line\">commit f0c8b4b31735b5e5e96e456f9b0c8d5fc7a3e68a</span><br><span class=\"line\">Author: lufficc &lt;luffy.lcc@gmail.com&gt;</span><br><span class=\"line\">Date:   Sat Oct 1 02:55:48 2016 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    fix post show css</span><br><span class=\"line\"></span><br><span class=\"line\">***********省略***********</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-8.png\"></p>\n<p>上图的Test.txt是第一次提交之前生成的，第一次它的初始 SHA-1 校验和以3c4e9c开头。随后对它进行了修改，所以第二次提交时生成了一个全新blob对象，校验和以1f7a7a开头。而第三次提交时Test.txt并没有变化，所以只是保存最近版本的 SHA-1 校验和而不生成全新的blob对象。在项目开发过程中新增加的文件在提交后都会生成一个全新的blob对象来保存它。注意除了第一次每个提交对象都有一个指向上一次提交对象的指针。</p>\n<p>因此简单来说，blob对象保存文件的内容；tree对象类似文件夹，保存blob对象和其它tree对象；commit对象保存tree对象，提交信息，作者，邮箱以及上一次的提交对象的ID（第一次提交没有）。而Git就是通过组织和管理这些对象的状态以及复杂的关系实现的版本控制以及以及其他功能如分支。</p>\n<h2 id=\"Git引用\"><a href=\"#Git引用\" class=\"headerlink\" title=\"Git引用\"></a>Git引用</h2><p>现在再来看引用，就会很简单了。如果我们想要看某个提交记录之前的完整历史，就必须记住这个提交ID，但提交ID是一个40位的 SHA-1 校验和，难记。所以引用就是SHA-1 校验和的别名，存储在.git&#x2F;refs文件夹中。</p>\n<p>最常见的引用也许就是master了，因为这是Git默认创建的（可以修改，但一般不修改），它始终指向你项目主分支的最后一次提交记录。如果在项目根目录运行cat .git&#x2F;refs&#x2F;heads，会输出一个SHA-1 校验和，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> .git/refs/heads/master</span></span><br><span class=\"line\">4f3e6a6f8c62bde818b4b3d12c8cf3af45d6dc00</span><br></pre></td></tr></table></figure>\n\n<p>因此master只是一个40位SHA-1 校验和的别名罢了。</p>\n<p>还有一个问题，Git如何知道你当前分支的最后一次的提交ID?在.git文件夹下有一个HEAD文件，像这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> .git/HEAD</span></span><br><span class=\"line\">ref: refs/heads/master</span><br></pre></td></tr></table></figure>\n\n<p>HEAD文件其实并不包含 SHA-1 值，而是一个指向当前分支的引用，内容会随着切换分支而变化，内容格式像这样：ref: refs&#x2F;heads&#x2F;<branch-name>。当你执行git commit命令时，它就创建了一个commit对象，把这个commit对象的父级设置为 HEAD 指向的引用的 SHA-1 值。</branch-name></p>\n<p>再来说说 Git 的 tag，标签。标签从某种意义上像是一个引用， 它指向一个 commit 对象而不是一个 tree，包含一个标签，一组数据，一个消息和一个commit 对象的指针。但是区别就是引用随着项目进行它的值在不断向前推进变化，但是标签不会变化——永远指向同一个 commit，仅仅是提供一个更加友好的名字。</p>\n<h2 id=\"Git分支\"><a href=\"#Git分支\" class=\"headerlink\" title=\"Git分支\"></a>Git分支</h2><h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>分支是Git的杀手级特征，而且Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。因为Git分支非常轻量级，不像其他的版本控制，创建分支意味着要把项目完整的拷贝一份，而Git创建分支是在瞬间完成的，而与你工程的复杂程度无关。</p>\n<p>因为在上文中已经说到，Git保存文件的最基本的对象是blob对象，Git本质上只是一棵巨大的文件树，树的每一个节点就是blob对象，而分支只是树的一个分叉。说白了，分支就是一个有名字的引用，它包含一个提交对象的的40位校验和，所以创建分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以自然就快了，而且与项目的复杂程度无关。</p>\n<p>Git的默认分支是master，存储在.git\\refs\\heads\\master文件中，假设你在master分支运行git branch dev创建了一个名字为dev的分支，那么git所做的实际操作是：</p>\n<ol>\n<li>在.git\\refs\\heads文件夹下新建一个文件名为dev（没有扩展名）的文本文件。</li>\n<li>将HEAD指向的当前分支（当前为master）的40位SHA-1 校验和外加一个换行符写入dev文件。</li>\n<li>结束。</li>\n</ol>\n<p>创建分支就是这么简单，那么切换分支呢？更简单：</p>\n<ol>\n<li>修改.git文件下的HEAD文件为ref: refs&#x2F;heads&#x2F;&lt;分支名称&gt;。</li>\n<li>按照分支指向的提交记录将工作区的文件恢复至一模一样。</li>\n<li>结束。</li>\n</ol>\n<blockquote>\n<p>记住，HEAD文件指向当前分支的最后一次提交，同时，它也是以当前分支再次创建一个分支时，将要写入的内容。</p>\n</blockquote>\n<h3 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h3><p>再来说一说合并，首先是Fast-forward，换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。比如：</p>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-9.png\"></p>\n<p>注意箭头方向，因为每一次提交都有一个指向上一次提交的指针，所以箭头方向向左，更为合理</p>\n<p>当在master分支合并dev分支时，因为他们在一条线上，这种单线的历史分支不存在任何需要解决的分歧，所以只需要master分支指向dev分支即可，所以非常快。</p>\n<p>当分支出现分叉时，就有可能出现冲突，而这时Git就会要求你去解决冲突，比如像下面的历史：</p>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-10.png\"></p>\n<p>因为master分支和dev分支不在一条线上，即v7不是v5的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（v7 和 v5）以及它们的共同祖先（v3）进行一次简单的三方合并计算。合并之后会生成一个和并提交v8：</p>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-11.png\"></p>\n<blockquote>\n<p>注意：合并提交有两个祖先（v7和v5）。</p>\n</blockquote>\n<p>分支的变基rebase<br>把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase。首先merge 和 rebase最终的结果是一样的，但 rebase能产生一个更为整洁的提交历史。仍然以上图为例，如果简单的merge，会生成一个提交对象v8，现在我们尝试使用变基合并分支，切换到dev：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git checkout dev</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git rebase master</span></span><br><span class=\"line\">First, rewinding head to replay your work on top of it...</span><br><span class=\"line\">Applying: added staged command</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-12.png\"></p>\n<p>这段代码的意思是：回到两个分支最近的共同祖先v3，根据当前分支（也就是要进行变基的分支 dev）后续的历次提交对象（包括v4，v5），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（v7）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成两个新的合并提交对象（v4’，v5’）,从而改写 dev 的提交历史，使它成为 master 分支的直接下游，如下图：</p>\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-13.png\"></p>\n<p>现在，就可以回到master分支进行快速合并Fast-forward了，因为master分支和dev分支在一条线上：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git checkout master</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git merge dev</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.yuleweici.com/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/img-14.png\"></p>\n<p>现在的v5’对应的快照，其实和普通的三方合并，即上个例子中的 v8 对应的快照内容一模一样。虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>Git保存文件的完整内容，不保存差量变化。</li>\n<li>Git以储键值对（key-value）的方式保存文件。</li>\n<li>每一个文件，相同文件的不同版本，都有一个唯一的40位的 SHA-1 校验和与之对应。</li>\n<li>SHA-1 校验和是文件的指针，Git依靠它来区分文件。</li>\n<li>每一个文件都会在Git的版本库里生成blob对象来保存。</li>\n<li>对于没有变化的文件，Git只会保留上一个版本的指针。</li>\n<li>Git实际上是通过维持复杂的文件树来实现版本控制的。</li>\n<li>使用Git的工作流程基本就是就是文件在三个工作区域之间的流动。</li>\n<li>应该大量使用分支进行团队协作。</li>\n<li>分支只是对提交对象的一个引用。</li>\n</ol>\n","slug":"Git-核心概念","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/20/Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"原文地址：https://lufficc.com/blog/the-core-conception-of-git Git的核心概念，原理理解","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://vwin.github.io/tags/git/"}]},{"title":"Linux安装Samba","date":"2018-08-09T06:19:56.000Z","path":"2018/08/09/Linux安装Samba/","text":"linux 安装Samba，Mac远程连接Linux 问题需要在Mac上远程连接一台Linux服务器，管理一些文件。不仅需要进行常规的本地文件操作，还需要上传、下载、编辑。 Samba简介samba，是一个基于GPL协议的自由软件。它重新实现了SMB&#x2F;CIFS协议，可以在各个平台共享文件和打印机。 1991年，还是大学生的Andrew Tridgwell，有三台机器，分别是Microsoft的DOS系统、DEC的Digital Unix系统、以及Sun的Unix系统。当时的技术无法让三者共享文件。为此，他开发了samba并将其开源。 本来改名为smbserver，但是一家商业公司注册了SMBServer商标。他被告知不能使用。于是执行了grep -i ‘^s.*m.*b’ &#x2F;usr&#x2F;share&#x2F;dict&#x2F;words，从中选择了samba这个词。 Samba安装安装以Ubuntu为例 1sudo apt-get install samba 创建共享文件夹也可以用现有的文件夹，chmod改变一下权限即可 12mkdir /home/USER_NAME/shared_directorysudo chmod 777 /home/USER_NAME/shared_directory 配置smb.conf直接修改&#x2F;etc&#x2F;samba&#x2F;smb.conf，在文件末尾添加： 123456[share] path = /home/USER_NAME/shared_directory available = yes browseable = yes public = yes writable = yes 添加samba账户12sudo touch /etc/samba/smbpasswdsudo smbpasswd -a USER_NAME USER_NAME就是你需要添加的用户名。然后会提示输入两次密码。 Mac连接 打开Finder（或在桌面），CMD + k，可以得到以下页面：在smb://后面，输入你的服务器地址或域名 输入前面设置的username 和 密码 .DS_Store安全隐患由于Finder自带的.DS_Store包含了太多信息，如果在服务器产生.DS_Store会造成安全隐患。如果没有特殊配置，你用Finder管理远程的文件夹会自动产生.DS_Store。 在云端检查你的共享文件夹，如果发现.DS_Store，立即删除！ 1ls -a /home/USER_NAME/shared_directory 如何让Finder不在远程连接时产生.DS_Store？打开Mac的Terminal，输入: 1defaults write com.apple.desktopservices DSDontWriteNetworkStores true 然后重启Mac，再试试远程连接。","raw":"---\ntitle: Linux安装Samba\ntoc: true\ndate: 2018-08-09 14:19:56\ntags: [linux,samba]\ncategories: [技术]\ndescription: Linux安装samba\n---\nlinux 安装Samba，Mac远程连接Linux\n<!--more-->\n## 问题\n需要在Mac上远程连接一台Linux服务器，管理一些文件。不仅需要进行常规的本地文件操作，还需要上传、下载、编辑。\n\n## Samba简介\nsamba，是一个基于GPL协议的自由软件。它重新实现了SMB/CIFS协议，可以在各个平台共享文件和打印机。\n\n1991年，还是大学生的Andrew Tridgwell，有三台机器，分别是Microsoft的DOS系统、DEC的Digital Unix系统、以及Sun的Unix系统。当时的技术无法让三者共享文件。为此，他开发了samba并将其开源。\n\n本来改名为smbserver，但是一家商业公司注册了SMBServer商标。他被告知不能使用。于是执行了grep -i '^s.*m.*b' /usr/share/dict/words，从中选择了samba这个词。\n\n## Samba安装\n\n### 安装\n以Ubuntu为例\n```shell\nsudo apt-get install samba\n```\n\n### 创建共享文件夹\n也可以用现有的文件夹，chmod改变一下权限即可\n```shell\nmkdir /home/USER_NAME/shared_directory\nsudo chmod 777 /home/USER_NAME/shared_directory\n```\n\n### 配置smb.conf\n直接修改/etc/samba/smb.conf，在文件末尾添加：\n```shell\n[share]\n      path = /home/USER_NAME/shared_directory\n      available = yes\n      browseable = yes\n      public = yes\n      writable = yes\n```\n\n### 添加samba账户\n```shell\nsudo touch /etc/samba/smbpasswd\nsudo smbpasswd -a USER_NAME\n```\nUSER_NAME就是你需要添加的用户名。然后会提示输入两次密码。\n\n## Mac连接\n\n1. 打开Finder（或在桌面），CMD + k，可以得到以下页面：\n在`smb://`后面，输入你的服务器地址或域名\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fu3fjrdat5j30dg06daaj.jpg)\n2. 输入前面设置的username 和 密码\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu3fkaxk02j30bq05m0t1.jpg)\n\n## .DS_Store安全隐患\n由于Finder自带的.DS_Store包含了太多信息，如果在服务器产生.DS_Store会造成安全隐患。如果没有特殊配置，你用Finder管理远程的文件夹会自动产生.DS_Store。\n\n在云端检查你的共享文件夹，如果发现.DS_Store，立即删除！\n\n```shell\nls -a /home/USER_NAME/shared_directory\n```\n如何让Finder不在远程连接时产生.DS_Store？\n打开Mac的Terminal，输入:\n```shell\ndefaults write com.apple.desktopservices DSDontWriteNetworkStores true\n```\n然后重启Mac，再试试远程连接。\n","content":"<p>linux 安装Samba，Mac远程连接Linux</p>\n<span id=\"more\"></span>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>需要在Mac上远程连接一台Linux服务器，管理一些文件。不仅需要进行常规的本地文件操作，还需要上传、下载、编辑。</p>\n<h2 id=\"Samba简介\"><a href=\"#Samba简介\" class=\"headerlink\" title=\"Samba简介\"></a>Samba简介</h2><p>samba，是一个基于GPL协议的自由软件。它重新实现了SMB&#x2F;CIFS协议，可以在各个平台共享文件和打印机。</p>\n<p>1991年，还是大学生的Andrew Tridgwell，有三台机器，分别是Microsoft的DOS系统、DEC的Digital Unix系统、以及Sun的Unix系统。当时的技术无法让三者共享文件。为此，他开发了samba并将其开源。</p>\n<p>本来改名为smbserver，但是一家商业公司注册了SMBServer商标。他被告知不能使用。于是执行了grep -i ‘^s.*m.*b’ &#x2F;usr&#x2F;share&#x2F;dict&#x2F;words，从中选择了samba这个词。</p>\n<h2 id=\"Samba安装\"><a href=\"#Samba安装\" class=\"headerlink\" title=\"Samba安装\"></a>Samba安装</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>以Ubuntu为例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install samba</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建共享文件夹\"><a href=\"#创建共享文件夹\" class=\"headerlink\" title=\"创建共享文件夹\"></a>创建共享文件夹</h3><p>也可以用现有的文件夹，chmod改变一下权限即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /home/USER_NAME/shared_directory</span><br><span class=\"line\">sudo chmod 777 /home/USER_NAME/shared_directory</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置smb-conf\"><a href=\"#配置smb-conf\" class=\"headerlink\" title=\"配置smb.conf\"></a>配置smb.conf</h3><p>直接修改&#x2F;etc&#x2F;samba&#x2F;smb.conf，在文件末尾添加：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[share]</span><br><span class=\"line\">      path = /home/USER_NAME/shared_directory</span><br><span class=\"line\">      available = yes</span><br><span class=\"line\">      browseable = yes</span><br><span class=\"line\">      public = yes</span><br><span class=\"line\">      writable = yes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加samba账户\"><a href=\"#添加samba账户\" class=\"headerlink\" title=\"添加samba账户\"></a>添加samba账户</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch /etc/samba/smbpasswd</span><br><span class=\"line\">sudo smbpasswd -a USER_NAME</span><br></pre></td></tr></table></figure>\n<p>USER_NAME就是你需要添加的用户名。然后会提示输入两次密码。</p>\n<h2 id=\"Mac连接\"><a href=\"#Mac连接\" class=\"headerlink\" title=\"Mac连接\"></a>Mac连接</h2><ol>\n<li>打开Finder（或在桌面），CMD + k，可以得到以下页面：<br>在<code>smb://</code>后面，输入你的服务器地址或域名<br><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fu3fjrdat5j30dg06daaj.jpg\"></li>\n<li>输入前面设置的username 和 密码<br><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu3fkaxk02j30bq05m0t1.jpg\"></li>\n</ol>\n<h2 id=\"DS-Store安全隐患\"><a href=\"#DS-Store安全隐患\" class=\"headerlink\" title=\".DS_Store安全隐患\"></a>.DS_Store安全隐患</h2><p>由于Finder自带的.DS_Store包含了太多信息，如果在服务器产生.DS_Store会造成安全隐患。如果没有特殊配置，你用Finder管理远程的文件夹会自动产生.DS_Store。</p>\n<p>在云端检查你的共享文件夹，如果发现.DS_Store，立即删除！</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a /home/USER_NAME/shared_directory</span><br></pre></td></tr></table></figure>\n<p>如何让Finder不在远程连接时产生.DS_Store？<br>打开Mac的Terminal，输入:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaults write com.apple.desktopservices DSDontWriteNetworkStores true</span><br></pre></td></tr></table></figure>\n<p>然后重启Mac，再试试远程连接。</p>\n","slug":"Linux安装Samba","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/09/Linux%E5%AE%89%E8%A3%85Samba/","excerpt":"linux 安装Samba，Mac远程连接Linux","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"samba","slug":"samba","permalink":"http://vwin.github.io/tags/samba/"}]},{"title":"Locust基础-2","date":"2018-08-08T10:39:50.000Z","path":"2018/08/08/Locust基础-2/","text":"分布式执行一旦单台机器不够模拟足够多的用户时，Locust支持运行在多台机器中进行压力测试。 为了实现这个，你应该在 master 模式中使用–master标记来启用一个 Locust 实例。这个实例将会运行你启动测试的 Locust 交互网站并查看实时统计数据。master 节点的机器自身不会模拟任何用户。相反，你必须使用 –slave 标记启动一台到多台 Locustslave 机器节点，与标记 –master-host 一起使用(指出master机器的IP&#x2F;hostname)。 常用的做法是在一台独立的机器中运行master，在slave机器中每个处理器内核运行一个slave实例。 注意：master 和每一台 slave 机器，在运行分布式测试时都必须要有 locust 的测试文件。 示例在 master 模式下启动 Locust: 1locust -f my_loucstfile.py --master 在每个 slave 中执行(192.168.0.14 替换为你 msater 的IP): 1locust -f my_locustfile.py --slave --master-host=192.168.0.14 参数说明 –master：设置 Locust 为 master 模式。网页交互会在这台节点机器中运行。 –slave：设置 Locust 为 slave 模式。 –master-host&#x3D;X.X.X.X：可选项，与 –slave 一起结合使用，用于设置 master 模式下的 master 机器的IP&#x2F;hostname(默认设置为127.0.0.1) –master-port&#x3D;5557：可选项，与 –slave 一起结合使用，用于设置 master 模式下的 master 机器中 Locust 的端口(默认为5557)。注意，locust 将会使用这个指定的端口号，同时指定端口+1的号也会被占用。因此，5557 会被使用，Locust将会使用 5557 和 5558。 –master-bind-host&#x3D;X.X.X.X：可选项，与 –master 一起结合使用。决定在 master 模式下将会绑定什么网络接口。默认设置为*(所有可用的接口)。 –master-bind-port&#x3D;5557：可选项，与 –master 一起结合使用。决定哪个网络端口 master 模式将会监听。默认设置为 5557。注意 Locust 会使用指定的端口号，同时指定端口+1的号也会被占用。因此，5557 会被使用，Locust 将会使用 5557 和 5558。 –expect-slaves&#x3D;X：在 no-web 模式下启动 master 时使用。master 将等待X连接节点在测试开始之前连接。 效果如下图，我启动了一个 master 和两个 slave，由两个 slave 来向被测试系统发送请求。","raw":"---\ntitle: Locust基础-2\ntoc: true\ndate: 2018-08-08 18:39:50\ntags: [locust,性能测试]\ncategories: [测试]\ndescription:\n---\n# 分布式执行\n一旦单台机器不够模拟足够多的用户时，Locust支持运行在多台机器中进行压力测试。\n\n为了实现这个，你应该在 master 模式中使用--master标记来启用一个 Locust 实例。这个实例将会运行你启动测试的 Locust 交互网站并查看实时统计数据。master 节点的机器自身不会模拟任何用户。相反，你必须使用 --slave 标记启动一台到多台 Locustslave 机器节点，与标记 --master-host 一起使用(指出master机器的IP/hostname)。\n\n常用的做法是在一台独立的机器中运行master，在slave机器中每个处理器内核运行一个slave实例。\n<!--more-->\n注意：master 和每一台 slave 机器，在运行分布式测试时都必须要有 locust 的测试文件。\n\n## 示例\n在 master 模式下启动 Locust:\n```shell\nlocust -f my_loucstfile.py --master\n```\n在每个 slave 中执行(192.168.0.14 替换为你 msater 的IP):\n```shell\nlocust -f my_locustfile.py --slave --master-host=192.168.0.14\n```\n## 参数说明\n\n- --master：设置 Locust 为 master 模式。网页交互会在这台节点机器中运行。\n- --slave：设置 Locust 为 slave 模式。\n- --master-host=X.X.X.X：可选项，与 --slave 一起结合使用，用于设置 master 模式下的 master 机器的IP/hostname(默认设置为127.0.0.1)\n- --master-port=5557：可选项，与 --slave 一起结合使用，用于设置 master 模式下的 master 机器中 Locust 的端口(默认为5557)。注意，locust 将会使用这个指定的端口号，同时指定端口+1的号也会被占用。因此，5557 会被使用，Locust将会使用 5557 和 5558。\n- --master-bind-host=X.X.X.X：可选项，与 --master 一起结合使用。决定在 master 模式下将会绑定什么网络接口。默认设置为*(所有可用的接口)。\n- --master-bind-port=5557：可选项，与 --master 一起结合使用。决定哪个网络端口 master 模式将会监听。默认设置为 5557。注意 Locust 会使用指定的端口号，同时指定端口+1的号也会被占用。因此，5557 会被使用，Locust 将会使用 5557 和 5558。\n- --expect-slaves=X：在 no-web 模式下启动 master 时使用。master 将等待X连接节点在测试开始之前连接。\n\n## 效果\n如下图，我启动了一个 master 和两个 slave，由两个 slave 来向被测试系统发送请求。\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fytcwca2gpj30yo0b276c.jpg)\n","content":"<h1 id=\"分布式执行\"><a href=\"#分布式执行\" class=\"headerlink\" title=\"分布式执行\"></a>分布式执行</h1><p>一旦单台机器不够模拟足够多的用户时，Locust支持运行在多台机器中进行压力测试。</p>\n<p>为了实现这个，你应该在 master 模式中使用–master标记来启用一个 Locust 实例。这个实例将会运行你启动测试的 Locust 交互网站并查看实时统计数据。master 节点的机器自身不会模拟任何用户。相反，你必须使用 –slave 标记启动一台到多台 Locustslave 机器节点，与标记 –master-host 一起使用(指出master机器的IP&#x2F;hostname)。</p>\n<p>常用的做法是在一台独立的机器中运行master，在slave机器中每个处理器内核运行一个slave实例。</p>\n<span id=\"more\"></span>\n<p>注意：master 和每一台 slave 机器，在运行分布式测试时都必须要有 locust 的测试文件。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>在 master 模式下启动 Locust:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locust -f my_loucstfile.py --master</span><br></pre></td></tr></table></figure>\n<p>在每个 slave 中执行(192.168.0.14 替换为你 msater 的IP):</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locust -f my_locustfile.py --slave --master-host=192.168.0.14</span><br></pre></td></tr></table></figure>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li>–master：设置 Locust 为 master 模式。网页交互会在这台节点机器中运行。</li>\n<li>–slave：设置 Locust 为 slave 模式。</li>\n<li>–master-host&#x3D;X.X.X.X：可选项，与 –slave 一起结合使用，用于设置 master 模式下的 master 机器的IP&#x2F;hostname(默认设置为127.0.0.1)</li>\n<li>–master-port&#x3D;5557：可选项，与 –slave 一起结合使用，用于设置 master 模式下的 master 机器中 Locust 的端口(默认为5557)。注意，locust 将会使用这个指定的端口号，同时指定端口+1的号也会被占用。因此，5557 会被使用，Locust将会使用 5557 和 5558。</li>\n<li>–master-bind-host&#x3D;X.X.X.X：可选项，与 –master 一起结合使用。决定在 master 模式下将会绑定什么网络接口。默认设置为*(所有可用的接口)。</li>\n<li>–master-bind-port&#x3D;5557：可选项，与 –master 一起结合使用。决定哪个网络端口 master 模式将会监听。默认设置为 5557。注意 Locust 会使用指定的端口号，同时指定端口+1的号也会被占用。因此，5557 会被使用，Locust 将会使用 5557 和 5558。</li>\n<li>–expect-slaves&#x3D;X：在 no-web 模式下启动 master 时使用。master 将等待X连接节点在测试开始之前连接。</li>\n</ul>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>如下图，我启动了一个 master 和两个 slave，由两个 slave 来向被测试系统发送请求。<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fytcwca2gpj30yo0b276c.jpg\"></p>\n","slug":"Locust基础-2","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/08/Locust%E5%9F%BA%E7%A1%80-2/","excerpt":"分布式执行一旦单台机器不够模拟足够多的用户时，Locust支持运行在多台机器中进行压力测试。 为了实现这个，你应该在 master 模式中使用–master标记来启用一个 Locust 实例。这个实例将会运行你启动测试的 Locust 交互网站并查看实时统计数据。master 节点的机器自身不会模拟任何用户。相反，你必须使用 –slave 标记启动一台到多台 Locustslave 机器节点，与标记 –master-host 一起使用(指出master机器的IP&#x2F;hostname)。 常用的做法是在一台独立的机器中运行master，在slave机器中每个处理器内核运行一个slave实例。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"locust","slug":"locust","permalink":"http://vwin.github.io/tags/locust/"},{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Locust基础-1","date":"2018-08-08T10:39:30.000Z","path":"2018/08/08/Locust基础-1/","text":"介绍Locust 官方网站：https://www.locust.io/An open source load testing tool.一个开源性能测试工具。define user behaviour with python code, and swarm your system with millions of simultaneous users.使用 Python 代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。 LoadRunner 是非常有名的商业性能测试工具，功能非常强大。使用也比较复杂，目前大多介绍性能测试的书籍都以该工具为基础，甚至有些书整本都在介绍 LoadRunner 的使用。 Jmeter 同样是非常有名的开源性能测试工具，功能也很完善，在本书中介绍了它作为接口测试工具的使用。但实际上，它是一个标准的性能测试工具。关于Jmeter相关的资料也非常丰富，它的官方文档也很完善。 Locust 同样是性能测试工具，虽然官方这样来描述它 “An open source load testing tool.” 。但其它和前面两个工具有着较大的不同。相比前面两个工具，功能上要差上不少，但它也并非优点全无。 Locust 完全基本 Python 编程语言，采用 Pure Python 描述测试脚本，并且 HTTP 请求完全基于 Requests 库。除了 HTTP&#x2F;HTTPS 协议，Locust 也可以测试其它协议的系统，只需要采用Python调用对应的库进行请求描述即可。 LoadRunner 和 Jmeter 这类采用进程和线程的测试工具，都很难在单机上模拟出较高的并发压力。Locust 的并发机制摒弃了进程和线程，采用协程（gevent）的机制。协程避免了系统级资源调度，由此可以大幅提高单机的并发能力。 正是基于这样的特点，使我选择使用Locust工具来做性能测试，另外一个原因是它可以让我们换一种方式认识性能测试，可能更容易看清性能测试的本质。 安装pip安装1pip install locust Git安装GitHub项目地址：https://github.com/locustio/locust/ 将项目克隆下来，通过Python 执行 setup.py 文件 1python setup.py install 最后，检查是否安装成功: 1locust --help 依赖分析 gevent 是在 Python 中实现协程的一个第三方库。协程，又称微线程（Coroutine）。使用gevent可以获得极高的并发性能。 flask 是 Python 的一个 Web 开发框架。 Requests 用来做 HTTP 接口测试。 msgpack-python 是一种快速、紧凑的二进制序列化格式，适用于类似JSON的数据。 six 提供了一些简单的工具用来封装 Python2 和 Python3 之间的差异性。 pyzmq 如果你打算运行 Locust 分布在多个进程&#x2F;机器，建议你安装pyzmq。 当我们在安装 Locust 时，它会检测我们当前的 Python 环境是否已经安装了这些库，如果没有安装，它会先把这些库一一装上。并且对这些库版本有要求，有些是必须等于某版本，有些是大于某版本。我们也可以事先把这些库全部按要求装好，再安装Locust时就会快上许多。 创建性能测试写脚本创建 load_test.py 文件，通过 Python 编写性能测试脚本。 1234567891011121314from locust import HttpLocust, TaskSet, task# 定义用户行为class UserBehavior(TaskSet): @task def baidu_index(self): self.client.get(&quot;/&quot;)class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 3000 max_wait = 6000 UserBehavior类继承TaskSet类，用于描述用户行为。 baidu_index() 方法表示一个用户为行，访问百度首页。使用@task装饰该方法为一个事务。client.get()用于指请求的路径“&#x2F;”，因为是百度首页，所以指定为根路径。 WebsiteUser类用于设置性能测试。 task_set ：指向一个定义的用户行为类。 min_wait ：执行事务之间用户等待时间的下界（单位：毫秒）。 max_wait ：执行事务之间用户等待时间的上界（单位：毫秒）。 启动性能测试1234&gt; locust -f .\\load_test.py --host=https://www.baidu.com[2017-10-16 16:44:40,839] DESKTOP-SMGQBBM/INFO/locust.main: Starting web monitor at *:8089[2017-10-16 16:44:40,842] DESKTOP-SMGQBBM/INFO/locust.main: Starting Locust 0.8 -f 指定性能测试脚本文件。 –host 指定被测试应用的URL的地址，注意访问百度使用的HTTPS协议。 通过浏览器访问：http://localhost:8089（Locust启动网络监控器，默认为端口号为: 8089） Number of users to simulate 设置模拟用户数。 Hatch rate（users spawned&#x2F;second） 每秒产生（启动）的虚拟用户数。 点击 “Start swarming” 按钮，开始运行性能测试。性能测试参数 Type： 请求的类型，例如GET&#x2F;POST。 Name：请求的路径。这里为百度首页，即：https://www.baidu.com/ request：当前请求的数量。 fails：当前请求失败的数量。 Median：中间值，单位毫秒，一半的服务器响应时间低于该值，而另一半高于该值。 Average：平均值，单位毫秒，所有请求的平均响应时间。 Min：请求的最小服务器响应时间，单位毫秒。 Max：请求的最大服务器响应时间，单位毫秒。 Content Size：单个请求的大小，单位字节。 reqs&#x2F;sec：是每秒钟请求的个数。 no-web模式以上一节的 baidu 首页测试（load_test.py）为例 通过 no-web 模式运行测试。 123456789101112131415161718192021222324&gt; locust -f load_test.py --host=https://www.baidu.com --no-web -c 10 -r 2 -t 1m[2017-10-30 22:17:30,292] DESKTOP-SMGQBBM/INFO/locust.main: Run time limit set to 60 seconds[2017-10-30 22:17:30,302] DESKTOP-SMGQBBM/INFO/locust.main: Starting Locust 0.8[2017-10-30 22:17:30,302] DESKTOP-SMGQBBM/INFO/locust.runners: Hatching and swarming 10 clients at the rate 2 clients/s... Name # reqs # fails Avg Min Max | Median req/s.... [2017-10-30 22:18:30,301] DESKTOP-SMGQBBM/INFO/locust.main: Time limit reached. Stopping Locust. [2017-10-30 22:18:30,302] DESKTOP-SMGQBBM/INFO/locust.main: Shutting down (exit code 0), bye. Name # reqs # fails Avg Min Max | Median req/s -------------------------------------------------------------------------------------------------------------------------------------------- GET / 117 0(0.00%) 31 17 96 | 28 2.10 -------------------------------------------------------------------------------------------------------------------------------------------- Total 117 0(0.00%) 2.10 Percentage of the requests completed within given times Name # reqs 50% 66% 75% 80% 90% 95% 98% 99% 100% -------------------------------------------------------------------------------------------------------------------------------------------- GET / 117 28 30 36 37 49 62 69 72 96 -------------------------------------------------------------------------------------------------------------------------------------------- Total 117 28 30 36 37 49 62 69 72 96 启动参数： –no-web 表示不使用Web界面运行测试。 -c 设置虚拟用户数。 -r 设置每秒启动虚拟用户数。 -t 设置设置运行时间。(在有些locust版本中可能不支持该参数，改用-n参数可以指定发送请求数量，具体的可以通过locust –help查看) Locust参数查看打开命令提示符（或Linux终端），输入 locust –help 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&gt; locust --helpUsage: locust [options] [LocustClass [LocustClass2 ... ]]Options: -h, --help show this help message and exit -H HOST, --host=HOST Host to load test in the following format: http://10.21.32.33 --web-host=WEB_HOST Host to bind the web interface to. Defaults to &#x27;&#x27; (all interfaces) -P PORT, --port=PORT, --web-port=PORT Port on which to run web host -f LOCUSTFILE, --locustfile=LOCUSTFILE Python module file to import, e.g. &#x27;../other.py&#x27;. Default: locustfile --csv=CSVFILEBASE, --csv-base-name=CSVFILEBASE Store current request stats to files in CSV format. --master Set locust to run in distributed mode with this process as master --slave Set locust to run in distributed mode with this process as slave --master-host=MASTER_HOST Host or IP address of locust master for distributed load testing. Only used when running with --slave. Defaults to 127.0.0.1. --master-port=MASTER_PORT The port to connect to that is used by the locust master for distributed load testing. Only used when running with --slave. Defaults to 5557. Note that slaves will also connect to the master node on this port + 1. --master-bind-host=MASTER_BIND_HOST Interfaces (hostname, ip) that locust master should bind to. Only used when running with --master. Defaults to * (all available interfaces). --master-bind-port=MASTER_BIND_PORT Port that locust master should bind to. Only used when running with --master. Defaults to 5557. Note that Locust will also use this port + 1, so by default the master node will bind to 5557 and 5558. --expect-slaves=EXPECT_SLAVES How many slaves master should expect to connect before starting the test (only when --no-web used). --no-web Disable the web interface, and instead start running the test immediately. Requires -c and -r to be specified. -c NUM_CLIENTS, --clients=NUM_CLIENTS Number of concurrent Locust users. Only used together with --no-web -r HATCH_RATE, --hatch-rate=HATCH_RATE The rate per second in which clients are spawned. Only used together with --no-web -t RUN_TIME, --run-time=RUN_TIME Stop after the specified amount of time, e.g. (300s, 20m, 3h, 1h30m, etc.). Only used together with --no- web -L LOGLEVEL, --loglevel=LOGLEVEL Choose between DEBUG/INFO/WARNING/ERROR/CRITICAL. Default is INFO. --logfile=LOGFILE Path to log file. If not set, log will go to stdout/stderr --print-stats Print stats in the console --only-summary Only print the summary stats --no-reset-stats Do not reset statistics once hatching has been completed -l, --list Show list of possible locust classes and exit --show-task-ratio print table of the locust classes&#x27; task execution ratio --show-task-ratio-json print json data of the locust classes&#x27; task execution ratio -V, --version show program&#x27;s version number and exit 说明 参数 说明 -h, –help 查看帮助 -H HOST, –host&#x3D;HOST 指定被测试的主机，采用以格式：http://10.21.32.33 –web-host&#x3D;WEB_HOST 指定运行 Locust Web 页面的主机，默认为空 ‘’。 -P PORT, –port&#x3D;PORT, –web-port&#x3D;PORT 指定 –web-host 的端口，默认是8089 -f LOCUSTFILE, –locustfile&#x3D;LOCUSTFILE 指定运行 Locust 性能测试文件，默认为: locustfile.py –csv&#x3D;CSVFILEBASE, –csv-base-name&#x3D;CSVFILEBASE 以CSV格式存储当前请求测试数据。 –master Locust 分布式模式使用，当前节点为 master 节点。 –slave Locust 分布式模式使用，当前节点为 slave 节点。 –master-host&#x3D;MASTER_HOST 分布式模式运行，设置 master 节点的主机或 IP 地址，只在与 –slave 节点一起运行时使用，默认为：127.0.0.1. –master-port&#x3D;MASTER_PORT 分布式模式运行， 设置 master 节点的端口号，只在与 –slave 节点一起运行时使用，默认为：5557。注意，slave 节点也将连接到这个端口+1 上的 master 节点。 –master-bind-host&#x3D;MASTER_BIND_HOST Interfaces (hostname, ip) that locust master should bind to. Only used when running with –master. Defaults to * (all available interfaces). –master-bind-port&#x3D;MASTER_BIND_PORT Port that locust master should bind to. Only used when running with –master. Defaults to 5557. Note that Locust will also use this port + 1, so by default the master node will bind to 5557 and 5558. –expect-slaves&#x3D;EXPECT_SLAVES How many slaves master should expect to connect before starting the test (only when –no-web used). –no-web no-web 模式运行测试，需要 -c 和 -r 配合使用. -c NUM_CLIENTS, –clients&#x3D;NUM_CLIENTS 指定并发用户数，作用于 –no-web 模式。 -r HATCH_RATE, –hatch-rate&#x3D;HATCH_RATE 指定每秒启动的用户数，作用于 –no-web 模式。 -t RUN_TIME, –run-time&#x3D;RUN_TIME 设置运行时间, 例如： (300s, 20m, 3h, 1h30m). 作用于 –no-web 模式。 -L LOGLEVEL, –loglevel&#x3D;LOGLEVEL 选择 log 级别（DEBUG&#x2F;INFO&#x2F;WARNING&#x2F;ERROR&#x2F;CRITICAL）. 默认是 INFO. –logfile&#x3D;LOGFILE 日志文件路径。如果没有设置，日志将去 stdout&#x2F;stderr –print-stats 在控制台中打印数据 –only-summary 只打印摘要统计 –no-reset-stats Do not reset statistics once hatching has been completed。 -l, –list 显示测试类, 配置 -f 参数使用 –show-task-ratio 打印 locust 测试类的任务执行比例，配合 -f 参数使用. –show-task-ratio-json 以 json 格式打印 locust 测试类的任务执行比例，配合 -f 参数使用. -V, –version 查看当前 Locust 工具的版本.","raw":"---\ntitle: Locust基础-1\ntoc: true\ndate: 2018-08-08 18:39:30\ntags: [locust,性能测试]\ncategories: [测试]\ndescription:\n---\n\n# 介绍\nLocust 官方网站：https://www.locust.io/\nAn open source load testing tool.\n一个开源性能测试工具。\ndefine user behaviour with python code, and swarm your system with millions of simultaneous users.\n使用 Python 代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fyt89j9tb3j31bd0u0tf7.jpg)\n<!--more-->\n1. LoadRunner 是非常有名的商业性能测试工具，功能非常强大。使用也比较复杂，目前大多介绍性能测试的书籍都以该工具为基础，甚至有些书整本都在介绍 LoadRunner 的使用。\n\n2. Jmeter 同样是非常有名的开源性能测试工具，功能也很完善，在本书中介绍了它作为接口测试工具的使用。但实际上，它是一个标准的性能测试工具。关于Jmeter相关的资料也非常丰富，它的官方文档也很完善。\n\n3. Locust 同样是性能测试工具，虽然官方这样来描述它 “An open source load testing tool.” 。但其它和前面两个工具有着较大的不同。相比前面两个工具，功能上要差上不少，但它也并非优点全无。\n   - Locust 完全基本 Python 编程语言，采用 Pure Python 描述测试脚本，并且 HTTP 请求完全基于 Requests 库。除了 HTTP/HTTPS 协议，Locust 也可以测试其它协议的系统，只需要采用Python调用对应的库进行请求描述即可。\n   - LoadRunner 和 Jmeter 这类采用进程和线程的测试工具，都很难在单机上模拟出较高的并发压力。Locust 的并发机制摒弃了进程和线程，采用协程（gevent）的机制。协程避免了系统级资源调度，由此可以大幅提高单机的并发能力。\n\n正是基于这样的特点，使我选择使用Locust工具来做性能测试，另外一个原因是它可以让我们换一种方式认识性能测试，可能更容易看清性能测试的本质。\n\n# 安装\n\n## pip安装\n```shell\npip install locust\n```\n## Git安装\nGitHub项目地址：https://github.com/locustio/locust/\n\n将项目克隆下来，通过Python 执行 setup.py 文件\n\n```python\npython setup.py install\n```\n\n最后，检查是否安装成功:\n```shell\nlocust --help\n```\n\n## 依赖分析\n- gevent 是在 Python 中实现协程的一个第三方库。协程，又称微线程（Coroutine）。使用gevent可以获得极高的并发性能。\n- flask 是 Python 的一个 Web 开发框架。\n- Requests 用来做 HTTP 接口测试。\n- msgpack-python 是一种快速、紧凑的二进制序列化格式，适用于类似JSON的数据。\n- six 提供了一些简单的工具用来封装 Python2 和 Python3 之间的差异性。\n- pyzmq 如果你打算运行 Locust 分布在多个进程/机器，建议你安装pyzmq。\n\n当我们在安装 Locust 时，它会检测我们当前的 Python 环境是否已经安装了这些库，如果没有安装，它会先把这些库一一装上。并且对这些库版本有要求，有些是必须等于某版本，有些是大于某版本。我们也可以事先把这些库全部按要求装好，再安装Locust时就会快上许多。\n\n# 创建性能测试\n## 写脚本\n创建 load_test.py 文件，通过 Python 编写性能测试脚本。\n```python\nfrom locust import HttpLocust, TaskSet, task\n\n# 定义用户行为\nclass UserBehavior(TaskSet):\n\n    @task\n    def baidu_index(self):\n        self.client.get(\"/\")\n\n\nclass WebsiteUser(HttpLocust):\n    task_set = UserBehavior\n    min_wait = 3000\n    max_wait = 6000\n```\n- UserBehavior类继承TaskSet类，用于描述用户行为。\n- baidu_index() 方法表示一个用户为行，访问百度首页。使用@task装饰该方法为一个事务。client.get()用于指请求的路径“/”，因为是百度首页，所以指定为根路径。\n- WebsiteUser类用于设置性能测试。\n  - task_set ：指向一个定义的用户行为类。\n  - min_wait ：执行事务之间用户等待时间的下界（单位：毫秒）。\n  - max_wait ：执行事务之间用户等待时间的上界（单位：毫秒）。\n\n## 启动性能测试\n```shell\n> locust -f .\\load_test.py --host=https://www.baidu.com\n\n[2017-10-16 16:44:40,839] DESKTOP-SMGQBBM/INFO/locust.main: Starting web monitor at *:8089\n[2017-10-16 16:44:40,842] DESKTOP-SMGQBBM/INFO/locust.main: Starting Locust 0.8\n```\n- -f 指定性能测试脚本文件。\n- --host 指定被测试应用的URL的地址，注意访问百度使用的HTTPS协议。\n- 通过浏览器访问：http://localhost:8089（Locust启动网络监控器，默认为端口号为: 8089）\n![](https://ws1.sinaimg.cn/large/006tNc79ly1fyt953kd2lj30zb0mjwgt.jpg)\n- Number of users to simulate 设置模拟用户数。\n- Hatch rate（users spawned/second） 每秒产生（启动）的虚拟用户数。\n\n点击 “Start swarming” 按钮，开始运行性能测试。\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fyt95m2zbaj30z90jlmza.jpg)\n性能测试参数\n1. Type： 请求的类型，例如GET/POST。\n2. Name：请求的路径。这里为百度首页，即：https://www.baidu.com/\n3. request：当前请求的数量。\n4. fails：当前请求失败的数量。\n5. Median：中间值，单位毫秒，一半的服务器响应时间低于该值，而另一半高于该值。\n6. Average：平均值，单位毫秒，所有请求的平均响应时间。\n7. Min：请求的最小服务器响应时间，单位毫秒。\n8. Max：请求的最大服务器响应时间，单位毫秒。\n9. Content Size：单个请求的大小，单位字节。\n10. reqs/sec：是每秒钟请求的个数。\n\n# no-web模式\n以上一节的 baidu 首页测试（load_test.py）为例 通过 no-web 模式运行测试。\n\n```shell\n> locust -f load_test.py --host=https://www.baidu.com --no-web -c 10 -r 2 -t 1m\n\n[2017-10-30 22:17:30,292] DESKTOP-SMGQBBM/INFO/locust.main: Run time limit set to 60 seconds\n[2017-10-30 22:17:30,302] DESKTOP-SMGQBBM/INFO/locust.main: Starting Locust 0.8\n[2017-10-30 22:17:30,302] DESKTOP-SMGQBBM/INFO/locust.runners: Hatching and swarming 10 clients at the rate 2 clients/s...\n Name                                                          # reqs      # fails     Avg     Min     Max  |  Median   req/s\n\n....\n\n\n [2017-10-30 22:18:30,301] DESKTOP-SMGQBBM/INFO/locust.main: Time limit reached. Stopping Locust.\n [2017-10-30 22:18:30,302] DESKTOP-SMGQBBM/INFO/locust.main: Shutting down (exit code 0), bye.\n  Name                                                          # reqs      # fails     Avg     Min     Max  |  Median   req/s\n --------------------------------------------------------------------------------------------------------------------------------------------\n  GET /                                                            117     0(0.00%)      31      17      96  |      28    2.10\n --------------------------------------------------------------------------------------------------------------------------------------------\n  Total                                                            117     0(0.00%)                                       2.10\n\n Percentage of the requests completed within given times\n  Name                                                           # reqs    50%    66%    75%    80%    90%    95%    98%    99%   100%\n --------------------------------------------------------------------------------------------------------------------------------------------\n  GET /                                                             117     28     30     36     37     49     62     69     72     96\n --------------------------------------------------------------------------------------------------------------------------------------------\n  Total                                                             117     28     30     36     37     49     62     69     72     96\n```\n启动参数：\n- --no-web 表示不使用Web界面运行测试。\n- -c 设置虚拟用户数。\n- -r 设置每秒启动虚拟用户数。\n- -t 设置设置运行时间。(在有些locust版本中可能不支持该参数，改用-n参数可以指定发送请求数量，具体的可以通过locust --help查看)\n\n# Locust参数\n## 查看\n打开命令提示符（或Linux终端），输入 locust --help 。\n```shell\n> locust --help\nUsage: locust [options] [LocustClass [LocustClass2 ... ]]\n\nOptions:\n  -h, --help            show this help message and exit\n  -H HOST, --host=HOST  Host to load test in the following format:\n                        http://10.21.32.33\n  --web-host=WEB_HOST   Host to bind the web interface to. Defaults to '' (all\n                        interfaces)\n  -P PORT, --port=PORT, --web-port=PORT\n                        Port on which to run web host\n  -f LOCUSTFILE, --locustfile=LOCUSTFILE\n                        Python module file to import, e.g. '../other.py'.\n                        Default: locustfile\n  --csv=CSVFILEBASE, --csv-base-name=CSVFILEBASE\n                        Store current request stats to files in CSV format.\n  --master              Set locust to run in distributed mode with this\n                        process as master\n  --slave               Set locust to run in distributed mode with this\n                        process as slave\n  --master-host=MASTER_HOST\n                        Host or IP address of locust master for distributed\n                        load testing. Only used when running with --slave.\n                        Defaults to 127.0.0.1.\n  --master-port=MASTER_PORT\n                        The port to connect to that is used by the locust\n                        master for distributed load testing. Only used when\n                        running with --slave. Defaults to 5557. Note that\n                        slaves will also connect to the master node on this\n                        port + 1.\n  --master-bind-host=MASTER_BIND_HOST\n                        Interfaces (hostname, ip) that locust master should\n                        bind to. Only used when running with --master.\n                        Defaults to * (all available interfaces).\n  --master-bind-port=MASTER_BIND_PORT\n                        Port that locust master should bind to. Only used when\n                        running with --master. Defaults to 5557. Note that\n                        Locust will also use this port + 1, so by default the\n                        master node will bind to 5557 and 5558.\n  --expect-slaves=EXPECT_SLAVES\n                        How many slaves master should expect to connect before\n                        starting the test (only when --no-web used).\n  --no-web              Disable the web interface, and instead start running\n                        the test immediately. Requires -c and -r to be\n                        specified.\n  -c NUM_CLIENTS, --clients=NUM_CLIENTS\n                        Number of concurrent Locust users. Only used together\n                        with --no-web\n  -r HATCH_RATE, --hatch-rate=HATCH_RATE\n                        The rate per second in which clients are spawned. Only\n                        used together with --no-web\n  -t RUN_TIME, --run-time=RUN_TIME\n                        Stop after the specified amount of time, e.g. (300s,\n                        20m, 3h, 1h30m, etc.). Only used together with --no-\n                        web\n  -L LOGLEVEL, --loglevel=LOGLEVEL\n                        Choose between DEBUG/INFO/WARNING/ERROR/CRITICAL.\n                        Default is INFO.\n  --logfile=LOGFILE     Path to log file. If not set, log will go to\n                        stdout/stderr\n  --print-stats         Print stats in the console\n  --only-summary        Only print the summary stats\n  --no-reset-stats      Do not reset statistics once hatching has been\n                        completed\n  -l, --list            Show list of possible locust classes and exit\n  --show-task-ratio     print table of the locust classes' task execution\n                        ratio\n  --show-task-ratio-json\n                        print json data of the locust classes' task execution\n                        ratio\n  -V, --version         show program's version number and exit\n\n```\n## 说明\n|参数|说明|\n|----|----|\n|-h, --help|查看帮助\n|-H HOST, --host=HOST|指定被测试的主机，采用以格式：http://10.21.32.33\n|--web-host=WEB_HOST|指定运行 Locust Web 页面的主机，默认为空 ''。\n|-P PORT, --port=PORT, --web-port=PORT|指定 --web-host 的端口，默认是8089\n|-f LOCUSTFILE, --locustfile=LOCUSTFILE|指定运行 Locust 性能测试文件，默认为: locustfile.py\n|--csv=CSVFILEBASE, --csv-base-name=CSVFILEBASE|以CSV格式存储当前请求测试数据。\n|--master|Locust 分布式模式使用，当前节点为 master 节点。\n|--slave|Locust 分布式模式使用，当前节点为 slave 节点。\n|--master-host=MASTER_HOST|分布式模式运行，设置 master 节点的主机或 IP 地址，只在与 --slave 节点一起运行时使用，默认为：127.0.0.1.\n|--master-port=MASTER_PORT|分布式模式运行， 设置 master 节点的端口号，只在与 --slave 节点一起运行时使用，默认为：5557。注意，slave 节点也将连接到这个端口+1 上的 master 节点。\n|--master-bind-host=MASTER_BIND_HOST|Interfaces (hostname, ip) that locust master should bind to. Only used when running with --master. Defaults to * (all available interfaces).\n|--master-bind-port=MASTER_BIND_PORT|Port that locust master should bind to. Only used when running with --master. Defaults to 5557. Note that Locust will also use this port + 1, so by default the master node will bind to 5557 and 5558.\n|--expect-slaves=EXPECT_SLAVES|How many slaves master should expect to connect before starting the test (only when --no-web used).\n|--no-web|no-web 模式运行测试，需要 -c 和 -r 配合使用.\n|-c NUM_CLIENTS, --clients=NUM_CLIENTS|指定并发用户数，作用于 --no-web 模式。\n|-r HATCH_RATE, --hatch-rate=HATCH_RATE|指定每秒启动的用户数，作用于 --no-web 模式。\n|-t RUN_TIME, --run-time=RUN_TIME|设置运行时间, 例如： (300s, 20m, 3h, 1h30m). 作用于 --no-web 模式。\n|-L LOGLEVEL, --loglevel=LOGLEVEL|选择 log 级别（DEBUG/INFO/WARNING/ERROR/CRITICAL）. 默认是 INFO.\n|--logfile=LOGFILE|日志文件路径。如果没有设置，日志将去 stdout/stderr\n|--print-stats|在控制台中打印数据\n|--only-summary|只打印摘要统计\n|--no-reset-stats|Do not reset statistics once hatching has been completed。\n|-l, --list|显示测试类, 配置 -f 参数使用\n|--show-task-ratio|打印 locust 测试类的任务执行比例，配合 -f 参数使用.\n|--show-task-ratio-json|以 json 格式打印 locust 测试类的任务执行比例，配合 -f 参数使用.\n|-V, --version|查看当前 Locust 工具的版本.\n\n","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Locust 官方网站：<a href=\"https://www.locust.io/\">https://www.locust.io/</a><br>An open source load testing tool.<br>一个开源性能测试工具。<br>define user behaviour with python code, and swarm your system with millions of simultaneous users.<br>使用 Python 代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fyt89j9tb3j31bd0u0tf7.jpg\"></p>\n<span id=\"more\"></span>\n<ol>\n<li><p>LoadRunner 是非常有名的商业性能测试工具，功能非常强大。使用也比较复杂，目前大多介绍性能测试的书籍都以该工具为基础，甚至有些书整本都在介绍 LoadRunner 的使用。</p>\n</li>\n<li><p>Jmeter 同样是非常有名的开源性能测试工具，功能也很完善，在本书中介绍了它作为接口测试工具的使用。但实际上，它是一个标准的性能测试工具。关于Jmeter相关的资料也非常丰富，它的官方文档也很完善。</p>\n</li>\n<li><p>Locust 同样是性能测试工具，虽然官方这样来描述它 “An open source load testing tool.” 。但其它和前面两个工具有着较大的不同。相比前面两个工具，功能上要差上不少，但它也并非优点全无。</p>\n<ul>\n<li>Locust 完全基本 Python 编程语言，采用 Pure Python 描述测试脚本，并且 HTTP 请求完全基于 Requests 库。除了 HTTP&#x2F;HTTPS 协议，Locust 也可以测试其它协议的系统，只需要采用Python调用对应的库进行请求描述即可。</li>\n<li>LoadRunner 和 Jmeter 这类采用进程和线程的测试工具，都很难在单机上模拟出较高的并发压力。Locust 的并发机制摒弃了进程和线程，采用协程（gevent）的机制。协程避免了系统级资源调度，由此可以大幅提高单机的并发能力。</li>\n</ul>\n</li>\n</ol>\n<p>正是基于这样的特点，使我选择使用Locust工具来做性能测试，另外一个原因是它可以让我们换一种方式认识性能测试，可能更容易看清性能测试的本质。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"pip安装\"><a href=\"#pip安装\" class=\"headerlink\" title=\"pip安装\"></a>pip安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install locust</span><br></pre></td></tr></table></figure>\n<h2 id=\"Git安装\"><a href=\"#Git安装\" class=\"headerlink\" title=\"Git安装\"></a>Git安装</h2><p>GitHub项目地址：<a href=\"https://github.com/locustio/locust/\">https://github.com/locustio/locust/</a></p>\n<p>将项目克隆下来，通过Python 执行 setup.py 文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup.py install</span><br></pre></td></tr></table></figure>\n\n<p>最后，检查是否安装成功:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locust --help</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"依赖分析\"><a href=\"#依赖分析\" class=\"headerlink\" title=\"依赖分析\"></a>依赖分析</h2><ul>\n<li>gevent 是在 Python 中实现协程的一个第三方库。协程，又称微线程（Coroutine）。使用gevent可以获得极高的并发性能。</li>\n<li>flask 是 Python 的一个 Web 开发框架。</li>\n<li>Requests 用来做 HTTP 接口测试。</li>\n<li>msgpack-python 是一种快速、紧凑的二进制序列化格式，适用于类似JSON的数据。</li>\n<li>six 提供了一些简单的工具用来封装 Python2 和 Python3 之间的差异性。</li>\n<li>pyzmq 如果你打算运行 Locust 分布在多个进程&#x2F;机器，建议你安装pyzmq。</li>\n</ul>\n<p>当我们在安装 Locust 时，它会检测我们当前的 Python 环境是否已经安装了这些库，如果没有安装，它会先把这些库一一装上。并且对这些库版本有要求，有些是必须等于某版本，有些是大于某版本。我们也可以事先把这些库全部按要求装好，再安装Locust时就会快上许多。</p>\n<h1 id=\"创建性能测试\"><a href=\"#创建性能测试\" class=\"headerlink\" title=\"创建性能测试\"></a>创建性能测试</h1><h2 id=\"写脚本\"><a href=\"#写脚本\" class=\"headerlink\" title=\"写脚本\"></a>写脚本</h2><p>创建 load_test.py 文件，通过 Python 编写性能测试脚本。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> locust <span class=\"keyword\">import</span> HttpLocust, TaskSet, task</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义用户行为</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserBehavior</span>(<span class=\"title class_ inherited__\">TaskSet</span>):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @task</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">baidu_index</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.client.get(<span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WebsiteUser</span>(<span class=\"title class_ inherited__\">HttpLocust</span>):</span><br><span class=\"line\">    task_set = UserBehavior</span><br><span class=\"line\">    min_wait = <span class=\"number\">3000</span></span><br><span class=\"line\">    max_wait = <span class=\"number\">6000</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>UserBehavior类继承TaskSet类，用于描述用户行为。</li>\n<li>baidu_index() 方法表示一个用户为行，访问百度首页。使用@task装饰该方法为一个事务。client.get()用于指请求的路径“&#x2F;”，因为是百度首页，所以指定为根路径。</li>\n<li>WebsiteUser类用于设置性能测试。<ul>\n<li>task_set ：指向一个定义的用户行为类。</li>\n<li>min_wait ：执行事务之间用户等待时间的下界（单位：毫秒）。</li>\n<li>max_wait ：执行事务之间用户等待时间的上界（单位：毫秒）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"启动性能测试\"><a href=\"#启动性能测试\" class=\"headerlink\" title=\"启动性能测试\"></a>启动性能测试</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">locust -f .\\load_test.py --host=https://www.baidu.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">[2017-10-16 16:44:40,839] DESKTOP-SMGQBBM/INFO/locust.main: Starting web monitor at *:8089</span><br><span class=\"line\">[2017-10-16 16:44:40,842] DESKTOP-SMGQBBM/INFO/locust.main: Starting Locust 0.8</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-f 指定性能测试脚本文件。</li>\n<li>–host 指定被测试应用的URL的地址，注意访问百度使用的HTTPS协议。</li>\n<li>通过浏览器访问：<a href=\"http://localhost:8089（Locust启动网络监控器，默认为端口号为\">http://localhost:8089（Locust启动网络监控器，默认为端口号为</a>: 8089）<br><img src=\"https://ws1.sinaimg.cn/large/006tNc79ly1fyt953kd2lj30zb0mjwgt.jpg\"></li>\n<li>Number of users to simulate 设置模拟用户数。</li>\n<li>Hatch rate（users spawned&#x2F;second） 每秒产生（启动）的虚拟用户数。</li>\n</ul>\n<p>点击 “Start swarming” 按钮，开始运行性能测试。<br><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fyt95m2zbaj30z90jlmza.jpg\"><br>性能测试参数</p>\n<ol>\n<li>Type： 请求的类型，例如GET&#x2F;POST。</li>\n<li>Name：请求的路径。这里为百度首页，即：<a href=\"https://www.baidu.com/\">https://www.baidu.com/</a></li>\n<li>request：当前请求的数量。</li>\n<li>fails：当前请求失败的数量。</li>\n<li>Median：中间值，单位毫秒，一半的服务器响应时间低于该值，而另一半高于该值。</li>\n<li>Average：平均值，单位毫秒，所有请求的平均响应时间。</li>\n<li>Min：请求的最小服务器响应时间，单位毫秒。</li>\n<li>Max：请求的最大服务器响应时间，单位毫秒。</li>\n<li>Content Size：单个请求的大小，单位字节。</li>\n<li>reqs&#x2F;sec：是每秒钟请求的个数。</li>\n</ol>\n<h1 id=\"no-web模式\"><a href=\"#no-web模式\" class=\"headerlink\" title=\"no-web模式\"></a>no-web模式</h1><p>以上一节的 baidu 首页测试（load_test.py）为例 通过 no-web 模式运行测试。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">locust -f load_test.py --host=https://www.baidu.com --no-web -c 10 -r 2 -t 1m</span></span><br><span class=\"line\"></span><br><span class=\"line\">[2017-10-30 22:17:30,292] DESKTOP-SMGQBBM/INFO/locust.main: Run time limit set to 60 seconds</span><br><span class=\"line\">[2017-10-30 22:17:30,302] DESKTOP-SMGQBBM/INFO/locust.main: Starting Locust 0.8</span><br><span class=\"line\">[2017-10-30 22:17:30,302] DESKTOP-SMGQBBM/INFO/locust.runners: Hatching and swarming 10 clients at the rate 2 clients/s...</span><br><span class=\"line\"> Name                                                          # reqs      # fails     Avg     Min     Max  |  Median   req/s</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> [2017-10-30 22:18:30,301] DESKTOP-SMGQBBM/INFO/locust.main: Time limit reached. Stopping Locust.</span><br><span class=\"line\"> [2017-10-30 22:18:30,302] DESKTOP-SMGQBBM/INFO/locust.main: Shutting down (exit code 0), bye.</span><br><span class=\"line\">  Name                                                          # reqs      # fails     Avg     Min     Max  |  Median   req/s</span><br><span class=\"line\"> --------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">  GET /                                                            117     0(0.00%)      31      17      96  |      28    2.10</span><br><span class=\"line\"> --------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">  Total                                                            117     0(0.00%)                                       2.10</span><br><span class=\"line\"></span><br><span class=\"line\"> Percentage of the requests completed within given times</span><br><span class=\"line\">  Name                                                           # reqs    50%    66%    75%    80%    90%    95%    98%    99%   100%</span><br><span class=\"line\"> --------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">  GET /                                                             117     28     30     36     37     49     62     69     72     96</span><br><span class=\"line\"> --------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">  Total                                                             117     28     30     36     37     49     62     69     72     96</span><br></pre></td></tr></table></figure>\n<p>启动参数：</p>\n<ul>\n<li>–no-web 表示不使用Web界面运行测试。</li>\n<li>-c 设置虚拟用户数。</li>\n<li>-r 设置每秒启动虚拟用户数。</li>\n<li>-t 设置设置运行时间。(在有些locust版本中可能不支持该参数，改用-n参数可以指定发送请求数量，具体的可以通过locust –help查看)</li>\n</ul>\n<h1 id=\"Locust参数\"><a href=\"#Locust参数\" class=\"headerlink\" title=\"Locust参数\"></a>Locust参数</h1><h2 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h2><p>打开命令提示符（或Linux终端），输入 locust –help 。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt; </span><span class=\"language-bash\">locust --<span class=\"built_in\">help</span></span></span><br><span class=\"line\">Usage: locust [options] [LocustClass [LocustClass2 ... ]]</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">  -h, --help            show this help message and exit</span><br><span class=\"line\">  -H HOST, --host=HOST  Host to load test in the following format:</span><br><span class=\"line\">                        http://10.21.32.33</span><br><span class=\"line\">  --web-host=WEB_HOST   Host to bind the web interface to. Defaults to &#x27;&#x27; (all</span><br><span class=\"line\">                        interfaces)</span><br><span class=\"line\">  -P PORT, --port=PORT, --web-port=PORT</span><br><span class=\"line\">                        Port on which to run web host</span><br><span class=\"line\">  -f LOCUSTFILE, --locustfile=LOCUSTFILE</span><br><span class=\"line\">                        Python module file to import, e.g. &#x27;../other.py&#x27;.</span><br><span class=\"line\">                        Default: locustfile</span><br><span class=\"line\">  --csv=CSVFILEBASE, --csv-base-name=CSVFILEBASE</span><br><span class=\"line\">                        Store current request stats to files in CSV format.</span><br><span class=\"line\">  --master              Set locust to run in distributed mode with this</span><br><span class=\"line\">                        process as master</span><br><span class=\"line\">  --slave               Set locust to run in distributed mode with this</span><br><span class=\"line\">                        process as slave</span><br><span class=\"line\">  --master-host=MASTER_HOST</span><br><span class=\"line\">                        Host or IP address of locust master for distributed</span><br><span class=\"line\">                        load testing. Only used when running with --slave.</span><br><span class=\"line\">                        Defaults to 127.0.0.1.</span><br><span class=\"line\">  --master-port=MASTER_PORT</span><br><span class=\"line\">                        The port to connect to that is used by the locust</span><br><span class=\"line\">                        master for distributed load testing. Only used when</span><br><span class=\"line\">                        running with --slave. Defaults to 5557. Note that</span><br><span class=\"line\">                        slaves will also connect to the master node on this</span><br><span class=\"line\">                        port + 1.</span><br><span class=\"line\">  --master-bind-host=MASTER_BIND_HOST</span><br><span class=\"line\">                        Interfaces (hostname, ip) that locust master should</span><br><span class=\"line\">                        bind to. Only used when running with --master.</span><br><span class=\"line\">                        Defaults to * (all available interfaces).</span><br><span class=\"line\">  --master-bind-port=MASTER_BIND_PORT</span><br><span class=\"line\">                        Port that locust master should bind to. Only used when</span><br><span class=\"line\">                        running with --master. Defaults to 5557. Note that</span><br><span class=\"line\">                        Locust will also use this port + 1, so by default the</span><br><span class=\"line\">                        master node will bind to 5557 and 5558.</span><br><span class=\"line\">  --expect-slaves=EXPECT_SLAVES</span><br><span class=\"line\">                        How many slaves master should expect to connect before</span><br><span class=\"line\">                        starting the test (only when --no-web used).</span><br><span class=\"line\">  --no-web              Disable the web interface, and instead start running</span><br><span class=\"line\">                        the test immediately. Requires -c and -r to be</span><br><span class=\"line\">                        specified.</span><br><span class=\"line\">  -c NUM_CLIENTS, --clients=NUM_CLIENTS</span><br><span class=\"line\">                        Number of concurrent Locust users. Only used together</span><br><span class=\"line\">                        with --no-web</span><br><span class=\"line\">  -r HATCH_RATE, --hatch-rate=HATCH_RATE</span><br><span class=\"line\">                        The rate per second in which clients are spawned. Only</span><br><span class=\"line\">                        used together with --no-web</span><br><span class=\"line\">  -t RUN_TIME, --run-time=RUN_TIME</span><br><span class=\"line\">                        Stop after the specified amount of time, e.g. (300s,</span><br><span class=\"line\">                        20m, 3h, 1h30m, etc.). Only used together with --no-</span><br><span class=\"line\">                        web</span><br><span class=\"line\">  -L LOGLEVEL, --loglevel=LOGLEVEL</span><br><span class=\"line\">                        Choose between DEBUG/INFO/WARNING/ERROR/CRITICAL.</span><br><span class=\"line\">                        Default is INFO.</span><br><span class=\"line\">  --logfile=LOGFILE     Path to log file. If not set, log will go to</span><br><span class=\"line\">                        stdout/stderr</span><br><span class=\"line\">  --print-stats         Print stats in the console</span><br><span class=\"line\">  --only-summary        Only print the summary stats</span><br><span class=\"line\">  --no-reset-stats      Do not reset statistics once hatching has been</span><br><span class=\"line\">                        completed</span><br><span class=\"line\">  -l, --list            Show list of possible locust classes and exit</span><br><span class=\"line\">  --show-task-ratio     print table of the locust classes&#x27; task execution</span><br><span class=\"line\">                        ratio</span><br><span class=\"line\">  --show-task-ratio-json</span><br><span class=\"line\">                        print json data of the locust classes&#x27; task execution</span><br><span class=\"line\">                        ratio</span><br><span class=\"line\">  -V, --version         show program&#x27;s version number and exit</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-h, –help</td>\n<td>查看帮助</td>\n</tr>\n<tr>\n<td>-H HOST, –host&#x3D;HOST</td>\n<td>指定被测试的主机，采用以格式：<a href=\"http://10.21.32.33/\">http://10.21.32.33</a></td>\n</tr>\n<tr>\n<td>–web-host&#x3D;WEB_HOST</td>\n<td>指定运行 Locust Web 页面的主机，默认为空 ‘’。</td>\n</tr>\n<tr>\n<td>-P PORT, –port&#x3D;PORT, –web-port&#x3D;PORT</td>\n<td>指定 –web-host 的端口，默认是8089</td>\n</tr>\n<tr>\n<td>-f LOCUSTFILE, –locustfile&#x3D;LOCUSTFILE</td>\n<td>指定运行 Locust 性能测试文件，默认为: locustfile.py</td>\n</tr>\n<tr>\n<td>–csv&#x3D;CSVFILEBASE, –csv-base-name&#x3D;CSVFILEBASE</td>\n<td>以CSV格式存储当前请求测试数据。</td>\n</tr>\n<tr>\n<td>–master</td>\n<td>Locust 分布式模式使用，当前节点为 master 节点。</td>\n</tr>\n<tr>\n<td>–slave</td>\n<td>Locust 分布式模式使用，当前节点为 slave 节点。</td>\n</tr>\n<tr>\n<td>–master-host&#x3D;MASTER_HOST</td>\n<td>分布式模式运行，设置 master 节点的主机或 IP 地址，只在与 –slave 节点一起运行时使用，默认为：127.0.0.1.</td>\n</tr>\n<tr>\n<td>–master-port&#x3D;MASTER_PORT</td>\n<td>分布式模式运行， 设置 master 节点的端口号，只在与 –slave 节点一起运行时使用，默认为：5557。注意，slave 节点也将连接到这个端口+1 上的 master 节点。</td>\n</tr>\n<tr>\n<td>–master-bind-host&#x3D;MASTER_BIND_HOST</td>\n<td>Interfaces (hostname, ip) that locust master should bind to. Only used when running with –master. Defaults to * (all available interfaces).</td>\n</tr>\n<tr>\n<td>–master-bind-port&#x3D;MASTER_BIND_PORT</td>\n<td>Port that locust master should bind to. Only used when running with –master. Defaults to 5557. Note that Locust will also use this port + 1, so by default the master node will bind to 5557 and 5558.</td>\n</tr>\n<tr>\n<td>–expect-slaves&#x3D;EXPECT_SLAVES</td>\n<td>How many slaves master should expect to connect before starting the test (only when –no-web used).</td>\n</tr>\n<tr>\n<td>–no-web</td>\n<td>no-web 模式运行测试，需要 -c 和 -r 配合使用.</td>\n</tr>\n<tr>\n<td>-c NUM_CLIENTS, –clients&#x3D;NUM_CLIENTS</td>\n<td>指定并发用户数，作用于 –no-web 模式。</td>\n</tr>\n<tr>\n<td>-r HATCH_RATE, –hatch-rate&#x3D;HATCH_RATE</td>\n<td>指定每秒启动的用户数，作用于 –no-web 模式。</td>\n</tr>\n<tr>\n<td>-t RUN_TIME, –run-time&#x3D;RUN_TIME</td>\n<td>设置运行时间, 例如： (300s, 20m, 3h, 1h30m). 作用于 –no-web 模式。</td>\n</tr>\n<tr>\n<td>-L LOGLEVEL, –loglevel&#x3D;LOGLEVEL</td>\n<td>选择 log 级别（DEBUG&#x2F;INFO&#x2F;WARNING&#x2F;ERROR&#x2F;CRITICAL）. 默认是 INFO.</td>\n</tr>\n<tr>\n<td>–logfile&#x3D;LOGFILE</td>\n<td>日志文件路径。如果没有设置，日志将去 stdout&#x2F;stderr</td>\n</tr>\n<tr>\n<td>–print-stats</td>\n<td>在控制台中打印数据</td>\n</tr>\n<tr>\n<td>–only-summary</td>\n<td>只打印摘要统计</td>\n</tr>\n<tr>\n<td>–no-reset-stats</td>\n<td>Do not reset statistics once hatching has been completed。</td>\n</tr>\n<tr>\n<td>-l, –list</td>\n<td>显示测试类, 配置 -f 参数使用</td>\n</tr>\n<tr>\n<td>–show-task-ratio</td>\n<td>打印 locust 测试类的任务执行比例，配合 -f 参数使用.</td>\n</tr>\n<tr>\n<td>–show-task-ratio-json</td>\n<td>以 json 格式打印 locust 测试类的任务执行比例，配合 -f 参数使用.</td>\n</tr>\n<tr>\n<td>-V, –version</td>\n<td>查看当前 Locust 工具的版本.</td>\n</tr>\n</tbody></table>\n","slug":"Locust基础-1","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/08/Locust%E5%9F%BA%E7%A1%80-1/","excerpt":"介绍Locust 官方网站：https://www.locust.io/An open source load testing tool.一个开源性能测试工具。define user behaviour with python code, and swarm your system with millions of simultaneous users.使用 Python 代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"locust","slug":"locust","permalink":"http://vwin.github.io/tags/locust/"},{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"持续集成介绍","date":"2018-08-07T11:05:14.000Z","path":"2018/08/07/持续集成介绍/","text":"互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称 CI）。 概念持续集成指的是，频繁地（一天多次）将代码集成到主干。它的好处主要有两个。 1、快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 2、防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 Martin Fowler 说过，”持续集成并不能消除 Bug，而是让它们非常容易发现和改正。” 与持续集成相关的，还有两个概念，分别是持续交付和持续部署。 持续交付持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。 持续部署持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 持续部署的前提是能自动化完成测试、构建、部署等步骤。它与持续交付的区别，可以参考下图。 流程根据持续集成的设计，代码从提交到生产，整个过程有以下几步。 提交流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。 测试（第一轮）代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 测试一般包括以下几种。 123单元测试：针对函数或模块的测试集成测试：针对整体产品的某个功能的测试，又称功能测试端对端测试：从用户界面直达数据库的全链路测试 第一轮至少要跑单元测试。 构建通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS 脚本、图片）等等。 常用的构建工具如下。 1234JenkinsTravisCodeshipStrider Jenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。 测试（第二轮）构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。 第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。 需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。 联调测试对于一部分大型项目来说，团队负责的模块可能只是整个项目中的一部分，每次项目可能会涉及到上下游各个团队之间联调。那么就需要在做完本模块的测试后配合上下游团队进行联调，等待联调完成没有问题后，然后上下游协调上线时间，再进行下一步部署 部署通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible，Chef，Puppet 等。 回滚一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。","raw":"---\ntitle: 持续集成介绍\ntoc: true\ndate: 2018-08-07 19:05:14\ntags: [持续集成,CI]\ncategories: [测试]\ndescription:\n---\n互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称 CI）。\n<!--more-->\n## 概念\n持续集成指的是，频繁地（一天多次）将代码集成到主干。\n它的好处主要有两个。\n\n1、快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。\n\n2、防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。\n\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。\n\nMartin Fowler 说过，\"持续集成并不能消除 Bug，而是让它们非常容易发现和改正。\"\n\n与持续集成相关的，还有两个概念，分别是持续交付和持续部署。\n\n## 持续交付\n持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。\n\n持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。\n\n## 持续部署\n\n持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。\n\n持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。\n\n持续部署的前提是能自动化完成测试、构建、部署等步骤。它与持续交付的区别，可以参考下图。\n![持续集成](http://ww1.sinaimg.cn/large/a2490837ly1fu1ch9liinj20go0a0dmd.jpg)\n## 流程\n根据持续集成的设计，代码从提交到生产，整个过程有以下几步。\n### 提交\n流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。\n\n### 测试（第一轮）\n代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。\n\n测试一般包括以下几种。\n```text\n单元测试：针对函数或模块的测试\n集成测试：针对整体产品的某个功能的测试，又称功能测试\n端对端测试：从用户界面直达数据库的全链路测试\n```\n第一轮至少要跑单元测试。\n\n### 构建\n通过第一轮测试，代码就可以合并进主干，就算可以交付了。\n\n交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS 脚本、图片）等等。\n\n常用的构建工具如下。\n\n```python\nJenkins\nTravis\nCodeship\nStrider\n```\n\nJenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。\n\n### 测试（第二轮）\n\n构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。\n\n第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。\n\n需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。\n\n### 联调测试\n对于一部分大型项目来说，团队负责的模块可能只是整个项目中的一部分，每次项目可能会涉及到上下游各个团队之间联调。\n那么就需要在做完本模块的测试后配合上下游团队进行联调，等待联调完成没有问题后，然后上下游协调上线时间，再进行下一步部署\n\n### 部署\n\n通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。\n\n生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible，Chef，Puppet 等。\n\n### 回滚\n\n一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。\n\n","content":"<p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称 CI）。</p>\n<span id=\"more\"></span>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。<br>它的好处主要有两个。</p>\n<p>1、快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</p>\n<p>2、防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</p>\n<p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>\n<p>Martin Fowler 说过，”持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”</p>\n<p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p>\n<h2 id=\"持续交付\"><a href=\"#持续交付\" class=\"headerlink\" title=\"持续交付\"></a>持续交付</h2><p>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。</p>\n<p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>\n<h2 id=\"持续部署\"><a href=\"#持续部署\" class=\"headerlink\" title=\"持续部署\"></a>持续部署</h2><p>持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p>\n<p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p>\n<p>持续部署的前提是能自动化完成测试、构建、部署等步骤。它与持续交付的区别，可以参考下图。<br><img src=\"http://ww1.sinaimg.cn/large/a2490837ly1fu1ch9liinj20go0a0dmd.jpg\" alt=\"持续集成\"></p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p>\n<h3 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h3><p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p>\n<h3 id=\"测试（第一轮）\"><a href=\"#测试（第一轮）\" class=\"headerlink\" title=\"测试（第一轮）\"></a>测试（第一轮）</h3><p>代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</p>\n<p>测试一般包括以下几种。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">单元测试：针对函数或模块的测试</span><br><span class=\"line\">集成测试：针对整体产品的某个功能的测试，又称功能测试</span><br><span class=\"line\">端对端测试：从用户界面直达数据库的全链路测试</span><br></pre></td></tr></table></figure>\n<p>第一轮至少要跑单元测试。</p>\n<h3 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h3><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>\n<p>交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS 脚本、图片）等等。</p>\n<p>常用的构建工具如下。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jenkins</span><br><span class=\"line\">Travis</span><br><span class=\"line\">Codeship</span><br><span class=\"line\">Strider</span><br></pre></td></tr></table></figure>\n\n<p>Jenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。</p>\n<h3 id=\"测试（第二轮）\"><a href=\"#测试（第二轮）\" class=\"headerlink\" title=\"测试（第二轮）\"></a>测试（第二轮）</h3><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>\n<p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p>\n<p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p>\n<h3 id=\"联调测试\"><a href=\"#联调测试\" class=\"headerlink\" title=\"联调测试\"></a>联调测试</h3><p>对于一部分大型项目来说，团队负责的模块可能只是整个项目中的一部分，每次项目可能会涉及到上下游各个团队之间联调。<br>那么就需要在做完本模块的测试后配合上下游团队进行联调，等待联调完成没有问题后，然后上下游协调上线时间，再进行下一步部署</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。</p>\n<p>生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible，Chef，Puppet 等。</p>\n<h3 id=\"回滚\"><a href=\"#回滚\" class=\"headerlink\" title=\"回滚\"></a>回滚</h3><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>\n","slug":"持续集成介绍","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/07/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%BB%8B%E7%BB%8D/","excerpt":"互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称 CI）。","categories":[{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"http://vwin.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"CI","slug":"CI","permalink":"http://vwin.github.io/tags/CI/"}]},{"title":"Hexo-博客文章插入图片","date":"2018-08-07T09:37:40.000Z","path":"2018/08/07/Hexo-博客文章插入图片/","text":"Hexo 博客文章插入图片 Hexo博客插入图片在网上查了一下有以下几种方式往hexo文章中插入图片 本地引用绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source&#x2F;images文件夹中，通过markdown语法访问它们。对于source&#x2F;images&#x2F;image.jpg这张图片可以用以下语法访问到 1![](/images/image.jpg) 图片既可以在首页内容中访问到，也可以在文章正文中访问到。 相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置\b博客根目录下的_config.yml来生成。 1post_asset_folder: true 将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source&#x2F;_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。_posts&#x2F;post_name&#x2F;image.jpg这张照片可以用以下方式访问： 1![](image.jpg) 上述markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。_posts&#x2F;post_name&#x2F;image.jpg这张照片可以用以下方式访问： 1&#123;% asset_img image.jpg This is an image %&#125; 虽然可以正常引用图片了，但是这种引用图片的方式太过复杂，所以引入图片插件解决。 图片插件：插件hexo-renderer-marked解决了这个问题。使用如下： 12345678npm install hexo-renderer-marked用该命令直接安装，之后在config.yaml中更改配置如下：post_asset_folder: truemarked: prependRoot: true postAsset: true 问题：使用该插件后生成的图片路径不正确，在路径中重复使用文章路径解决：找到插件 hexo-assert-image 安装位置（插件都在node_modules文件夹下）如上图，红框3打印了完整的图片路径，红框1是获取src路径，经过对比发现src路径获取时重复，所以增加红框2的解决办法，完美解决编译后图片路径不正确的问题 之后就可以在使用 1![](image.jpg) 这种方式愉快的插入图片了。 CDN引用除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。因国内访问github速度较慢，所以将突破放到国内图床上，然后引用外链\b是常用的方法。常用图床总结：https://sspai.com/post/40499 图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。 当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生 目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。 微博图床（Chrome浏览器有个“新浪微博图床\u001d”插件，可以自动生成markdown链接）简单方便 七牛：\b需要注册且实名认证等太麻烦，放弃 腾讯云等云存储服务，需要先将照片放到云盘，然后找到超链接，然后\b粘贴到文章。太麻烦，放弃。 【强烈推荐！！！】ipic 工具，具体用法请谷歌，支持监控剪贴板，一键上传到微博图床，\b免费版默认是微博图床，支持七牛云等，下载地址: https://itunes.apple.com/cn/app/id1101244278?mt=12 使用GitHub\b\b使用github存储博客图片 创建一个空的repo 然后将图片push到repo中 点击图片进去，有个download，右键复制链接 将链接插入\b文章1![logo](https://github.com/xxxx/xx.jpg)","raw":"---\ntitle: Hexo-博客文章插入图片\ntoc: true\ndate: 2018-08-07 17:37:40\ntags: [hexo]\ncategories: [Hexo]\ndescription: Hexo博客插入图片\n---\nHexo 博客文章插入图片\n<!--more-->\n## Hexo博客插入图片\n在网上查了一下有以下几种方式往hexo文章中插入图片\n### 本地引用\n#### 绝对路径\n当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。对于source/images/image.jpg这张图片可以用以下语法访问到\n```shell\n![](/images/image.jpg)\n```\n图片既可以在首页内容中访问到，也可以在文章正文中访问到。\n#### 相对路径\n图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置\b博客根目录下的_config.yml来生成。\n\n```shell\npost_asset_folder: true\n```\n\n将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。_posts/post_name/image.jpg这张照片可以用以下方式访问：\n\n```shell\n![](image.jpg)\n```\n\n上述markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。\n如果希望图片在文章和首页中同时显示，可以使用标签插件语法。_posts/post_name/image.jpg这张照片可以用以下方式访问：\n\n```shell\n{% asset_img image.jpg This is an image %}\n```\n\n虽然可以正常引用图片了，但是这种引用图片的方式太过复杂，所以引入图片插件解决。\n\n图片插件：\n插件hexo-renderer-marked解决了这个问题。使用如下：\n```shell\nnpm install hexo-renderer-marked\n\n用该命令直接安装，之后在config.yaml中更改配置如下：\n\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n问题：使用该插件后生成的图片路径不正确，在路径中重复使用文章路径\n解决：找到插件 hexo-assert-image 安装位置（插件都在node_modules文件夹下）\n![Hexo-assert-image](http://cdn.yuleweici.com/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/hexo-image.png)\n如上图，红框3打印了完整的图片路径，红框1是获取src路径，经过对比发现src路径获取时重复，所以增加红框2的解决办法，完美解决编译后图片路径不正确的问题\n\n之后就可以在使用\n```shell \n![](image.jpg) \n```\n这种方式愉快的插入图片了。\n\n### CDN引用\n除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。因国内访问github速度较慢，所以将突破放到国内图床上，然后引用外链\b是常用的方法。\n常用图床总结：https://sspai.com/post/40499\n\n>图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。\n\n>当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生\n\n>目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。\n\n1. 微博图床（Chrome浏览器有个“新浪微博图床\u001d”插件，可以自动生成markdown链接）简单方便\n2. 七牛：\b需要注册且实名认证等太麻烦，放弃\n3. 腾讯云等云存储服务，需要先将照片放到云盘，然后找到超链接，然后\b粘贴到文章。太麻烦，放弃。\n4. <font color=red>【强烈推荐！！！】</font>ipic 工具，具体用法请谷歌，支持监控剪贴板，一键上传到微博图床，\b免费版默认是微博图床，支持七牛云等，下载地址: https://itunes.apple.com/cn/app/id1101244278?mt=12\n\n### 使用GitHub\n\b\b使用github存储博客图片\n1. 创建一个空的repo\n2. 然后将图片push到repo中\n3. 点击图片进去，有个download，右键复制链接\n4. 将链接插入\b文章\n```\n![logo](https://github.com/xxxx/xx.jpg)\n```","content":"<p>Hexo 博客文章插入图片</p>\n<span id=\"more\"></span>\n<h2 id=\"Hexo博客插入图片\"><a href=\"#Hexo博客插入图片\" class=\"headerlink\" title=\"Hexo博客插入图片\"></a>Hexo博客插入图片</h2><p>在网上查了一下有以下几种方式往hexo文章中插入图片</p>\n<h3 id=\"本地引用\"><a href=\"#本地引用\" class=\"headerlink\" title=\"本地引用\"></a>本地引用</h3><h4 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h4><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source&#x2F;images文件夹中，通过markdown语法访问它们。对于source&#x2F;images&#x2F;image.jpg这张图片可以用以下语法访问到</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![](/images/image.jpg)</span><br></pre></td></tr></table></figure>\n<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>\n<h4 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h4><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置\b博客根目录下的_config.yml来生成。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure>\n\n<p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source&#x2F;_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。_posts&#x2F;post_name&#x2F;image.jpg这张照片可以用以下方式访问：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![](image.jpg)</span><br></pre></td></tr></table></figure>\n\n<p>上述markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。_posts&#x2F;post_name&#x2F;image.jpg这张照片可以用以下方式访问：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然可以正常引用图片了，但是这种引用图片的方式太过复杂，所以引入图片插件解决。</p>\n<p>图片插件：<br>插件hexo-renderer-marked解决了这个问题。使用如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-marked</span><br><span class=\"line\"></span><br><span class=\"line\">用该命令直接安装，之后在config.yaml中更改配置如下：</span><br><span class=\"line\"></span><br><span class=\"line\">post_asset_folder: true</span><br><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br></pre></td></tr></table></figure>\n\n<p>问题：使用该插件后生成的图片路径不正确，在路径中重复使用文章路径<br>解决：找到插件 hexo-assert-image 安装位置（插件都在node_modules文件夹下）<br><img src=\"http://cdn.yuleweici.com/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/hexo-image.png\" alt=\"Hexo-assert-image\"><br>如上图，红框3打印了完整的图片路径，红框1是获取src路径，经过对比发现src路径获取时重复，所以增加红框2的解决办法，完美解决编译后图片路径不正确的问题</p>\n<p>之后就可以在使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![](image.jpg) </span><br></pre></td></tr></table></figure>\n<p>这种方式愉快的插入图片了。</p>\n<h3 id=\"CDN引用\"><a href=\"#CDN引用\" class=\"headerlink\" title=\"CDN引用\"></a>CDN引用</h3><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。因国内访问github速度较慢，所以将突破放到国内图床上，然后引用外链\b是常用的方法。<br>常用图床总结：<a href=\"https://sspai.com/post/40499\">https://sspai.com/post/40499</a></p>\n<blockquote>\n<p>图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。</p>\n</blockquote>\n<blockquote>\n<p>当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生</p>\n</blockquote>\n<blockquote>\n<p>目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。</p>\n</blockquote>\n<ol>\n<li>微博图床（Chrome浏览器有个“新浪微博图床\u001d”插件，可以自动生成markdown链接）简单方便</li>\n<li>七牛：\b需要注册且实名认证等太麻烦，放弃</li>\n<li>腾讯云等云存储服务，需要先将照片放到云盘，然后找到超链接，然后\b粘贴到文章。太麻烦，放弃。</li>\n<li><font color=\"red\">【强烈推荐！！！】</font>ipic 工具，具体用法请谷歌，支持监控剪贴板，一键上传到微博图床，\b免费版默认是微博图床，支持七牛云等，下载地址: <a href=\"https://itunes.apple.com/cn/app/id1101244278?mt=12\">https://itunes.apple.com/cn/app/id1101244278?mt=12</a></li>\n</ol>\n<h3 id=\"使用GitHub\"><a href=\"#使用GitHub\" class=\"headerlink\" title=\"使用GitHub\"></a>使用GitHub</h3><p>\b\b使用github存储博客图片</p>\n<ol>\n<li>创建一个空的repo</li>\n<li>然后将图片push到repo中</li>\n<li>点击图片进去，有个download，右键复制链接</li>\n<li>将链接插入\b文章<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![logo](https://github.com/xxxx/xx.jpg)</span><br></pre></td></tr></table></figure></li>\n</ol>\n","slug":"Hexo-博客文章插入图片","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/07/Hexo-%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/","excerpt":"Hexo 博客文章插入图片","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://vwin.github.io/tags/hexo/"}]},{"title":"Hexo Next主题开启字数统计和阅读时长统计","date":"2018-08-02T08:37:32.000Z","path":"2018/08/02/Hexo-Next主题开启字数统计和阅读时长统计/","text":"Hexo Next 主题开启字数统计和阅读时长统计 注：Next主题版本 v6.3.0 安装 hexo-symbols-count-time在博客目录下执行： 123npm install hexo-symbols-count-timeoryarn add hexo-symbols-count-time 配置 hexo配置在博客根目录下的_config.yaml,增加如下配置： 注：增加该配置需要重启hexohexo clean &amp;&amp; hexo s 12345symbols_count_time: symbols: true # 文章字数 time: true # 阅读时长 total_symbols: true # 所有文章总字数 total_time: true # 所有文章阅读中时长 next主题配置在themes&#x2F;next&#x2F;_config.yaml，修改如下配置： 注：无需重启 123456symbols_count_time: separated_meta: true # 是否换行显示 字数统计 及 阅读时长 item_text_post: true # 文章 字数统计 阅读时长 使用图标 还是 文本表示 item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示 awl: 4 wpm: 275","raw":"---\ntitle: Hexo Next主题开启字数统计和阅读时长统计\ntoc: true\ndate: 2018-08-02 16:37:32\ntags: [hexo,next]\ncategories: [Hexo]\ndescription:\n---\nHexo Next 主题开启字数统计和阅读时长统计\n<!-- more -->\n>注：Next主题版本 v6.3.0\n## 安装 hexo-symbols-count-time\n在博客目录下执行：\n```\nnpm install hexo-symbols-count-time\nor\nyarn add hexo-symbols-count-time\n```\n## 配置\n1. hexo配置\n在博客根目录下的_config.yaml,增加如下配置：\n>注：增加该配置需要重启hexo\n>hexo clean && hexo s\n\n```shell\nsymbols_count_time:\n  symbols: true # 文章字数\n  time: true # 阅读时长\n  total_symbols: true # 所有文章总字数\n  total_time: true # 所有文章阅读中时长\n```\n2. next主题配置\n在themes/next/_config.yaml，修改如下配置：\n>注：无需重启\n\n```shell\nsymbols_count_time:\n  separated_meta: true  # 是否换行显示 字数统计 及 阅读时长\n  item_text_post: true  # 文章 字数统计 阅读时长 使用图标 还是 文本表示\n  item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示\n  awl: 4\n  wpm: 275\n```\n\n","content":"<p>Hexo Next 主题开启字数统计和阅读时长统计</p>\n<span id=\"more\"></span>\n<blockquote>\n<p>注：Next主题版本 v6.3.0</p>\n</blockquote>\n<h2 id=\"安装-hexo-symbols-count-time\"><a href=\"#安装-hexo-symbols-count-time\" class=\"headerlink\" title=\"安装 hexo-symbols-count-time\"></a>安装 hexo-symbols-count-time</h2><p>在博客目录下执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-symbols-count-time</span><br><span class=\"line\">or</span><br><span class=\"line\">yarn add hexo-symbols-count-time</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ol>\n<li>hexo配置<br>在博客根目录下的_config.yaml,增加如下配置：<blockquote>\n<p>注：增加该配置需要重启hexo<br>hexo clean &amp;&amp; hexo s</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">symbols_count_time:</span><br><span class=\"line\">  symbols: true # 文章字数</span><br><span class=\"line\">  time: true # 阅读时长</span><br><span class=\"line\">  total_symbols: true # 所有文章总字数</span><br><span class=\"line\">  total_time: true # 所有文章阅读中时长</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>next主题配置<br>在themes&#x2F;next&#x2F;_config.yaml，修改如下配置：<blockquote>\n<p>注：无需重启</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">symbols_count_time:</span><br><span class=\"line\">  separated_meta: true  # 是否换行显示 字数统计 及 阅读时长</span><br><span class=\"line\">  item_text_post: true  # 文章 字数统计 阅读时长 使用图标 还是 文本表示</span><br><span class=\"line\">  item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示</span><br><span class=\"line\">  awl: 4</span><br><span class=\"line\">  wpm: 275</span><br></pre></td></tr></table></figure>\n\n","slug":"Hexo-Next主题开启字数统计和阅读时长统计","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/02/Hexo-Next%E4%B8%BB%E9%A2%98%E5%BC%80%E5%90%AF%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E5%92%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF%E7%BB%9F%E8%AE%A1/","excerpt":"Hexo Next 主题开启字数统计和阅读时长统计","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://vwin.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://vwin.github.io/tags/next/"}]},{"title":"Hexo Next主题头像旋转","date":"2018-08-02T08:32:39.000Z","path":"2018/08/02/Hexo-Next主题头像旋转/","text":"Hexo Next主题将头像显示成圆形，鼠标放上去有旋转效果。 将头像显示成圆形，鼠标放上去有旋转效果。找到&#x2F;themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;sidebar&#x2F;sidebar-author.styl替换其中的site-author-img和site-author-image:hover属性 1234567891011121314151617181920212223242526# 头像显示圆形.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;# 头像旋转事件/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */","raw":"---\ntitle: Hexo Next主题头像旋转\ntoc: true\ndate: 2018-08-02 16:32:39\ntags: [hexo,next]\ncategories: [Hexo]\ndescription:\n---\nHexo Next主题将头像显示成圆形，鼠标放上去有旋转效果。\n<!-- more -->\n将头像显示成圆形，鼠标放上去有旋转效果。\n找到/themes/next/source/css/_common/components/sidebar/sidebar-author.styl\n替换其中的site-author-img和site-author-image:hover属性\n\n```python\n# 头像显示圆形\n.site-author-image {\n  display: block;\n  margin: 0 auto;\n  padding: $site-author-image-padding;\n  max-width: $site-author-image-width;\n  height: $site-author-image-height;\n  border: site-author-image-border-color;\n  /* start*/\n  border-radius: 50%\n  webkit-transition: 1.4s all;\n  moz-transition: 1.4s all;\n  ms-transition: 1.4s all;\n  transition: 1.4s all;\n  /* end */\n}\n# 头像旋转事件\n/* start */\n.site-author-image:hover {\n  background-color: #55DAE1;\n  webkit-transform: rotate(360deg) scale(1.1);\n  moz-transform: rotate(360deg) scale(1.1);\n  ms-transform: rotate(360deg) scale(1.1);\n  transform: rotate(360deg) scale(1.1);\n}\n/* end */\n```","content":"<p>Hexo Next主题将头像显示成圆形，鼠标放上去有旋转效果。</p>\n<span id=\"more\"></span>\n<p>将头像显示成圆形，鼠标放上去有旋转效果。<br>找到&#x2F;themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;components&#x2F;sidebar&#x2F;sidebar-author.styl<br>替换其中的site-author-img和site-author-image:hover属性</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 头像显示圆形</span></span><br><span class=\"line\">.site-author-image &#123;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  margin: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">  padding: $site-author-image-padding;</span><br><span class=\"line\">  <span class=\"built_in\">max</span>-width: $site-author-image-width;</span><br><span class=\"line\">  height: $site-author-image-height;</span><br><span class=\"line\">  border: site-author-image-border-color;</span><br><span class=\"line\">  /* start*/</span><br><span class=\"line\">  border-radius: <span class=\"number\">50</span>%</span><br><span class=\"line\">  webkit-transition: <span class=\"number\">1.4</span>s <span class=\"built_in\">all</span>;</span><br><span class=\"line\">  moz-transition: <span class=\"number\">1.4</span>s <span class=\"built_in\">all</span>;</span><br><span class=\"line\">  ms-transition: <span class=\"number\">1.4</span>s <span class=\"built_in\">all</span>;</span><br><span class=\"line\">  transition: <span class=\"number\">1.4</span>s <span class=\"built_in\">all</span>;</span><br><span class=\"line\">  /* end */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 头像旋转事件</span></span><br><span class=\"line\">/* start */</span><br><span class=\"line\">.site-author-image:hover &#123;</span><br><span class=\"line\">  background-color: <span class=\"comment\">#55DAE1;</span></span><br><span class=\"line\">  webkit-transform: rotate(360deg) scale(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">  moz-transform: rotate(360deg) scale(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">  ms-transform: rotate(360deg) scale(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">  transform: rotate(360deg) scale(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* end */</span><br></pre></td></tr></table></figure>","slug":"Hexo-Next主题头像旋转","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/08/02/Hexo-Next%E4%B8%BB%E9%A2%98%E5%A4%B4%E5%83%8F%E6%97%8B%E8%BD%AC/","excerpt":"Hexo Next主题将头像显示成圆形，鼠标放上去有旋转效果。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://vwin.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://vwin.github.io/tags/next/"}]},{"title":"tmux 配置&快捷键","date":"2018-07-17T02:52:52.000Z","path":"2018/07/17/tmux-配置&快捷键/","text":"tmux基本配置&amp;快捷键 Tmux基本配置12345678910111213set -g prefix C-a #unbind C-b # C-b即Ctrl+b键，unbind意味着解除绑定bind C-a send-prefix # 绑定Ctrl+a为新的指令前缀# 从tmux v1.6版起，支持设置第二个指令前缀set-option -g prefix2 ` # 设置一个不常用的`键作为指令前缀，按键更快些set-option -g mouse on # 等同于以上4个指令的效果unbind &#x27;&quot;&#x27;bind - splitw -v -c &#x27;#&#123;pane_current_path&#125;&#x27; # 垂直方向新增面板，默认进入当前目录unbind %bind | splitw -h -c &#x27;#&#123;pane_current_path&#125;&#x27; # 水平方向新增面板，默认进入当前目录# 绑定快捷键为r,读取配置文件bind r source-file ~/.tmux.conf \\; display-message &quot;Config reloaded..&quot; Tmux快捷键启动新会话： 1tmux [new -s 会话名 -n 窗口名] 恢复会话： 1tmux at [-t 会话名] 列出所有会话： 1tmux ls 关闭会话： 1tmux kill-session -t 会话名 关闭所有会话： 1tmux ls | grep : | cut -d. -f1 | awk &#x27;&#123;print substr($1, 0, length($1)-1)&#125;&#x27; | xargs kill Tmux 快捷键","raw":"---\ntitle: tmux 配置&快捷键\ntoc: true\ndate: 2018-07-17 10:52:52\ntags: [tmux,linux]\ncategories: [技术]\ndescription: tmux 配置整理 & 快捷键\n---\ntmux基本配置&快捷键\n\n## Tmux基本配置\n\n```python\nset -g prefix C-a #\nunbind C-b # C-b即Ctrl+b键，unbind意味着解除绑定\nbind C-a send-prefix # 绑定Ctrl+a为新的指令前缀\n\n# 从tmux v1.6版起，支持设置第二个指令前缀\nset-option -g prefix2 ` # 设置一个不常用的`键作为指令前缀，按键更快些\nset-option -g mouse on # 等同于以上4个指令的效果\nunbind '\"'\nbind - splitw -v -c '#{pane_current_path}' # 垂直方向新增面板，默认进入当前目录\nunbind %\nbind | splitw -h -c '#{pane_current_path}' # 水平方向新增面板，默认进入当前目录\n# 绑定快捷键为r,读取配置文件\nbind r source-file ~/.tmux.conf \\; display-message \"Config reloaded..\"\n```\n\n## Tmux快捷键\n启动新会话：\n```shell\ntmux [new -s 会话名 -n 窗口名]\n```\n\n恢复会话：\n```shell\ntmux at [-t 会话名]\n```\n\n列出所有会话：\n```shell\ntmux ls\n```\n\n关闭会话：\n```shell\ntmux kill-session -t 会话名\n```\n\n关闭所有会话：\n```shell\ntmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill\n```\n\n# Tmux 快捷键\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fxzd6et3t8j30l80f0wi7.jpg)","content":"<p>tmux基本配置&amp;快捷键</p>\n<h2 id=\"Tmux基本配置\"><a href=\"#Tmux基本配置\" class=\"headerlink\" title=\"Tmux基本配置\"></a>Tmux基本配置</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> -g prefix C-a <span class=\"comment\">#</span></span><br><span class=\"line\">unbind C-b <span class=\"comment\"># C-b即Ctrl+b键，unbind意味着解除绑定</span></span><br><span class=\"line\">bind C-a send-prefix <span class=\"comment\"># 绑定Ctrl+a为新的指令前缀</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从tmux v1.6版起，支持设置第二个指令前缀</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>-option -g prefix2 ` <span class=\"comment\"># 设置一个不常用的`键作为指令前缀，按键更快些</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>-option -g mouse on <span class=\"comment\"># 等同于以上4个指令的效果</span></span><br><span class=\"line\">unbind <span class=\"string\">&#x27;&quot;&#x27;</span></span><br><span class=\"line\">bind - splitw -v -c <span class=\"string\">&#x27;#&#123;pane_current_path&#125;&#x27;</span> <span class=\"comment\"># 垂直方向新增面板，默认进入当前目录</span></span><br><span class=\"line\">unbind %</span><br><span class=\"line\">bind | splitw -h -c <span class=\"string\">&#x27;#&#123;pane_current_path&#125;&#x27;</span> <span class=\"comment\"># 水平方向新增面板，默认进入当前目录</span></span><br><span class=\"line\"><span class=\"comment\"># 绑定快捷键为r,读取配置文件</span></span><br><span class=\"line\">bind r source-file ~/.tmux.conf \\; display-message <span class=\"string\">&quot;Config reloaded..&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tmux快捷键\"><a href=\"#Tmux快捷键\" class=\"headerlink\" title=\"Tmux快捷键\"></a>Tmux快捷键</h2><p>启动新会话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux [new -s 会话名 -n 窗口名]</span><br></pre></td></tr></table></figure>\n\n<p>恢复会话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux at [-t 会话名]</span><br></pre></td></tr></table></figure>\n\n<p>列出所有会话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux ls</span><br></pre></td></tr></table></figure>\n\n<p>关闭会话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux kill-session -t 会话名</span><br></pre></td></tr></table></figure>\n\n<p>关闭所有会话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux ls | grep : | cut -d. -f1 | awk &#x27;&#123;print substr($1, 0, length($1)-1)&#125;&#x27; | xargs kill</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Tmux-快捷键\"><a href=\"#Tmux-快捷键\" class=\"headerlink\" title=\"Tmux 快捷键\"></a>Tmux 快捷键</h1><p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fxzd6et3t8j30l80f0wi7.jpg\"></p>\n","slug":"tmux-配置&快捷键","updated":"2022-11-27T10:39:22.791Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/07/17/tmux-%E9%85%8D%E7%BD%AE&%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"tmux","slug":"tmux","permalink":"http://vwin.github.io/tags/tmux/"}]},{"title":"豆瓣电影评论生成词云","date":"2018-07-13T09:33:12.000Z","path":"2018/07/13/豆瓣电影评论生成词云/","text":"抓取豆瓣电影评论并生成词云 目标：抓取豆瓣电影评论生成词云第一步：抓取评论代码如下。具体见注释 123456789101112131415161718192021222324252627282930313233343536def getCommentsById(movieId, pageNum): eachCommentList = [] # 抓取评论的页数 if pageNum &gt; 0: start = (pageNum - 1) * 20 else: return False # 豆瓣电影评论的地址 requrl = ( &quot;https://movie.douban.com/subject/&quot; + movieId + &quot;/comments&quot; + &quot;?&quot; + &quot;start=&quot; + str(start) + &quot;&amp;limit=20&quot; ) try: # 抓取 resp = requests.get(requrl) # 用utf-8格式化返回结果 html_data = resp.content.decode(&quot;utf-8&quot;) # 用beautifulsoup处理返回结果，指定parser为html soup = bs(html_data, &quot;html.parser&quot;) # 获取评论 comment_div_lits = soup.find_all(&quot;div&quot;, class_=&quot;comment&quot;) # 将评论写入数组 for item in comment_div_lits: if item.find_all(&quot;p&quot;)[0].string is not None: eachCommentList.append(item.find_all(&quot;p&quot;)[0].string) # 捕获异常 except RequestException as e: print(&quot;请求问题，原因：%s&quot; % e) # 返回评论数组 return eachCommentList 第二步：将抓取的评论转换为字符串代码如下。具体见注释 12345678910111213commentList = []for i in range(10): num = i + 1 # 使用上面的方法获取评论列表 commentList_temp = getCommentsById(movieId=movieId, pageNum=num) commentList.append(commentList_temp) # 将列表中的数据转换为字符串comments = &quot;&quot;for k in range(len(commentList)): # print(commentList[k]) # 去掉空格等 for m in range(len(commentList[k])): comments = comments + str(commentList[k][m]).strip() 第三步：使用正则去掉标点代码如下。具体见注释 123# 使用正则去掉标点filtrate = re.compile(r&quot;[^\\u4E00-\\u9FA5]&quot;) # 提取中文，过滤掉非中文字符filtered_str = filtrate.sub(r&quot;&quot;, comments) # replace 第四步：使用结巴分词进行中文分词代码如下。具体见注释 123# 用结巴分词进行中文分词segment = jieba.lcut(filtered_str)words_df = pd.DataFrame(&#123;&quot;segment&quot;: segment&#125;) 第五步：去掉停用词代码如下。具体见注释 12345678910111213# 去掉停用词。# 停用词是指在信息检索中，为节省存储空间和提高搜索效率# 在处理自然语言数据（或文本）之前或之后会自动过滤掉某些字或词# 这些字或词即被称为Stop Words（停用词）。stopwords = pd.read_csv( &quot;./stopwords.txt&quot;, index_col=False, quoting=3, sep=&quot;t&quot;, names=[&quot;stopword&quot;], encoding=&quot;utf-8&quot;,)words_df = words_df[~words_df.segment.isin(stopwords.stopword)] 第六步：统计词频代码如下。具体见注释 123# 统计词频words_stat = words_df.groupby(by=[&quot;segment&quot;])[&quot;segment&quot;].agg(&#123;&quot;计数&quot;: numpy.size&#125;)words_stat = words_stat.reset_index().sort_values(by=[&quot;计数&quot;], ascending=False) 第七步：用词云进行显示代码如下。具体见注释 1234567891011121314151617# 用词云进行显示wordcloud = WordCloud( font_path=&quot;./simkai.ttf&quot;, background_color=&quot;white&quot;, max_font_size=80, width=1000, height=860, margin=2,)word_frequence = &#123;x[0]: x[1] for x in words_stat.head(1000).values&#125;wordcloud = wordcloud.fit_words(word_frequence)plt.imshow(wordcloud)plt.axis(&quot;off&quot;)plt.show(block=False)img_name = &quot;./&quot; + movieName + &quot;.jpg&quot;wordcloud.to_file(img_name) End源码github地址","raw":"---\ntitle: 豆瓣电影评论生成词云\ntoc: true\ndate: 2018-07-13 17:33:12\ntags: [豆瓣,电影,词云,python]\ncategories: [技术]\ndescription:\n---\n## 抓取豆瓣电影评论并生成词云\n<!-- more -->\n## 目标：抓取豆瓣电影评论生成词云\n### 第一步：抓取评论\n代码如下。具体见注释\n```python\ndef getCommentsById(movieId, pageNum):\n    eachCommentList = []\n    # 抓取评论的页数\n    if pageNum > 0:\n    \n        start = (pageNum - 1) * 20\n    else:\n        return False\n    # 豆瓣电影评论的地址\n    requrl = (\n        \"https://movie.douban.com/subject/\"\n        + movieId\n        + \"/comments\"\n        + \"?\"\n        + \"start=\"\n        + str(start)\n        + \"&limit=20\"\n    )\n    try:\n        # 抓取\n        resp = requests.get(requrl)\n        # 用utf-8格式化返回结果\n        html_data = resp.content.decode(\"utf-8\")\n        # 用beautifulsoup处理返回结果，指定parser为html\n        soup = bs(html_data, \"html.parser\")\n        # 获取评论\n        comment_div_lits = soup.find_all(\"div\", class_=\"comment\")\n        # 将评论写入数组\n        for item in comment_div_lits:\n            if item.find_all(\"p\")[0].string is not None:\n                eachCommentList.append(item.find_all(\"p\")[0].string)\n    # 捕获异常\n    except RequestException as e:\n        print(\"请求问题，原因：%s\" % e)\n    # 返回评论数组\n    return eachCommentList\n```\n\n### 第二步：将抓取的评论转换为字符串\n代码如下。具体见注释\n```python\ncommentList = []\nfor i in range(10):\n    num = i + 1\n    # 使用上面的方法获取评论列表\n    commentList_temp = getCommentsById(movieId=movieId, pageNum=num)\n    commentList.append(commentList_temp)\n    # 将列表中的数据转换为字符串\ncomments = \"\"\nfor k in range(len(commentList)):\n    # print(commentList[k])\n    # 去掉空格等\n    for m in range(len(commentList[k])):\n        comments = comments + str(commentList[k][m]).strip()\n```\n\n### 第三步：使用正则去掉标点\n代码如下。具体见注释\n```python\n# 使用正则去掉标点\nfiltrate = re.compile(r\"[^\\u4E00-\\u9FA5]\")  # 提取中文，过滤掉非中文字符\nfiltered_str = filtrate.sub(r\"\", comments)  # replace\n```\n\n### 第四步：使用结巴分词进行中文分词\n代码如下。具体见注释\n```python\n# 用结巴分词进行中文分词\nsegment = jieba.lcut(filtered_str)\nwords_df = pd.DataFrame({\"segment\": segment})\n```\n\n### 第五步：去掉停用词\n代码如下。具体见注释\n```python\n# 去掉停用词。\n# 停用词是指在信息检索中，为节省存储空间和提高搜索效率\n# 在处理自然语言数据（或文本）之前或之后会自动过滤掉某些字或词\n# 这些字或词即被称为Stop Words（停用词）。\nstopwords = pd.read_csv(\n    \"./stopwords.txt\",\n    index_col=False,\n    quoting=3,\n    sep=\"t\",\n    names=[\"stopword\"],\n    encoding=\"utf-8\",\n)\nwords_df = words_df[~words_df.segment.isin(stopwords.stopword)]\n```\n\n### 第六步：统计词频\n代码如下。具体见注释\n```python\n# 统计词频\nwords_stat = words_df.groupby(by=[\"segment\"])[\"segment\"].agg({\"计数\": numpy.size})\nwords_stat = words_stat.reset_index().sort_values(by=[\"计数\"], ascending=False)\n```\n\n### 第七步：用词云进行显示\n代码如下。具体见注释\n```python\n# 用词云进行显示\nwordcloud = WordCloud(\n    font_path=\"./simkai.ttf\",\n    background_color=\"white\",\n    max_font_size=80,\n    width=1000,\n    height=860,\n    margin=2,\n)\nword_frequence = {x[0]: x[1] for x in words_stat.head(1000).values}\n\nwordcloud = wordcloud.fit_words(word_frequence)\nplt.imshow(wordcloud)\nplt.axis(\"off\")\nplt.show(block=False)\nimg_name = \"./\" + movieName + \".jpg\"\nwordcloud.to_file(img_name)\n```\n\n### End \n\n[源码github地址](https://github.com/vwin/douban-movie-wordcloud)","content":"<h2 id=\"抓取豆瓣电影评论并生成词云\"><a href=\"#抓取豆瓣电影评论并生成词云\" class=\"headerlink\" title=\"抓取豆瓣电影评论并生成词云\"></a>抓取豆瓣电影评论并生成词云</h2><span id=\"more\"></span>\n<h2 id=\"目标：抓取豆瓣电影评论生成词云\"><a href=\"#目标：抓取豆瓣电影评论生成词云\" class=\"headerlink\" title=\"目标：抓取豆瓣电影评论生成词云\"></a>目标：抓取豆瓣电影评论生成词云</h2><h3 id=\"第一步：抓取评论\"><a href=\"#第一步：抓取评论\" class=\"headerlink\" title=\"第一步：抓取评论\"></a>第一步：抓取评论</h3><p>代码如下。具体见注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getCommentsById</span>(<span class=\"params\">movieId, pageNum</span>):</span><br><span class=\"line\">    eachCommentList = []</span><br><span class=\"line\">    <span class=\"comment\"># 抓取评论的页数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pageNum &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">        start = (pageNum - <span class=\"number\">1</span>) * <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 豆瓣电影评论的地址</span></span><br><span class=\"line\">    requrl = (</span><br><span class=\"line\">        <span class=\"string\">&quot;https://movie.douban.com/subject/&quot;</span></span><br><span class=\"line\">        + movieId</span><br><span class=\"line\">        + <span class=\"string\">&quot;/comments&quot;</span></span><br><span class=\"line\">        + <span class=\"string\">&quot;?&quot;</span></span><br><span class=\"line\">        + <span class=\"string\">&quot;start=&quot;</span></span><br><span class=\"line\">        + <span class=\"built_in\">str</span>(start)</span><br><span class=\"line\">        + <span class=\"string\">&quot;&amp;limit=20&quot;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 抓取</span></span><br><span class=\"line\">        resp = requests.get(requrl)</span><br><span class=\"line\">        <span class=\"comment\"># 用utf-8格式化返回结果</span></span><br><span class=\"line\">        html_data = resp.content.decode(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 用beautifulsoup处理返回结果，指定parser为html</span></span><br><span class=\"line\">        soup = bs(html_data, <span class=\"string\">&quot;html.parser&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 获取评论</span></span><br><span class=\"line\">        comment_div_lits = soup.find_all(<span class=\"string\">&quot;div&quot;</span>, class_=<span class=\"string\">&quot;comment&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 将评论写入数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> comment_div_lits:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item.find_all(<span class=\"string\">&quot;p&quot;</span>)[<span class=\"number\">0</span>].string <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                eachCommentList.append(item.find_all(<span class=\"string\">&quot;p&quot;</span>)[<span class=\"number\">0</span>].string)</span><br><span class=\"line\">    <span class=\"comment\"># 捕获异常</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> RequestException <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;请求问题，原因：%s&quot;</span> % e)</span><br><span class=\"line\">    <span class=\"comment\"># 返回评论数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> eachCommentList</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第二步：将抓取的评论转换为字符串\"><a href=\"#第二步：将抓取的评论转换为字符串\" class=\"headerlink\" title=\"第二步：将抓取的评论转换为字符串\"></a>第二步：将抓取的评论转换为字符串</h3><p>代码如下。具体见注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commentList = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    num = i + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用上面的方法获取评论列表</span></span><br><span class=\"line\">    commentList_temp = getCommentsById(movieId=movieId, pageNum=num)</span><br><span class=\"line\">    commentList.append(commentList_temp)</span><br><span class=\"line\">    <span class=\"comment\"># 将列表中的数据转换为字符串</span></span><br><span class=\"line\">comments = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(commentList)):</span><br><span class=\"line\">    <span class=\"comment\"># print(commentList[k])</span></span><br><span class=\"line\">    <span class=\"comment\"># 去掉空格等</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(commentList[k])):</span><br><span class=\"line\">        comments = comments + <span class=\"built_in\">str</span>(commentList[k][m]).strip()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三步：使用正则去掉标点\"><a href=\"#第三步：使用正则去掉标点\" class=\"headerlink\" title=\"第三步：使用正则去掉标点\"></a>第三步：使用正则去掉标点</h3><p>代码如下。具体见注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用正则去掉标点</span></span><br><span class=\"line\">filtrate = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&quot;[^\\u4E00-\\u9FA5]&quot;</span>)  <span class=\"comment\"># 提取中文，过滤掉非中文字符</span></span><br><span class=\"line\">filtered_str = filtrate.sub(<span class=\"string\">r&quot;&quot;</span>, comments)  <span class=\"comment\"># replace</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第四步：使用结巴分词进行中文分词\"><a href=\"#第四步：使用结巴分词进行中文分词\" class=\"headerlink\" title=\"第四步：使用结巴分词进行中文分词\"></a>第四步：使用结巴分词进行中文分词</h3><p>代码如下。具体见注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用结巴分词进行中文分词</span></span><br><span class=\"line\">segment = jieba.lcut(filtered_str)</span><br><span class=\"line\">words_df = pd.DataFrame(&#123;<span class=\"string\">&quot;segment&quot;</span>: segment&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第五步：去掉停用词\"><a href=\"#第五步：去掉停用词\" class=\"headerlink\" title=\"第五步：去掉停用词\"></a>第五步：去掉停用词</h3><p>代码如下。具体见注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 去掉停用词。</span></span><br><span class=\"line\"><span class=\"comment\"># 停用词是指在信息检索中，为节省存储空间和提高搜索效率</span></span><br><span class=\"line\"><span class=\"comment\"># 在处理自然语言数据（或文本）之前或之后会自动过滤掉某些字或词</span></span><br><span class=\"line\"><span class=\"comment\"># 这些字或词即被称为Stop Words（停用词）。</span></span><br><span class=\"line\">stopwords = pd.read_csv(</span><br><span class=\"line\">    <span class=\"string\">&quot;./stopwords.txt&quot;</span>,</span><br><span class=\"line\">    index_col=<span class=\"literal\">False</span>,</span><br><span class=\"line\">    quoting=<span class=\"number\">3</span>,</span><br><span class=\"line\">    sep=<span class=\"string\">&quot;t&quot;</span>,</span><br><span class=\"line\">    names=[<span class=\"string\">&quot;stopword&quot;</span>],</span><br><span class=\"line\">    encoding=<span class=\"string\">&quot;utf-8&quot;</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\">words_df = words_df[~words_df.segment.isin(stopwords.stopword)]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第六步：统计词频\"><a href=\"#第六步：统计词频\" class=\"headerlink\" title=\"第六步：统计词频\"></a>第六步：统计词频</h3><p>代码如下。具体见注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 统计词频</span></span><br><span class=\"line\">words_stat = words_df.groupby(by=[<span class=\"string\">&quot;segment&quot;</span>])[<span class=\"string\">&quot;segment&quot;</span>].agg(&#123;<span class=\"string\">&quot;计数&quot;</span>: numpy.size&#125;)</span><br><span class=\"line\">words_stat = words_stat.reset_index().sort_values(by=[<span class=\"string\">&quot;计数&quot;</span>], ascending=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第七步：用词云进行显示\"><a href=\"#第七步：用词云进行显示\" class=\"headerlink\" title=\"第七步：用词云进行显示\"></a>第七步：用词云进行显示</h3><p>代码如下。具体见注释</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用词云进行显示</span></span><br><span class=\"line\">wordcloud = WordCloud(</span><br><span class=\"line\">    font_path=<span class=\"string\">&quot;./simkai.ttf&quot;</span>,</span><br><span class=\"line\">    background_color=<span class=\"string\">&quot;white&quot;</span>,</span><br><span class=\"line\">    max_font_size=<span class=\"number\">80</span>,</span><br><span class=\"line\">    width=<span class=\"number\">1000</span>,</span><br><span class=\"line\">    height=<span class=\"number\">860</span>,</span><br><span class=\"line\">    margin=<span class=\"number\">2</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\">word_frequence = &#123;x[<span class=\"number\">0</span>]: x[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> words_stat.head(<span class=\"number\">1000</span>).values&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wordcloud = wordcloud.fit_words(word_frequence)</span><br><span class=\"line\">plt.imshow(wordcloud)</span><br><span class=\"line\">plt.axis(<span class=\"string\">&quot;off&quot;</span>)</span><br><span class=\"line\">plt.show(block=<span class=\"literal\">False</span>)</span><br><span class=\"line\">img_name = <span class=\"string\">&quot;./&quot;</span> + movieName + <span class=\"string\">&quot;.jpg&quot;</span></span><br><span class=\"line\">wordcloud.to_file(img_name)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h3><p><a href=\"https://github.com/vwin/douban-movie-wordcloud\">源码github地址</a></p>\n","slug":"豆瓣电影评论生成词云","updated":"2022-11-27T10:39:22.795Z","comments":true,"link":"","permalink":"http://vwin.github.io/2018/07/13/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/","excerpt":"抓取豆瓣电影评论并生成词云","categories":[{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"豆瓣","slug":"豆瓣","permalink":"http://vwin.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"电影","slug":"电影","permalink":"http://vwin.github.io/tags/%E7%94%B5%E5%BD%B1/"},{"name":"词云","slug":"词云","permalink":"http://vwin.github.io/tags/%E8%AF%8D%E4%BA%91/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/categories/Hexo/"},{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/categories/%E6%B5%8B%E8%AF%95/"},{"name":"技术","slug":"技术","permalink":"http://vwin.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"工作","slug":"工作","permalink":"http://vwin.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"生活","slug":"生活","permalink":"http://vwin.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://vwin.github.io/tags/hexo/"},{"name":"valine","slug":"valine","permalink":"http://vwin.github.io/tags/valine/"},{"name":"waline","slug":"waline","permalink":"http://vwin.github.io/tags/waline/"},{"name":"Hexo","slug":"Hexo","permalink":"http://vwin.github.io/tags/Hexo/"},{"name":"压测","slug":"压测","permalink":"http://vwin.github.io/tags/%E5%8E%8B%E6%B5%8B/"},{"name":"k6","slug":"k6","permalink":"http://vwin.github.io/tags/k6/"},{"name":"自动驾驶","slug":"自动驾驶","permalink":"http://vwin.github.io/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"},{"name":"geojson","slug":"geojson","permalink":"http://vwin.github.io/tags/geojson/"},{"name":"qgis","slug":"qgis","permalink":"http://vwin.github.io/tags/qgis/"},{"name":"性能测试","slug":"性能测试","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"测试","slug":"测试","permalink":"http://vwin.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"后台","slug":"后台","permalink":"http://vwin.github.io/tags/%E5%90%8E%E5%8F%B0/"},{"name":"Prometheus","slug":"Prometheus","permalink":"http://vwin.github.io/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","permalink":"http://vwin.github.io/tags/Grafana/"},{"name":"监控","slug":"监控","permalink":"http://vwin.github.io/tags/%E7%9B%91%E6%8E%A7/"},{"name":"单测","slug":"单测","permalink":"http://vwin.github.io/tags/%E5%8D%95%E6%B5%8B/"},{"name":"go","slug":"go","permalink":"http://vwin.github.io/tags/go/"},{"name":"python","slug":"python","permalink":"http://vwin.github.io/tags/python/"},{"name":"pytest","slug":"pytest","permalink":"http://vwin.github.io/tags/pytest/"},{"name":"unittest","slug":"unittest","permalink":"http://vwin.github.io/tags/unittest/"},{"name":"C++","slug":"C","permalink":"http://vwin.github.io/tags/C/"},{"name":"IaaS","slug":"IaaS","permalink":"http://vwin.github.io/tags/IaaS/"},{"name":"存储","slug":"存储","permalink":"http://vwin.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"分布式","slug":"分布式","permalink":"http://vwin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"Iaas","slug":"Iaas","permalink":"http://vwin.github.io/tags/Iaas/"},{"name":"云","slug":"云","permalink":"http://vwin.github.io/tags/%E4%BA%91/"},{"name":"c++","slug":"c","permalink":"http://vwin.github.io/tags/c/"},{"name":"头文件","slug":"头文件","permalink":"http://vwin.github.io/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"name":"性能分析","slug":"性能分析","permalink":"http://vwin.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"perf","slug":"perf","permalink":"http://vwin.github.io/tags/perf/"},{"name":"火焰图","slug":"火焰图","permalink":"http://vwin.github.io/tags/%E7%81%AB%E7%84%B0%E5%9B%BE/"},{"name":"道格拉斯","slug":"道格拉斯","permalink":"http://vwin.github.io/tags/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF/"},{"name":"算法","slug":"算法","permalink":"http://vwin.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"全链路","slug":"全链路","permalink":"http://vwin.github.io/tags/%E5%85%A8%E9%93%BE%E8%B7%AF/"},{"name":"systemtap","slug":"systemtap","permalink":"http://vwin.github.io/tags/systemtap/"},{"name":"cmake","slug":"cmake","permalink":"http://vwin.github.io/tags/cmake/"},{"name":"makefile","slug":"makefile","permalink":"http://vwin.github.io/tags/makefile/"},{"name":"nmake","slug":"nmake","permalink":"http://vwin.github.io/tags/nmake/"},{"name":"Conan","slug":"Conan","permalink":"http://vwin.github.io/tags/Conan/"},{"name":"zip","slug":"zip","permalink":"http://vwin.github.io/tags/zip/"},{"name":"UI自动化","slug":"UI自动化","permalink":"http://vwin.github.io/tags/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"airtest","slug":"airtest","permalink":"http://vwin.github.io/tags/airtest/"},{"name":"ios","slug":"ios","permalink":"http://vwin.github.io/tags/ios/"},{"name":"行政区","slug":"行政区","permalink":"http://vwin.github.io/tags/%E8%A1%8C%E6%94%BF%E5%8C%BA/"},{"name":"github pages","slug":"github-pages","permalink":"http://vwin.github.io/tags/github-pages/"},{"name":"域名解析","slug":"域名解析","permalink":"http://vwin.github.io/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"分支策略","slug":"分支策略","permalink":"http://vwin.github.io/tags/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://vwin.github.io/tags/ubuntu/"},{"name":"jmeter","slug":"jmeter","permalink":"http://vwin.github.io/tags/jmeter/"},{"name":"jdk","slug":"jdk","permalink":"http://vwin.github.io/tags/jdk/"},{"name":"jre","slug":"jre","permalink":"http://vwin.github.io/tags/jre/"},{"name":"大数据","slug":"大数据","permalink":"http://vwin.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"人工智能","slug":"人工智能","permalink":"http://vwin.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"网络环境","slug":"网络环境","permalink":"http://vwin.github.io/tags/%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83/"},{"name":"QPS","slug":"QPS","permalink":"http://vwin.github.io/tags/QPS/"},{"name":"TPS","slug":"TPS","permalink":"http://vwin.github.io/tags/TPS/"},{"name":"github","slug":"github","permalink":"http://vwin.github.io/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"http://vwin.github.io/tags/ssh/"},{"name":"保险","slug":"保险","permalink":"http://vwin.github.io/tags/%E4%BF%9D%E9%99%A9/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://vwin.github.io/tags/Jenkins/"},{"name":"插件","slug":"插件","permalink":"http://vwin.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"websocket","slug":"websocket","permalink":"http://vwin.github.io/tags/websocket/"},{"name":"http","slug":"http","permalink":"http://vwin.github.io/tags/http/"},{"name":"flask","slug":"flask","permalink":"http://vwin.github.io/tags/flask/"},{"name":"celery","slug":"celery","permalink":"http://vwin.github.io/tags/celery/"},{"name":"闭包","slug":"闭包","permalink":"http://vwin.github.io/tags/%E9%97%AD%E5%8C%85/"},{"name":"lambda","slug":"lambda","permalink":"http://vwin.github.io/tags/lambda/"},{"name":"sorted","slug":"sorted","permalink":"http://vwin.github.io/tags/sorted/"},{"name":"函数","slug":"函数","permalink":"http://vwin.github.io/tags/%E5%87%BD%E6%95%B0/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"http://vwin.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"矩阵","slug":"矩阵","permalink":"http://vwin.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"递归","slug":"递归","permalink":"http://vwin.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"设计模式","slug":"设计模式","permalink":"http://vwin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"责任链模式","slug":"责任链模式","permalink":"http://vwin.github.io/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"http://vwin.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"spark","slug":"spark","permalink":"http://vwin.github.io/tags/spark/"},{"name":"hadoop","slug":"hadoop","permalink":"http://vwin.github.io/tags/hadoop/"},{"name":"mfs","slug":"mfs","permalink":"http://vwin.github.io/tags/mfs/"},{"name":"seaweedfs","slug":"seaweedfs","permalink":"http://vwin.github.io/tags/seaweedfs/"},{"name":"Go","slug":"Go","permalink":"http://vwin.github.io/tags/Go/"},{"name":"教程","slug":"教程","permalink":"http://vwin.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"pdf","slug":"pdf","permalink":"http://vwin.github.io/tags/pdf/"},{"name":"百度网盘","slug":"百度网盘","permalink":"http://vwin.github.io/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"},{"name":"Devops","slug":"Devops","permalink":"http://vwin.github.io/tags/Devops/"},{"name":"Derrick","slug":"Derrick","permalink":"http://vwin.github.io/tags/Derrick/"},{"name":"npm","slug":"npm","permalink":"http://vwin.github.io/tags/npm/"},{"name":"cnpm","slug":"cnpm","permalink":"http://vwin.github.io/tags/cnpm/"},{"name":"linux","slug":"linux","permalink":"http://vwin.github.io/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://vwin.github.io/tags/mysql/"},{"name":"metaclass","slug":"metaclass","permalink":"http://vwin.github.io/tags/metaclass/"},{"name":"php7-fpm","slug":"php7-fpm","permalink":"http://vwin.github.io/tags/php7-fpm/"},{"name":"php5-fpm","slug":"php5-fpm","permalink":"http://vwin.github.io/tags/php5-fpm/"},{"name":"php","slug":"php","permalink":"http://vwin.github.io/tags/php/"},{"name":"jupyter notebook","slug":"jupyter-notebook","permalink":"http://vwin.github.io/tags/jupyter-notebook/"},{"name":"paramiko","slug":"paramiko","permalink":"http://vwin.github.io/tags/paramiko/"},{"name":"scp","slug":"scp","permalink":"http://vwin.github.io/tags/scp/"},{"name":"json","slug":"json","permalink":"http://vwin.github.io/tags/json/"},{"name":"tp","slug":"tp","permalink":"http://vwin.github.io/tags/tp/"},{"name":"fn","slug":"fn","permalink":"http://vwin.github.io/tags/fn/"},{"name":"tn","slug":"tn","permalink":"http://vwin.github.io/tags/tn/"},{"name":"fp","slug":"fp","permalink":"http://vwin.github.io/tags/fp/"},{"name":"roc","slug":"roc","permalink":"http://vwin.github.io/tags/roc/"},{"name":"AI评测","slug":"AI评测","permalink":"http://vwin.github.io/tags/AI%E8%AF%84%E6%B5%8B/"},{"name":"Python","slug":"Python","permalink":"http://vwin.github.io/tags/Python/"},{"name":"re","slug":"re","permalink":"http://vwin.github.io/tags/re/"},{"name":"timeout","slug":"timeout","permalink":"http://vwin.github.io/tags/timeout/"},{"name":"sudo","slug":"sudo","permalink":"http://vwin.github.io/tags/sudo/"},{"name":"bio","slug":"bio","permalink":"http://vwin.github.io/tags/bio/"},{"name":"nio","slug":"nio","permalink":"http://vwin.github.io/tags/nio/"},{"name":"aio","slug":"aio","permalink":"http://vwin.github.io/tags/aio/"},{"name":"kafka-topic.sh","slug":"kafka-topic-sh","permalink":"http://vwin.github.io/tags/kafka-topic-sh/"},{"name":"describe","slug":"describe","permalink":"http://vwin.github.io/tags/describe/"},{"name":"kafka","slug":"kafka","permalink":"http://vwin.github.io/tags/kafka/"},{"name":"replica","slug":"replica","permalink":"http://vwin.github.io/tags/replica/"},{"name":"broker","slug":"broker","permalink":"http://vwin.github.io/tags/broker/"},{"name":"partition","slug":"partition","permalink":"http://vwin.github.io/tags/partition/"},{"name":"consumer","slug":"consumer","permalink":"http://vwin.github.io/tags/consumer/"},{"name":"docker","slug":"docker","permalink":"http://vwin.github.io/tags/docker/"},{"name":"持续集成","slug":"持续集成","permalink":"http://vwin.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"HTML","slug":"HTML","permalink":"http://vwin.github.io/tags/HTML/"},{"name":"pip","slug":"pip","permalink":"http://vwin.github.io/tags/pip/"},{"name":"supervisor","slug":"supervisor","permalink":"http://vwin.github.io/tags/supervisor/"},{"name":"gunicorn","slug":"gunicorn","permalink":"http://vwin.github.io/tags/gunicorn/"},{"name":"后台关系","slug":"后台关系","permalink":"http://vwin.github.io/tags/%E5%90%8E%E5%8F%B0%E5%85%B3%E7%B3%BB/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://vwin.github.io/tags/bootstrap/"},{"name":"vue","slug":"vue","permalink":"http://vwin.github.io/tags/vue/"},{"name":"laravel","slug":"laravel","permalink":"http://vwin.github.io/tags/laravel/"},{"name":"element ui","slug":"element-ui","permalink":"http://vwin.github.io/tags/element-ui/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://vwin.github.io/tags/Ubuntu/"},{"name":"datetime","slug":"datetime","permalink":"http://vwin.github.io/tags/datetime/"},{"name":"time","slug":"time","permalink":"http://vwin.github.io/tags/time/"},{"name":"date","slug":"date","permalink":"http://vwin.github.io/tags/date/"},{"name":"时间","slug":"时间","permalink":"http://vwin.github.io/tags/%E6%97%B6%E9%97%B4/"},{"name":"日期","slug":"日期","permalink":"http://vwin.github.io/tags/%E6%97%A5%E6%9C%9F/"},{"name":"排序","slug":"排序","permalink":"http://vwin.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"list","slug":"list","permalink":"http://vwin.github.io/tags/list/"},{"name":"dict","slug":"dict","permalink":"http://vwin.github.io/tags/dict/"},{"name":"pythonic","slug":"pythonic","permalink":"http://vwin.github.io/tags/pythonic/"},{"name":"语法糖","slug":"语法糖","permalink":"http://vwin.github.io/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"name":"free","slug":"free","permalink":"http://vwin.github.io/tags/free/"},{"name":"cached","slug":"cached","permalink":"http://vwin.github.io/tags/cached/"},{"name":"buffer","slug":"buffer","permalink":"http://vwin.github.io/tags/buffer/"},{"name":"git","slug":"git","permalink":"http://vwin.github.io/tags/git/"},{"name":"samba","slug":"samba","permalink":"http://vwin.github.io/tags/samba/"},{"name":"locust","slug":"locust","permalink":"http://vwin.github.io/tags/locust/"},{"name":"CI","slug":"CI","permalink":"http://vwin.github.io/tags/CI/"},{"name":"next","slug":"next","permalink":"http://vwin.github.io/tags/next/"},{"name":"tmux","slug":"tmux","permalink":"http://vwin.github.io/tags/tmux/"},{"name":"豆瓣","slug":"豆瓣","permalink":"http://vwin.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"电影","slug":"电影","permalink":"http://vwin.github.io/tags/%E7%94%B5%E5%BD%B1/"},{"name":"词云","slug":"词云","permalink":"http://vwin.github.io/tags/%E8%AF%8D%E4%BA%91/"}]}